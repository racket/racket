/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_indent_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
#else
  return 0;
#endif
}

static int mark_indent_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
# endif
#endif
}

static int mark_indent_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
# endif
#endif
}

#define mark_indent_IS_ATOMIC 1
#define mark_indent_IS_CONST_SIZE 1


static int mark_cport_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(CPort));
#else
  return 0;
#endif
}

static int mark_cport_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  CPort *cp = (CPort *)p;
  gcMARK2(cp->start, gc);
  gcMARK2(cp->orig_port, gc);
  gcMARK2(cp->ht, gc);
  gcMARK2(cp->ut, gc);
  gcMARK2(cp->symtab, gc);
  gcMARK2(cp->symtab_entries, gc);
  gcMARK2(cp->relto, gc);
  gcMARK2(cp->magic_sym, gc);
  gcMARK2(cp->magic_val, gc);
  gcMARK2(cp->shared_offsets, gc);
  gcMARK2(cp->delay_info, gc);
  gcMARK2(cp->symtab_refs, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(CPort));
# endif
#endif
}

static int mark_cport_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  CPort *cp = (CPort *)p;
  gcFIXUP2(cp->start, gc);
  gcFIXUP2(cp->orig_port, gc);
  gcFIXUP2(cp->ht, gc);
  gcFIXUP2(cp->ut, gc);
  gcFIXUP2(cp->symtab, gc);
  gcFIXUP2(cp->symtab_entries, gc);
  gcFIXUP2(cp->relto, gc);
  gcFIXUP2(cp->magic_sym, gc);
  gcFIXUP2(cp->magic_val, gc);
  gcFIXUP2(cp->shared_offsets, gc);
  gcFIXUP2(cp->delay_info, gc);
  gcFIXUP2(cp->symtab_refs, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(CPort));
# endif
#endif
}

#define mark_cport_IS_ATOMIC 0
#define mark_cport_IS_CONST_SIZE 1


static int mark_readtable_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Readtable));
#else
  return 0;
#endif
}

static int mark_readtable_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Readtable *t = (Readtable *)p;
  gcMARK2(t->mapping, gc);
  gcMARK2(t->fast_mapping, gc);
  gcMARK2(t->symbol_parser, gc);
  gcMARK2(t->names, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Readtable));
# endif
#endif
}

static int mark_readtable_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Readtable *t = (Readtable *)p;
  gcFIXUP2(t->mapping, gc);
  gcFIXUP2(t->fast_mapping, gc);
  gcFIXUP2(t->symbol_parser, gc);
  gcFIXUP2(t->names, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Readtable));
# endif
#endif
}

#define mark_readtable_IS_ATOMIC 0
#define mark_readtable_IS_CONST_SIZE 1


static int mark_read_params_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(ReadParams));
#else
  return 0;
#endif
}

static int mark_read_params_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  ReadParams *rp = (ReadParams *)p;
  gcMARK2(rp->table, gc);
  gcMARK2(rp->magic_sym, gc);
  gcMARK2(rp->magic_val, gc);
  gcMARK2(rp->delay_load_info, gc);
  gcMARK2(rp->read_relative_path, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(ReadParams));
# endif
#endif
}

static int mark_read_params_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  ReadParams *rp = (ReadParams *)p;
  gcFIXUP2(rp->table, gc);
  gcFIXUP2(rp->magic_sym, gc);
  gcFIXUP2(rp->magic_val, gc);
  gcFIXUP2(rp->delay_load_info, gc);
  gcFIXUP2(rp->read_relative_path, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(ReadParams));
# endif
#endif
}

#define mark_read_params_IS_ATOMIC 0
#define mark_read_params_IS_CONST_SIZE 1


static int mark_delay_load_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Load_Delay));
#else
  return 0;
#endif
}

static int mark_delay_load_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Load_Delay *ld = (Scheme_Load_Delay *)p;
  gcMARK2(ld->path, gc);
  gcMARK2(ld->symtab, gc);
  gcMARK2(ld->symtab_entries, gc);
  gcMARK2(ld->shared_offsets, gc);
  gcMARK2(ld->relto, gc);
  gcMARK2(ld->ut, gc);
  gcMARK2(ld->current_rp, gc);
  gcMARK2(ld->cached, gc);
  gcMARK2(ld->cached_port, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Load_Delay));
# endif
#endif
}

static int mark_delay_load_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Load_Delay *ld = (Scheme_Load_Delay *)p;
  gcFIXUP2(ld->path, gc);
  gcFIXUP2(ld->symtab, gc);
  gcFIXUP2(ld->symtab_entries, gc);
  gcFIXUP2(ld->shared_offsets, gc);
  gcFIXUP2(ld->relto, gc);
  gcFIXUP2(ld->ut, gc);
  gcFIXUP2(ld->current_rp, gc);
  gcFIXUP2(ld->cached, gc);
  gcFIXUP2(ld->cached_port, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Load_Delay));
# endif
#endif
}

#define mark_delay_load_IS_ATOMIC 0
#define mark_delay_load_IS_CONST_SIZE 1


static int mark_unmarshal_tables_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Unmarshal_Tables));
#else
  return 0;
#endif
}

static int mark_unmarshal_tables_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Unmarshal_Tables *ut = (Scheme_Unmarshal_Tables *)p;
  gcMARK2(ut->rns, gc);
  gcMARK2(ut->current_rns, gc);
  gcMARK2(ut->multi_scope_pairs, gc);
  gcMARK2(ut->current_multi_scope_pairs, gc);
  gcMARK2(ut->rp, gc);
  gcMARK2(ut->decoded, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Unmarshal_Tables));
# endif
#endif
}

static int mark_unmarshal_tables_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Unmarshal_Tables *ut = (Scheme_Unmarshal_Tables *)p;
  gcFIXUP2(ut->rns, gc);
  gcFIXUP2(ut->current_rns, gc);
  gcFIXUP2(ut->multi_scope_pairs, gc);
  gcFIXUP2(ut->current_multi_scope_pairs, gc);
  gcFIXUP2(ut->rp, gc);
  gcFIXUP2(ut->decoded, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Unmarshal_Tables));
# endif
#endif
}

#define mark_unmarshal_tables_IS_ATOMIC 0
#define mark_unmarshal_tables_IS_CONST_SIZE 1


