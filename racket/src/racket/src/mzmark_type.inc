/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int variable_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
#else
  return 0;
#endif
}

static int variable_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcMARK2(b->key, gc);
  gcMARK2(b->val, gc);
  gcMARK2(((Scheme_Bucket_With_Home *)b)->home_link, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
# endif
#endif
}

static int variable_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcFIXUP2(b->key, gc);
  gcFIXUP2(b->val, gc);
  gcFIXUP2(((Scheme_Bucket_With_Home *)b)->home_link, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
# endif
#endif
}

#define variable_obj_IS_ATOMIC 0
#define variable_obj_IS_CONST_SIZE 1


static int bucket_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
#else
  return 0;
#endif
}

static int bucket_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcMARK2(b->key, gc);
  gcMARK2(b->val, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
# endif
#endif
}

static int bucket_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcFIXUP2(b->key, gc);
  gcFIXUP2(b->val, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
# endif
#endif
}

#define bucket_obj_IS_ATOMIC 0
#define bucket_obj_IS_CONST_SIZE 1


static int local_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
#else
  return 0;
#endif
}

static int local_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
# endif
#endif
}

static int local_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
# endif
#endif
}

#define local_obj_IS_ATOMIC 1
#define local_obj_IS_CONST_SIZE 1


static int toplevel_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
#else
  return 0;
#endif
}

static int toplevel_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
# endif
#endif
}

static int toplevel_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
# endif
#endif
}

#define toplevel_obj_IS_ATOMIC 1
#define toplevel_obj_IS_CONST_SIZE 1


static int static_toplevel_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
#else
  return 0;
#endif
}

static int static_toplevel_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  gcMARK2(SCHEME_STATIC_TOPLEVEL_PREFIX(p), gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
# endif
#endif
}

static int static_toplevel_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  gcFIXUP2(SCHEME_STATIC_TOPLEVEL_PREFIX(p), gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
# endif
#endif
}

#define static_toplevel_obj_IS_ATOMIC 0
#define static_toplevel_obj_IS_CONST_SIZE 1


static int cpointer_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
   (SCHEME_CPTR_HAS_OFFSET(p)
    ? gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr))
    : gcBYTES_TO_WORDS(sizeof(Scheme_Cptr)));
#else
  return 0;
#endif
}

static int cpointer_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  if (!(SCHEME_CPTR_FLAGS(p) & 0x1)) {
    gcMARK2(SCHEME_CPTR_VAL(p), gc);
  }
  gcMARK2(SCHEME_CPTR_TYPE(p), gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
   (SCHEME_CPTR_HAS_OFFSET(p)
    ? gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr))
    : gcBYTES_TO_WORDS(sizeof(Scheme_Cptr)));
# endif
#endif
}

static int cpointer_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  if (!(SCHEME_CPTR_FLAGS(p) & 0x1)) {
    gcFIXUP2(SCHEME_CPTR_VAL(p), gc);
  }
  gcFIXUP2(SCHEME_CPTR_TYPE(p), gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
   (SCHEME_CPTR_HAS_OFFSET(p)
    ? gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr))
    : gcBYTES_TO_WORDS(sizeof(Scheme_Cptr)));
# endif
#endif
}

#define cpointer_obj_IS_ATOMIC 0
#define cpointer_obj_IS_CONST_SIZE 0


static int twoptr_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
#else
  return 0;
#endif
}

static int twoptr_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  gcMARK2(SCHEME_PTR1_VAL((Scheme_Object *)p), gc);
  gcMARK2(SCHEME_PTR2_VAL((Scheme_Object *)p), gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

static int twoptr_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  gcFIXUP2(SCHEME_PTR1_VAL((Scheme_Object *)p), gc);
  gcFIXUP2(SCHEME_PTR2_VAL((Scheme_Object *)p), gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

#define twoptr_obj_IS_ATOMIC 0
#define twoptr_obj_IS_CONST_SIZE 1


static int iptr_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
#else
  return 0;
#endif
}

static int iptr_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  gcMARK2(SCHEME_IPTR_VAL((Scheme_Object *)p), gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

static int iptr_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  gcFIXUP2(SCHEME_IPTR_VAL((Scheme_Object *)p), gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

#define iptr_obj_IS_ATOMIC 0
#define iptr_obj_IS_CONST_SIZE 1


static int small_object_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
#else
  return 0;
#endif
}

static int small_object_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  gcMARK2(((Scheme_Small_Object *)p)->u.ptr_value, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
# endif
#endif
}

static int small_object_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  gcFIXUP2(((Scheme_Small_Object *)p)->u.ptr_value, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
# endif
#endif
}

#define small_object_IS_ATOMIC 0
#define small_object_IS_CONST_SIZE 1


static int small_atomic_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
#else
  return 0;
#endif
}

static int small_atomic_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
# endif
#endif
}

static int small_atomic_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
# endif
#endif
}

#define small_atomic_obj_IS_ATOMIC 1
#define small_atomic_obj_IS_CONST_SIZE 1


static int app_rec_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + ((r->num_args + 1 - mzFLEX_DELTA) * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
#else
  return 0;
#endif
}

static int app_rec_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  int i = r->num_args + 1;
  while (i--) 
    gcMARK2(r->args[i], gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + ((r->num_args + 1 - mzFLEX_DELTA) * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
# endif
#endif
}

static int app_rec_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  int i = r->num_args + 1;
  while (i--) 
    gcFIXUP2(r->args[i], gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + ((r->num_args + 1 - mzFLEX_DELTA) * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
# endif
#endif
}

#define app_rec_IS_ATOMIC 0
#define app_rec_IS_CONST_SIZE 0


static int app2_rec_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
#else
  return 0;
#endif
}

static int app2_rec_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_App2_Rec *r = (Scheme_App2_Rec *)p;
  gcMARK2(r->rator, gc);
  gcMARK2(r->rand, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
# endif
#endif
}

static int app2_rec_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_App2_Rec *r = (Scheme_App2_Rec *)p;
  gcFIXUP2(r->rator, gc);
  gcFIXUP2(r->rand, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
# endif
#endif
}

#define app2_rec_IS_ATOMIC 0
#define app2_rec_IS_CONST_SIZE 1


static int app3_rec_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
#else
  return 0;
#endif
}

static int app3_rec_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_App3_Rec *r = (Scheme_App3_Rec *)p;
  gcMARK2(r->rator, gc);
  gcMARK2(r->rand1, gc);
  gcMARK2(r->rand2, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
# endif
#endif
}

static int app3_rec_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_App3_Rec *r = (Scheme_App3_Rec *)p;
  gcFIXUP2(r->rator, gc);
  gcFIXUP2(r->rand1, gc);
  gcFIXUP2(r->rand2, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
# endif
#endif
}

#define app3_rec_IS_ATOMIC 0
#define app3_rec_IS_CONST_SIZE 1


static int seq_rec_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
#else
  return 0;
#endif
}

static int seq_rec_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  int i = s->count;
  while (i--)
    gcMARK2(s->array[i], gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
# endif
#endif
}

static int seq_rec_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  int i = s->count;
  while (i--)
    gcFIXUP2(s->array[i], gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
# endif
#endif
}

#define seq_rec_IS_ATOMIC 0
#define seq_rec_IS_CONST_SIZE 0


static int branch_rec_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
#else
  return 0;
#endif
}

static int branch_rec_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Branch_Rec *b = (Scheme_Branch_Rec *)p;
  
  gcMARK2(b->test, gc);
  gcMARK2(b->tbranch, gc);
  gcMARK2(b->fbranch, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
# endif
#endif
}

static int branch_rec_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Branch_Rec *b = (Scheme_Branch_Rec *)p;
  
  gcFIXUP2(b->test, gc);
  gcFIXUP2(b->tbranch, gc);
  gcFIXUP2(b->fbranch, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
# endif
#endif
}

#define branch_rec_IS_ATOMIC 0
#define branch_rec_IS_CONST_SIZE 1


static int unclosed_proc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Lambda));
#else
  return 0;
#endif
}

static int unclosed_proc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Lambda *d = (Scheme_Lambda *)p;

  gcMARK2(d->name, gc);
  gcMARK2(d->body, gc);
  gcMARK2(d->closure_map, gc); /* covers `ir_info` */
  gcMARK2(d->tl_map, gc);
#ifdef MZ_USE_JIT
  gcMARK2(d->u.native_code, gc);
  gcMARK2(d->context, gc);
#endif

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lambda));
# endif
#endif
}

static int unclosed_proc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Lambda *d = (Scheme_Lambda *)p;

  gcFIXUP2(d->name, gc);
  gcFIXUP2(d->body, gc);
  gcFIXUP2(d->closure_map, gc); /* covers `ir_info` */
  gcFIXUP2(d->tl_map, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(d->u.native_code, gc);
  gcFIXUP2(d->context, gc);
#endif

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lambda));
# endif
#endif
}

#define unclosed_proc_IS_ATOMIC 0
#define unclosed_proc_IS_CONST_SIZE 1


static int let_value_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
#else
  return 0;
#endif
}

static int let_value_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Let_Value *l = (Scheme_Let_Value *)p;
  
  gcMARK2(l->value, gc);
  gcMARK2(l->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
# endif
#endif
}

static int let_value_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Let_Value *l = (Scheme_Let_Value *)p;
  
  gcFIXUP2(l->value, gc);
  gcFIXUP2(l->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
# endif
#endif
}

#define let_value_IS_ATOMIC 0
#define let_value_IS_CONST_SIZE 1


static int let_void_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
#else
  return 0;
#endif
}

static int let_void_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Let_Void *l = (Scheme_Let_Void *)p;

  gcMARK2(l->body, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
# endif
#endif
}

static int let_void_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Let_Void *l = (Scheme_Let_Void *)p;

  gcFIXUP2(l->body, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
# endif
#endif
}

#define let_void_IS_ATOMIC 0
#define let_void_IS_CONST_SIZE 1


static int letrec_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
#else
  return 0;
#endif
}

static int letrec_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Letrec *l = (Scheme_Letrec *)p;
  
  gcMARK2(l->procs, gc);
  gcMARK2(l->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
# endif
#endif
}

static int letrec_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Letrec *l = (Scheme_Letrec *)p;
  
  gcFIXUP2(l->procs, gc);
  gcFIXUP2(l->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
# endif
#endif
}

#define letrec_IS_ATOMIC 0
#define letrec_IS_CONST_SIZE 1


static int let_one_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
#else
  return 0;
#endif
}

static int let_one_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Let_One *l = (Scheme_Let_One *)p;
  
  gcMARK2(l->value, gc);
  gcMARK2(l->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
# endif
#endif
}

static int let_one_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Let_One *l = (Scheme_Let_One *)p;
  
  gcFIXUP2(l->value, gc);
  gcFIXUP2(l->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
# endif
#endif
}

#define let_one_IS_ATOMIC 0
#define let_one_IS_CONST_SIZE 1


static int with_cont_mark_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
#else
  return 0;
#endif
}

static int with_cont_mark_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_With_Continuation_Mark *w = (Scheme_With_Continuation_Mark *)p;

  gcMARK2(w->key, gc);
  gcMARK2(w->val, gc);
  gcMARK2(w->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
# endif
#endif
}

static int with_cont_mark_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_With_Continuation_Mark *w = (Scheme_With_Continuation_Mark *)p;

  gcFIXUP2(w->key, gc);
  gcFIXUP2(w->val, gc);
  gcFIXUP2(w->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
# endif
#endif
}

#define with_cont_mark_IS_ATOMIC 0
#define with_cont_mark_IS_CONST_SIZE 1


static int ir_local_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Local));
#else
  return 0;
#endif
}

static int ir_local_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_IR_Local *var = (Scheme_IR_Local *)p;

  gcMARK2(var->name, gc);
  switch (var->mode) {
  case SCHEME_VAR_MODE_COMPILE:
    gcMARK2(var->compile.use_box, gc);
    break;
  case SCHEME_VAR_MODE_LETREC_CHECK:
    gcMARK2(var->letrec_check.frame, gc);
    break;
  case SCHEME_VAR_MODE_OPTIMIZE:
    gcMARK2(var->optimize.known_val, gc);
    gcMARK2(var->optimize.transitive_uses, gc);
    break;
  case SCHEME_VAR_MODE_RESOLVE:
    gcMARK2(var->resolve.lifted, gc);
    break;
  default:
    break;
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Local));
# endif
#endif
}

static int ir_local_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_IR_Local *var = (Scheme_IR_Local *)p;

  gcFIXUP2(var->name, gc);
  switch (var->mode) {
  case SCHEME_VAR_MODE_COMPILE:
    gcFIXUP2(var->compile.use_box, gc);
    break;
  case SCHEME_VAR_MODE_LETREC_CHECK:
    gcFIXUP2(var->letrec_check.frame, gc);
    break;
  case SCHEME_VAR_MODE_OPTIMIZE:
    gcFIXUP2(var->optimize.known_val, gc);
    gcFIXUP2(var->optimize.transitive_uses, gc);
    break;
  case SCHEME_VAR_MODE_RESOLVE:
    gcFIXUP2(var->resolve.lifted, gc);
    break;
  default:
    break;
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Local));
# endif
#endif
}

#define ir_local_IS_ATOMIC 0
#define ir_local_IS_CONST_SIZE 1


static int ir_toplevel_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Toplevel));
#else
  return 0;
#endif
}

static int ir_toplevel_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Toplevel));
# endif
#endif
}

static int ir_toplevel_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Toplevel));
# endif
#endif
}

#define ir_toplevel_IS_ATOMIC 1
#define ir_toplevel_IS_CONST_SIZE 1


static int ir_let_value_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Let_Value));
#else
  return 0;
#endif
}

static int ir_let_value_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_IR_Let_Value *c = (Scheme_IR_Let_Value *)p;

  gcMARK2(c->value, gc);
  gcMARK2(c->body, gc);
  gcMARK2(c->vars, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Let_Value));
# endif
#endif
}

static int ir_let_value_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_IR_Let_Value *c = (Scheme_IR_Let_Value *)p;

  gcFIXUP2(c->value, gc);
  gcFIXUP2(c->body, gc);
  gcFIXUP2(c->vars, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Let_Value));
# endif
#endif
}

#define ir_let_value_IS_ATOMIC 0
#define ir_let_value_IS_CONST_SIZE 1


static int let_header_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Let_Header));
#else
  return 0;
#endif
}

static int let_header_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_IR_Let_Header *h = (Scheme_IR_Let_Header *)p;
  
  gcMARK2(h->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Let_Header));
# endif
#endif
}

static int let_header_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_IR_Let_Header *h = (Scheme_IR_Let_Header *)p;
  
  gcFIXUP2(h->body, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_IR_Let_Header));
# endif
#endif
}

#define let_header_IS_ATOMIC 0
#define let_header_IS_CONST_SIZE 1


static int set_bang_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Set_Bang));
#else
  return 0;
#endif
}

static int set_bang_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Set_Bang *b = (Scheme_Set_Bang *)p;
  
  gcMARK2(b->var, gc);
  gcMARK2(b->val, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Set_Bang));
# endif
#endif
}

static int set_bang_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Set_Bang *b = (Scheme_Set_Bang *)p;
  
  gcFIXUP2(b->var, gc);
  gcFIXUP2(b->val, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Set_Bang));
# endif
#endif
}

#define set_bang_IS_ATOMIC 0
#define set_bang_IS_CONST_SIZE 1


static int prim_proc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - mzFLEX_DELTA)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
#else
  return 0;
#endif
}

static int prim_proc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  gcMARK2(prim->name, gc);
  if (prim->mina < 0) {
    gcMARK2(prim->mu.cases, gc);
  }
  if (prim->pp.flags & SCHEME_PRIM_IS_CLOSURE) {
    Scheme_Primitive_Closure *cc = (Scheme_Primitive_Closure *)prim;
    int i;
    for (i = cc->count; i--; ) {
      gcMARK2(cc->val[i], gc);
    }
  }  
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - mzFLEX_DELTA)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
# endif
#endif
}

static int prim_proc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  gcFIXUP2(prim->name, gc);
  if (prim->mina < 0) {
    gcFIXUP2(prim->mu.cases, gc);
  }
  if (prim->pp.flags & SCHEME_PRIM_IS_CLOSURE) {
    Scheme_Primitive_Closure *cc = (Scheme_Primitive_Closure *)prim;
    int i;
    for (i = cc->count; i--; ) {
      gcFIXUP2(cc->val[i], gc);
    }
  }  
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - mzFLEX_DELTA)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
# endif
#endif
}

#define prim_proc_IS_ATOMIC 0
#define prim_proc_IS_CONST_SIZE 0


static int closed_prim_proc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
#else
  return 0;
#endif
}

static int closed_prim_proc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  gcMARK2(c->name, gc);
  gcMARK2(SCHEME_CLSD_PRIM_DATA(c), gc);
  if (c->mina == -2) {
    gcMARK2(((Scheme_Closed_Case_Primitive_Proc *)c)->cases, gc);
  }
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
# endif
#endif
}

static int closed_prim_proc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  gcFIXUP2(c->name, gc);
  gcFIXUP2(SCHEME_CLSD_PRIM_DATA(c), gc);
  if (c->mina == -2) {
    gcFIXUP2(((Scheme_Closed_Case_Primitive_Proc *)c)->cases, gc);
  }
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
# endif
#endif
}

#define closed_prim_proc_IS_ATOMIC 0
#define closed_prim_proc_IS_CONST_SIZE 0


static int scm_closure_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Lambda *)GC_resolve2(c->code, gc))->closure_size
                      : 0);

  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
#else
  return 0;
#endif
}

static int scm_closure_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Lambda *)GC_resolve2(c->code, gc))->closure_size
                      : 0);


  int i = closure_size;
# define CLOSURE_DATA_TYPE Scheme_Lambda
# include "mzclpf_decl.inc"

  gcMARK2(c->code, gc);

# include "mzclpf_pre.inc"

  while (i--)
    gcMARK2(c->vals[i], gc);

# include "mzclpf_post.inc"
# undef CLOSURE_DATA_TYPE
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
# endif
#endif
}

static int scm_closure_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Lambda *)GC_resolve2(c->code, gc))->closure_size
                      : 0);


  int i = closure_size;

  gcFIXUP2(c->code, gc);


  while (i--)
    gcFIXUP2(c->vals[i], gc);

  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
# endif
#endif
}

#define scm_closure_IS_ATOMIC 0
#define scm_closure_IS_CONST_SIZE 0


static int case_closure_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
#else
  return 0;
#endif
}

static int case_closure_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  int i;
  
  for (i = c->count; i--; )
    gcMARK2(c->array[i], gc);
  gcMARK2(c->name, gc);
#ifdef MZ_USE_JIT
  gcMARK2(c->native_code, gc);
#endif

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
# endif
#endif
}

static int case_closure_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  int i;
  
  for (i = c->count; i--; )
    gcFIXUP2(c->array[i], gc);
  gcFIXUP2(c->name, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_code, gc);
#endif

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
# endif
#endif
}

#define case_closure_IS_ATOMIC 0
#define case_closure_IS_CONST_SIZE 0


static int cont_proc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
#else
  return 0;
#endif
}

static int cont_proc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Cont *c = (Scheme_Cont *)p;
  
  gcMARK2(c->dw, gc);
  gcMARK2(c->prompt_tag, gc);
  gcMARK2(c->meta_continuation, gc);
  gcMARK2(c->meta_continuation_src, gc);
  gcMARK2(c->common_dw, gc);
  gcMARK2(c->save_overflow, gc);
  gcMARK2(c->runstack_copied, gc);
  gcMARK2(c->runstack_owner, gc);
  gcMARK2(c->cont_mark_stack_copied, gc);
  gcMARK2(c->cont_mark_stack_owner, gc);
  gcMARK2(c->init_config, gc);
  gcMARK2(c->init_break_cell, gc);
#ifdef MZ_USE_JIT
  gcMARK2(c->native_trace, gc);
#endif

  gcMARK2(c->buf_ptr, gc);
  MARK_cjs(&c->cjs, gc);
  MARK_stack_state(&c->ss, gc);
  gcMARK2(c->barrier_prompt, gc);
  if (!GC_merely_accounting()) {
    gcMARK2(c->runstack_start, gc);
    gcMARK2(c->runstack_saved, gc);
  }

  gcMARK2(c->prompt_id, gc);
  gcMARK2(c->prompt_buf, gc);

  gcMARK2(c->escape_cont, gc);

  gcMARK2(c->value, gc);
  gcMARK2(c->resume_to, gc);
  gcMARK2(c->use_next_cont, gc);
  gcMARK2(c->extra_marks, gc);
  gcMARK2(c->shortcut_prompt, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
# endif
#endif
}

static int cont_proc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Cont *c = (Scheme_Cont *)p;
  
  gcFIXUP2(c->dw, gc);
  gcFIXUP2(c->prompt_tag, gc);
  gcFIXUP2(c->meta_continuation, gc);
  gcFIXUP2(c->meta_continuation_src, gc);
  gcFIXUP2(c->common_dw, gc);
  gcFIXUP2(c->save_overflow, gc);
  gcFIXUP2(c->runstack_copied, gc);
  gcFIXUP2(c->runstack_owner, gc);
  gcFIXUP2(c->cont_mark_stack_copied, gc);
  gcFIXUP2(c->cont_mark_stack_owner, gc);
  gcFIXUP2(c->init_config, gc);
  gcFIXUP2(c->init_break_cell, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_trace, gc);
#endif

  gcFIXUP2(c->buf_ptr, gc);
  FIXUP_cjs(&c->cjs, gc);
  FIXUP_stack_state(&c->ss, gc);
  gcFIXUP2(c->barrier_prompt, gc);
  if (!GC_merely_accounting()) {
    gcFIXUP2(c->runstack_start, gc);
    gcFIXUP2(c->runstack_saved, gc);
  }

  gcFIXUP2(c->prompt_id, gc);
  gcFIXUP2(c->prompt_buf, gc);

  gcFIXUP2(c->escape_cont, gc);

  gcFIXUP2(c->value, gc);
  gcFIXUP2(c->resume_to, gc);
  gcFIXUP2(c->use_next_cont, gc);
  gcFIXUP2(c->extra_marks, gc);
  gcFIXUP2(c->shortcut_prompt, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
# endif
#endif
}

#define cont_proc_IS_ATOMIC 0
#define cont_proc_IS_CONST_SIZE 1


static int cont_jmp_proc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Jmp));
#else
  return 0;
#endif
}

static int cont_jmp_proc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Cont_Jmp *c = (Scheme_Cont_Jmp *)p;

  MARK_jmpup(&c->buf, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Jmp));
# endif
#endif
}

static int cont_jmp_proc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Cont_Jmp *c = (Scheme_Cont_Jmp *)p;

  FIXUP_jmpup(&c->buf, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Jmp));
# endif
#endif
}

#define cont_jmp_proc_IS_ATOMIC 0
#define cont_jmp_proc_IS_CONST_SIZE 1


static int meta_cont_proc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
#else
  return 0;
#endif
}

static int meta_cont_proc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Meta_Continuation *c = (Scheme_Meta_Continuation *)p;
  
  gcMARK2(c->prompt_tag, gc);
  gcMARK2(c->overflow, gc);
  gcMARK2(c->next, gc);
  gcMARK2(c->cont_mark_stack_copied, gc);
  gcMARK2(c->cont, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
# endif
#endif
}

static int meta_cont_proc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Meta_Continuation *c = (Scheme_Meta_Continuation *)p;
  
  gcFIXUP2(c->prompt_tag, gc);
  gcFIXUP2(c->overflow, gc);
  gcFIXUP2(c->next, gc);
  gcFIXUP2(c->cont_mark_stack_copied, gc);
  gcFIXUP2(c->cont, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
# endif
#endif
}

#define meta_cont_proc_IS_ATOMIC 0
#define meta_cont_proc_IS_CONST_SIZE 1


static int mark_dyn_wind_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
#else
  return 0;
#endif
}

static int mark_dyn_wind_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Dynamic_Wind *dw = (Scheme_Dynamic_Wind *)p;
  
  gcMARK2(dw->id, gc);
  gcMARK2(dw->data, gc);
  gcMARK2(dw->prompt_tag, gc);
  gcMARK2(dw->prev, gc);
    
  MARK_stack_state(&dw->envss, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
# endif
#endif
}

static int mark_dyn_wind_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Dynamic_Wind *dw = (Scheme_Dynamic_Wind *)p;
  
  gcFIXUP2(dw->id, gc);
  gcFIXUP2(dw->data, gc);
  gcFIXUP2(dw->prompt_tag, gc);
  gcFIXUP2(dw->prev, gc);
    
  FIXUP_stack_state(&dw->envss, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
# endif
#endif
}

#define mark_dyn_wind_IS_ATOMIC 0
#define mark_dyn_wind_IS_CONST_SIZE 1


static int mark_overflow_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
#else
  return 0;
#endif
}

static int mark_overflow_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Overflow *o = (Scheme_Overflow *)p;

  gcMARK2(o->prev, gc);
  gcMARK2(o->jmp, gc);
  gcMARK2(o->id, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
# endif
#endif
}

static int mark_overflow_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Overflow *o = (Scheme_Overflow *)p;

  gcFIXUP2(o->prev, gc);
  gcFIXUP2(o->jmp, gc);
  gcFIXUP2(o->id, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
# endif
#endif
}

#define mark_overflow_IS_ATOMIC 0
#define mark_overflow_IS_CONST_SIZE 1


static int mark_overflow_jmp_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
#else
  return 0;
#endif
}

static int mark_overflow_jmp_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Overflow_Jmp *o = (Scheme_Overflow_Jmp *)p;

  MARK_jmpup(&o->cont, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
# endif
#endif
}

static int mark_overflow_jmp_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Overflow_Jmp *o = (Scheme_Overflow_Jmp *)p;

  FIXUP_jmpup(&o->cont, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
# endif
#endif
}

#define mark_overflow_jmp_IS_ATOMIC 0
#define mark_overflow_jmp_IS_CONST_SIZE 1


static int escaping_cont_proc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
#else
  return 0;
#endif
}

static int escaping_cont_proc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Escaping_Cont *c = (Scheme_Escaping_Cont *)p;

#ifdef MZ_USE_JIT
  gcMARK2(c->native_trace, gc);
#endif

  gcMARK2(c->barrier_prompt, gc);
  MARK_stack_state(&c->envss, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
# endif
#endif
}

static int escaping_cont_proc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Escaping_Cont *c = (Scheme_Escaping_Cont *)p;

#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_trace, gc);
#endif

  gcFIXUP2(c->barrier_prompt, gc);
  FIXUP_stack_state(&c->envss, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
# endif
#endif
}

#define escaping_cont_proc_IS_ATOMIC 0
#define escaping_cont_proc_IS_CONST_SIZE 1


static int bignum_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
#else
  return 0;
#endif
}

static int bignum_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  if (!SCHEME_BIGINLINE(b)) {
    gcMARK2(b->digits, gc);
  } else {
    b->digits = ((Small_Bignum *)GC_fixup_self(b))->v;
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
# endif
#endif
}

static int bignum_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  if (!SCHEME_BIGINLINE(b)) {
    gcFIXUP2(b->digits, gc);
  } else {
    b->digits = ((Small_Bignum *)GC_fixup_self(b))->v;
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
# endif
#endif
}

#define bignum_obj_IS_ATOMIC 0
#define bignum_obj_IS_CONST_SIZE 0


static int rational_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
#else
  return 0;
#endif
}

static int rational_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Rational *r = (Scheme_Rational *)p;
  
  gcMARK2(r->num, gc);
  gcMARK2(r->denom, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
# endif
#endif
}

static int rational_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Rational *r = (Scheme_Rational *)p;
  
  gcFIXUP2(r->num, gc);
  gcFIXUP2(r->denom, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
# endif
#endif
}

#define rational_obj_IS_ATOMIC 0
#define rational_obj_IS_CONST_SIZE 1


static int float_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
#else
  return 0;
#endif
}

static int float_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
# endif
#endif
}

static int float_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
# endif
#endif
}

#define float_obj_IS_ATOMIC 1
#define float_obj_IS_CONST_SIZE 0


static int double_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
#else
  return 0;
#endif
}

static int double_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
# endif
#endif
}

static int double_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
# endif
#endif
}

#define double_obj_IS_ATOMIC 1
#define double_obj_IS_CONST_SIZE 1


#ifdef MZ_LONG_DOUBLE
static int long_double_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
#else
  return 0;
#endif
}

static int long_double_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
# endif
#endif
}

static int long_double_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
# endif
#endif
}

#define long_double_obj_IS_ATOMIC 1
#define long_double_obj_IS_CONST_SIZE 1

#else
static int long_double_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
#else
  return 0;
#endif
}

static int long_double_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Long_Double *ld = (Scheme_Long_Double *)p;
  gcMARK2(ld->printed_form, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
# endif
#endif
}

static int long_double_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Long_Double *ld = (Scheme_Long_Double *)p;
  gcFIXUP2(ld->printed_form, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
# endif
#endif
}

#define long_double_obj_IS_ATOMIC 0
#define long_double_obj_IS_CONST_SIZE 1

#endif

static int complex_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
#else
  return 0;
#endif
}

static int complex_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Complex *c = (Scheme_Complex *)p;
  
  gcMARK2(c->r, gc);
  gcMARK2(c->i, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
# endif
#endif
}

static int complex_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Complex *c = (Scheme_Complex *)p;
  
  gcFIXUP2(c->r, gc);
  gcFIXUP2(c->i, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
# endif
#endif
}

#define complex_obj_IS_ATOMIC 0
#define complex_obj_IS_CONST_SIZE 1


static int string_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
#else
  return 0;
#endif
}

static int string_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Object *o = (Scheme_Object *)p;
  gcMARK2(SCHEME_CHAR_STR_VAL(o), gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

static int string_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Object *o = (Scheme_Object *)p;
  gcFIXUP2(SCHEME_CHAR_STR_VAL(o), gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

#define string_obj_IS_ATOMIC 0
#define string_obj_IS_CONST_SIZE 1


static int bstring_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
#else
  return 0;
#endif
}

static int bstring_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Object *o = (Scheme_Object *)p;
  gcMARK2(SCHEME_BYTE_STR_VAL(o), gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

static int bstring_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Object *o = (Scheme_Object *)p;
  gcFIXUP2(SCHEME_BYTE_STR_VAL(o), gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

#define bstring_obj_IS_ATOMIC 0
#define bstring_obj_IS_CONST_SIZE 1


static int symbol_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + ((Scheme_Symbol *)p)->len + 1 - mzFLEX4_DELTA);
#else
  return 0;
#endif
}

static int symbol_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + ((Scheme_Symbol *)p)->len + 1 - mzFLEX4_DELTA);
# endif
#endif
}

static int symbol_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + ((Scheme_Symbol *)p)->len + 1 - mzFLEX4_DELTA);
# endif
#endif
}

#define symbol_obj_IS_ATOMIC 1
#define symbol_obj_IS_CONST_SIZE 0


static int cons_cell_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
#else
  return 0;
#endif
}

static int cons_cell_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Object *o = (Scheme_Object *)p;
  
  gcMARK2(SCHEME_CAR(o), gc);
  gcMARK2(SCHEME_CDR(o), gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

static int cons_cell_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Object *o = (Scheme_Object *)p;
  
  gcFIXUP2(SCHEME_CAR(o), gc);
  gcFIXUP2(SCHEME_CDR(o), gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

#define cons_cell_IS_ATOMIC 0
#define cons_cell_IS_CONST_SIZE 1


static int vector_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Vector *vec = (Scheme_Vector *)p;

  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
#else
  return 0;
#endif
}

static int vector_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Vector *vec = (Scheme_Vector *)p;

  int i;
  for (i = vec->size; i--; )
    gcMARK2(vec->els[i], gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
# endif
#endif
}

static int vector_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Vector *vec = (Scheme_Vector *)p;

  int i;
  for (i = vec->size; i--; )
    gcFIXUP2(vec->els[i], gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
# endif
#endif
}

#define vector_obj_IS_ATOMIC 0
#define vector_obj_IS_CONST_SIZE 0


static int fxvector_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((((Scheme_Vector *)p)->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
#else
  return 0;
#endif
}

static int fxvector_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((((Scheme_Vector *)p)->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
# endif
#endif
}

static int fxvector_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((((Scheme_Vector *)p)->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
# endif
#endif
}

#define fxvector_obj_IS_ATOMIC 1
#define fxvector_obj_IS_CONST_SIZE 0


static int flvector_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((((Scheme_Double_Vector *)p)->size - mzFLEX_DELTA) * sizeof(double))));
#else
  return 0;
#endif
}

static int flvector_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((((Scheme_Double_Vector *)p)->size - mzFLEX_DELTA) * sizeof(double))));
# endif
#endif
}

static int flvector_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((((Scheme_Double_Vector *)p)->size - mzFLEX_DELTA) * sizeof(double))));
# endif
#endif
}

#define flvector_obj_IS_ATOMIC 1
#define flvector_obj_IS_CONST_SIZE 0


#ifdef MZ_LONG_DOUBLE
static int extflvector_obj_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS((sizeof(Scheme_Long_Double_Vector) 
		    + ((((Scheme_Long_Double_Vector *)p)->size - mzFLEX_DELTA) * sizeof(long double))));
#else
  return 0;
#endif
}

static int extflvector_obj_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Long_Double_Vector) 
		    + ((((Scheme_Long_Double_Vector *)p)->size - mzFLEX_DELTA) * sizeof(long double))));
# endif
#endif
}

static int extflvector_obj_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Long_Double_Vector) 
		    + ((((Scheme_Long_Double_Vector *)p)->size - mzFLEX_DELTA) * sizeof(long double))));
# endif
#endif
}

#define extflvector_obj_IS_ATOMIC 1
#define extflvector_obj_IS_CONST_SIZE 0

#endif

static int input_port_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
#else
  return 0;
#endif
}

static int input_port_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Input_Port *ip = (Scheme_Input_Port *)p;
  
  gcMARK2(ip->p.position_redirect, gc);
  gcMARK2(ip->sub_type, gc);
  gcMARK2(ip->port_data, gc);
  gcMARK2(ip->name, gc);
  gcMARK2(ip->peeked_read, gc);
  gcMARK2(ip->peeked_write, gc);
  gcMARK2(ip->read_handler, gc);
  gcMARK2(ip->closed_evt, gc);
  gcMARK2(ip->mref, gc);
  gcMARK2(ip->output_half, gc);
  gcMARK2(ip->special, gc);
  gcMARK2(ip->ungotten_special, gc);
  gcMARK2(ip->progress_evt, gc);
  gcMARK2(ip->input_lock, gc);
  gcMARK2(ip->input_giveup, gc);
  gcMARK2(ip->input_extras, gc);
  gcMARK2(ip->input_extras_ready, gc);
  gcMARK2(ip->unless, gc);
  gcMARK2(ip->unless_cache, gc);
#ifdef WINDOWS_FILE_HANDLES
  gcMARK2(ip->bufwidths, gc);
#endif

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
# endif
#endif
}

static int input_port_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Input_Port *ip = (Scheme_Input_Port *)p;
  
  gcFIXUP2(ip->p.position_redirect, gc);
  gcFIXUP2(ip->sub_type, gc);
  gcFIXUP2(ip->port_data, gc);
  gcFIXUP2(ip->name, gc);
  gcFIXUP2(ip->peeked_read, gc);
  gcFIXUP2(ip->peeked_write, gc);
  gcFIXUP2(ip->read_handler, gc);
  gcFIXUP2(ip->closed_evt, gc);
  gcFIXUP2(ip->mref, gc);
  gcFIXUP2(ip->output_half, gc);
  gcFIXUP2(ip->special, gc);
  gcFIXUP2(ip->ungotten_special, gc);
  gcFIXUP2(ip->progress_evt, gc);
  gcFIXUP2(ip->input_lock, gc);
  gcFIXUP2(ip->input_giveup, gc);
  gcFIXUP2(ip->input_extras, gc);
  gcFIXUP2(ip->input_extras_ready, gc);
  gcFIXUP2(ip->unless, gc);
  gcFIXUP2(ip->unless_cache, gc);
#ifdef WINDOWS_FILE_HANDLES
  gcFIXUP2(ip->bufwidths, gc);
#endif

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
# endif
#endif
}

#define input_port_IS_ATOMIC 0
#define input_port_IS_CONST_SIZE 1


static int output_port_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
#else
  return 0;
#endif
}

static int output_port_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Output_Port *op = (Scheme_Output_Port *)p;

  gcMARK2(op->p.position_redirect, gc);
  gcMARK2(op->sub_type, gc);
  gcMARK2(op->port_data, gc);
  gcMARK2(op->name, gc);
  gcMARK2(op->display_handler, gc);
  gcMARK2(op->write_handler, gc);
  gcMARK2(op->print_handler, gc);
  gcMARK2(op->closed_evt, gc);
  gcMARK2(op->mref, gc);
  gcMARK2(op->input_half, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
# endif
#endif
}

static int output_port_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Output_Port *op = (Scheme_Output_Port *)p;

  gcFIXUP2(op->p.position_redirect, gc);
  gcFIXUP2(op->sub_type, gc);
  gcFIXUP2(op->port_data, gc);
  gcFIXUP2(op->name, gc);
  gcFIXUP2(op->display_handler, gc);
  gcFIXUP2(op->write_handler, gc);
  gcFIXUP2(op->print_handler, gc);
  gcFIXUP2(op->closed_evt, gc);
  gcFIXUP2(op->mref, gc);
  gcFIXUP2(op->input_half, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
# endif
#endif
}

#define output_port_IS_ATOMIC 0
#define output_port_IS_CONST_SIZE 1


static int thread_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
#else
  return 0;
#endif
}

static int thread_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Thread *pr = (Scheme_Thread *)p;

  gcMARK2(pr->next, gc);
  gcMARK2(pr->prev, gc);

  gcMARK2(pr->t_set_parent, gc);
  gcMARK2(pr->t_set_next, gc);
  gcMARK2(pr->t_set_prev, gc);

  MARK_cjs(&pr->cjs, gc);
  gcMARK2(pr->decompose_mc, gc);

  gcMARK2(pr->cell_values, gc);
  gcMARK2(pr->init_config, gc);
  gcMARK2(pr->init_break_cell, gc);

  if (!pr->runstack_owner
      || !GC_merely_accounting()
      || (*pr->runstack_owner == pr)) {
    Scheme_Object **rs = pr->runstack_start;
    gcMARK2( pr->runstack_start, gc);
    if (pr->runstack != pr->runstack_start + (pr->runstack - rs))
      pr->runstack = pr->runstack_start + (pr->runstack - rs);

    gcMARK2(pr->runstack_saved, gc);
  }
  gcMARK2(pr->runstack_owner, gc);
  gcMARK2(pr->runstack_swapped, gc);
  pr->spare_runstack = NULL; /* just in case */

  gcMARK2(pr->meta_prompt, gc);
  gcMARK2(pr->meta_continuation, gc);
  gcMARK2(pr->acting_barrier_prompt, gc);
  
  gcMARK2(pr->cont_mark_stack_segments, gc);
  gcMARK2(pr->cont_mark_stack_owner, gc);
  gcMARK2(pr->cont_mark_stack_swapped, gc);

  MARK_jmpup(&pr->jmpup_buf, gc);
  
  gcMARK2(pr->dw, gc);
  
  gcMARK2(pr->nester, gc);
  gcMARK2(pr->nestee, gc);

  gcMARK2(pr->current_ft, gc);
  
  gcMARK2(pr->blocker, gc);
  gcMARK2(pr->overflow, gc);

  gcMARK2(pr->return_marks_to, gc);
  gcMARK2(pr->returned_marks, gc);
  
  gcMARK2(pr->current_mt, gc);

  gcMARK2(pr->constant_folding, gc);
  gcMARK2(pr->reading_delayed, gc);
  
  gcMARK2(pr->overflow_reply, gc);

  gcMARK2(pr->values_buffer, gc);

  gcMARK2(pr->tail_buffer, gc);
  
  gcMARK2(pr->ku.eval.wait_expr, gc);

  gcMARK2(pr->ku.apply.tail_rator, gc);
  gcMARK2(pr->ku.apply.tail_rands, gc);

  gcMARK2(pr->ku.multiple.array, gc);

  gcMARK2(pr->ku.k.p1, gc);
  gcMARK2(pr->ku.k.p2, gc);
  gcMARK2(pr->ku.k.p3, gc);
  gcMARK2(pr->ku.k.p4, gc);
  gcMARK2(pr->ku.k.p5, gc);

  gcMARK2(pr->self_for_proc_chaperone, gc);
  
  gcMARK2(pr->kill_data, gc);
  gcMARK2(pr->private_kill_data, gc);
  gcMARK2(pr->private_kill_next, gc);
  
  gcMARK2(pr->user_tls, gc);
  gcMARK2(pr->gmp_tls_data, gc);
  
  gcMARK2(pr->mr_hop, gc);
  gcMARK2(pr->mref, gc);
  gcMARK2(pr->extra_mrefs, gc);

  gcMARK2(pr->name, gc);

  gcMARK2(pr->transitive_resumes, gc);

  gcMARK2(pr->suspended_box, gc);
  gcMARK2(pr->resumed_box, gc);
  gcMARK2(pr->dead_box, gc);
  gcMARK2(pr->running_box, gc);
  gcMARK2(pr->sync_box, gc);

  gcMARK2(pr->mbox_first, gc);
  gcMARK2(pr->mbox_last, gc);
  gcMARK2(pr->mbox_sema, gc);

  /* Follow msg_chain for an in-flight message like in place_async_channel_val */
  {
    Scheme_Object *cpr = pr->place_channel_msg_chain_in_flight;
    while (cpr) {
      gcMARK2(SCHEME_CAR(cpr), gc);
      cpr = SCHEME_CDR(cpr);
    }
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
# endif
#endif
}

static int thread_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Thread *pr = (Scheme_Thread *)p;

  gcFIXUP2(pr->next, gc);
  gcFIXUP2(pr->prev, gc);

  gcFIXUP2(pr->t_set_parent, gc);
  gcFIXUP2(pr->t_set_next, gc);
  gcFIXUP2(pr->t_set_prev, gc);

  FIXUP_cjs(&pr->cjs, gc);
  gcFIXUP2(pr->decompose_mc, gc);

  gcFIXUP2(pr->cell_values, gc);
  gcFIXUP2(pr->init_config, gc);
  gcFIXUP2(pr->init_break_cell, gc);

  if (!pr->runstack_owner
      || !GC_merely_accounting()
      || (*pr->runstack_owner == pr)) {
    Scheme_Object **rs = pr->runstack_start;
    gcFIXUP2_TYPED_NOW(Scheme_Object **, pr->runstack_start, gc);
    if (pr->runstack != pr->runstack_start + (pr->runstack - rs))
      pr->runstack = pr->runstack_start + (pr->runstack - rs);

    gcFIXUP2(pr->runstack_saved, gc);
  }
  gcFIXUP2(pr->runstack_owner, gc);
  gcFIXUP2(pr->runstack_swapped, gc);
  pr->spare_runstack = NULL; /* just in case */

  gcFIXUP2(pr->meta_prompt, gc);
  gcFIXUP2(pr->meta_continuation, gc);
  gcFIXUP2(pr->acting_barrier_prompt, gc);
  
  gcFIXUP2(pr->cont_mark_stack_segments, gc);
  gcFIXUP2(pr->cont_mark_stack_owner, gc);
  gcFIXUP2(pr->cont_mark_stack_swapped, gc);

  FIXUP_jmpup(&pr->jmpup_buf, gc);
  
  gcFIXUP2(pr->dw, gc);
  
  gcFIXUP2(pr->nester, gc);
  gcFIXUP2(pr->nestee, gc);

  gcFIXUP2(pr->current_ft, gc);
  
  gcFIXUP2(pr->blocker, gc);
  gcFIXUP2(pr->overflow, gc);

  gcFIXUP2(pr->return_marks_to, gc);
  gcFIXUP2(pr->returned_marks, gc);
  
  gcFIXUP2(pr->current_mt, gc);

  gcFIXUP2(pr->constant_folding, gc);
  gcFIXUP2(pr->reading_delayed, gc);
  
  gcFIXUP2(pr->overflow_reply, gc);

  gcFIXUP2(pr->values_buffer, gc);

  gcFIXUP2(pr->tail_buffer, gc);
  
  gcFIXUP2(pr->ku.eval.wait_expr, gc);

  gcFIXUP2(pr->ku.apply.tail_rator, gc);
  gcFIXUP2(pr->ku.apply.tail_rands, gc);

  gcFIXUP2(pr->ku.multiple.array, gc);

  gcFIXUP2(pr->ku.k.p1, gc);
  gcFIXUP2(pr->ku.k.p2, gc);
  gcFIXUP2(pr->ku.k.p3, gc);
  gcFIXUP2(pr->ku.k.p4, gc);
  gcFIXUP2(pr->ku.k.p5, gc);

  gcFIXUP2(pr->self_for_proc_chaperone, gc);
  
  gcFIXUP2(pr->kill_data, gc);
  gcFIXUP2(pr->private_kill_data, gc);
  gcFIXUP2(pr->private_kill_next, gc);
  
  gcFIXUP2(pr->user_tls, gc);
  gcFIXUP2(pr->gmp_tls_data, gc);
  
  gcFIXUP2(pr->mr_hop, gc);
  gcFIXUP2(pr->mref, gc);
  gcFIXUP2(pr->extra_mrefs, gc);

  gcFIXUP2(pr->name, gc);

  gcFIXUP2(pr->transitive_resumes, gc);

  gcFIXUP2(pr->suspended_box, gc);
  gcFIXUP2(pr->resumed_box, gc);
  gcFIXUP2(pr->dead_box, gc);
  gcFIXUP2(pr->running_box, gc);
  gcFIXUP2(pr->sync_box, gc);

  gcFIXUP2(pr->mbox_first, gc);
  gcFIXUP2(pr->mbox_last, gc);
  gcFIXUP2(pr->mbox_sema, gc);

  /* Follow msg_chain for an in-flight message like in place_async_channel_val */
  {
    Scheme_Object *cpr = pr->place_channel_msg_chain_in_flight;
    while (cpr) {
      gcFIXUP2(SCHEME_CAR(cpr), gc);
      cpr = SCHEME_CDR(cpr);
    }
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
# endif
#endif
}

#define thread_val_IS_ATOMIC 0
#define thread_val_IS_CONST_SIZE 1


static int runstack_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  intptr_t *s = (intptr_t *)p;
  s[1];
#else
  return 0;
#endif
}

static int runstack_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  intptr_t *s = (intptr_t *)p;
  void **a, **b;
  a = (void **)s + 5 + s[2];
  b = (void **)s + 5 + s[3];
  while (a < b) {
    gcMARK2(*a, gc);
    a++;
  }

  /* Zero out the part that we didn't mark, in case it becomes
     live later. */
  a = (void **)s + 5;
  b = (void **)s + 5 + s[2];
  while (a < b) {
    *a = RUNSTACK_ZERO_VAL;
    a++;
  }
  a = (void **)s + 5 + s[3];
  b = (void **)s + 5 + (s[1] - 5);
  while (a < b) {
    *a = RUNSTACK_ZERO_VAL;
    a++;
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  s[1];
# endif
#endif
}

static int runstack_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  intptr_t *s = (intptr_t *)p;
  void **a, **b;
  a = (void **)s + 5 + s[2];
  b = (void **)s + 5 + s[3];
  while (a < b) {
    gcFIXUP2(*a, gc);
    a++;
  }


# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  s[1];
# endif
#endif
}

#define runstack_val_IS_ATOMIC 0
#define runstack_val_IS_CONST_SIZE 0


static int prompt_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
#else
  return 0;
#endif
}

static int prompt_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Prompt *pr = (Scheme_Prompt *)p;
  gcMARK2(pr->boundary_overflow_id, gc);
  if (!GC_merely_accounting())
    gcMARK2(pr->runstack_boundary_start, gc);
  gcMARK2(pr->tag, gc);
  gcMARK2(pr->id, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
# endif
#endif
}

static int prompt_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Prompt *pr = (Scheme_Prompt *)p;
  gcFIXUP2(pr->boundary_overflow_id, gc);
  if (!GC_merely_accounting())
    gcFIXUP2(pr->runstack_boundary_start, gc);
  gcFIXUP2(pr->tag, gc);
  gcFIXUP2(pr->id, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
# endif
#endif
}

#define prompt_val_IS_ATOMIC 0
#define prompt_val_IS_CONST_SIZE 1


static int cont_mark_set_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
#else
  return 0;
#endif
}

static int cont_mark_set_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Cont_Mark_Set *s = (Scheme_Cont_Mark_Set *)p;
  gcMARK2(s->chain, gc);
  gcMARK2(s->native_stack_trace, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
# endif
#endif
}

static int cont_mark_set_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Cont_Mark_Set *s = (Scheme_Cont_Mark_Set *)p;
  gcFIXUP2(s->chain, gc);
  gcFIXUP2(s->native_stack_trace, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
# endif
#endif
}

#define cont_mark_set_val_IS_ATOMIC 0
#define cont_mark_set_val_IS_CONST_SIZE 1


static int sema_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
#else
  return 0;
#endif
}

static int sema_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Sema *s = (Scheme_Sema *)p;

  gcMARK2(s->first, gc);
  gcMARK2(s->last, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
# endif
#endif
}

static int sema_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Sema *s = (Scheme_Sema *)p;

  gcFIXUP2(s->first, gc);
  gcFIXUP2(s->last, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
# endif
#endif
}

#define sema_val_IS_ATOMIC 0
#define sema_val_IS_CONST_SIZE 1


static int channel_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
#else
  return 0;
#endif
}

static int channel_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Channel *s = (Scheme_Channel *)p;

  gcMARK2(s->get_first, gc);
  gcMARK2(s->get_last, gc);
  gcMARK2(s->put_first, gc);
  gcMARK2(s->put_last, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
# endif
#endif
}

static int channel_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Channel *s = (Scheme_Channel *)p;

  gcFIXUP2(s->get_first, gc);
  gcFIXUP2(s->get_last, gc);
  gcFIXUP2(s->put_first, gc);
  gcFIXUP2(s->put_last, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
# endif
#endif
}

#define channel_val_IS_ATOMIC 0
#define channel_val_IS_CONST_SIZE 1


static int channel_put_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
#else
  return 0;
#endif
}

static int channel_put_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Channel_Put *s = (Scheme_Channel_Put *)p;

  gcMARK2(s->ch, gc);
  gcMARK2(s->val, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
# endif
#endif
}

static int channel_put_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Channel_Put *s = (Scheme_Channel_Put *)p;

  gcFIXUP2(s->ch, gc);
  gcFIXUP2(s->val, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
# endif
#endif
}

#define channel_put_val_IS_ATOMIC 0
#define channel_put_val_IS_CONST_SIZE 1


static int hash_table_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
#else
  return 0;
#endif
}

static int hash_table_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Hash_Table *ht = (Scheme_Hash_Table *)p;

  gcMARK2(ht->keys, gc);
  gcMARK2(ht->vals, gc);
  gcMARK2(ht->mutex, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
# endif
#endif
}

static int hash_table_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Hash_Table *ht = (Scheme_Hash_Table *)p;

  gcFIXUP2(ht->keys, gc);
  gcFIXUP2(ht->vals, gc);
  gcFIXUP2(ht->mutex, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
# endif
#endif
}

#define hash_table_val_IS_ATOMIC 0
#define hash_table_val_IS_CONST_SIZE 1


static int bucket_table_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
#else
  return 0;
#endif
}

static int bucket_table_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Bucket_Table *ht = (Scheme_Bucket_Table *)p;

  gcMARK2(ht->buckets, gc);
  gcMARK2(ht->mutex, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
# endif
#endif
}

static int bucket_table_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Bucket_Table *ht = (Scheme_Bucket_Table *)p;

  gcFIXUP2(ht->buckets, gc);
  gcFIXUP2(ht->mutex, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
# endif
#endif
}

#define bucket_table_val_IS_ATOMIC 0
#define bucket_table_val_IS_CONST_SIZE 1


static int env_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
#else
  return 0;
#endif
}

static int env_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Env *e = (Scheme_Env *)p;

  gcMARK2(e->namespace, gc);
  gcMARK2(e->instance, gc);
  gcMARK2(e->protected, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
# endif
#endif
}

static int env_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Env *e = (Scheme_Env *)p;

  gcFIXUP2(e->namespace, gc);
  gcFIXUP2(e->instance, gc);
  gcFIXUP2(e->protected, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
# endif
#endif
}

#define env_val_IS_ATOMIC 0
#define env_val_IS_CONST_SIZE 1


static int startup_env_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Startup_Env));
#else
  return 0;
#endif
}

static int startup_env_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Startup_Env *e = (Scheme_Startup_Env *)p;

  gcMARK2(e->current_table, gc);
  gcMARK2(e->primitive_tables, gc);
  gcMARK2(e->all_primitives_table, gc);
  gcMARK2(e->primitive_ids_table, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Startup_Env));
# endif
#endif
}

static int startup_env_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Startup_Env *e = (Scheme_Startup_Env *)p;

  gcFIXUP2(e->current_table, gc);
  gcFIXUP2(e->primitive_tables, gc);
  gcFIXUP2(e->all_primitives_table, gc);
  gcFIXUP2(e->primitive_ids_table, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Startup_Env));
# endif
#endif
}

#define startup_env_val_IS_ATOMIC 0
#define startup_env_val_IS_CONST_SIZE 1


static int random_state_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
#else
  return 0;
#endif
}

static int random_state_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
# endif
#endif
}

static int random_state_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
# endif
#endif
}

#define random_state_val_IS_ATOMIC 1
#define random_state_val_IS_CONST_SIZE 1


static int prefix_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Prefix *pf = (Scheme_Prefix *)p;
  gcBYTES_TO_WORDS((sizeof(Scheme_Prefix) 
		    + ((pf->num_slots-mzFLEX_DELTA) * sizeof(Scheme_Object *))
                    + ((((pf->num_slots + 31) / 32) 
                       * sizeof(int))));
#else
  return 0;
#endif
}

static int prefix_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Prefix *pf = (Scheme_Prefix *)p;
  int i;
  for (i = pf->num_slots; i--; )
    gcMARK2(pf->a[i], gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Prefix) 
		    + ((pf->num_slots-mzFLEX_DELTA) * sizeof(Scheme_Object *))
                    + ((((pf->num_slots + 31) / 32) 
                       * sizeof(int))));
# endif
#endif
}

static int prefix_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Prefix *pf = (Scheme_Prefix *)p;
  int i;
  for (i = pf->num_slots; i--; )
    gcFIXUP2(pf->a[i], gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Prefix) 
		    + ((pf->num_slots-mzFLEX_DELTA) * sizeof(Scheme_Object *))
                    + ((((pf->num_slots + 31) / 32) 
                       * sizeof(int))));
# endif
#endif
}

#define prefix_val_IS_ATOMIC 0
#define prefix_val_IS_CONST_SIZE 0


static int svector_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
#else
  return 0;
#endif
}

static int svector_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Object *o = (Scheme_Object *)p;

  gcMARK2(SCHEME_SVEC_VEC(o), gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

static int svector_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Object *o = (Scheme_Object *)p;

  gcFIXUP2(SCHEME_SVEC_VEC(o), gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
# endif
#endif
}

#define svector_val_IS_ATOMIC 0
#define svector_val_IS_CONST_SIZE 1


static int stx_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
#else
  return 0;
#endif
}

static int stx_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Stx *stx = (Scheme_Stx *)p;
  gcMARK2(stx->val, gc);
  gcMARK2(stx->srcloc, gc);
  gcMARK2(stx->props, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
# endif
#endif
}

static int stx_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Stx *stx = (Scheme_Stx *)p;
  gcFIXUP2(stx->val, gc);
  gcFIXUP2(stx->srcloc, gc);
  gcFIXUP2(stx->props, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
# endif
#endif
}

#define stx_val_IS_ATOMIC 0
#define stx_val_IS_CONST_SIZE 1


static int linklet_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Linklet));
#else
  return 0;
#endif
}

static int linklet_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Linklet *l = (Scheme_Linklet *)p;

  gcMARK2(l->name, gc);
  gcMARK2(l->importss, gc);
  gcMARK2(l->import_shapes, gc);
  gcMARK2(l->defns, gc);
  gcMARK2(l->source_names, gc);
  gcMARK2(l->bodies, gc);
  gcMARK2(l->constants, gc);
  gcMARK2(l->static_prefix, gc);
  gcMARK2(l->native_lambdas, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Linklet));
# endif
#endif
}

static int linklet_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Linklet *l = (Scheme_Linklet *)p;

  gcFIXUP2(l->name, gc);
  gcFIXUP2(l->importss, gc);
  gcFIXUP2(l->import_shapes, gc);
  gcFIXUP2(l->defns, gc);
  gcFIXUP2(l->source_names, gc);
  gcFIXUP2(l->bodies, gc);
  gcFIXUP2(l->constants, gc);
  gcFIXUP2(l->static_prefix, gc);
  gcFIXUP2(l->native_lambdas, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Linklet));
# endif
#endif
}

#define linklet_val_IS_ATOMIC 0
#define linklet_val_IS_CONST_SIZE 1


static int instance_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Instance));
#else
  return 0;
#endif
}

static int instance_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Instance *i = (Scheme_Instance *)p;

  gcMARK2(i->variables.a, gc);
  gcMARK2(i->weak_self_link, gc);
  gcMARK2(i->source_names, gc);
  gcMARK2(i->name, gc);
  gcMARK2(i->data, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Instance));
# endif
#endif
}

static int instance_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Instance *i = (Scheme_Instance *)p;

  gcFIXUP2(i->variables.a, gc);
  gcFIXUP2(i->weak_self_link, gc);
  gcFIXUP2(i->source_names, gc);
  gcFIXUP2(i->name, gc);
  gcFIXUP2(i->data, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Instance));
# endif
#endif
}

#define instance_val_IS_ATOMIC 0
#define instance_val_IS_CONST_SIZE 1


static int guard_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
#else
  return 0;
#endif
}

static int guard_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Security_Guard *g = (Scheme_Security_Guard *)p;

  gcMARK2(g->parent, gc);
  gcMARK2(g->file_proc, gc);
  gcMARK2(g->network_proc, gc);
  gcMARK2(g->link_proc, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
# endif
#endif
}

static int guard_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Security_Guard *g = (Scheme_Security_Guard *)p;

  gcFIXUP2(g->parent, gc);
  gcFIXUP2(g->file_proc, gc);
  gcFIXUP2(g->network_proc, gc);
  gcFIXUP2(g->link_proc, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
# endif
#endif
}

#define guard_val_IS_ATOMIC 0
#define guard_val_IS_CONST_SIZE 1


static int buf_holder_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
#else
  return 0;
#endif
}

static int buf_holder_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Jumpup_Buf_Holder *h = (Scheme_Jumpup_Buf_Holder *)p;
 
  MARK_jmpup(&h->buf, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
# endif
#endif
}

static int buf_holder_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Jumpup_Buf_Holder *h = (Scheme_Jumpup_Buf_Holder *)p;
 
  FIXUP_jmpup(&h->buf, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
# endif
#endif
}

#define buf_holder_IS_ATOMIC 0
#define buf_holder_IS_CONST_SIZE 1


static int mark_inspector_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
#else
  return 0;
#endif
}

static int mark_inspector_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Inspector *i = (Scheme_Inspector *)p;
  gcMARK2(i->superior, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
# endif
#endif
}

static int mark_inspector_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Inspector *i = (Scheme_Inspector *)p;
  gcFIXUP2(i->superior, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
# endif
#endif
}

#define mark_inspector_IS_ATOMIC 0
#define mark_inspector_IS_CONST_SIZE 1


static int mark_pipe_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
#else
  return 0;
#endif
}

static int mark_pipe_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Pipe *pp = (Scheme_Pipe *)p;
    
  gcMARK2(pp->buf, gc);
  gcMARK2(pp->wakeup_on_read, gc);
  gcMARK2(pp->wakeup_on_write, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
# endif
#endif
}

static int mark_pipe_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Pipe *pp = (Scheme_Pipe *)p;
    
  gcFIXUP2(pp->buf, gc);
  gcFIXUP2(pp->wakeup_on_read, gc);
  gcFIXUP2(pp->wakeup_on_write, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
# endif
#endif
}

#define mark_pipe_IS_ATOMIC 0
#define mark_pipe_IS_CONST_SIZE 1


static int mark_logger_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
#else
  return 0;
#endif
}

static int mark_logger_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Logger *l = (Scheme_Logger *)p;
  gcMARK2(l->name, gc);
  gcMARK2(l->parent, gc);
  gcMARK2(l->want_name_level_cache, gc);
  gcMARK2(l->root_timestamp, gc);
  gcMARK2(l->syslog_level, gc);
  gcMARK2(l->stderr_level, gc);
  gcMARK2(l->stdout_level, gc);
  gcMARK2(l->propagate_level, gc);
  gcMARK2(l->readers, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
# endif
#endif
}

static int mark_logger_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Logger *l = (Scheme_Logger *)p;
  gcFIXUP2(l->name, gc);
  gcFIXUP2(l->parent, gc);
  gcFIXUP2(l->want_name_level_cache, gc);
  gcFIXUP2(l->root_timestamp, gc);
  gcFIXUP2(l->syslog_level, gc);
  gcFIXUP2(l->stderr_level, gc);
  gcFIXUP2(l->stdout_level, gc);
  gcFIXUP2(l->propagate_level, gc);
  gcFIXUP2(l->readers, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
# endif
#endif
}

#define mark_logger_IS_ATOMIC 0
#define mark_logger_IS_CONST_SIZE 1


static int mark_log_reader_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
#else
  return 0;
#endif
}

static int mark_log_reader_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Log_Reader *lr = (Scheme_Log_Reader *)p;
  gcMARK2(lr->level, gc);
  gcMARK2(lr->sema, gc);
  gcMARK2(lr->head, gc);
  gcMARK2(lr->tail, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
# endif
#endif
}

static int mark_log_reader_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Log_Reader *lr = (Scheme_Log_Reader *)p;
  gcFIXUP2(lr->level, gc);
  gcFIXUP2(lr->sema, gc);
  gcFIXUP2(lr->head, gc);
  gcFIXUP2(lr->tail, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
# endif
#endif
}

#define mark_log_reader_IS_ATOMIC 0
#define mark_log_reader_IS_CONST_SIZE 1


static int struct_proc_shape_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Proc_Shape));
#else
  return 0;
#endif
}

static int struct_proc_shape_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Struct_Proc_Shape *s = (Scheme_Struct_Proc_Shape *)p;
  gcMARK2(s->identity, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Proc_Shape));
# endif
#endif
}

static int struct_proc_shape_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Struct_Proc_Shape *s = (Scheme_Struct_Proc_Shape *)p;
  gcFIXUP2(s->identity, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Proc_Shape));
# endif
#endif
}

#define struct_proc_shape_IS_ATOMIC 0
#define struct_proc_shape_IS_CONST_SIZE 1


