/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_print_params_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(PrintParams));
#else
  return 0;
#endif
}

static int mark_print_params_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  PrintParams *pp = (PrintParams *)p;
  gcMARK2(pp->inspector, gc);
  gcMARK2(pp->print_port, gc);
  gcMARK2(pp->print_buffer, gc);
  gcMARK2(pp->depth_delta, gc);
  gcMARK2(pp->uq_ht, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(PrintParams));
# endif
#endif
}

static int mark_print_params_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  PrintParams *pp = (PrintParams *)p;
  gcFIXUP2(pp->inspector, gc);
  gcFIXUP2(pp->print_port, gc);
  gcFIXUP2(pp->print_buffer, gc);
  gcFIXUP2(pp->depth_delta, gc);
  gcFIXUP2(pp->uq_ht, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(PrintParams));
# endif
#endif
}

#define mark_print_params_IS_ATOMIC 0
#define mark_print_params_IS_CONST_SIZE 1


static int mark_marshal_tables_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Marshal_Tables));
#else
  return 0;
#endif
}

static int mark_marshal_tables_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Marshal_Tables *mt = (Scheme_Marshal_Tables *)p;
  gcMARK2(mt->symtab, gc);
  gcMARK2(mt->st_refs, gc);
  gcMARK2(mt->st_ref_stack, gc);
  gcMARK2(mt->reachable_scopes, gc);
  gcMARK2(mt->reachable_scope_stack, gc);
  gcMARK2(mt->pending_reachable_ids, gc);
  gcMARK2(mt->conditionally_reachable_scopes, gc);
  gcMARK2(mt->intern_map, gc);
  gcMARK2(mt->identity_map, gc);
  gcMARK2(mt->top_map, gc);
  gcMARK2(mt->key_map, gc);
  gcMARK2(mt->delay_map, gc);
  gcMARK2(mt->cdata_map, gc);
  gcMARK2(mt->rn_saved, gc);
  gcMARK2(mt->shared_offsets, gc);
  gcMARK2(mt->path_cache, gc);
  gcMARK2(mt->sorted_keys, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Marshal_Tables));
# endif
#endif
}

static int mark_marshal_tables_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Marshal_Tables *mt = (Scheme_Marshal_Tables *)p;
  gcFIXUP2(mt->symtab, gc);
  gcFIXUP2(mt->st_refs, gc);
  gcFIXUP2(mt->st_ref_stack, gc);
  gcFIXUP2(mt->reachable_scopes, gc);
  gcFIXUP2(mt->reachable_scope_stack, gc);
  gcFIXUP2(mt->pending_reachable_ids, gc);
  gcFIXUP2(mt->conditionally_reachable_scopes, gc);
  gcFIXUP2(mt->intern_map, gc);
  gcFIXUP2(mt->identity_map, gc);
  gcFIXUP2(mt->top_map, gc);
  gcFIXUP2(mt->key_map, gc);
  gcFIXUP2(mt->delay_map, gc);
  gcFIXUP2(mt->cdata_map, gc);
  gcFIXUP2(mt->rn_saved, gc);
  gcFIXUP2(mt->shared_offsets, gc);
  gcFIXUP2(mt->path_cache, gc);
  gcFIXUP2(mt->sorted_keys, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Marshal_Tables));
# endif
#endif
}

#define mark_marshal_tables_IS_ATOMIC 0
#define mark_marshal_tables_IS_CONST_SIZE 1


