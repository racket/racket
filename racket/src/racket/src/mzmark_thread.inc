/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_parameterization_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - mzFLEX_DELTA) * sizeof(Scheme_Object*))));
}

static int mark_parameterization_MARK(void *p, struct NewGC *gc) {
  Scheme_Parameterization *c = (Scheme_Parameterization *)p;
  int i;
    
  for (i = max_configs; i--; ) {
    gcMARK2(c->prims[i], gc);
  }
  gcMARK2(c->extensions, gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - mzFLEX_DELTA) * sizeof(Scheme_Object*))));
}

static int mark_parameterization_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Parameterization *c = (Scheme_Parameterization *)p;
  int i;
    
  for (i = max_configs; i--; ) {
    gcFIXUP2(c->prims[i], gc);
  }
  gcFIXUP2(c->extensions, gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - mzFLEX_DELTA) * sizeof(Scheme_Object*))));
}

#define mark_parameterization_IS_ATOMIC 0
#define mark_parameterization_IS_CONST_SIZE 0


static int mark_config_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

static int mark_config_MARK(void *p, struct NewGC *gc) {
  Scheme_Config *config = (Scheme_Config *)p;
  gcMARK2(config->ht, gc);
  gcMARK2(config->root, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

static int mark_config_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Config *config = (Scheme_Config *)p;
  gcFIXUP2(config->ht, gc);
  gcFIXUP2(config->root, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

#define mark_config_IS_ATOMIC 0
#define mark_config_IS_CONST_SIZE 1


static int mark_will_executor_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

static int mark_will_executor_val_MARK(void *p, struct NewGC *gc) {
  WillExecutor *e = (WillExecutor *)p;
  
  gcMARK2(e->sema, gc);
  gcMARK2(e->first, gc);
  gcMARK2(e->last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

static int mark_will_executor_val_FIXUP(void *p, struct NewGC *gc) {
  WillExecutor *e = (WillExecutor *)p;
  
  gcFIXUP2(e->sema, gc);
  gcFIXUP2(e->first, gc);
  gcFIXUP2(e->last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

#define mark_will_executor_val_IS_ATOMIC 0
#define mark_will_executor_val_IS_CONST_SIZE 1


static int mark_custodian_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

static int mark_custodian_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Custodian *m = (Scheme_Custodian *)p;
  
  gcMARK2(m->boxes, gc);
  gcMARK2(m->mrefs, gc);
  gcMARK2(m->closers, gc);
  gcMARK2(m->data, gc);
  gcMARK2(m->data_ptr, gc);

  gcMARK2(m->parent, gc);
  gcMARK2(m->sibling, gc);
  gcMARK2(m->children, gc);

  gcMARK2(m->global_next, gc);
  gcMARK2(m->global_prev, gc);

  gcMARK2(m->cust_boxes, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

static int mark_custodian_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Custodian *m = (Scheme_Custodian *)p;
  
  gcFIXUP2(m->boxes, gc);
  gcFIXUP2(m->mrefs, gc);
  gcFIXUP2(m->closers, gc);
  gcFIXUP2(m->data, gc);
  gcFIXUP2(m->data_ptr, gc);

  gcFIXUP2(m->parent, gc);
  gcFIXUP2(m->sibling, gc);
  gcFIXUP2(m->children, gc);

  gcFIXUP2(m->global_next, gc);
  gcFIXUP2(m->global_prev, gc);

  gcFIXUP2(m->cust_boxes, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

#define mark_custodian_val_IS_ATOMIC 0
#define mark_custodian_val_IS_CONST_SIZE 1


static int mark_custodian_box_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian_Box));
}

static int mark_custodian_box_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Custodian_Box *b = (Scheme_Custodian_Box *)p;
  int sd = ((Scheme_Custodian *)GC_resolve2(b->cust, gc))->shut_down;

  gcMARK2(b->cust, gc);
  if (!sd) {
    gcMARK2(b->v, gc);
  }

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian_Box));
}

static int mark_custodian_box_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Custodian_Box *b = (Scheme_Custodian_Box *)p;
  int sd = ((Scheme_Custodian *)GC_resolve2(b->cust, gc))->shut_down;

  gcFIXUP2(b->cust, gc);
  if (!sd) {
    gcFIXUP2(b->v, gc);
  }

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian_Box));
}

#define mark_custodian_box_val_IS_ATOMIC 0
#define mark_custodian_box_val_IS_CONST_SIZE 1


static int mark_thread_hop_SIZE(void *p, struct NewGC *gc) {
  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

static int mark_thread_hop_MARK(void *p, struct NewGC *gc) {
  Scheme_Thread_Custodian_Hop *hop = (Scheme_Thread_Custodian_Hop *)p;

  gcMARK2(hop->p, gc);

  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

static int mark_thread_hop_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Thread_Custodian_Hop *hop = (Scheme_Thread_Custodian_Hop *)p;

  gcFIXUP2(hop->p, gc);

  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

#define mark_thread_hop_IS_ATOMIC 0
#define mark_thread_hop_IS_CONST_SIZE 1


static int mark_param_data_SIZE(void *p, struct NewGC *gc) {
  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

static int mark_param_data_MARK(void *p, struct NewGC *gc) {
  ParamData *d = (ParamData *)p;

  gcMARK2(d->key, gc);
  gcMARK2(d->guard, gc);
  gcMARK2(d->extract_guard, gc);
  gcMARK2(d->defcell, gc);

  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

static int mark_param_data_FIXUP(void *p, struct NewGC *gc) {
  ParamData *d = (ParamData *)p;

  gcFIXUP2(d->key, gc);
  gcFIXUP2(d->guard, gc);
  gcFIXUP2(d->extract_guard, gc);
  gcFIXUP2(d->defcell, gc);

  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

#define mark_param_data_IS_ATOMIC 0
#define mark_param_data_IS_CONST_SIZE 1


static int mark_will_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

static int mark_will_MARK(void *p, struct NewGC *gc) {
  ActiveWill *w = (ActiveWill *)p;
  
  gcMARK2(w->o, gc);
  gcMARK2(w->proc, gc);
  gcMARK2(w->w, gc);
  gcMARK2(w->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

static int mark_will_FIXUP(void *p, struct NewGC *gc) {
  ActiveWill *w = (ActiveWill *)p;
  
  gcFIXUP2(w->o, gc);
  gcFIXUP2(w->proc, gc);
  gcFIXUP2(w->w, gc);
  gcFIXUP2(w->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

#define mark_will_IS_ATOMIC 0
#define mark_will_IS_CONST_SIZE 1


static int mark_evt_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

static int mark_evt_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

static int mark_evt_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

#define mark_evt_IS_ATOMIC 1
#define mark_evt_IS_CONST_SIZE 1


static int mark_syncing_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

static int mark_syncing_MARK(void *p, struct NewGC *gc) {
  Syncing *w = (Syncing *)p;
 
  gcMARK2(w->set, gc);
  gcMARK2(w->wrapss, gc);
  gcMARK2(w->nackss, gc);
  gcMARK2(w->reposts, gc);
  gcMARK2(w->accepts, gc);
  gcMARK2(w->disable_break, gc);
  gcMARK2(w->thread, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

static int mark_syncing_FIXUP(void *p, struct NewGC *gc) {
  Syncing *w = (Syncing *)p;
 
  gcFIXUP2(w->set, gc);
  gcFIXUP2(w->wrapss, gc);
  gcFIXUP2(w->nackss, gc);
  gcFIXUP2(w->reposts, gc);
  gcFIXUP2(w->accepts, gc);
  gcFIXUP2(w->disable_break, gc);
  gcFIXUP2(w->thread, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

#define mark_syncing_IS_ATOMIC 0
#define mark_syncing_IS_CONST_SIZE 1


static int mark_evt_set_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

static int mark_evt_set_MARK(void *p, struct NewGC *gc) {
  Evt_Set *w = (Evt_Set *)p;
 
  gcMARK2(w->ws, gc);
  gcMARK2(w->argv, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

static int mark_evt_set_FIXUP(void *p, struct NewGC *gc) {
  Evt_Set *w = (Evt_Set *)p;
 
  gcFIXUP2(w->ws, gc);
  gcFIXUP2(w->argv, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

#define mark_evt_set_IS_ATOMIC 0
#define mark_evt_set_IS_CONST_SIZE 1


static int mark_thread_set_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

static int mark_thread_set_MARK(void *p, struct NewGC *gc) {
  Scheme_Thread_Set *ts = (Scheme_Thread_Set *)p;
 
  gcMARK2(ts->parent, gc);
  gcMARK2(ts->first, gc);
  gcMARK2(ts->next, gc);
  gcMARK2(ts->prev, gc);
  gcMARK2(ts->search_start, gc);
  gcMARK2(ts->current, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

static int mark_thread_set_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Thread_Set *ts = (Scheme_Thread_Set *)p;
 
  gcFIXUP2(ts->parent, gc);
  gcFIXUP2(ts->first, gc);
  gcFIXUP2(ts->next, gc);
  gcFIXUP2(ts->prev, gc);
  gcFIXUP2(ts->search_start, gc);
  gcFIXUP2(ts->current, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

#define mark_thread_set_IS_ATOMIC 0
#define mark_thread_set_IS_CONST_SIZE 1


static int mark_thread_cell_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

static int mark_thread_cell_MARK(void *p, struct NewGC *gc) {
  Thread_Cell *c = (Thread_Cell *)p;
 
  gcMARK2(c->def_val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

static int mark_thread_cell_FIXUP(void *p, struct NewGC *gc) {
  Thread_Cell *c = (Thread_Cell *)p;
 
  gcFIXUP2(c->def_val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

#define mark_thread_cell_IS_ATOMIC 0
#define mark_thread_cell_IS_CONST_SIZE 1


static int mark_plumber_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Plumber));
}

static int mark_plumber_MARK(void *p, struct NewGC *gc) {
  Scheme_Plumber *pl = (Scheme_Plumber *)p;
 
  gcMARK2(pl->handles, gc);
  gcMARK2(pl->weak_handles, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Plumber));
}

static int mark_plumber_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Plumber *pl = (Scheme_Plumber *)p;
 
  gcFIXUP2(pl->handles, gc);
  gcFIXUP2(pl->weak_handles, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Plumber));
}

#define mark_plumber_IS_ATOMIC 0
#define mark_plumber_IS_CONST_SIZE 1


