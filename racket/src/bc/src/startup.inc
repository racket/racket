#define EVAL_STARTUP EVAL_ONE_STR(startup_source)
static const char *startup_source =
"(linklet"
"()"
"((boot boot)"
"(1/bound-identifier=? bound-identifier=?)"
"(1/compile compile)"
"(compile-keep-source-locations! compile-keep-source-locations!)"
"(1/compiled-expression-recompile compiled-expression-recompile)"
"(1/current-compile current-compile)"
"(1/current-compiled-file-roots current-compiled-file-roots)"
"(1/current-eval current-eval)"
"(1/current-library-collection-links current-library-collection-links)"
"(1/current-library-collection-paths current-library-collection-paths)"
"(1/current-load current-load)"
"(1/current-load/use-compiled current-load/use-compiled)"
"(1/current-namespace current-namespace)"
"(datum->kernel-syntax datum->kernel-syntax)"
"(1/datum->syntax datum->syntax)"
"(declare-primitive-module! declare-primitive-module!)"
"(1/dynamic-require dynamic-require)"
"(embedded-load embedded-load)"
"(1/eval eval)"
"(eval$1 eval-top-level)"
"(expand$1 expand)"
"(expander-place-init! expander-place-init!)"
"(1/find-compiled-file-roots find-compiled-file-roots)"
"(1/find-library-collection-links find-library-collection-links)"
"(1/find-library-collection-paths find-library-collection-paths)"
"(find-main-config find-main-config)"
"(get-installation-name get-installation-name)"
"(1/identifier-binding identifier-binding)"
"(identifier? identifier?)"
"(1/load load)"
"(1/load-extension load-extension)"
"(1/load/use-compiled load/use-compiled)"
"(make-namespace make-namespace)"
"(maybe-raise-missing-module maybe-raise-missing-module)"
"(maybe-syntax->datum maybe-syntax->datum)"
"(1/module->language-info module->language-info)"
"(1/module-compiled-exports module-compiled-exports)"
"(1/module-compiled-indirect-exports module-compiled-indirect-exports)"
"(1/module-declared? module-declared?)"
"(1/module-path-index-join module-path-index-join)"
"(1/module-path-index? module-path-index?)"
"(1/module-path? module-path?)"
"(1/module-predefined? module-predefined?)"
"(namespace->instance namespace->instance)"
"(1/namespace-attach-module namespace-attach-module)"
"(1/namespace-attach-module-declaration namespace-attach-module-declaration)"
"(namespace-datum-introduce namespace-datum-introduce)"
"(1/namespace-mapped-symbols namespace-mapped-symbols)"
"(1/namespace-module-identifier namespace-module-identifier)"
"(1/namespace-require namespace-require)"
"(1/namespace-syntax-introduce namespace-syntax-introduce)"
"(1/namespace-variable-value namespace-variable-value)"
"(path-list-string->path-list path-list-string->path-list)"
"(1/read read)"
"(1/read-accept-compiled read-accept-compiled)"
"(1/read-installation-configuration-table read-installation-configuration-table)"
"(1/read-syntax read-syntax)"
"(1/resolved-module-path? resolved-module-path?)"
"(seal seal)"
"(1/syntax->datum syntax->datum)"
"(1/syntax-debug-info syntax-debug-info)"
"(1/syntax-deserialize syntax-deserialize)"
"(1/syntax-e syntax-e)"
"(syntax-property$1 syntax-property)"
"(1/syntax-serialize syntax-serialize)"
"(1/syntax-shift-phase-level syntax-shift-phase-level)"
"(syntax?$1 syntax?)"
"(1/use-collection-link-paths use-collection-link-paths)"
"(1/use-compiled-file-check use-compiled-file-check)"
"(1/use-compiled-file-paths use-compiled-file-paths)"
"(1/use-user-specific-search-paths use-user-specific-search-paths))"
"(define-values(call/ec) call-with-escape-continuation)"
"(define-values"
"(qq-append)"
"  (lambda (a_0 b_0) (begin (if (list? a_0) (append a_0 b_0) (raise-argument-error 'unquote-splicing \"list?\" a_0)))))"
"(define-values"
"(bad-list$1)"
"  (lambda (who_0 orig-l_0) (begin 'bad-list (raise-arguments-error who_0 \"not a proper list\" \"in\" orig-l_0))))"
"(define-values"
"(member)"
"(letrec-values(((member_0)"
"(lambda(v_0 orig-l_0 eql?_0)"
"(begin"
" 'member"
"((letrec-values(((loop_0)"
"(lambda(ls_0 turtle_0)"
"(begin"
" 'loop"
"(if(null? ls_0)"
"(let-values() #f)"
"(if(not(pair? ls_0))"
"(let-values()(bad-list$1 'member orig-l_0))"
"(if(eql?_0 v_0(car ls_0))"
"(let-values() ls_0)"
"(let-values()"
"(let-values(((ls_1)(cdr ls_0)))"
"(if(null? ls_1)"
"(let-values() #f)"
"(if(let-values(((or-part_0)(not(pair? ls_1))))"
"(if or-part_0 or-part_0(eq? ls_1 turtle_0)))"
"(let-values()(bad-list$1 'member orig-l_0))"
"(if(eql?_0 v_0(car ls_1))"
"(let-values() ls_1)"
"(let-values()"
"(loop_0(cdr ls_1)(cdr turtle_0)))))))))))))))"
" loop_0)"
" orig-l_0"
" orig-l_0)))))"
"(case-lambda"
"((v_0 ls_0)(begin(member_0 v_0 ls_0 equal?)))"
"((v_0 ls_0 eql?_0)"
"(begin"
"(if(if(procedure? eql?_0)(procedure-arity-includes? eql?_0 2) #f)"
"(void)"
"          (raise-argument-error 'member \"(procedure-arity-includes/c 2)\" eq?))"
"(member_0 v_0 ls_0 eql?_0))))))"
"(define-values(current-parameterization)(lambda()(begin(continuation-mark-set-first #f parameterization-key))))"
"(define-values"
"(call-with-parameterization)"
"(lambda(paramz_0 thunk_0)"
"(begin"
"(begin"
"(if(parameterization? paramz_0)"
"(void)"
"          (let-values () (raise-argument-error 'call-with-parameterization \"parameterization?\" 0 paramz_0 thunk_0)))"
"(if(if(procedure? thunk_0)(procedure-arity-includes? thunk_0 0) #f)"
"(void)"
"          (let-values () (raise-argument-error 'call-with-parameterization \"(-> any)\" 1 paramz_0 thunk_0)))"
"(with-continuation-mark parameterization-key paramz_0(thunk_0))))))"
"(define-values"
"(struct:break-paramz make-break-paramz break-paramz? break-paramz-ref break-paramz-set!)"
"(make-struct-type 'break-parameterization #f 1 0 #f))"
"(define-values"
"(current-break-parameterization)"
"(lambda()(begin(make-break-paramz(continuation-mark-set-first #f break-enabled-key)))))"
"(define-values"
"(call-with-break-parameterization)"
"(lambda(paramz_0 thunk_0)"
"(begin"
"(begin"
"(if(break-paramz? paramz_0)"
"(void)"
"(let-values()"
"            (raise-argument-error 'call-with-break-parameterization \"break-parameterization?\" 0 paramz_0 thunk_0)))"
"(if(if(procedure? thunk_0)(procedure-arity-includes? thunk_0 0) #f)"
"(void)"
"          (let-values () (raise-argument-error 'call-with-parameterization \"(-> any)\" 1 paramz_0 thunk_0)))"
"(begin0"
"(with-continuation-mark break-enabled-key(break-paramz-ref paramz_0 0)(begin(check-for-break)(thunk_0)))"
"(check-for-break))))))"
"(define-values"
"(select-handler/no-breaks)"
"(lambda(e_0 bpz_0 l_0)"
"(begin"
"(with-continuation-mark"
" break-enabled-key"
"(make-thread-cell #f)"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values()(raise e_0))"
"(if((caar l_1) e_0)"
"(let-values()"
"(begin0"
"((cdar l_1) e_0)"
"(with-continuation-mark break-enabled-key bpz_0(check-for-break))))"
"(let-values()(loop_0(cdr l_1)))))))))"
" loop_0)"
" l_0)))))"
"(define-values(false-thread-cell)(make-thread-cell #f))"
"(define-values(handler-prompt-key)(make-continuation-prompt-tag 'handler-prompt-tag))"
"(define-values"
"(call-handled-body)"
"(lambda(bpz_0 handle-proc_0 body-thunk_0)"
"(begin"
"(with-continuation-mark"
" break-enabled-key"
" false-thread-cell"
"(call-with-continuation-prompt"
"(lambda(bpz_1 body-thunk_1)"
"(with-continuation-mark"
" break-enabled-key"
" bpz_1"
"(with-continuation-mark"
" exception-handler-key"
"(lambda(e_0)(abort-current-continuation handler-prompt-key e_0))"
"(body-thunk_1))))"
" handler-prompt-key"
" handle-proc_0"
" bpz_0"
" body-thunk_0)))))"
"(define-values"
"(call-with-exception-handler)"
"(lambda(exnh_0 thunk_0)(begin(begin0(with-continuation-mark exception-handler-key exnh_0(thunk_0))(void)))))"
"(define-values(not-there)(gensym))"
"(define-values"
"(do-hash-update)"
"(lambda(who_0 mut?_0 set_0 ht_0 key_0 xform_0 default_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()"
"(begin"
"(if(if(hash? ht_0)(if mut?_0(not(immutable? ht_0))(immutable? ht_0)) #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                   (if mut?_0 \"(and/c hash? (not/c immutable?))\" \"(and/c hash? immutable?)\")"
" ht_0)))"
"(if(if(procedure? xform_0)(procedure-arity-includes? xform_0 1) #f)"
"(void)"
"                (let-values () (raise-argument-error who_0 \"(any/c . -> . any/c)\" xform_0))))))"
"(let-values(((v_0)(hash-ref ht_0 key_0 default_0)))"
"(if(eq? v_0 not-there)"
"            (raise-mismatch-error who_0 \"no value found for key: \" key_0)"
"(set_0 ht_0 key_0(xform_0 v_0))))))))"
"(define-values"
"(hash-update)"
"(case-lambda"
"((ht_0 key_0 xform_0 default_0)(begin(do-hash-update 'hash-update #f hash-set ht_0 key_0 xform_0 default_0)))"
"((ht_0 key_0 xform_0)(hash-update ht_0 key_0 xform_0 not-there))))"
"(define-values"
"(hash-update!)"
"(case-lambda"
"((ht_0 key_0 xform_0 default_0)(begin(do-hash-update 'hash-update! #t hash-set! ht_0 key_0 xform_0 default_0)))"
"((ht_0 key_0 xform_0)(hash-update! ht_0 key_0 xform_0 not-there))))"
"(define-values"
"(hash-has-key?)"
"(lambda(ht_0 key_0)"
"(begin"
"(begin"
"        (if (hash? ht_0) (void) (let-values () (raise-argument-error 'hash-has-key? \"hash?\" 0 ht_0 key_0)))"
"(not(eq? not-there(hash-ref ht_0 key_0 not-there)))))))"
"(define-values"
"(hash-ref!)"
"(lambda(ht_0 key_0 new_0)"
"(begin"
"(begin"
"(if(if(hash? ht_0)(not(immutable? ht_0)) #f)"
"(void)"
"          (let-values () (raise-argument-error 'hash-ref! \"(and/c hash? (not/c immutable?))\" 0 ht_0 key_0 new_0)))"
"(let-values(((v_0)(hash-ref ht_0 key_0 not-there)))"
"(if(eq? not-there v_0)"
"(let-values(((n_0)(if(procedure? new_0)(new_0) new_0)))(begin(hash-set! ht_0 key_0 n_0) n_0))"
" v_0))))))"
"(define-values"
"(path-string?)"
"(lambda(s_0)"
"(begin"
"(let-values(((or-part_0)(path? s_0)))"
"(if or-part_0"
" or-part_0"
"(if(string? s_0)"
"(let-values(((or-part_1)(relative-path? s_0)))(if or-part_1 or-part_1(absolute-path? s_0)))"
" #f))))))"
"(define-values(bsbs)(string '#\\\\ '#\\\\))"
"(define-values"
"(normal-case-path)"
"(lambda(s_0)"
"(begin"
"(begin"
"(if(let-values(((or-part_0)(path-for-some-system? s_0)))(if or-part_0 or-part_0(path-string? s_0)))"
"(void)"
"(let-values()"
"(raise-argument-error*"
" 'normal-case-path"
" 'racket/primitive"
"             \"(or/c path-for-some-system? path-string?)\""
" s_0)))"
"(if(if(path-for-some-system? s_0)(eq?(path-convention-type s_0) 'windows)(eq?(system-type) 'windows))"
"(let-values()"
"(let-values(((bstr_0)(if(string? s_0) #f(path->bytes s_0))))"
"              (if (if (string? s_0) (regexp-match? '#rx\"^[\\\\][\\\\][?][\\\\]\" s_0) #f)"
"(let-values()(string->path s_0))"
"                (if (if bstr_0 (regexp-match? '#rx#\"^[\\\\][\\\\][?][\\\\]\" bstr_0) #f)"
"(let-values() s_0)"
"(let-values()"
"(let-values(((norm_0)"
"(lambda(s_1)"
"                                    (begin 'norm (string-locale-downcase (regexp-replace* '#rx\"/\" s_1 bsbs)))))"
"((norm-tail_0)"
"(lambda(s_1)"
"(begin"
" 'norm-tail"
"                                      (if (regexp-match? '#rx\"[/\\\\][. ]+[/\\\\]*$\" s_1)"
" s_1"
"                                        (regexp-replace* '#rx\"(?<=[^ ./\\\\])[ .]+([/\\\\]*)$\" s_1 \"\\\\1\")))))"
"((finish_0)(lambda(bstr_1)(begin 'finish(bytes->path bstr_1 'windows)))))"
"(if(string? s_0)"
"(let-values()(finish_0(string->bytes/locale(norm_0(norm-tail_0 s_0)))))"
"(let-values()"
"                          (let-values (((c_0) (bytes-open-converter \"\" \"UTF-8\")))"
"(finish_0"
"((letrec-values(((loop_0)"
"(lambda(offset_0)"
"(begin"
" 'loop"
"(let-values(((new-bstr_0 used_0 status_0)"
"(bytes-convert"
" c_0"
" bstr_0"
" offset_0"
"(bytes-length bstr_0))))"
"(let-values(((s_1)(bytes->string/locale new-bstr_0)))"
"(let-values(((tail-s_0)"
"(if(eq? status_0 'complete)"
"(norm-tail_0 s_1)"
" s_1)))"
"(let-values(((done_0)"
"(string->bytes/locale(norm_0 tail-s_0))))"
"(if(eq? status_0 'complete)"
"(let-values() done_0)"
"(if(eq? status_0 'aborts)"
"(let-values()"
"(bytes-append"
" done_0"
"(subbytes bstr_0(+ offset_0 used_0))))"
"(let-values()"
"(bytes-append"
" done_0"
"(subbytes"
" bstr_0"
"(+ offset_0 used_0)"
"(+ offset_0 used_0 1))"
"(loop_0(+ offset_0 used_0 1))))))))))))))"
" loop_0)"
" 0)))))))))))"
"(if(string? s_0)(let-values()(string->path s_0))(let-values() s_0)))))))"
"(define-values"
"(check-extension-call)"
"(lambda(s_0 sfx_0 who_0 sep_0 trust-sep?_0)"
"(begin"
"(begin"
"(let-values(((err-msg_0 err-index_0)"
"(if(not"
"(let-values(((or-part_0)(path-for-some-system? s_0)))"
"(if or-part_0 or-part_0(path-string? s_0))))"
"                        (let-values () (values \"(or/c path-for-some-system? path-string?)\" 0))"
"(if(not(let-values(((or-part_0)(string? sfx_0)))(if or-part_0 or-part_0(bytes? sfx_0))))"
"                          (let-values () (values \"(or/c string? bytes?)\" 1))"
"(if(not"
"(let-values(((or-part_0) trust-sep?_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(string? sep_0)))"
"(if or-part_1 or-part_1(bytes? sep_0))))))"
"                            (let-values () (values \"(or/c string? bytes?)\" 2))"
"(let-values()(values #f #f)))))))"
"(if err-msg_0"
"(let-values()"
"(if trust-sep?_0"
"(raise-argument-error* who_0 'racket/primitive err-msg_0 err-index_0 s_0 sfx_0)"
"(raise-argument-error* who_0 'racket/primitive err-msg_0 err-index_0 s_0 sfx_0 sep_0)))"
"(void)))"
"(let-values(((base_0 name_0 dir?_0)(split-path s_0)))"
"(begin"
"(if(not base_0)"
"(let-values()"
"                (raise-arguments-error* who_0 'racket/primitive \"cannot add an extension to a root path\" \"path\" s_0))"
"(void))"
"(if(let-values(((or-part_0)(eq? name_0 'same)))(if or-part_0 or-part_0(eq? name_0 'up)))"
"(let-values()"
"(raise-arguments-error*"
" who_0"
" 'racket/primitive"
"                 \"cannot add an extension to path that ends with a dot element\""
"                 \"path\""
" s_0))"
"(void))"
"(values base_0 name_0)))))))"
"(define-values"
"(path-adjust-extension)"
"(lambda(who_0 sep_0 rest-bytes_0 s_0 sfx_0 trust-sep?_0)"
"(begin"
"(let-values(((base_0 name_0)(check-extension-call s_0 sfx_0 who_0 sep_0 trust-sep?_0)))"
"(let-values(((bs_0)(path-element->bytes name_0)))"
"(let-values(((finish_0)"
"(lambda(i_0 sep_1 i2_0)"
"(begin"
" 'finish"
"(bytes->path-element"
"(bytes-append"
"(subbytes bs_0 0 i_0)"
"(if(string? sep_1)(string->bytes/locale sep_1(char->integer '#\\?)) sep_1)"
"(rest-bytes_0 bs_0 i2_0)"
"(if(string? sfx_0)(string->bytes/locale sfx_0(char->integer '#\\?)) sfx_0))"
"(if(path-for-some-system? s_0)"
"(path-convention-type s_0)"
"(system-path-convention-type)))))))"
"(let-values(((new-name_0)"
"(letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(zero? i_0)"
"                                                 (finish_0 (bytes-length bs_0) #\"\" (bytes-length bs_0))"
"(let-values(((i_1)(sub1 i_0)))"
"(if(if(not(zero? i_1))"
"(eq?(char->integer '#\\.)(bytes-ref bs_0 i_1))"
" #f)"
"(finish_0 i_1 sep_0(add1 i_1))"
"(loop_0 i_1))))))))"
"(loop_0(bytes-length bs_0)))))"
"(if(path-for-some-system? base_0)(build-path base_0 new-name_0) new-name_0))))))))"
"(define-values"
"(path-replace-extension)"
"  (lambda (s_0 sfx_0) (begin (path-adjust-extension 'path-replace-extension #\"\" (lambda (bs_0 i_0) #\"\") s_0 sfx_0 #t))))"
"(define-values"
"(path-add-extension)"
"(case-lambda"
"   ((s_0 sfx_0) (begin (path-adjust-extension 'path-add-extension #\"_\" subbytes s_0 sfx_0 #t)))"
"((s_0 sfx_0 sep_0)(path-adjust-extension 'path-add-extension sep_0 subbytes s_0 sfx_0 #f))))"
"(define-values"
"(reroot-path)"
"(lambda(p_0 root_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(path-string? p_0)))"
"(if or-part_0 or-part_0(path-for-some-system? p_0)))"
"(void)"
"(let-values()"
"(raise-argument-error*"
" 'reroot-path"
" 'racket/primitive"
"                           \"(or/c path-string? path-for-some-system?)\""
" 0"
" p_0"
" root_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(path-string? root_0)))"
"(if or-part_0 or-part_0(path-for-some-system? root_0)))"
"(void)"
"(let-values()"
"(raise-argument-error*"
" 'reroot-path"
" 'racket/primitive"
"                             \"(or/c path-string? path-for-some-system?)\""
" 1"
" p_0"
" root_0)))"
"(values))))"
"(let-values(((conv_0)"
"(if(path-for-some-system? p_0)(path-convention-type p_0)(system-path-convention-type))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(complete-path? p_0)))"
"(if or-part_0 or-part_0(eq?(system-path-convention-type) conv_0)))"
"(void)"
"(let-values()"
"(raise-arguments-error*"
" 'reroot-path"
" 'racket/primitive"
"                                 \"path is not complete and not the platform's convention\""
"                                 \"path\""
" p_0"
"                                 \"platform convention type\""
"(system-path-convention-type))))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?"
"(if(path-for-some-system? root_0)"
"(path-convention-type root_0)"
"(system-path-convention-type))"
" conv_0)"
"(void)"
"(let-values()"
"(raise-arguments-error*"
" 'reroot-path"
" 'racket/primitive"
"                                   \"given paths use different conventions\""
"                                   \"path\""
" p_0"
"                                   \"root path\""
" root_0)))"
"(values))))"
"(let-values(((c-p_0)"
"(normal-case-path"
"(cleanse-path(if(complete-path? p_0) p_0(path->complete-path p_0))))))"
"(let-values(((bstr_0)(path->bytes c-p_0)))"
"(if(eq? conv_0 'unix)"
"(let-values()"
"                        (if (bytes=? bstr_0 #\"/\")"
"(if(path-for-some-system? root_0) root_0(string->path root_0))"
"(build-path root_0(bytes->path(subbytes(path->bytes c-p_0) 1) conv_0))))"
"(if(eq? conv_0 'windows)"
"(let-values()"
"(build-path"
" root_0"
"(bytes->path"
"                            (if (regexp-match? '#rx\"^\\\\\\\\\\\\\\\\[?]\\\\\\\\[a-z]:\" bstr_0)"
"(let-values()"
"                                (bytes-append #\"\\\\\\\\?\\\\REL\\\\\" (subbytes bstr_0 4 5) #\"\\\\\" (subbytes bstr_0 6)))"
"                              (if (regexp-match? '#rx\"^\\\\\\\\\\\\\\\\[?]\\\\\\\\UNC\\\\\\\\\" bstr_0)"
"                                (let-values () (bytes-append #\"\\\\\\\\?\\\\REL\\\\\" (subbytes bstr_0 4)))"
"                                (if (regexp-match? '#rx\"^\\\\\\\\\\\\\\\\[?]\\\\\\\\UNC\\\\\\\\\" bstr_0)"
"                                  (let-values () (bytes-append #\"\\\\\\\\?\\\\REL\\\\\" (subbytes bstr_0 4)))"
"                                  (if (regexp-match? '#rx\"^\\\\\\\\\\\\\\\\\" bstr_0)"
"                                    (let-values () (bytes-append #\"UNC\\\\\" (subbytes bstr_0 2)))"
"                                    (if (regexp-match? '#rx\"^[a-z]:\" bstr_0)"
"(let-values()(bytes-append(subbytes bstr_0 0 1)(subbytes bstr_0 2)))"
"(void))))))"
" conv_0)))"
"(void)))))))))))))"
"(define-values(rx:path-list) #f)"
"(define-values"
"(init-rx:path-list!)"
"(lambda()"
"(begin"
"(if rx:path-list"
"(void)"
"(let-values()"
"(set! rx:path-list"
"(byte-regexp"
"(string->bytes/utf-8"
"              (let-values (((sep_0) (if (eq? (system-type) 'windows) \";\" \":\")))"
"                (format \"([^~a]*)~a(.*)\" sep_0 sep_0))))))))))"
"(define-values"
"(cons-path)"
"(lambda(default_0 s_0 l_0)"
"(begin"
"      (let-values (((s_1) (if (eq? (system-type) 'windows) (regexp-replace* '#rx#\"\\\"\" s_0 #\"\") s_0)))"
"        (if (bytes=? s_1 #\"\") (append default_0 l_0) (cons (bytes->path s_1) l_0))))))"
"(define-values"
"(path-list-string->path-list)"
"(lambda(s_0 default_0)"
"(begin"
"(begin"
"(if(let-values(((or-part_0)(bytes? s_0)))(if or-part_0 or-part_0(string? s_0)))"
"(void)"
"          (let-values () (raise-argument-error 'path-list-string->path-list \"(or/c bytes? string?)\" s_0)))"
"        (if (regexp-match? '#rx#\"\\0\" s_0)"
"(let-values()"
"            (let-values (((label_0) (if (bytes? s_0) \"byte string\" \"string\")))"
"(raise-arguments-error"
" 'path-list-string->path-list"
"               (format \"given ~a contains a nul character\" label_0)"
" label_0"
" s_0)))"
"(void))"
"(if(if(list? default_0)"
"(andmap"
"(lambda(p_0)(let-values(((or-part_0)(eq? p_0 'same)))(if or-part_0 or-part_0 path?)))"
" default_0)"
" #f)"
"(void)"
"          (let-values () (raise-argument-error 'path-list-string->path-list \"(listof path?)\" default_0)))"
"(init-rx:path-list!)"
"((letrec-values(((loop_0)"
"(lambda(s_1)"
"(begin"
" 'loop"
"(let-values(((m_0)(regexp-match rx:path-list s_1)))"
"(if m_0"
"(cons-path default_0(cadr m_0)(loop_0(caddr m_0)))"
"(cons-path default_0 s_1 null)))))))"
" loop_0)"
"(if(string? s_0)(string->bytes/utf-8 s_0) s_0))))))"
"(define-values"
"(find-executable-path)"
"(case-lambda"
"((program_0 libpath_0 reverse?_0)"
"(begin"
"(begin"
"(if(path-string? program_0)"
"(void)"
"          (let-values () (raise-argument-error 'find-executable-path \"path-string?\" program_0)))"
"(if(let-values(((or-part_0)(not libpath_0)))"
"(if or-part_0 or-part_0(if(path-string? libpath_0)(relative-path? libpath_0) #f)))"
"(void)"
"(let-values()"
"            (raise-argument-error 'find-executable-path \"(or/c #f (and/c path-string? relative-path?))\" libpath_0)))"
"(letrec-values(((found-exec_0)"
"(lambda(exec-name_0)"
"(begin"
" 'found-exec"
"(if libpath_0"
"(let-values(((base_0 name_0 isdir?_0)(split-path exec-name_0)))"
"(let-values(((next_0)"
"(lambda()"
"(begin"
" 'next"
"(let-values(((resolved_0)(resolve-path exec-name_0)))"
"(if(equal? resolved_0 exec-name_0)"
"(let-values() #f)"
"(if(relative-path? resolved_0)"
"(let-values()(found-exec_0(build-path base_0 resolved_0)))"
"(let-values()(found-exec_0 resolved_0)))))))))"
"(let-values(((or-part_0)(if reverse?_0(next_0) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(path? base_0)"
"(let-values(((lib_0)(build-path base_0 libpath_0)))"
"(if(let-values(((or-part_1)(directory-exists? lib_0)))"
"(if or-part_1 or-part_1(file-exists? lib_0)))"
" lib_0"
" #f))"
" #f)))"
"(if or-part_1 or-part_1(if(not reverse?_0)(next_0) #f)))))))"
" exec-name_0))))"
"((try-exec_0)"
"(lambda(program_1)"
"(begin"
" 'try-exec"
"(if(if(relative-path? program_1)"
"(let-values(((base_0 name_0 dir?_0)(split-path program_1)))(eq? base_0 'relative))"
" #f)"
"(let-values(((paths-bstr_0)"
"                                             (environment-variables-ref (current-environment-variables) #\"PATH\"))"
"((win-add_0)"
"(lambda(s_0)"
"(begin"
" 'win-add"
"                                                 (if (eq? (system-type) 'windows) (cons (bytes->path #\".\") s_0) s_0)))))"
"((letrec-values(((loop_0)"
"(lambda(paths_0)"
"(begin"
" 'loop"
"(if(null? paths_0)"
" #f"
"(let-values(((base_0)(path->complete-path(car paths_0))))"
"(let-values(((name_0)(build-path base_0 program_1)))"
"(if(file-exists? name_0)"
"(found-exec_0 name_0)"
"(loop_0(cdr paths_0))))))))))"
" loop_0)"
"(win-add_0(if paths-bstr_0(path-list-string->path-list paths-bstr_0 null) null))))"
"(let-values(((p_0)(path->complete-path program_1)))"
"(if(file-exists? p_0)(found-exec_0 p_0) #f)))))))"
"(let-values(((or-part_0)(try-exec_0 program_0)))"
"(if or-part_0"
" or-part_0"
"(if(eq? 'windows(system-type))"
"(let-values(((base_0 name_0 dir?_0)(split-path program_0)))"
"(if(path? name_0)"
"                    (if (not (regexp-match? '#rx\"[.]\" name_0))"
"                      (try-exec_0 (path-replace-extension program_0 #\".exe\"))"
" #f)"
" #f))"
" #f)))))))"
"((program_0 libpath_0)(find-executable-path program_0 libpath_0 #f))"
"((program_0)(find-executable-path program_0 #f #f))))"
"(define-values"
"(call-with-default-reading-parameterization)"
"(lambda(thunk_0)"
"(begin"
"(if(if(procedure? thunk_0)(procedure-arity-includes? thunk_0 0) #f)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" read-case-sensitive"
" #t"
" 1/read-square-bracket-as-paren"
" #t"
" 1/read-curly-brace-as-paren"
" #t"
" 1/read-square-bracket-with-tag"
" #f"
" 1/read-curly-brace-with-tag"
" #f"
" 1/read-accept-box"
" #t"
" 1/read-accept-compiled"
" #f"
" read-accept-bar-quote"
" #t"
" 1/read-accept-graph"
" #t"
" 1/read-syntax-accept-graph"
" #f"
" 1/read-decimal-as-inexact"
" #t"
" 1/read-single-flonum"
" #f"
" 1/read-cdot"
" #f"
" 1/read-accept-dot"
" #t"
" 1/read-accept-infix-dot"
" #t"
" 1/read-accept-quasiquote"
" #t"
" 1/read-accept-reader"
" #f"
" 1/read-accept-lang"
" #t"
" 1/current-readtable"
" #f)"
"(thunk_0))"
"        (raise-argument-error 'call-with-default-reading-parameterization \"(procedure-arity-includes/c 0)\" thunk_0)))))"
"(define-values"
"(prop:keyword-impersonator keyword-impersonator? keyword-impersonator-ref)"
"(make-struct-type-property 'keyword-impersonator))"
"(define-values"
"(keyword-procedure-impersonator-of)"
"(lambda(v_0)"
"(begin(if(keyword-impersonator? v_0)(let-values()((keyword-impersonator-ref v_0) v_0))(let-values() #f)))))"
"(define-values"
"(struct:keyword-procedure mk-kw-proc keyword-procedure? keyword-procedure-ref keyword-procedure-set!)"
"(make-struct-type"
" 'keyword-procedure"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:checked-procedure #t)(cons prop:impersonator-of keyword-procedure-impersonator-of))"
"(current-inspector)"
" #f"
" '(0 1 2 3)))"
"(define-values(keyword-procedure-required)(make-struct-field-accessor keyword-procedure-ref 2))"
"(define-values(keyword-procedure-allowed)(make-struct-field-accessor keyword-procedure-ref 3))"
"(define-values"
"(prop:procedure-accessor procedure-accessor? procedure-accessor-ref)"
"(make-struct-type-property"
" 'procedure"
"(lambda(v_0 info-l_0)(if(exact-integer? v_0)(make-struct-field-accessor(list-ref info-l_0 3) v_0) #f))))"
"(define-values"
"(new-prop:procedure new-procedure? new-procedure-ref)"
"(make-struct-type-property"
" 'procedure"
" #f"
"(list(cons prop:procedure values)(cons prop:procedure-accessor values))"
" #t))"
"(define-values"
"(procedure-keywords)"
"(lambda(p_0)"
"(begin"
"(if(keyword-procedure? p_0)"
"(let-values()(values(keyword-procedure-required p_0)(keyword-procedure-allowed p_0)))"
"(if(procedure? p_0)"
"(let-values()"
"(if(new-procedure? p_0)"
"(let-values(((v_0)(new-procedure-ref p_0)))"
"(if(procedure? v_0)"
"(procedure-keywords v_0)"
"(let-values(((a_0)(procedure-accessor-ref p_0)))"
"(if a_0(procedure-keywords(a_0 p_0))(values null null)))))"
"(values null null)))"
"          (let-values () (raise-argument-error* 'procedure-keywords 'racket/primitive \"procedure?\" p_0)))))))"
"(define-values(print-values)(lambda vs_0(begin(begin(for-each(current-print) vs_0)(apply values vs_0)))))"
"(define-values"
"(reverse$1)"
"(lambda(l_0)"
"(begin"
" 'reverse"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"          (if (list? l_0) (void) (raise-argument-error 'reverse \"list?\" l_0)))"
"(letrec-values(((loop_0)"
"(lambda(a_0 l_1)(begin 'loop(if(null? l_1) a_0(loop_0(cons(car l_1) a_0)(cdr l_1)))))))"
"(loop_0 null l_0))))))"
"(define-values"
"(sort vector-sort vector-sort!)"
"(let-values()"
"(let-values(((generic-sort_0)"
"(lambda(A_0 less-than?_0 n_0)"
"(begin"
" 'generic-sort"
"(let-values()"
"(let-values()"
"(let-values(((n/2-_0)(unsafe-fxrshift n_0 1)))"
"(let-values(((n/2+_0)(unsafe-fx- n_0 n/2-_0)))"
"(letrec-values(((copying-mergesort_0)"
"(lambda(Alo_0 Blo_0 n_1)"
"(begin"
" 'copying-mergesort"
"(if(unsafe-fx= n_1 1)"
"(let-values()"
"(unsafe-vector-set! A_0 Blo_0(unsafe-vector-ref A_0 Alo_0)))"
"(if(unsafe-fx= n_1 2)"
"(let-values()"
"(let-values(((x_0)(unsafe-vector-ref A_0 Alo_0))"
"((y_0)"
"(unsafe-vector-ref A_0(unsafe-fx+ Alo_0 1))))"
"(if(less-than?_0 y_0 x_0)"
"(begin"
"(unsafe-vector-set! A_0 Blo_0 y_0)"
"(unsafe-vector-set! A_0(unsafe-fx+ Blo_0 1) x_0))"
"(begin"
"(unsafe-vector-set! A_0 Blo_0 x_0)"
"(unsafe-vector-set! A_0(unsafe-fx+ Blo_0 1) y_0)))))"
"(if(unsafe-fx< n_1 16)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" Blo_0"
"(unsafe-vector-ref A_0 Alo_0))"
"((letrec-values(((iloop_0)"
"(lambda(i_0)"
"(begin"
" 'iloop"
"(if(unsafe-fx< i_0 n_1)"
"(let-values()"
"(let-values(((ref-i_0)"
"(unsafe-vector-ref"
" A_0"
"(unsafe-fx+"
" Alo_0"
" i_0))))"
"((letrec-values(((jloop_0)"
"(lambda(j_0)"
"(begin"
" 'jloop"
"(let-values(((ref-j-1_0)"
"(unsafe-vector-ref"
" A_0"
"(unsafe-fx-"
" j_0"
" 1))))"
"(if(if(unsafe-fx<"
" Blo_0"
" j_0)"
"(less-than?_0"
" ref-i_0"
" ref-j-1_0)"
" #f)"
"(begin"
"(unsafe-vector-set!"
" A_0"
" j_0"
" ref-j-1_0)"
"(jloop_0"
"(unsafe-fx-"
" j_0"
" 1)))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" j_0"
" ref-i_0)"
"(iloop_0"
"(unsafe-fx+"
" i_0"
" 1)))))))))"
" jloop_0)"
"(unsafe-fx+ Blo_0 i_0))))"
"(void))))))"
" iloop_0)"
" 1)))"
"(let-values()"
"(let-values(((n/2-_1)(unsafe-fxrshift n_1 1)))"
"(let-values(((n/2+_1)(unsafe-fx- n_1 n/2-_1)))"
"(let-values(((Amid1_0)(unsafe-fx+ Alo_0 n/2-_1))"
"((Amid2_0)(unsafe-fx+ Alo_0 n/2+_1))"
"((Bmid1_0)(unsafe-fx+ Blo_0 n/2-_1)))"
"(begin"
"(copying-mergesort_0 Amid1_0 Bmid1_0 n/2+_1)"
"(copying-mergesort_0 Alo_0 Amid2_0 n/2-_1)"
"(let-values(((b2_0)(unsafe-fx+ Blo_0 n_1)))"
"((letrec-values(((loop_0)"
"(lambda(a1_0 b1_0 c1_0)"
"(begin"
" 'loop"
"(let-values(((x_0)"
"(unsafe-vector-ref"
" A_0"
" a1_0))"
"((y_0)"
"(unsafe-vector-ref"
" A_0"
" b1_0)))"
"(if(not"
"(less-than?_0"
" y_0"
" x_0))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_0"
" x_0)"
"(let-values(((a1_1)"
"(unsafe-fx+"
" a1_0"
" 1))"
"((c1_1)"
"(unsafe-fx+"
" c1_0"
" 1)))"
"(if(unsafe-fx<"
" c1_1"
" b1_0)"
"(let-values()"
"(loop_0"
" a1_1"
" b1_0"
" c1_1))"
"(void))))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_0"
" y_0)"
"(let-values(((b1_1)"
"(unsafe-fx+"
" b1_0"
" 1))"
"((c1_1)"
"(unsafe-fx+"
" c1_0"
" 1)))"
"(if(unsafe-fx<="
" b2_0"
" b1_1)"
"((letrec-values(((loop_1)"
"(lambda(a1_1"
" c1_2)"
"(begin"
" 'loop"
"(if(unsafe-fx<"
" c1_2"
" b1_1)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_2"
"(unsafe-vector-ref"
" A_0"
" a1_1))"
"(loop_1"
"(unsafe-fx+"
" a1_1"
" 1)"
"(unsafe-fx+"
" c1_2"
" 1))))"
"(void))))))"
" loop_1)"
" a1_0"
" c1_1)"
"(loop_0"
" a1_0"
" b1_1"
" c1_1))))))))))"
" loop_0)"
" Amid2_0"
" Bmid1_0"
" Blo_0))))))))))))))"
"(let-values(((Alo_0) 0)"
"((Amid1_0) n/2-_0)"
"((Amid2_0) n/2+_0)"
"((Ahi_0) n_0)"
"((B1lo_0) n_0))"
"(begin"
"(copying-mergesort_0 Amid1_0 B1lo_0 n/2+_0)"
"(if(zero? n/2-_0)"
"(void)"
"(let-values()(copying-mergesort_0 Alo_0 Amid2_0 n/2-_0)))"
"(let-values(((b2_0) Ahi_0))"
"((letrec-values(((loop_0)"
"(lambda(a1_0 b1_0 c1_0)"
"(begin"
" 'loop"
"(let-values(((x_0)(unsafe-vector-ref A_0 a1_0))"
"((y_0)(unsafe-vector-ref A_0 b1_0)))"
"(if(less-than?_0 x_0 y_0)"
"(begin"
"(unsafe-vector-set! A_0 c1_0 x_0)"
"(let-values(((a1_1)(unsafe-fx+ a1_0 1))"
"((c1_1)(unsafe-fx+ c1_0 1)))"
"(if(unsafe-fx< c1_1 b1_0)"
"(let-values()(loop_0 a1_1 b1_0 c1_1))"
"(void))))"
"(begin"
"(unsafe-vector-set! A_0 c1_0 y_0)"
"(let-values(((b1_1)(unsafe-fx+ b1_0 1))"
"((c1_1)(unsafe-fx+ c1_0 1)))"
"(if(unsafe-fx<= b2_0 b1_1)"
"((letrec-values(((loop_1)"
"(lambda(a1_1 c1_2)"
"(begin"
" 'loop"
"(if(unsafe-fx< c1_2 b1_1)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_2"
"(unsafe-vector-ref"
" A_0"
" a1_1))"
"(loop_1"
"(unsafe-fx+ a1_1 1)"
"(unsafe-fx+"
" c1_2"
" 1))))"
"(void))))))"
" loop_1)"
" a1_0"
" c1_1)"
"(loop_0 a1_0 b1_1 c1_1))))))))))"
" loop_0)"
" B1lo_0"
" Amid2_0"
" Alo_0)))))))))))))"
"(let-values(((generic-sort/key_0)"
"(lambda(A_0 less-than?_0 n_0 key_0)"
"(begin"
" 'generic-sort/key"
"(let-values()"
"(let-values()"
"(let-values(((n/2-_0)(unsafe-fxrshift n_0 1)))"
"(let-values(((n/2+_0)(unsafe-fx- n_0 n/2-_0)))"
"(letrec-values(((copying-mergesort_0)"
"(lambda(Alo_0 Blo_0 n_1)"
"(begin"
" 'copying-mergesort"
"(if(unsafe-fx= n_1 1)"
"(let-values()"
"(unsafe-vector-set! A_0 Blo_0(unsafe-vector-ref A_0 Alo_0)))"
"(if(unsafe-fx= n_1 2)"
"(let-values()"
"(let-values(((x_0)(unsafe-vector-ref A_0 Alo_0))"
"((y_0)"
"(unsafe-vector-ref A_0(unsafe-fx+ Alo_0 1))))"
"(if(if key_0"
"(less-than?_0(key_0 y_0)(key_0 x_0))"
"(less-than?_0 y_0 x_0))"
"(begin"
"(unsafe-vector-set! A_0 Blo_0 y_0)"
"(unsafe-vector-set! A_0(unsafe-fx+ Blo_0 1) x_0))"
"(begin"
"(unsafe-vector-set! A_0 Blo_0 x_0)"
"(unsafe-vector-set! A_0(unsafe-fx+ Blo_0 1) y_0)))))"
"(if(unsafe-fx< n_1 16)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" Blo_0"
"(unsafe-vector-ref A_0 Alo_0))"
"((letrec-values(((iloop_0)"
"(lambda(i_0)"
"(begin"
" 'iloop"
"(if(unsafe-fx< i_0 n_1)"
"(let-values()"
"(let-values(((ref-i_0)"
"(unsafe-vector-ref"
" A_0"
"(unsafe-fx+"
" Alo_0"
" i_0))))"
"((letrec-values(((jloop_0)"
"(lambda(j_0)"
"(begin"
" 'jloop"
"(let-values(((ref-j-1_0)"
"(unsafe-vector-ref"
" A_0"
"(unsafe-fx-"
" j_0"
" 1))))"
"(if(if(unsafe-fx<"
" Blo_0"
" j_0)"
"(if key_0"
"(less-than?_0"
"(key_0"
" ref-i_0)"
"(key_0"
" ref-j-1_0))"
"(less-than?_0"
" ref-i_0"
" ref-j-1_0))"
" #f)"
"(begin"
"(unsafe-vector-set!"
" A_0"
" j_0"
" ref-j-1_0)"
"(jloop_0"
"(unsafe-fx-"
" j_0"
" 1)))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" j_0"
" ref-i_0)"
"(iloop_0"
"(unsafe-fx+"
" i_0"
" 1)))))))))"
" jloop_0)"
"(unsafe-fx+ Blo_0 i_0))))"
"(void))))))"
" iloop_0)"
" 1)))"
"(let-values()"
"(let-values(((n/2-_1)(unsafe-fxrshift n_1 1)))"
"(let-values(((n/2+_1)(unsafe-fx- n_1 n/2-_1)))"
"(let-values(((Amid1_0)(unsafe-fx+ Alo_0 n/2-_1))"
"((Amid2_0)(unsafe-fx+ Alo_0 n/2+_1))"
"((Bmid1_0)(unsafe-fx+ Blo_0 n/2-_1)))"
"(begin"
"(copying-mergesort_0 Amid1_0 Bmid1_0 n/2+_1)"
"(copying-mergesort_0 Alo_0 Amid2_0 n/2-_1)"
"(let-values(((b2_0)(unsafe-fx+ Blo_0 n_1)))"
"((letrec-values(((loop_0)"
"(lambda(a1_0 b1_0 c1_0)"
"(begin"
" 'loop"
"(let-values(((x_0)"
"(unsafe-vector-ref"
" A_0"
" a1_0))"
"((y_0)"
"(unsafe-vector-ref"
" A_0"
" b1_0)))"
"(if(not"
"(if key_0"
"(less-than?_0"
"(key_0 y_0)"
"(key_0 x_0))"
"(less-than?_0"
" y_0"
" x_0)))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_0"
" x_0)"
"(let-values(((a1_1)"
"(unsafe-fx+"
" a1_0"
" 1))"
"((c1_1)"
"(unsafe-fx+"
" c1_0"
" 1)))"
"(if(unsafe-fx<"
" c1_1"
" b1_0)"
"(let-values()"
"(loop_0"
" a1_1"
" b1_0"
" c1_1))"
"(void))))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_0"
" y_0)"
"(let-values(((b1_1)"
"(unsafe-fx+"
" b1_0"
" 1))"
"((c1_1)"
"(unsafe-fx+"
" c1_0"
" 1)))"
"(if(unsafe-fx<="
" b2_0"
" b1_1)"
"((letrec-values(((loop_1)"
"(lambda(a1_1"
" c1_2)"
"(begin"
" 'loop"
"(if(unsafe-fx<"
" c1_2"
" b1_1)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_2"
"(unsafe-vector-ref"
" A_0"
" a1_1))"
"(loop_1"
"(unsafe-fx+"
" a1_1"
" 1)"
"(unsafe-fx+"
" c1_2"
" 1))))"
"(void))))))"
" loop_1)"
" a1_0"
" c1_1)"
"(loop_0"
" a1_0"
" b1_1"
" c1_1))))))))))"
" loop_0)"
" Amid2_0"
" Bmid1_0"
" Blo_0))))))))))))))"
"(let-values(((Alo_0) 0)"
"((Amid1_0) n/2-_0)"
"((Amid2_0) n/2+_0)"
"((Ahi_0) n_0)"
"((B1lo_0) n_0))"
"(begin"
"(copying-mergesort_0 Amid1_0 B1lo_0 n/2+_0)"
"(if(zero? n/2-_0)"
"(void)"
"(let-values()(copying-mergesort_0 Alo_0 Amid2_0 n/2-_0)))"
"(let-values(((b2_0) Ahi_0))"
"((letrec-values(((loop_0)"
"(lambda(a1_0 b1_0 c1_0)"
"(begin"
" 'loop"
"(let-values(((x_0)(unsafe-vector-ref A_0 a1_0))"
"((y_0)(unsafe-vector-ref A_0 b1_0)))"
"(if(if key_0"
"(less-than?_0(key_0 x_0)(key_0 y_0))"
"(less-than?_0 x_0 y_0))"
"(begin"
"(unsafe-vector-set! A_0 c1_0 x_0)"
"(let-values(((a1_1)(unsafe-fx+ a1_0 1))"
"((c1_1)(unsafe-fx+ c1_0 1)))"
"(if(unsafe-fx< c1_1 b1_0)"
"(let-values()(loop_0 a1_1 b1_0 c1_1))"
"(void))))"
"(begin"
"(unsafe-vector-set! A_0 c1_0 y_0)"
"(let-values(((b1_1)(unsafe-fx+ b1_0 1))"
"((c1_1)(unsafe-fx+ c1_0 1)))"
"(if(unsafe-fx<= b2_0 b1_1)"
"((letrec-values(((loop_1)"
"(lambda(a1_1 c1_2)"
"(begin"
" 'loop"
"(if(unsafe-fx< c1_2 b1_1)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_2"
"(unsafe-vector-ref"
" A_0"
" a1_1))"
"(loop_1"
"(unsafe-fx+ a1_1 1)"
"(unsafe-fx+"
" c1_2"
" 1))))"
"(void))))))"
" loop_1)"
" a1_0"
" c1_1)"
"(loop_0 a1_0 b1_1 c1_1))))))))))"
" loop_0)"
" B1lo_0"
" Amid2_0"
" Alo_0)))))))))))))"
"(values"
"(case-lambda"
"((lst_0 less-than?_0)"
"(let-values(((n_0)(length lst_0)))"
"(let-values()"
"(if(unsafe-fx= n_0 0)"
"(let-values() lst_0)"
"(if((letrec-values(((loop_0)"
"(lambda(last_0 next_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(null? next_0)))"
"(if or-part_0"
" or-part_0"
"(if(not(less-than?_0(unsafe-car next_0) last_0))"
"(loop_0(unsafe-car next_0)(unsafe-cdr next_0))"
" #f)))))))"
" loop_0)"
"(car lst_0)"
"(cdr lst_0))"
"(let-values() lst_0)"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(if(unsafe-fx= n_0 1)"
"(let-values() lst_0)"
"(if(unsafe-fx= n_0 2)"
"(let-values()(list(cadr lst_0)(car lst_0)))"
"(let-values()"
"(let-values(((a_0)(car lst_0))((b_0)(cadr lst_0))((c_0)(caddr lst_0)))"
"(if(less-than?_0 b_0 a_0)"
"(if(less-than?_0 c_0 b_0)"
"(list c_0 b_0 a_0)"
"(if(less-than?_0 c_0 a_0)(list b_0 c_0 a_0)(list b_0 a_0 c_0)))"
"(if(less-than?_0 c_0 a_0)(list c_0 a_0 b_0)(list a_0 c_0 b_0))))))))"
"(let-values()"
"(let-values(((vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))))))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0 lst_1)"
"(begin"
" 'loop"
"(if(pair? lst_1)"
"(let-values()"
"(begin"
"(vector-set! vec_0 i_0(car lst_1))"
"(loop_0(add1 i_0)(cdr lst_1))))"
"(void))))))"
" loop_0)"
" 0"
" lst_0)"
"(generic-sort_0 vec_0 less-than?_0 n_0)"
"((letrec-values(((loop_0)"
"(lambda(i_0 r_0)"
"(begin"
" 'loop"
"(let-values(((i_1)(sub1 i_0)))"
"(if(< i_1 0)"
" r_0"
"(loop_0 i_1(cons(vector-ref vec_0 i_1) r_0))))))))"
" loop_0)"
" n_0"
" '()))))))))))"
"((lst_0 less-than?_0 getkey_0)"
"(if(if getkey_0(not(eq? values getkey_0)) #f)"
"(sort lst_0 less-than?_0 getkey_0 #f)"
"(sort lst_0 less-than?_0)))"
"((lst_0 less-than?_0 getkey_0 cache-keys?_0)"
"(if(if getkey_0(not(eq? values getkey_0)) #f)"
"(let-values(((n_0)(length lst_0)))"
"(let-values()"
"(if(unsafe-fx= n_0 0)"
"(let-values() lst_0)"
"(if cache-keys?_0"
"(let-values()"
"(let-values(((vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))))))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0 lst_1)"
"(begin"
" 'loop"
"(if(pair? lst_1)"
"(let-values()"
"(let-values(((x_0)(car lst_1)))"
"(begin"
"(unsafe-vector-set! vec_0 i_0(cons(getkey_0 x_0) x_0))"
"(loop_0(unsafe-fx+ i_0 1)(cdr lst_1)))))"
"(void))))))"
" loop_0)"
" 0"
" lst_0)"
"(generic-sort/key_0 vec_0 less-than?_0 n_0 unsafe-car)"
"((letrec-values(((loop_0)"
"(lambda(i_0 r_0)"
"(begin"
" 'loop"
"(let-values(((i_1)(unsafe-fx- i_0 1)))"
"(if(unsafe-fx< i_1 0)"
" r_0"
"(loop_0"
" i_1"
"(cons(unsafe-cdr(unsafe-vector-ref vec_0 i_1)) r_0))))))))"
" loop_0)"
" n_0"
" '()))))"
"(if((letrec-values(((loop_0)"
"(lambda(last_0 next_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(null? next_0)))"
"(if or-part_0"
" or-part_0"
"(if(not"
"(if getkey_0"
"(less-than?_0"
"(getkey_0(unsafe-car next_0))"
"(getkey_0 last_0))"
"(less-than?_0(unsafe-car next_0) last_0)))"
"(loop_0(unsafe-car next_0)(unsafe-cdr next_0))"
" #f)))))))"
" loop_0)"
"(car lst_0)"
"(cdr lst_0))"
"(let-values() lst_0)"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(if(unsafe-fx= n_0 1)"
"(let-values() lst_0)"
"(if(unsafe-fx= n_0 2)"
"(let-values()(list(cadr lst_0)(car lst_0)))"
"(let-values()"
"(let-values(((a_0)(car lst_0))((b_0)(cadr lst_0))((c_0)(caddr lst_0)))"
"(if(if getkey_0(less-than?_0(getkey_0 b_0)(getkey_0 a_0))(less-than?_0 b_0 a_0))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 b_0))"
"(less-than?_0 c_0 b_0))"
"(list c_0 b_0 a_0)"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(list b_0 c_0 a_0)"
"(list b_0 a_0 c_0)))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(list c_0 a_0 b_0)"
"(list a_0 c_0 b_0))))))))"
"(let-values()"
"(let-values(((vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))))))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0 lst_1)"
"(begin"
" 'loop"
"(if(pair? lst_1)"
"(let-values()"
"(begin"
"(vector-set! vec_0 i_0(car lst_1))"
"(loop_0(add1 i_0)(cdr lst_1))))"
"(void))))))"
" loop_0)"
" 0"
" lst_0)"
"(generic-sort/key_0 vec_0 less-than?_0 n_0 getkey_0)"
"((letrec-values(((loop_0)"
"(lambda(i_0 r_0)"
"(begin"
" 'loop"
"(let-values(((i_1)(sub1 i_0)))"
"(if(< i_1 0)"
" r_0"
"(loop_0 i_1(cons(vector-ref vec_0 i_1) r_0))))))))"
" loop_0)"
" n_0"
" '()))))))))))"
"(sort lst_0 less-than?_0))))"
"(case-lambda"
"((vec_0 less-than?_0 start_0 end_0)"
"(let-values(((n_0)(- end_0 start_0)))"
"(let-values(((dst-vec_0)(make-vector n_0)))"
"(let-values(((dst-start_0) 0))"
"(begin"
"(if(unsafe-fx= n_0 0)"
"(let-values()(void))"
"(if((letrec-values(((loop_0)"
"(lambda(prev-val_0 next-index_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(unsafe-fx= next-index_0 end_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((next-val_0)(unsafe-vector-ref vec_0 next-index_0)))"
"(if(not(less-than?_0 next-val_0 prev-val_0))"
"(loop_0 next-val_0(unsafe-fx+ next-index_0 1))"
" #f))))))))"
" loop_0)"
"(unsafe-vector-ref vec_0 start_0)"
"(unsafe-fx+ start_0 1))"
"(let-values()(let-values()(vector-copy! dst-vec_0 dst-start_0 vec_0 start_0 end_0)))"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(begin"
"(let-values()(vector-copy! dst-vec_0 dst-start_0 vec_0 start_0 end_0))"
"(if(unsafe-fx= n_0 1)"
"(let-values()(void))"
"(if(unsafe-fx= n_0 2)"
"(let-values()"
"(let-values(((tmp_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0))))"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ dst-start_0 0)"
"(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) tmp_0))))"
"(let-values()"
"(let-values(((a_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0)))"
"((b_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"((c_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 2))))"
"(if(less-than?_0 b_0 a_0)"
"(let-values()"
"(if(less-than?_0 c_0 b_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(if(less-than?_0 c_0 a_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0))))))"
"(if(less-than?_0 c_0 a_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))))))))))"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #f)))"
"(begin"
"(vector-copy! work-vec_0 0 vec_0 start_0 end_0)"
"(generic-sort_0 work-vec_0 less-than?_0 n_0)"
"(vector-copy! dst-vec_0 dst-start_0 work-vec_0 0 n_0)))))))"
" dst-vec_0)))))"
"((vec_0 less-than?_0 start_0 end_0 getkey_0 cache-keys?_0)"
"(if(if getkey_0(not(eq? values getkey_0)) #f)"
"(let-values(((n_0)(- end_0 start_0)))"
"(let-values(((dst-vec_0)(make-vector n_0)))"
"(let-values(((dst-start_0) 0))"
"(begin"
"(if(unsafe-fx= n_0 0)"
"(let-values()(void))"
"(if cache-keys?_0"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #t)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(unsafe-fx< i_0 n_0)"
"(let-values()"
"(begin"
"(let-values(((x_0)"
"(unsafe-vector-ref"
" vec_0"
"(unsafe-fx+ i_0 start_0))))"
"(unsafe-vector-set!"
" work-vec_0"
" i_0"
"(cons(getkey_0 x_0) x_0)))"
"(loop_0(unsafe-fx+ i_0 1))))"
"(void))))))"
" loop_0)"
" 0)"
"(generic-sort/key_0 work-vec_0 less-than?_0 n_0 unsafe-car)"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(unsafe-fx< i_0 n_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ i_0 dst-start_0)"
"(unsafe-cdr(unsafe-vector-ref work-vec_0 i_0)))"
"(loop_0(unsafe-fx+ i_0 1))))"
"(void))))))"
" loop_0)"
" 0))))"
"(if((letrec-values(((loop_0)"
"(lambda(prev-val_0 next-index_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(unsafe-fx= next-index_0 end_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((next-val_0)"
"(unsafe-vector-ref vec_0 next-index_0)))"
"(if(not"
"(if getkey_0"
"(less-than?_0"
"(getkey_0 next-val_0)"
"(getkey_0 prev-val_0))"
"(less-than?_0 next-val_0 prev-val_0)))"
"(loop_0 next-val_0(unsafe-fx+ next-index_0 1))"
" #f))))))))"
" loop_0)"
"(unsafe-vector-ref vec_0 start_0)"
"(unsafe-fx+ start_0 1))"
"(let-values()(let-values()(vector-copy! dst-vec_0 dst-start_0 vec_0 start_0 end_0)))"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(begin"
"(let-values()(vector-copy! dst-vec_0 dst-start_0 vec_0 start_0 end_0))"
"(if(unsafe-fx= n_0 1)"
"(let-values()(void))"
"(if(unsafe-fx= n_0 2)"
"(let-values()"
"(let-values(((tmp_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0))))"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ dst-start_0 0)"
"(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) tmp_0))))"
"(let-values()"
"(let-values(((a_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0)))"
"((b_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"((c_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 2))))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 b_0)(getkey_0 a_0))"
"(less-than?_0 b_0 a_0))"
"(let-values()"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 b_0))"
"(less-than?_0 c_0 b_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0))))))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))))))))))"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #f)))"
"(begin"
"(vector-copy! work-vec_0 0 vec_0 start_0 end_0)"
"(generic-sort/key_0 work-vec_0 less-than?_0 n_0 getkey_0)"
"(vector-copy! dst-vec_0 dst-start_0 work-vec_0 0 n_0))))))))"
" dst-vec_0))))"
"(vector-sort vec_0 less-than?_0 start_0 end_0))))"
"(case-lambda"
"((vec_0 less-than?_0 start_0 end_0)"
"(let-values(((n_0)(- end_0 start_0)))"
"(let-values(((dst-vec_0) vec_0))"
"(let-values(((dst-start_0) start_0))"
"(begin"
"(if(unsafe-fx= n_0 0)"
"(let-values()(void))"
"(if((letrec-values(((loop_0)"
"(lambda(prev-val_0 next-index_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(unsafe-fx= next-index_0 end_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((next-val_0)(unsafe-vector-ref vec_0 next-index_0)))"
"(if(not(less-than?_0 next-val_0 prev-val_0))"
"(loop_0 next-val_0(unsafe-fx+ next-index_0 1))"
" #f))))))))"
" loop_0)"
"(unsafe-vector-ref vec_0 start_0)"
"(unsafe-fx+ start_0 1))"
"(let-values()(void))"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(if(unsafe-fx= n_0 1)"
"(let-values()(void))"
"(if(unsafe-fx= n_0 2)"
"(let-values()"
"(let-values(((tmp_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0))))"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ dst-start_0 0)"
"(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) tmp_0))))"
"(let-values()"
"(let-values(((a_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0)))"
"((b_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"((c_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 2))))"
"(if(less-than?_0 b_0 a_0)"
"(let-values()"
"(if(less-than?_0 c_0 b_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(if(less-than?_0 c_0 a_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0))))))"
"(if(less-than?_0 c_0 a_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0))))))))))"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #f)))"
"(begin"
"(vector-copy! work-vec_0 0 vec_0 start_0 end_0)"
"(generic-sort_0 work-vec_0 less-than?_0 n_0)"
"(vector-copy! dst-vec_0 dst-start_0 work-vec_0 0 n_0)))))))"
"(void))))))"
"((vec_0 less-than?_0 start_0 end_0 getkey_0 cache-keys?_0)"
"(if(if getkey_0(not(eq? values getkey_0)) #f)"
"(let-values(((n_0)(- end_0 start_0)))"
"(let-values(((dst-vec_0) vec_0))"
"(let-values(((dst-start_0) start_0))"
"(begin"
"(if(unsafe-fx= n_0 0)"
"(let-values()(void))"
"(if cache-keys?_0"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #t)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(unsafe-fx< i_0 n_0)"
"(let-values()"
"(begin"
"(let-values(((x_0)"
"(unsafe-vector-ref"
" vec_0"
"(unsafe-fx+ i_0 start_0))))"
"(unsafe-vector-set!"
" work-vec_0"
" i_0"
"(cons(getkey_0 x_0) x_0)))"
"(loop_0(unsafe-fx+ i_0 1))))"
"(void))))))"
" loop_0)"
" 0)"
"(generic-sort/key_0 work-vec_0 less-than?_0 n_0 unsafe-car)"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(unsafe-fx< i_0 n_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ i_0 dst-start_0)"
"(unsafe-cdr(unsafe-vector-ref work-vec_0 i_0)))"
"(loop_0(unsafe-fx+ i_0 1))))"
"(void))))))"
" loop_0)"
" 0))))"
"(if((letrec-values(((loop_0)"
"(lambda(prev-val_0 next-index_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(unsafe-fx= next-index_0 end_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((next-val_0)"
"(unsafe-vector-ref vec_0 next-index_0)))"
"(if(not"
"(if getkey_0"
"(less-than?_0"
"(getkey_0 next-val_0)"
"(getkey_0 prev-val_0))"
"(less-than?_0 next-val_0 prev-val_0)))"
"(loop_0 next-val_0(unsafe-fx+ next-index_0 1))"
" #f))))))))"
" loop_0)"
"(unsafe-vector-ref vec_0 start_0)"
"(unsafe-fx+ start_0 1))"
"(let-values()(void))"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(if(unsafe-fx= n_0 1)"
"(let-values()(void))"
"(if(unsafe-fx= n_0 2)"
"(let-values()"
"(let-values(((tmp_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0))))"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ dst-start_0 0)"
"(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) tmp_0))))"
"(let-values()"
"(let-values(((a_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0)))"
"((b_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"((c_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 2))))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 b_0)(getkey_0 a_0))"
"(less-than?_0 b_0 a_0))"
"(let-values()"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 b_0))"
"(less-than?_0 c_0 b_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0))))))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0))))))))))"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #f)))"
"(begin"
"(vector-copy! work-vec_0 0 vec_0 start_0 end_0)"
"(generic-sort/key_0 work-vec_0 less-than?_0 n_0 getkey_0)"
"(vector-copy! dst-vec_0 dst-start_0 work-vec_0 0 n_0))))))))"
"(void)))))"
"(vector-sort! vec_0 less-than?_0 start_0 end_0)))))))))"
"(define-values"
"(1/raise-argument-error)"
"(lambda(who_0 . args_0)(begin 'raise-argument-error(apply raise-argument-error* who_0 'racket/primitive args_0))))"
"(define-values"
"(1/raise-arguments-error)"
"(lambda(who_0 . args_0)"
"(begin 'raise-arguments-error(apply raise-arguments-error* who_0 'racket/primitive args_0))))"
"(define-values"
"(1/raise-range-error)"
"(lambda(who_0 . args_0)(begin 'raise-range-error(apply raise-range-error* who_0 'racket/primitive args_0))))"
"(define-values"
"(struct:do-sequence make-do-sequence do-sequence? do-sequence-ref do-sequence-set!)"
"(make-struct-type 'sequence #f 1 0 #f))"
"(define-values"
"(prop:stream stream-via-prop? stream-ref)"
"(make-struct-type-property"
" 'stream"
"(lambda(v_0 si_0)"
"(begin"
"(if(if(vector? v_0)"
"(if(= 3(vector-length v_0))"
"(if(procedure?(vector-ref v_0 0))"
"(if(procedure-arity-includes?(vector-ref v_0 0) 1)"
"(if(procedure?(vector-ref v_0 1))"
"(if(procedure-arity-includes?(vector-ref v_0 1) 1)"
"(if(procedure?(vector-ref v_0 2))(procedure-arity-includes?(vector-ref v_0 2) 1) #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
"(void)"
"(let-values()"
"(1/raise-argument-error"
" 'guard-for-prop:stream"
"(string-append"
"             \"(vector/c (procedure-arity-includes/c 1)\\n\""
"             \"          (procedure-arity-includes/c 1)\\n\""
"             \"          (procedure-arity-includes/c 1))\")"
" v_0)))"
"(vector->immutable-vector v_0)))"
" '()"
" #t))"
"(define-values"
"(prop:gen-sequence sequence-via-prop? sequence-ref)"
"(make-struct-type-property"
" 'sequence"
"(lambda(v_0 si_0)"
"(begin"
"(if(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)"
"(void)"
"         (let-values () (1/raise-argument-error 'guard-for-prop:sequence \"(procedure-arity-includes/c 1)\" v_0)))"
" v_0))))"
"(define-values"
"(prop:sequence :sequence? :sequence-ref)"
"(make-struct-type-property"
" 'sequence"
"(lambda(v_0 sinfo_0)"
"(begin"
"(if(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)"
"(void)"
"         (let-values () (1/raise-argument-error 'sequence-property-guard \"(procedure-arity-includes/c 1)\" v_0)))"
"(lambda(self_0)"
"(let-values(((s_0)(v_0 self_0)))"
"(begin"
"(if(sequence? s_0)"
"(void)"
"(let-values()"
"(raise-mismatch-error"
" 'sequence-generate"
"                  \"procedure (value of prop:sequence) produced a non-sequence: \""
" s_0)))"
" s_0)))))))"
"(define-values"
"(stream?)"
"(lambda(v_0)(begin(let-values(((or-part_0)(list? v_0)))(if or-part_0 or-part_0(stream-via-prop? v_0))))))"
"(define-values"
"(unsafe-stream-not-empty?)"
"(lambda(v_0)"
"(begin"
"(if(null? v_0)"
" #f"
"(let-values(((or-part_0)(pair? v_0)))"
"(if or-part_0 or-part_0(not((unsafe-vector-ref(stream-ref v_0) 0) v_0))))))))"
"(define-values"
"(unsafe-stream-first)"
"(lambda(v_0)"
"(begin(if(pair? v_0)(let-values()(car v_0))(let-values()((unsafe-vector-ref(stream-ref v_0) 1) v_0))))))"
"(define-values"
"(unsafe-stream-rest)"
"(lambda(v_0)"
"(begin"
"(if(pair? v_0)"
"(let-values()(cdr v_0))"
"(let-values()"
"(let-values(((r_0)((unsafe-vector-ref(stream-ref v_0) 2) v_0)))"
"(begin"
"(if(stream? r_0)"
"(void)"
"                (let-values () (raise-mismatch-error 'stream-rest-guard \"result is not a stream: \" r_0)))"
" r_0)))))))"
"(define-values"
"(sequence?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(exact-nonnegative-integer? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(do-sequence? v_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(sequence-via-prop? v_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(stream? v_0)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(mpair? v_0)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(vector? v_0)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(flvector? v_0)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(fxvector? v_0)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(string? v_0)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(bytes? v_0)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(input-port? v_0)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(hash? v_0)))"
"(if or-part_11"
" or-part_11"
"(if(:sequence? v_0)"
"(not(struct-type? v_0))"
" #f))))))))))))))))))))))))))))"
"(define-values"
"(make-sequence)"
"(lambda(who_0 v_0)"
"(begin"
"(if(exact-nonnegative-integer? v_0)"
"(let-values()(:integer-gen v_0))"
"(if(do-sequence? v_0)"
"(let-values()"
"(call-with-values"
"(lambda()((do-sequence-ref v_0 0)))"
"(case-lambda"
"((pos->vals_0 pos-next_0 init_0 pos-cont?_0 val-cont?_0 all-cont?_0)"
"(values pos->vals_0 #f pos-next_0 init_0 pos-cont?_0 val-cont?_0 all-cont?_0))"
"((pos->vals_0 pre-pos-next_0 pos-next_0 init_0 pos-cont?_0 val-cont?_0 all-cont?_0)"
"(values pos->vals_0 pre-pos-next_0 pos-next_0 init_0 pos-cont?_0 val-cont?_0 all-cont?_0)))))"
"(if(mpair? v_0)"
"(let-values()(:mlist-gen v_0))"
"(if(list? v_0)"
"(let-values()(:list-gen v_0))"
"(if(vector? v_0)"
"(let-values()(:vector-gen v_0 0(vector-length v_0) 1))"
"(if(flvector? v_0)"
"(let-values()(:flvector-gen v_0 0(flvector-length v_0) 1))"
"(if(fxvector? v_0)"
"(let-values()(:fxvector-gen v_0 0(fxvector-length v_0) 1))"
"(if(string? v_0)"
"(let-values()(:string-gen v_0 0(string-length v_0) 1))"
"(if(bytes? v_0)"
"(let-values()(:bytes-gen v_0 0(bytes-length v_0) 1))"
"(if(input-port? v_0)"
"(let-values()(:input-port-gen v_0))"
"(if(hash? v_0)"
"(let-values()(:hash-gen v_0 hash-iterate-key+value hash-iterate-first hash-iterate-next))"
"(if(sequence-via-prop? v_0)"
"(let-values()((sequence-ref v_0) v_0))"
"(if(:sequence? v_0)"
"(let-values()(make-sequence who_0((:sequence-ref v_0) v_0)))"
"(if(stream? v_0)"
"(let-values()(:stream-gen v_0))"
"(let-values()"
"(raise"
"(exn:fail:contract"
"(format"
"                                       \"for: expected a sequence for ~a, got something else: ~v\""
"(if(= 1(length who_0))(car who_0) who_0)"
" v_0)"
"(current-continuation-marks)))))))))))))))))))))"
"(define-values"
"(struct:range make-range range? range-ref range-set!)"
"(make-struct-type"
" 'stream"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons"
" prop:stream"
"(vector"
"(lambda(v_0)(let-values(((cont?_0)(range-ref v_0 2)))(if cont?_0(not(cont?_0(range-ref v_0 0))) #f)))"
"(lambda(v_0)(range-ref v_0 0))"
"(lambda(v_0)(make-range((range-ref v_0 1)(range-ref v_0 0))(range-ref v_0 1)(range-ref v_0 2)))))"
"(cons"
" prop:gen-sequence"
"(lambda(v_0)(values values #f(range-ref v_0 1)(range-ref v_0 0)(range-ref v_0 2) #f #f))))))"
"(define-values(check-range)(lambda(a_0 b_0 step_0)(begin(check-range-generic 'in-range a_0 b_0 step_0))))"
"(define-values"
"(check-range-generic)"
"(lambda(who_0 a_0 b_0 step_0)"
"(begin"
"(begin"
"        (if (real? a_0) (void) (let-values () (1/raise-argument-error who_0 \"real?\" a_0)))"
"        (if (real? b_0) (void) (let-values () (1/raise-argument-error who_0 \"real?\" b_0)))"
"        (if (real? step_0) (void) (let-values () (1/raise-argument-error who_0 \"real?\" step_0)))))))"
"(define-values(:integer-gen)(lambda(v_0)(begin(values values #f add1 0(lambda(i_0)(< i_0 v_0)) #f #f))))"
"(define-values"
"(check-naturals)"
"(lambda(n_0)"
"(begin"
"(if(if(integer? n_0)(if(exact? n_0)(>= n_0 0) #f) #f)"
"(void)"
"        (let-values () (1/raise-argument-error 'in-naturals \"exact-nonnegative-integer?\" n_0))))))"
"(define-values"
"(struct:list-stream make-list-stream list-stream? list-stream-ref list-stream-set!)"
"(make-struct-type"
" 'stream"
" #f"
" 1"
" 0"
" #f"
"(list"
"(cons"
" prop:stream"
"(vector"
"(lambda(v_0)(not(pair?(list-stream-ref v_0 0))))"
"(lambda(v_0)(car(list-stream-ref v_0 0)))"
"(lambda(v_0)(make-list-stream(cdr(list-stream-ref v_0 0))))))"
"(cons prop:gen-sequence(lambda(v_0)(values car cdr values(list-stream-ref v_0 0) pair? #f #f))))))"
"(define-values"
"(check-list)"
"  (lambda (l_0) (begin (if (list? l_0) (void) (let-values () (1/raise-argument-error 'in-list \"list?\" l_0))))))"
"(define-values(:list-gen)(lambda(l_0)(begin(values car cdr values l_0 pair? #f #f))))"
"(define-values(:mlist-gen)(lambda(l_0)(begin(values mcar #f mcdr l_0 mpair? #f #f))))"
"(define-values"
"(:input-port-gen)"
"(lambda(p_0)(begin(values read-byte #f values p_0 #f(lambda(x_0)(not(eof-object? x_0))) #f))))"
"(define-values"
"(:stream-gen)"
"(lambda(l_0)(begin(values unsafe-stream-first unsafe-stream-rest values l_0 unsafe-stream-not-empty? #f #f))))"
"(define-values"
"(:hash-gen)"
"(case-lambda"
"((ht_0 -get_0 -first_0 -next_0)"
"(begin"
"(values"
"(lambda(pos_0)(-get_0 ht_0 pos_0))"
" #f"
"(lambda(pos_0)(-next_0 ht_0 pos_0))"
"(-first_0 ht_0)"
"(lambda(pos_0) pos_0)"
" #f"
" #f)))"
"((ht_0 -get_0 -first_0 -next_0 bad-v_0)"
"(values"
"(lambda(pos_0)(-get_0 ht_0 pos_0 bad-v_0))"
" #f"
"(lambda(pos_0)(-next_0 ht_0 pos_0))"
"(-first_0 ht_0)"
"(lambda(pos_0) pos_0)"
" #f"
" #f))))"
"(define-values"
"(check-in-hash)"
"(lambda(ht_0)"
"(begin"
"      (if ((lambda (ht_1) (hash? ht_1)) ht_0) (void) (let-values () (1/raise-argument-error 'in-hash \"hash?\" ht_0))))))"
"(define-values"
"(check-in-immutable-hash)"
"(lambda(ht_0)"
"(begin"
"(if((lambda(ht_1)(if(hash? ht_1)(immutable? ht_1) #f)) ht_0)"
"(void)"
"        (let-values () (1/raise-argument-error 'in-immutable-hash \"(and/c hash? immutable?)\" ht_0))))))"
"(define-values"
"(check-in-hash-keys)"
"(lambda(ht_0)"
"(begin"
"(if((lambda(ht_1)(hash? ht_1)) ht_0)"
"(void)"
"        (let-values () (1/raise-argument-error 'in-hash-keys \"hash?\" ht_0))))))"
"(define-values"
"(check-in-immutable-hash-keys)"
"(lambda(ht_0)"
"(begin"
"(if((lambda(ht_1)(if(hash? ht_1)(immutable? ht_1) #f)) ht_0)"
"(void)"
"        (let-values () (1/raise-argument-error 'in-immutable-hash-keys \"(and/c hash? immutable?)\" ht_0))))))"
"(define-values"
"(check-in-hash-values)"
"(lambda(ht_0)"
"(begin"
"(if((lambda(ht_1)(hash? ht_1)) ht_0)"
"(void)"
"        (let-values () (1/raise-argument-error 'in-hash-values \"hash?\" ht_0))))))"
"(define-values"
"(check-ranges)"
"(lambda(who_0 type-name_0 vec_0 start_0 stop_0 step_0 len_0)"
"(begin"
"(begin"
"(if(exact-nonnegative-integer? start_0)"
"(void)"
"          (let-values () (1/raise-argument-error who_0 \"exact-nonnegative-integer?\" start_0)))"
"(if(let-values(((or-part_0)(< start_0 len_0)))(if or-part_0 or-part_0(= len_0 start_0 stop_0)))"
"(void)"
"          (let-values () (1/raise-range-error who_0 type-name_0 \"starting \" start_0 vec_0 0 (sub1 len_0))))"
"        (if (exact-integer? stop_0) (void) (let-values () (1/raise-argument-error who_0 \"exact-integer?\" stop_0)))"
"(if(if(<= -1 stop_0)(<= stop_0 len_0) #f)"
"(void)"
"          (let-values () (1/raise-range-error who_0 type-name_0 \"stopping \" stop_0 vec_0 -1 len_0)))"
"(if(if(exact-integer? step_0)(not(zero? step_0)) #f)"
"(void)"
"          (let-values () (1/raise-argument-error who_0 \"(and/c exact-integer? (not/c zero?))\" step_0)))"
"(if(if(< start_0 stop_0)(< step_0 0) #f)"
"(let-values()"
"(1/raise-arguments-error"
" who_0"
"             \"starting index less than stopping index, but given a negative step\""
"             \"starting index\""
" start_0"
"             \"stopping index\""
" stop_0"
"             \"step\""
" step_0))"
"(void))"
"(if(if(< stop_0 start_0)(> step_0 0) #f)"
"(let-values()"
"(1/raise-arguments-error"
" who_0"
"             \"starting index more than stopping index, but given a positive step\""
"             \"starting index\""
" start_0"
"             \"stopping index\""
" stop_0"
"             \"step\""
" step_0))"
"(void))))))"
"(define-values"
"(normalise-inputs)"
"(lambda(who_0 type-name_0 vector?_0 unsafe-vector-length_0 vec_0 start_0 stop_0 step_0)"
"(begin"
"(begin"
"(if(vector?_0 vec_0)"
"(void)"
"          (let-values () (1/raise-argument-error who_0 (string-append type-name_0 \"?\") vec_0)))"
"(let-values(((len_0)(unsafe-vector-length_0 vec_0)))"
"(let-values(((stop*_0)(if stop_0 stop_0 len_0)))"
"(begin"
"(check-ranges who_0 type-name_0 vec_0 start_0 stop*_0 step_0 len_0)"
"(values vec_0 start_0 stop*_0 step_0))))))))"
"(define-values"
"(unsafe-normalise-inputs)"
"(lambda(unsafe-vector-length_0 vec_0 start_0 stop_0 step_0)"
"(begin"
"(values"
" vec_0"
" start_0"
"(let-values(((or-part_0) stop_0))(if or-part_0 or-part_0(unsafe-vector-length_0 vec_0)))"
" step_0))))"
"(define-values"
"(:vector-gen)"
"(lambda(v_0 start_0 stop_0 step_0)"
"(begin"
"(values"
"(lambda(i_0)(unsafe-vector-ref v_0 i_0))"
" #f"
"(if(= step_0 1) add1(lambda(i_0)(+ i_0 step_0)))"
" start_0"
"(if(> step_0 0)(lambda(i_0)(< i_0 stop_0))(lambda(i_0)(> i_0 stop_0)))"
" #f"
" #f))))"
"(define-values"
"(check-vector)"
"(lambda(v_0)"
"(begin"
"      (if (vector? v_0) (void) (let-values () (1/raise-argument-error 'in-vector (string-append \"vector\" \"?\") v_0))))))"
"(define-values"
"(:string-gen)"
"(lambda(v_0 start_0 stop_0 step_0)"
"(begin"
"(values"
"(lambda(i_0)(string-ref v_0 i_0))"
" #f"
"(if(= step_0 1) add1(lambda(i_0)(+ i_0 step_0)))"
" start_0"
"(if(> step_0 0)(lambda(i_0)(< i_0 stop_0))(lambda(i_0)(> i_0 stop_0)))"
" #f"
" #f))))"
"(define-values"
"(check-string)"
"(lambda(v_0)"
"(begin"
"      (if (string? v_0) (void) (let-values () (1/raise-argument-error 'in-string (string-append \"string\" \"?\") v_0))))))"
"(define-values"
"(:bytes-gen)"
"(lambda(v_0 start_0 stop_0 step_0)"
"(begin"
"(values"
"(lambda(i_0)(unsafe-bytes-ref v_0 i_0))"
" #f"
"(if(= step_0 1) add1(lambda(i_0)(+ i_0 step_0)))"
" start_0"
"(if(> step_0 0)(lambda(i_0)(< i_0 stop_0))(lambda(i_0)(> i_0 stop_0)))"
" #f"
" #f))))"
"(define-values"
"(check-bytes)"
"(lambda(v_0)"
"(begin"
"      (if (bytes? v_0) (void) (let-values () (1/raise-argument-error 'in-bytes (string-append \"bytes\" \"?\") v_0))))))"
"(define-values"
"(:flvector-gen)"
"(lambda(v_0 start_0 stop_0 step_0)"
"(begin"
"(values"
"(lambda(i_0)(unsafe-flvector-ref v_0 i_0))"
" #f"
"(if(= step_0 1) add1(lambda(i_0)(+ i_0 step_0)))"
" start_0"
"(if(> step_0 0)(lambda(i_0)(< i_0 stop_0))(lambda(i_0)(> i_0 stop_0)))"
" #f"
" #f))))"
"(define-values"
"(:fxvector-gen)"
"(lambda(v_0 start_0 stop_0 step_0)"
"(begin"
"(values"
"(lambda(i_0)(unsafe-fxvector-ref v_0 i_0))"
" #f"
"(if(= step_0 1) add1(lambda(i_0)(+ i_0 step_0)))"
" start_0"
"(if(> step_0 0)(lambda(i_0)(< i_0 stop_0))(lambda(i_0)(> i_0 stop_0)))"
" #f"
" #f))))"
"(define-values"
"(struct:do-stream make-do-stream do-stream? do-stream-ref do-stream-set!)"
"(make-struct-type"
" 'stream"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons"
" prop:stream"
"(vector"
"(lambda(v_0)((do-stream-ref v_0 0)))"
"(lambda(v_0)((do-stream-ref v_0 1)))"
"(lambda(v_0)((do-stream-ref v_0 2))))))))"
"(define-values(empty-stream)(make-do-stream(lambda() #t) void void))"
"(define-values"
"(grow-vector)"
"(lambda(vec_0)"
"(begin"
"(let-values(((n_0)(vector-length vec_0)))"
"(let-values(((new-vec_0)(make-vector(* 2 n_0))))"
"(begin(vector-copy! new-vec_0 0 vec_0 0 n_0) new-vec_0))))))"
"(define-values"
"(shrink-vector)"
"(lambda(vec_0 i_0)"
"(begin(let-values(((new-vec_0)(make-vector i_0)))(begin(vector-copy! new-vec_0 0 vec_0 0 i_0) new-vec_0)))))"
"(define-values"
"(map2)"
"(let-values(((map_0)"
"(case-lambda"
"((f_0 l_0)"
"(begin"
" 'map"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)(if(procedure-arity-includes? f_0 1)(list? l_0) #f) #f))"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values() null)"
"(let-values()"
"(let-values(((r_0)(cdr l_1)))"
"(cons(f_0(car l_1))(loop_0 r_0)))))))))"
" loop_0)"
" l_0)"
"(gen-map f_0(list l_0)))))"
"((f_0 l1_0 l2_0)"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)"
"(if(procedure-arity-includes? f_0 2)"
"(if(list? l1_0)(if(list? l2_0)(=(length l1_0)(length l2_0)) #f) #f)"
" #f)"
" #f))"
"((letrec-values(((loop_0)"
"(lambda(l1_1 l2_1)"
"(begin"
" 'loop"
"(if(null? l1_1)"
"(let-values() null)"
"(let-values()"
"(let-values(((r1_0)(cdr l1_1))((r2_0)(cdr l2_1)))"
"(cons(f_0(car l1_1)(car l2_1))(loop_0 r1_0 r2_0)))))))))"
" loop_0)"
" l1_0"
" l2_0)"
"(gen-map f_0(list l1_0 l2_0))))"
"((f_0 l_0 . args_0)(gen-map f_0(cons l_0 args_0))))))"
" map_0))"
"(define-values"
"(for-each2)"
"(let-values(((for-each_0)"
"(case-lambda"
"((f_0 l_0)"
"(begin"
" 'for-each"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)(if(procedure-arity-includes? f_0 1)(list? l_0) #f) #f))"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values()(void))"
"(let-values()"
"(let-values(((r_0)(cdr l_1)))"
"(begin(f_0(car l_1))(loop_0 r_0)))))))))"
" loop_0)"
" l_0)"
"(gen-for-each f_0(list l_0)))))"
"((f_0 l1_0 l2_0)"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)"
"(if(procedure-arity-includes? f_0 2)"
"(if(list? l1_0)(if(list? l2_0)(=(length l1_0)(length l2_0)) #f) #f)"
" #f)"
" #f))"
"((letrec-values(((loop_0)"
"(lambda(l1_1 l2_1)"
"(begin"
" 'loop"
"(if(null? l1_1)"
"(let-values()(void))"
"(let-values()"
"(let-values(((r1_0)(cdr l1_1))((r2_0)(cdr l2_1)))"
"(begin(f_0(car l1_1)(car l2_1))(loop_0 r1_0 r2_0)))))))))"
" loop_0)"
" l1_0"
" l2_0)"
"(gen-for-each f_0(list l1_0 l2_0))))"
"((f_0 l_0 . args_0)(gen-for-each f_0(cons l_0 args_0))))))"
" for-each_0))"
"(define-values"
"(andmap2)"
"(let-values(((andmap_0)"
"(case-lambda"
"((f_0 l_0)"
"(begin"
" 'andmap"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)(if(procedure-arity-includes? f_0 1)(list? l_0) #f) #f))"
"(if(null? l_0)"
" #t"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null?(cdr l_1))"
"(let-values()(f_0(car l_1)))"
"(let-values()"
"(let-values(((r_0)(cdr l_1)))"
"(if(f_0(car l_1))(loop_0 r_0) #f))))))))"
" loop_0)"
" l_0))"
"(gen-andmap f_0(list l_0)))))"
"((f_0 l1_0 l2_0)"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)"
"(if(procedure-arity-includes? f_0 2)"
"(if(list? l1_0)(if(list? l2_0)(=(length l1_0)(length l2_0)) #f) #f)"
" #f)"
" #f))"
"(if(null? l1_0)"
" #t"
"((letrec-values(((loop_0)"
"(lambda(l1_1 l2_1)"
"(begin"
" 'loop"
"(if(null?(cdr l1_1))"
"(let-values()(f_0(car l1_1)(car l2_1)))"
"(let-values()"
"(let-values(((r1_0)(cdr l1_1))((r2_0)(cdr l2_1)))"
"(if(f_0(car l1_1)(car l2_1))(loop_0 r1_0 r2_0) #f))))))))"
" loop_0)"
" l1_0"
" l2_0))"
"(gen-andmap f_0(list l1_0 l2_0))))"
"((f_0 l_0 . args_0)(gen-andmap f_0(cons l_0 args_0))))))"
" andmap_0))"
"(define-values"
"(ormap2)"
"(let-values(((ormap_0)"
"(case-lambda"
"((f_0 l_0)"
"(begin"
" 'ormap"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)(if(procedure-arity-includes? f_0 1)(list? l_0) #f) #f))"
"(if(null? l_0)"
" #f"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null?(cdr l_1))"
"(let-values()(f_0(car l_1)))"
"(let-values()"
"(let-values(((r_0)(cdr l_1)))"
"(let-values(((or-part_0)(f_0(car l_1))))"
"(if or-part_0 or-part_0(loop_0 r_0))))))))))"
" loop_0)"
" l_0))"
"(gen-ormap f_0(list l_0)))))"
"((f_0 l1_0 l2_0)"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)"
"(if(procedure-arity-includes? f_0 2)"
"(if(list? l1_0)(if(list? l2_0)(=(length l1_0)(length l2_0)) #f) #f)"
" #f)"
" #f))"
"(if(null? l1_0)"
" #f"
"((letrec-values(((loop_0)"
"(lambda(l1_1 l2_1)"
"(begin"
" 'loop"
"(if(null?(cdr l1_1))"
"(let-values()(f_0(car l1_1)(car l2_1)))"
"(let-values()"
"(let-values(((r1_0)(cdr l1_1))((r2_0)(cdr l2_1)))"
"(let-values(((or-part_0)(f_0(car l1_1)(car l2_1))))"
"(if or-part_0 or-part_0(loop_0 r1_0 r2_0))))))))))"
" loop_0)"
" l1_0"
" l2_0))"
"(gen-ormap f_0(list l1_0 l2_0))))"
"((f_0 l_0 . args_0)(gen-ormap f_0(cons l_0 args_0))))))"
" ormap_0))"
"(define-values"
"(check-args)"
"(lambda(who_0 f_0 ls_0)"
"(begin"
"(begin"
"        (if (procedure? f_0) (void) (let-values () (raise-argument-error who_0 \"procedure?\" f_0)))"
"((letrec-values(((loop_0)"
"(lambda(prev-len_0 ls_1 i_0)"
"(begin"
" 'loop"
"(if(null? ls_1)"
"(void)"
"(let-values()"
"(let-values(((l_0)(car ls_1)))"
"(begin"
"                                      (if (list? l_0) (void) (let-values () (raise-argument-error who_0 \"list?\" l_0)))"
"(let-values(((len_0)(length l_0)))"
"(begin"
"(if(if prev-len_0(not(= len_0 prev-len_0)) #f)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                               \"all lists must have same size\""
"                                               \"first list length\""
" prev-len_0"
"                                               \"other list length\""
" len_0"
"                                               \"procedure\""
" f_0))"
"(void))"
"(loop_0 len_0(cdr ls_1)(add1 i_0))))))))))))"
" loop_0)"
" #f"
" ls_0"
" 1)"
"(if(procedure-arity-includes? f_0(length ls_0))"
"(void)"
"(let-values()"
"(let-values(((required-keywords_0 optional-keywords_0)(procedure-keywords f_0)))"
"(apply"
" raise-arguments-error"
" who_0"
"(if(pair? required-keywords_0)"
"                 (string-append \"argument mismatch;\\n\" \" the given procedure expects keyword arguments\")"
"(string-append"
"                  \"argument mismatch;\\n\""
"                  \" the given procedure's expected number of arguments does not match\""
"                  \" the given number of lists\"))"
"               \"given procedure\""
"(unquoted-printing-string"
"(let-values(((or-part_0)"
"(let-values(((n_0)(object-name f_0)))(if(symbol? n_0)(symbol->string n_0) #f))))"
"                  (if or-part_0 or-part_0 \"#<procedure>\")))"
"(append"
"(let-values(((a_0)(procedure-arity f_0)))"
"(if(pair? required-keywords_0)"
"(let-values() null)"
"(if(integer? a_0)"
"                      (let-values () (list \"expected\" a_0))"
"(if(arity-at-least? a_0)"
"(let-values()"
"(list"
"                           \"expected\""
"(unquoted-printing-string"
"                            (string-append \"at least \" (number->string (arity-at-least-value a_0))))))"
"(let-values() null)))))"
"                (if (pair? required-keywords_0) (let-values () null) (let-values () (list \"given\" (length ls_0))))"
"(if(pair? required-keywords_0)"
"(let-values()"
"(list"
"                     \"required keywords\""
"(unquoted-printing-string"
"(apply"
" string-append"
"(cdr"
"((letrec-values(((loop_0)"
"(lambda(kws_0)"
"(begin"
" 'loop"
"(if(null? kws_0)"
"(let-values() null)"
"(let-values()"
"(list*"
"                                                   \" \""
"                                                   (string-append \"#:\" (keyword->string (car kws_0)))"
"(loop_0(cdr kws_0)))))))))"
" loop_0)"
" required-keywords_0))))))"
"(let-values() null))"
"(let-values(((w_0)(quotient(error-print-width)(length ls_0))))"
"(if(> w_0 10)"
"(list"
"                     \"argument lists...\""
"(unquoted-printing-string"
"(apply"
" string-append"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null? ls_1)"
"(let-values() null)"
"(let-values()"
"(cons"
"                                                  (string-append \"\\n   \" ((error-value->string-handler) (car ls_1) w_0))"
"(loop_0(cdr ls_1)))))))))"
" loop_0)"
" ls_0))))"
" null)))))))))))"
"(define-values"
"(gen-map)"
"(lambda(f_0 ls_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference)) #t(check-args 'map f_0 ls_0))"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null?(car ls_1))"
"(let-values() null)"
"(let-values()"
"(let-values(((next-ls_0)(map2 cdr ls_1)))"
"(cons(apply f_0(map2 car ls_1))(loop_0 next-ls_0)))))))))"
" loop_0)"
" ls_0)))))"
"(define-values"
"(gen-for-each)"
"(lambda(f_0 ls_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference)) #t(check-args 'for-each f_0 ls_0))"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null?(car ls_1))"
"(void)"
"(let-values()"
"(let-values(((next-ls_0)(map2 cdr ls_1)))"
"(begin(apply f_0(map2 car ls_1))(loop_0 next-ls_0)))))))))"
" loop_0)"
" ls_0)))))"
"(define-values"
"(gen-andmap)"
"(lambda(f_0 ls_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference)) #t(check-args 'andmap f_0 ls_0))"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null?(car ls_1))"
"(let-values() #t)"
"(if(null?(cdar ls_1))"
"(let-values()(apply f_0(map2 car ls_1)))"
"(let-values()"
"(let-values(((next-ls_0)(map2 cdr ls_1)))"
"(if(apply f_0(map2 car ls_1))(loop_0 next-ls_0) #f)))))))))"
" loop_0)"
" ls_0)))))"
"(define-values"
"(gen-ormap)"
"(lambda(f_0 ls_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference)) #t(check-args 'ormap f_0 ls_0))"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null?(car ls_1))"
"(let-values() #f)"
"(if(null?(cdar ls_1))"
"(let-values()(apply f_0(map2 car ls_1)))"
"(let-values()"
"(let-values(((next-ls_0)(map2 cdr ls_1)))"
"(let-values(((or-part_0)(apply f_0(map2 car ls_1))))"
"(if or-part_0 or-part_0(loop_0 next-ls_0)))))))))))"
" loop_0)"
" ls_0)))))"
"(define-values"
"(hash-keys)"
"(let-values(((hash-keys_0)"
"(lambda(h_0 try-order?_0)"
"(begin"
" 'hash-keys"
"(if try-order?_0"
"(hash-map h_0(lambda(k_0 v_0) k_0) #t)"
"((letrec-values(((loop_0)"
"(lambda(pos_0)"
"(begin"
" 'loop"
"(if pos_0"
"(let-values(((k_0)(hash-iterate-key h_0 pos_0 unsafe-undefined))"
"((r_0)(loop_0(hash-iterate-next h_0 pos_0))))"
"(if(eq? k_0 unsafe-undefined) r_0(cons k_0 r_0)))"
" null)))))"
" loop_0)"
"(hash-iterate-first h_0)))))))"
"(let-values(((hash-keys_1)"
"(case-lambda"
"((h_0)"
"(begin"
" 'hash-keys"
"(begin"
"                        (if (hash? h_0) (void) (let-values () (raise-argument-error 'hash-keys \"hash?\" 0 h_0)))"
"(hash-keys_0 h_0 #f))))"
"((h_0 try-order?_0)"
"(begin"
"(if(hash? h_0)"
"(void)"
"                        (let-values () (raise-argument-error 'hash-keys \"hash?\" 0 h_0 try-order?_0)))"
"(hash-keys_0 h_0 try-order?_0))))))"
" hash-keys_1)))"
"(define-values"
"(hash-copy-clear.1)"
"(lambda(kind1_0 table3_0)"
"(begin"
" 'hash-copy-clear"
"(let-values(((table_0) table3_0))"
"(let-values(((kind_0) kind1_0))"
"(let-values()"
"(begin"
"              (if (hash? table_0) (void) (let-values () (raise-argument-error 'hash-copy-clear \"hash?\" table_0)))"
"(if(memq kind_0 '(#f immutable mutable weak ephemeron))"
"(void)"
"(let-values()"
"                  (raise-argument-error 'hash-copy-clear \"(or/c #f 'immutable 'mutable 'weak 'ephemeron)\" kind_0)))"
"(if(if kind_0(eq? 'immutable kind_0)(immutable? table_0))"
"(let-values()"
"(if(hash-equal? table_0)"
"(let-values()(hash))"
"(if(hash-equal-always? table_0)"
"(let-values()(hashalw))"
"(if(hash-eqv? table_0)"
"(let-values()(hasheqv))"
"(if(hash-eq? table_0)(let-values()(hasheq))(void))))))"
"(if(if kind_0(eq? 'weak kind_0)(hash-weak? table_0))"
"(let-values()"
"(if(hash-equal? table_0)"
"(let-values()(make-weak-hash))"
"(if(hash-equal-always? table_0)"
"(let-values()(make-weak-hashalw))"
"(if(hash-eqv? table_0)"
"(let-values()(make-weak-hasheqv))"
"(if(hash-eq? table_0)(let-values()(make-weak-hasheq))(void))))))"
"(if(if kind_0(eq? 'ephemeron kind_0)(hash-ephemeron? table_0))"
"(let-values()"
"(if(hash-equal? table_0)"
"(let-values()(make-ephemeron-hash))"
"(if(hash-equal-always? table_0)"
"(let-values()(make-ephemeron-hashalw))"
"(if(hash-eqv? table_0)"
"(let-values()(make-ephemeron-hasheqv))"
"(if(hash-eq? table_0)(let-values()(make-ephemeron-hasheq))(void))))))"
"(let-values()"
"(if(hash-equal? table_0)"
"(let-values()(make-hash))"
"(if(hash-equal-always? table_0)"
"(let-values()(make-hashalw))"
"(if(hash-eqv? table_0)"
"(let-values()(make-hasheqv))"
"(if(hash-eq? table_0)(let-values()(make-hasheq))(void))))))))))))))))"
"(define-values"
"(hash-map/copy.1)"
"(lambda(kind5_0 table7_0 f8_0)"
"(begin"
" 'hash-map/copy"
"(let-values(((table_0) table7_0))"
"(let-values(((f_0) f8_0))"
"(let-values(((kind_0) kind5_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(hash? table_0)"
"(void)"
"                                (let-values () (raise-argument-error 'hash-map/copy \"hash?\" table_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(if(procedure? f_0)(procedure-arity-includes? f_0 2) #f)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'hash-map/copy \"(procedure-arity-includes/c 2)\" f_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(memq kind_0 '(#f immutable mutable weak ephemeron))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'hash-map/copy"
"                                       \"(or/c #f 'immutable 'mutable 'weak 'ephemeron)\""
" kind_0)))"
"(values))))"
"(let-values(((acc_0)"
"(let-values(((table10_0) table_0)((kind11_0) kind_0))"
"(hash-copy-clear.1 kind11_0 table10_0))))"
"(if(immutable? acc_0)"
"(let-values()"
"(let-values(((acc_1)(let-values(((acc_1) acc_0)) acc_1)))"
"(let-values(((ht_0) table_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(acc_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k1_0 v1_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((acc_3)"
"(let-values(((acc_3)"
"(let-values()"
"(let-values(((k2_0 v2_0)"
"(f_0"
" k1_0"
" v1_0)))"
"(hash-set"
" acc_2"
" k2_0"
" v2_0)))))"
"(values acc_3))))"
"(if(not #f)"
"(for-loop_0 acc_3(hash-iterate-next ht_0 i_0))"
" acc_3)))"
" acc_2))))))"
" for-loop_0)"
" acc_1"
"(hash-iterate-first ht_0))))))"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_0) table_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k1_0 v1_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((k2_0 v2_0)"
"(f_0"
" k1_0"
" v1_0)))"
"(hash-set!"
" acc_0"
" k2_0"
" v2_0)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)"
" acc_0))))))))))))))"
"(define-values"
"(sort.1)"
"(lambda(cache-keys?2_0 key1_0 lst5_0 less?6_0)"
"(begin"
" 'sort"
"(let-values(((lst_0) lst5_0))"
"(let-values(((less?_0) less?6_0))"
"(let-values(((getkey_0) key1_0))"
"(let-values(((cache-keys?_0) cache-keys?2_0))"
"(let-values()"
"(begin"
"                  (if (list? lst_0) (void) (let-values () (raise-argument-error 'sort \"list?\" lst_0)))"
"(if(if(procedure? less?_0)(procedure-arity-includes? less?_0 2) #f)"
"(void)"
"                    (let-values () (raise-argument-error 'sort \"(any/c any/c . -> . any/c)\" less?_0)))"
"(if(if getkey_0(not(if(procedure? getkey_0)(procedure-arity-includes? getkey_0 1) #f)) #f)"
"                    (let-values () (raise-argument-error 'sort \"(any/c . -> . any/c)\" getkey_0))"
"(void))"
"(if getkey_0(sort lst_0 less?_0 getkey_0 cache-keys?_0)(sort lst_0 less?_0)))))))))))"
"(define-values"
"(filter)"
"(lambda(f_0 list_0)"
"(begin"
"(begin"
"(if(if(procedure? f_0)(procedure-arity-includes? f_0 1) #f)"
"(void)"
"          (let-values () (raise-argument-error 'filter \"(any/c . -> . any/c)\" f_0)))"
"        (if (list? list_0) (void) (let-values () (raise-argument-error 'filter \"list?\" list_0)))"
"((letrec-values(((loop_0)"
"(lambda(l_0 result_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
"(reverse$1 result_0)"
"(loop_0(cdr l_0)(if(f_0(car l_0))(cons(car l_0) result_0) result_0)))))))"
" loop_0)"
" list_0"
" null)))))"
" (define-values (binary-or-text-desc) \"(or/c 'binary 'text)\")"
"(define-values"
"(raise-argument-error$1)"
"(lambda(who_0 what_0 v_0)(begin 'raise-argument-error(raise-argument-error* who_0 'racket/primitive what_0 v_0))))"
"(define-values"
"(open-input-file.1)"
"(lambda(for-module?2_0 mode1_0 path5_0)"
"(begin"
" 'open-input-file"
"(let-values(((path_0) path5_0))"
"(let-values(((mode_0) mode1_0))"
"(let-values(((for-module?_0) for-module?2_0))"
"(let-values()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                  (let-values () (raise-argument-error$1 'open-input-file \"path-string?\" path_0)))"
"(if(memq mode_0 '(binary text))"
"(void)"
"(let-values()(raise-argument-error$1 'open-input-file binary-or-text-desc mode_0)))"
"(open-input-file path_0 mode_0(if for-module?_0 'module 'none))))))))))"
"(define-values"
"(with-input-from-file.1)"
"(lambda(mode43_0 path45_0 proc46_0)"
"(begin"
" 'with-input-from-file"
"(let-values(((path_0) path45_0))"
"(let-values(((proc_0) proc46_0))"
"(let-values(((mode_0) mode43_0))"
"(let-values()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                  (let-values () (raise-argument-error$1 'with-input-from-file \"path-string?\" path_0)))"
"(if(if(procedure? proc_0)(procedure-arity-includes? proc_0 0) #f)"
"(void)"
"                  (let-values () (raise-argument-error$1 'with-input-from-file \"(-> any)\" proc_0)))"
"(if(memq mode_0 '(binary text))"
"(void)"
"(let-values()(raise-argument-error$1 'with-input-from-file binary-or-text-desc mode_0)))"
"(with-input-from-file path_0 proc_0 mode_0)))))))))"
"(define-values"
"(call-with-input-file*.1)"
"(lambda(mode59_0 path61_0 proc62_0)"
"(begin"
" 'call-with-input-file*"
"(let-values(((path_0) path61_0))"
"(let-values(((proc_0) proc62_0))"
"(let-values(((mode_0) mode59_0))"
"(let-values()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                  (let-values () (raise-argument-error$1 'call-with-input-file* \"path-string?\" path_0)))"
"(if(if(procedure? proc_0)(procedure-arity-includes? proc_0 1) #f)"
"(void)"
"                  (let-values () (raise-argument-error$1 'call-with-input-file* \"(input-port? . -> . any)\" proc_0)))"
"(if(memq mode_0 '(binary text))"
"(void)"
"(let-values()(raise-argument-error$1 'call-with-input-file* binary-or-text-desc mode_0)))"
"(let-values(((p_0)(open-input-file path_0 mode_0)))"
"(dynamic-wind void(lambda()(proc_0 p_0))(lambda()(close-input-port p_0))))))))))))"
"(define-values"
"(print-value-columns)"
"(make-parameter"
" +inf.0"
"(lambda(c_0)"
"(if(let-values(((or-part_0)(eqv? c_0 +inf.0)))(if or-part_0 or-part_0(if(exact-integer? c_0)(> c_0 5) #f)))"
" c_0"
"       (raise-argument-error 'print-value-columns \"(or/c +inf.0 (and/c exact-integer? (>/c 5)))\" c_0)))"
" 'print-value-columns))"
"(define-values(the-empty-hash) '#hash())"
"(define-values(the-empty-hasheq) '#hasheq())"
"(define-values(the-empty-hasheqv) '#hasheqv())"
"(define-values"
"(set)"
"(case-lambda"
"(()(begin the-empty-hash))"
"(l_0"
"(let-values(((s_0)(let-values(((s_0) the-empty-hash)) s_0)))"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_2)"
"(let-values(((s_2)(let-values()(hash-set s_1 e_0 #t))))"
"(values s_2))))"
"(if(not #f)(for-loop_0 s_2 rest_0) s_2)))"
" s_1))))))"
" for-loop_0)"
" s_0"
" lst_0)))))))"
"(define-values"
"(seteq)"
"(case-lambda"
"(()(begin the-empty-hasheq))"
"(l_0"
"(let-values(((s_0)(let-values(((s_0) the-empty-hasheq)) s_0)))"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_2)"
"(let-values(((s_2)(let-values()(hash-set s_1 e_0 #t))))"
"(values s_2))))"
"(if(not #f)(for-loop_0 s_2 rest_0) s_2)))"
" s_1))))))"
" for-loop_0)"
" s_0"
" lst_0)))))))"
"(define-values(seteqv)(lambda()(begin the-empty-hasheqv)))"
"(define-values(set?)(lambda(s_0)(begin(hash? s_0))))"
"(define-values(set-empty?)(lambda(s_0)(begin(zero?(hash-count s_0)))))"
"(define-values(set-member?)(lambda(s_0 e_0)(begin(hash-ref s_0 e_0 #f))))"
"(define-values(set-count)(lambda(s_0)(begin(hash-count s_0))))"
"(define-values(set-add)(lambda(s_0 e_0)(begin(hash-set s_0 e_0 #t))))"
"(define-values(set-remove)(lambda(s_0 e_0)(begin(hash-remove s_0 e_0))))"
"(define-values(set-first)(lambda(s_0)(begin(hash-iterate-key s_0(hash-iterate-first s_0)))))"
"(define-values(subset?)(lambda(s1_0 s2_0)(begin(hash-keys-subset? s1_0 s2_0))))"
"(define-values"
"(set=?)"
"(lambda(s1_0 s2_0)"
"(begin"
"(let-values(((or-part_0)(eq? s1_0 s2_0)))"
"(if or-part_0 or-part_0(if(=(hash-count s1_0)(hash-count s2_0))(hash-keys-subset? s1_0 s2_0) #f))))))"
"(define-values"
"(set-subtract)"
"(lambda(s1_0 s2_0)"
"(begin"
"(let-values(((s1_1)(let-values(((s1_1) s1_0)) s1_1)))"
"(let-values(((ht_0) s2_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s1_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((s1_3)"
"(let-values(((s1_3)(let-values()(hash-remove s1_2 k_0))))"
"(values s1_3))))"
"(if(not #f)"
"(for-loop_0 s1_3(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" s1_3)))"
" s1_2))))))"
" for-loop_0)"
" s1_1"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(set-union)"
"(lambda(s1_0 s2_0)"
"(begin"
"(if(<(set-count s1_0)(set-count s2_0))"
"(set-union s2_0 s1_0)"
"(let-values(((s1_1)(let-values(((s1_1) s1_0)) s1_1)))"
"(let-values(((ht_0) s2_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s1_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((s1_3)"
"(let-values(((s1_3)(let-values()(hash-set s1_2 k_0 #t))))"
"(values s1_3))))"
"(if(not #f)"
"(for-loop_0 s1_3(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" s1_3)))"
" s1_2))))))"
" for-loop_0)"
" s1_1"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))"
"(define-values"
"(set-intersect)"
"(lambda(s1_0 s2_0)"
"(begin"
"(if(<(set-count s1_0)(set-count s2_0))"
"(set-intersect s2_0 s1_0)"
"(let-values(((s_0)(let-values(((s_0) s2_0)) s_0)))"
"(let-values(((ht_0) s2_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((s_2)"
"(let-values(((s_2)"
"(let-values()"
"(if(hash-ref s1_0 k_0 #f)"
" s_1"
"(hash-remove s_1 k_0)))))"
"(values s_2))))"
"(if(not #f)"
"(for-loop_0 s_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" s_2)))"
" s_1))))))"
" for-loop_0)"
" s_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))"
"(define-values"
"(set-partition)"
"(lambda(s_0 pred_0 empty-y-set_0 empty-n-set_0)"
"(begin"
"(let-values(((y_0)(let-values(((y_0) empty-y-set_0)) y_0))((n_0)(let-values(((n_0) empty-n-set_0)) n_0)))"
"(let-values(((ht_0) s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(y_1 n_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((v_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((y_2 n_2)"
"(let-values(((y_2 n_2)"
"(let-values()"
"(if(pred_0 v_0)"
"(values(set-add y_1 v_0) n_1)"
"(values y_1(set-add n_1 v_0))))))"
"(values y_2 n_2))))"
"(if(not #f)"
"(for-loop_0 y_2 n_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values y_2 n_2))))"
"(values y_1 n_1)))))))"
" for-loop_0)"
" y_0"
" n_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(set->list)"
"(lambda(s_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0) s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons(let-values() k_0) fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))"
"(define-values"
"(list->set)"
"(lambda(l_0)"
"(begin"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((k_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values(let-values() k_0) #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2 rest_0) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0)))))))"
"(define-values"
"(list->seteq)"
"(lambda(l_0)"
"(begin"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((k_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values(let-values() k_0) #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2 rest_0) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0)))))))"
"(define-values(start-atomic)(lambda()(begin(unsafe-start-atomic))))"
"(define-values(end-atomic)(lambda()(begin(unsafe-end-atomic))))"
"(define-values(start-breakable-atomic)(lambda()(begin(unsafe-start-breakable-atomic))))"
"(define-values(end-breakable-atomic)(lambda()(begin(unsafe-end-breakable-atomic))))"
"(define-values(cell.1$11)(unsafe-make-place-local #f))"
"(define-values"
"(entered-err-string-handler)"
"(lambda(s_0 n_0)(begin(call-as-nonatomic(lambda()((error-value->string-handler) s_0 n_0))))))"
"(define-values(cell.2$5)(unsafe-make-place-local #f))"
"(define-values(cell.3$2)(unsafe-make-place-local #f))"
"(define-values(cell.4$2)(unsafe-make-place-local 0))"
"(define-values(exited-key)(gensym 'as-exit))"
"(define-values(lock-tag)(make-continuation-prompt-tag 'lock))"
"(define-values"
"(call-as-atomic)"
"(lambda(f_0)"
"(begin"
"(begin"
"(if(if(procedure? f_0)(procedure-arity-includes? f_0 0) #f)"
"(void)"
"          (let-values () (raise-type-error 'call-as-atomic \"procedure (arity 0)\" f_0)))"
"(if(eq?(unsafe-place-local-ref cell.1$11)(current-thread))"
"(let-values()"
"(dynamic-wind"
"(lambda()"
"(begin"
"(start-breakable-atomic)"
"(unsafe-place-local-set! cell.4$2(add1(unsafe-place-local-ref cell.4$2)))))"
" f_0"
"(lambda()"
"(begin"
"(unsafe-place-local-set! cell.4$2(sub1(unsafe-place-local-ref cell.4$2)))"
"(end-breakable-atomic)))))"
"(let-values()"
"(with-continuation-mark"
" exited-key"
" #f"
"(call-with-continuation-prompt"
"(lambda()"
"(dynamic-wind"
"(lambda()(begin(start-breakable-atomic)(unsafe-place-local-set! cell.1$11(current-thread))))"
"(lambda()"
"(begin"
"(unsafe-place-local-set! cell.2$5(current-parameterization))"
"(unsafe-place-local-set! cell.3$2(current-break-parameterization))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" error-value->string-handler"
" entered-err-string-handler)"
"(let-values()"
"(with-continuation-mark"
" break-enabled-key"
"(make-thread-cell #f)"
"(begin"
"(check-for-break)"
"(let-values()"
"(call-with-exception-handler"
"(lambda(exn_0)"
"(if(continuation-mark-set-first #f exited-key)"
" exn_0"
"(abort-current-continuation lock-tag(lambda()(raise exn_0)))))"
" f_0))))))))"
"(lambda()"
"(begin"
"(unsafe-place-local-set! cell.1$11 #f)"
"(unsafe-place-local-set! cell.2$5 #f)"
"(unsafe-place-local-set! cell.3$2 #f)"
"(end-breakable-atomic)))))"
" lock-tag"
"(lambda(t_0)(t_0))))))))))"
"(define-values"
"(call-as-nonatomic)"
"(lambda(f_0)"
"(begin"
"(begin"
"(if(if(procedure? f_0)(procedure-arity-includes? f_0 0) #f)"
"(void)"
"          (let-values () (raise-type-error 'call-as-nonatomic \"procedure (arity 0)\" f_0)))"
"(if(eq?(unsafe-place-local-ref cell.1$11)(current-thread))"
"(void)"
"          (let-values () (error 'call-as-nonatomic \"not in atomic area for ~e\" f_0)))"
"(let-values(((paramz_0)(unsafe-place-local-ref cell.2$5))"
"((break-paramz_0)(unsafe-place-local-ref cell.3$2))"
"((extra-depth_0)(unsafe-place-local-ref cell.4$2)))"
"(with-continuation-mark"
" exited-key"
" #t"
"(call-with-parameterization"
" paramz_0"
"(lambda()"
"(call-with-break-parameterization"
" break-paramz_0"
"(lambda()"
"(dynamic-wind"
"(lambda()"
"(begin"
"(unsafe-place-local-set! cell.1$11 #f)"
"(unsafe-place-local-set! cell.4$2 0)"
"(end-breakable-atomic)"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(zero? i_0)"
"(void)"
"(let-values()(begin(end-breakable-atomic)(loop_0(sub1 i_0)))))))))"
" loop_0)"
" extra-depth_0)))"
" f_0"
"(lambda()"
"(begin"
"(start-breakable-atomic)"
"(unsafe-place-local-set! cell.2$5 paramz_0)"
"(unsafe-place-local-set! cell.3$2 break-paramz_0)"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(zero? i_0)"
"(void)"
"(let-values()(begin(start-breakable-atomic)(loop_0(sub1 i_0)))))))))"
" loop_0)"
" extra-depth_0)"
"(unsafe-place-local-set! cell.4$2 extra-depth_0)"
"(unsafe-place-local-set! cell.1$11(current-thread)))))))))))))))"
"(define-values"
"(check-fxvector)"
"(lambda(v_0)"
"(begin"
"(if(fxvector? v_0)"
"(void)"
"        (let-values () (1/raise-argument-error 'in-fxvector* (string-append \"fxvector\" \"?\") v_0))))))"
" (define-values (not-an-fX.1) (lambda (who_0 v_0) (begin 'not-an-fX (raise-argument-error who_0 \"fixnum?\" v_0))))"
"(define-values(prop:serialize serialize? serialize-ref)(make-struct-type-property 'serialize))"
"(define-values"
"(prop:serialize-fill! serialize-fill!? serialize-fill!-ref)"
"(make-struct-type-property 'serialize-fill!))"
"(define-values(prop:reach-scopes reach-scopes? reach-scopes-ref)(make-struct-type-property 'reach-scopes))"
"(define-values"
"(prop:scope-with-bindings scope-with-bindings? scope-with-bindings-ref)"
"(make-struct-type-property 'scope-with-bindings))"
"(define-values"
"(prop:binding-reach-scopes binding-reach-scopes? binding-reach-scopes-ref)"
"(make-struct-type-property 'binding-reach-scopes))"
"(define-values"
"(prop:binding-shift-report binding-shift-report? binding-shift-report-ref)"
"(make-struct-type-property 'binding-shift-report))"
"(define-values"
"(log-performance?)"
"  (if (environment-variables-ref (current-environment-variables) #\"PLT_EXPANDER_TIMES\") #t #f))"
"(define-values(cell.1$10)(unsafe-make-place-local #f))"
"(define-values(cell.2$4)(unsafe-make-place-local(make-hasheq)))"
"(define-values(performance-place-init!)(lambda()(begin(unsafe-place-local-set! cell.2$4(make-hasheq)))))"
"(define-values"
"(struct:region"
" region1.1"
" region?"
" region-path"
" region-start"
" region-start-gc"
" region-start-memory"
" region-as-nested"
" region-as-nested-gc"
" region-as-nested-memory"
" set-region-start!"
" set-region-start-gc!"
" set-region-start-memory!"
" set-region-as-nested!"
" set-region-as-nested-gc!"
" set-region-as-nested-memory!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'region #f 7 0 #f null(current-inspector) #f '(0) #f 'region)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'path)"
"(make-struct-field-accessor -ref_0 1 'start)"
"(make-struct-field-accessor -ref_0 2 'start-gc)"
"(make-struct-field-accessor -ref_0 3 'start-memory)"
"(make-struct-field-accessor -ref_0 4 'as-nested)"
"(make-struct-field-accessor -ref_0 5 'as-nested-gc)"
"(make-struct-field-accessor -ref_0 6 'as-nested-memory)"
"(make-struct-field-mutator -set!_0 1 'start)"
"(make-struct-field-mutator -set!_0 2 'start-gc)"
"(make-struct-field-mutator -set!_0 3 'start-memory)"
"(make-struct-field-mutator -set!_0 4 'as-nested)"
"(make-struct-field-mutator -set!_0 5 'as-nested-gc)"
"(make-struct-field-mutator -set!_0 6 'as-nested-memory))))"
"(define-values"
"(struct:stat"
" stat2.1"
" stat?"
" stat-msecs"
" stat-msecs-gc"
" stat-memory"
" stat-count"
" set-stat-msecs!"
" set-stat-msecs-gc!"
" set-stat-memory!"
" set-stat-count!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'stat #f 4 0 #f null(current-inspector) #f '() #f 'stat)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'msecs)"
"(make-struct-field-accessor -ref_0 1 'msecs-gc)"
"(make-struct-field-accessor -ref_0 2 'memory)"
"(make-struct-field-accessor -ref_0 3 'count)"
"(make-struct-field-mutator -set!_0 0 'msecs)"
"(make-struct-field-mutator -set!_0 1 'msecs-gc)"
"(make-struct-field-mutator -set!_0 2 'memory)"
"(make-struct-field-mutator -set!_0 3 'count))))"
"(define-values(stat-key)(gensym))"
"(define-values"
"(start-performance-region)"
"(lambda path_0"
"(begin"
"(unsafe-place-local-set!"
" cell.1$10"
"(cons"
"(region1.1"
"(if(unsafe-place-local-ref cell.1$10)"
"((letrec-values(((loop_0)"
"(lambda(path_1 enclosing-path_0)"
"(begin"
" 'loop"
"(if(null? path_1)"
" null"
"(cons"
"(if(if(eq? '_(car path_1))(pair? enclosing-path_0) #f)"
"(car enclosing-path_0)"
"(car path_1))"
"(loop_0"
"(cdr path_1)"
"(if(pair? enclosing-path_0)(cdr enclosing-path_0) null))))))))"
" loop_0)"
" path_0"
"(region-path(car(unsafe-place-local-ref cell.1$10))))"
" path_0)"
"(current-inexact-monotonic-milliseconds)"
"(current-gc-milliseconds)"
"(current-memory-use 'cumulative)"
" 0.0"
" 0"
" 0)"
"(unsafe-place-local-ref cell.1$10))))))"
"(define-values"
"(end-performance-region)"
"(lambda()"
"(begin"
"(let-values(((now_0)(current-inexact-monotonic-milliseconds)))"
"(let-values(((now-gc_0)(current-gc-milliseconds)))"
"(let-values(((now-memory_0)(current-memory-use 'cumulative)))"
"(let-values(((r_0)(car(unsafe-place-local-ref cell.1$10))))"
"(let-values((()"
"(begin"
"(unsafe-place-local-set! cell.1$10(cdr(unsafe-place-local-ref cell.1$10)))"
"(values))))"
"(let-values(((full-delta_0)(- now_0(region-start r_0))))"
"(let-values(((delta_0)(- full-delta_0(region-as-nested r_0))))"
"(let-values(((full-delta-gc_0)(- now-gc_0(region-start-gc r_0))))"
"(let-values(((delta-gc_0)(- full-delta-gc_0(region-as-nested-gc r_0))))"
"(let-values(((full-delta-memory_0)(- now-memory_0(region-start-memory r_0))))"
"(let-values(((delta-memory_0)(- full-delta-memory_0(region-as-nested-memory r_0))))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(accums_0 path_0)"
"(begin"
" 'loop"
"(let-values(((key_0)(car path_0)))"
"(let-values(((accum_0)"
"(let-values(((or-part_0)"
"(hash-ref accums_0 key_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((accum_0)(make-hasheq)))"
"(begin"
"(hash-set! accums_0 key_0 accum_0)"
" accum_0))))))"
"(let-values(((s_0)"
"(let-values(((or-part_0)"
"(hash-ref accum_0 stat-key #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((s_0)(stat2.1 0.0 0 0 0)))"
"(begin"
"(hash-set! accum_0 stat-key s_0)"
" s_0))))))"
"(begin"
"(set-stat-msecs! s_0(+ delta_0(stat-msecs s_0)))"
"(set-stat-msecs-gc! s_0(+ delta-gc_0(stat-msecs-gc s_0)))"
"(set-stat-memory! s_0(+ delta-memory_0(stat-memory s_0)))"
"(if(null?(cdr path_0))"
"(let-values()"
"(set-stat-count! s_0(add1(stat-count s_0))))"
"(void))"
"(if(null?(cdr path_0))"
"(void)"
"(let-values()(loop_0 accum_0(cdr path_0))))))))))))"
" loop_0)"
"(unsafe-place-local-ref cell.2$4)"
"(region-path r_0))"
"(if(unsafe-place-local-ref cell.1$10)"
"(let-values()"
"(begin"
"(set-region-as-nested!"
"(car(unsafe-place-local-ref cell.1$10))"
"(+(region-as-nested(car(unsafe-place-local-ref cell.1$10))) full-delta_0))"
"(set-region-as-nested-gc!"
"(car(unsafe-place-local-ref cell.1$10))"
"(+(region-as-nested-gc(car(unsafe-place-local-ref cell.1$10))) full-delta-gc_0))"
"(set-region-as-nested-memory!"
"(car(unsafe-place-local-ref cell.1$10))"
"(+"
"(region-as-nested-memory(car(unsafe-place-local-ref cell.1$10)))"
" full-delta-memory_0))))"
"(void)))))))))))))))))"
"(call-with-values"
"(lambda()"
"(if log-performance?"
"(let-values()"
"(void"
"(plumber-add-flush!"
"(current-plumber)"
"(lambda(h_0)"
"(let-values(((whole-len_0)"
"(lambda(s_0)"
"(begin"
" 'whole-len"
"(caar"
"                               (let-values (((or-part_0) (regexp-match-positions '#rx\"[.]\" s_0)))"
"(if or-part_0 or-part_0 '(0))))))))"
"(let-values(((kb_0)"
"(lambda(b_0)"
"(begin"
" 'kb"
"(let-values(((s_0)(number->string(quotient b_0 1024))))"
"(list->string"
"(let-values(((l_0)(let-values(((l_0) null)) l_0)))"
"(let-values(((lst_0)(reverse$1(string->list s_0)))((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(l_1 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((c_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values(((l_2)"
"(let-values(((l_2)"
"(let-values()"
"(if(if(positive?"
" i_0)"
"(zero?"
"(modulo"
" i_0"
" 3))"
" #f)"
"(let-values()"
"(list*"
" c_0"
" '#\\,"
" l_1))"
"(let-values()"
"(cons"
" c_0"
" l_1))))))"
"(values l_2))))"
"(if(not #f)"
"(for-loop_0 l_2 rest_0(+ pos_0 1))"
" l_2)))"
" l_1))))))"
" for-loop_0)"
" l_0"
" lst_0"
" start_0))))))))))"
"(let-values(((stat-msecs-nongc_0)"
"(lambda(v_0)(begin 'stat-msecs-nongc(-(stat-msecs v_0)(stat-msecs-gc v_0))))))"
"(let-values(((label-max-len_0 value-max-len_0 value-gc-max-len_0 memory-max-len_0 count-max-len_0)"
"((letrec-values(((loop_0)"
"(lambda(accums_0"
" label-len_0"
" value-len_0"
" value-gc-len_0"
" memory-len_0"
" count-len_0"
" indent_0)"
"(begin"
" 'loop"
"(let-values(((label-len_1)"
"(let-values(((label-len_1) label-len_0))"
" label-len_1))"
"((value-len_1)"
"(let-values(((value-len_1) value-len_0))"
" value-len_1))"
"((value-gc-len_1)"
"(let-values(((value-gc-len_1) value-gc-len_0))"
" value-gc-len_1))"
"((memory-len_1)"
"(let-values(((memory-len_1) memory-len_0))"
" memory-len_1))"
"((count-len_1)"
"(let-values(((count-len_1) count-len_0))"
" count-len_1)))"
"(let-values(((ht_0) accums_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(label-len_2"
" value-len_2"
" value-gc-len_2"
" memory-len_2"
" count-len_2"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((label-len_3"
" value-len_3"
" value-gc-len_3"
" memory-len_3"
" count-len_3)"
"(let-values(((label-len_3"
" value-len_3"
" value-gc-len_3"
" memory-len_3"
" count-len_3)"
"(let-values()"
"(if(eq?"
" k_0"
" stat-key)"
"(let-values()"
"(values"
" label-len_2"
"(max"
" value-len_2"
"(whole-len_0"
"(format"
"                                                                                                                              \"~a\""
"(stat-msecs-nongc_0"
" v_0))))"
"(max"
" value-gc-len_2"
"(string-length"
"(format"
"                                                                                                                              \"~a\""
"(stat-msecs-gc"
" v_0))))"
"(max"
" memory-len_2"
"(string-length"
"(format"
"                                                                                                                              \"~a\""
"(kb_0"
"(stat-memory"
" v_0)))))"
"(max"
" count-len_2"
"(string-length"
"(format"
"                                                                                                                              \"~a\""
"(stat-count"
" v_0))))))"
"(let-values()"
"(loop_0"
" v_0"
"(max"
" label-len_2"
"(+"
" indent_0"
"(string-length"
"(format"
"                                                                                                                               \"~a\""
" k_0))))"
" value-len_2"
" value-gc-len_2"
" memory-len_2"
" count-len_2"
"(+"
" 2"
" indent_0)))))))"
"(values"
" label-len_3"
" value-len_3"
" value-gc-len_3"
" memory-len_3"
" count-len_3))))"
"(if(not #f)"
"(for-loop_0"
" label-len_3"
" value-len_3"
" value-gc-len_3"
" memory-len_3"
" count-len_3"
"(hash-iterate-next"
" ht_0"
" i_0))"
"(values"
" label-len_3"
" value-len_3"
" value-gc-len_3"
" memory-len_3"
" count-len_3))))"
"(values"
" label-len_2"
" value-len_2"
" value-gc-len_2"
" memory-len_2"
" count-len_2)))))))"
" for-loop_0)"
" label-len_1"
" value-len_1"
" value-gc-len_1"
" memory-len_1"
" count-len_1"
"(hash-iterate-first ht_0)))))))))"
" loop_0)"
"(unsafe-place-local-ref cell.2$4)"
" 6"
" 5"
" 2"
" 4"
" 5"
" 2)))"
"(begin"
"(let-values(((l_0)(current-logger)))"
"(if(log-level? l_0 'error(logger-name l_0))"
"(let-values()"
"(log-message"
" l_0"
" 'error"
"(format"
"                              \"REGION      ~aMSECS  ~a+GC   ~aMEMK   ~aCOUNT\""
"(make-string(-(+ label-max-len_0 value-max-len_0) 11) '#\\space)"
"(make-string(- value-gc-max-len_0 2) '#\\space)"
"(make-string(- memory-max-len_0 4) '#\\space)"
"(make-string(- count-max-len_0 5) '#\\space))"
"(current-continuation-marks)))"
"(void)))"
"((letrec-values(((loop_0)"
"(lambda(name_0 accums_0 indent_0 newline?_0)"
"(begin"
" 'loop"
"(let-values((()"
"(begin"
"(if name_0"
"(let-values()"
"(let-values(((v_0)(hash-ref accums_0 stat-key)))"
"(let-values(((l_0)(current-logger)))"
"(if(log-level? l_0 'error(logger-name l_0))"
"(let-values()"
"(log-message"
" l_0"
" 'error"
"(format"
"                                                                          \"~a~a   ~a~a   ~a~a   ~a~a   ~a~a\""
" indent_0"
" name_0"
"(make-string"
"(+"
"(-"
" label-max-len_0"
"                                                                             (string-length (format \"~a\" name_0))"
"(string-length indent_0))"
"(-"
" value-max-len_0"
"(whole-len_0"
"                                                                              (format \"~a\" (stat-msecs-nongc_0 v_0)))))"
" '#\\space)"
"(regexp-replace"
"                                                                           '#rx\"[.](..).*\""
"                                                                           (format \"~a00\" (stat-msecs-nongc_0 v_0))"
"                                                                           \".\\\\1\")"
"(make-string"
"(-"
" value-gc-max-len_0"
"(string-length"
"                                                                             (format \"~a\" (stat-msecs-gc v_0))))"
" '#\\space)"
"                                                                          (format \"~a\" (stat-msecs-gc v_0))"
"(make-string"
"(-"
" memory-max-len_0"
"(string-length"
"                                                                             (format \"~a\" (kb_0 (stat-memory v_0)))))"
" '#\\space)"
"(kb_0(stat-memory v_0))"
"(make-string"
"(-"
" count-max-len_0"
"(string-length"
"                                                                             (format \"~a\" (stat-count v_0))))"
" '#\\space)"
"(stat-count v_0))"
"(current-continuation-marks)))"
"(void)))))"
"(void))"
"(values))))"
"(let-values(((keys_0)"
"(let-values(((temp5_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((ht_0) accums_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0)"
"(hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((fold-var_2)"
"(if(not"
"(eq?"
" k_0"
" stat-key))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" k_0)"
" fold-var_1))))"
"(values"
" fold-var_2))"
" fold-var_1)))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_0)))))))"
"((>6_0) >)"
"((temp7_0)"
"(lambda(key_0)"
"(stat-msecs-nongc_0"
"(hash-ref"
"(hash-ref accums_0 key_0)"
" stat-key)))))"
"(sort.1 #f temp7_0 temp5_0 >6_0))))"
"(begin"
"(let-values()"
"(let-values(((lst_0) keys_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((k_0)(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(if(if newline?_0"
"(positive?"
" i_0)"
" #f)"
"(let-values()"
"(let-values(((l_0)"
"(current-logger)))"
"(if(log-level?"
" l_0"
" 'error"
"(logger-name"
" l_0))"
"(let-values()"
"(log-message"
" l_0"
" 'error"
"                                                                                                                                 \"\""
"(current-continuation-marks)))"
"(void))))"
"(void))"
"(loop_0"
" k_0"
"(hash-ref"
" accums_0"
" k_0)"
"(string-append"
" indent_0"
"                                                                                                                        \"  \")"
" #f)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0 rest_0(+ pos_0 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0))))"
"(void))))))))"
" loop_0)"
" #f"
"(unsafe-place-local-ref cell.2$4)"
"                       \"\""
" #t))))))))))"
"(void)))"
" print-values)"
"(define-values"
"(1/module-path?)"
"(lambda(v_0)"
"(begin"
" 'module-path?"
"(let-values(((or-part_0)(if(pair? v_0)(if(eq?(car v_0) 'submod)(submodule-module-path? v_0) #f) #f)))"
"(if or-part_0 or-part_0(root-module-path? v_0))))))"
"(define-values"
"(root-module-path?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(path? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(string? v_0)(string-module-path? v_0) #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(if(symbol? v_0)(symbol-module-path? v_0) #f)))"
"(if or-part_2"
" or-part_2"
"(if(pair? v_0)"
"(let-values(((tmp_0)(car v_0)))"
"(if(equal? tmp_0 'quote)"
"(let-values()(if(pair?(cdr v_0))(if(symbol?(cadr v_0))(null?(cddr v_0)) #f) #f))"
"(if(equal? tmp_0 'lib)"
"(let-values()(lib-module-path? v_0))"
"(if(equal? tmp_0 'file)"
"(let-values()"
"(if(pair?(cdr v_0))"
"(if(string?(cadr v_0))(if(path-string?(cadr v_0))(null?(cddr v_0)) #f) #f)"
" #f))"
"(if(equal? tmp_0 'planet)(let-values()(planet-module-path? v_0))(let-values() #f))))))"
" #f))))))))))"
"(define-values"
"(submodule-module-path?)"
"(lambda(v_0)"
"(begin"
"(if(pair?(cdr v_0))"
"(if(list? v_0)"
"          (if (let-values (((or-part_0) (equal? (cadr v_0) \"..\")))"
"(if or-part_0"
" or-part_0"
"                  (let-values (((or-part_1) (equal? (cadr v_0) \".\")))"
"(if or-part_1 or-part_1(root-module-path?(cadr v_0))))))"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0)(cddr v_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((or-part_0)"
"                                                                                            (equal? e_0 \"..\")))"
"(if or-part_0"
" or-part_0"
"(symbol? e_0)))))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) e_0))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f)"
" #f)"
" #f))))"
"(define-values"
"(string-module-path?)"
"(lambda(v_0)"
"(begin"
"(let-values(((v11_0) v_0)((temp12_0) #t)((temp13_0) #t)((temp14_0) #t))"
"(module-path-string?.1 temp12_0 temp14_0 #f temp13_0 v11_0)))))"
"(define-values"
"(symbol-module-path?)"
"(lambda(v_0)(begin(let-values(((temp15_0)(symbol->string v_0)))(module-path-string?.1 #f #f #f #f temp15_0)))))"
"(define-values"
"(lib-module-path?)"
"(lambda(v_0)"
"(begin"
"(if(list? v_0)"
"(if(pair?(cdr v_0))"
"((letrec-values(((loop_0)"
"(lambda(v_1 first?_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(null? v_1)))"
"(if or-part_0"
" or-part_0"
"(if(string?(car v_1))"
"(if(let-values(((temp16_0)(car v_1))"
"((first?17_0) first?_0)"
"((first?18_0) first?_0))"
"(module-path-string?.1 #f first?18_0 #f first?17_0 temp16_0))"
"(loop_0(cdr v_1) #f)"
" #f)"
" #f)))))))"
" loop_0)"
"(cdr v_0)"
" #t)"
" #f)"
" #f))))"
"(define-values"
"(planet-module-path?)"
"(lambda(v_0)"
"(begin"
"(if(list? v_0)"
"(let-values(((tmp_0)(length v_0)))"
"(if(equal? tmp_0 1)"
"(let-values() #f)"
"(if(equal? tmp_0 2)"
"(let-values()"
"(let-values(((e_0)(cadr v_0)))"
"(if(string? e_0)"
"(let-values()"
"(let-values(((e19_0) e_0)((temp20_0) #t)((temp21_0) #t))"
"(module-path-string?.1 #f temp21_0 temp20_0 #f e19_0)))"
"(if(symbol? e_0)"
"(let-values()"
"(let-values(((temp22_0)(symbol->string e_0))((temp23_0) #t))"
"(module-path-string?.1 #f #f temp23_0 #f temp22_0)))"
"(let-values() #f)))))"
"(let-values()"
"(let-values(((file_0)(cadr v_0)))"
"(let-values(((pkg_0)(caddr v_0)))"
"(let-values(((subs_0)(cdddr v_0)))"
"(if file_0"
"(if(let-values(((file24_0) file_0)((temp25_0) #t)((temp26_0) #t))"
"(module-path-string?.1 #f temp26_0 #f temp25_0 file24_0))"
"(if(if(list? pkg_0)"
"(if(<= 2(length pkg_0) 4)"
"(if(planet-user/pkg-string?(car pkg_0))"
"(if(planet-user/pkg-string?(cadr pkg_0))"
"(let-values(((or-part_0)(null?(cddr pkg_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(planet-version-number?(caddr pkg_0))))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(null?(cddr pkg_0))))"
"(if or-part_2"
" or-part_2"
"(planet-version-minor-spec?(cadddr pkg_0))))))))"
" #f)"
" #f)"
" #f)"
" #f)"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0) subs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sub_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((sub27_0)"
" sub_0))"
"(module-path-string?.1"
" #f"
" #f"
" #f"
" #f"
" sub27_0))))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) sub_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f)"
" #f)"
" #f))))))))"
" #f))))"
"(define-values(planet-version-number?)(lambda(v_0)(begin(exact-nonnegative-integer? v_0))))"
"(define-values"
"(planet-version-minor-spec?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(planet-version-number? v_0)))"
"(if or-part_0"
" or-part_0"
"(if(pair? v_0)"
"(if(list? v_0)"
"(if(= 2(length v_0))"
"(let-values(((tmp_0)(car v_0)))"
"(if(if(equal? tmp_0 '=) #t(if(equal? tmp_0 '+) #t(equal? tmp_0 '-)))"
"(let-values()(planet-version-number?(cadr v_0)))"
"(let-values()(if(planet-version-number?(car v_0))(planet-version-number?(cadr v_0)) #f))))"
" #f)"
" #f)"
" #f))))))"
"(define-values"
"(module-path-string?.1)"
"(lambda(dots-dir-ok?2_0 file-end-ok?4_0 for-planet?1_0 just-file-ok?3_0 v9_0)"
"(begin"
" 'module-path-string?"
"(let-values(((v_0) v9_0))"
"(let-values(((for-planet?_0) for-planet?1_0))"
"(let-values(((dots-dir-ok?_0) dots-dir-ok?2_0))"
"(let-values(((just-file-ok?_0) just-file-ok?3_0))"
"(let-values(((file-end-ok?_0) file-end-ok?4_0))"
"(let-values()"
"(let-values(((len_0)(string-length v_0)))"
"(if(positive? len_0)"
"(if(not(char=? '#\\/(string-ref v_0 0)))"
"(if(not(char=? '#\\/(string-ref v_0(sub1 len_0))))"
"(let-values(((start-package-version-pos_0 end-package-version-pos_0)"
"(if for-planet?_0(check-planet-part v_0 len_0)(values 0 0))))"
"(if start-package-version-pos_0"
"((letrec-values(((loop_0)"
"(lambda(i_0 prev-was-slash?_0 saw-slash?_0 saw-dot?_0)"
"(begin"
" 'loop"
"(if(not(negative? i_0))"
"(let-values()"
"(let-values(((c_0)(string-ref v_0 i_0)))"
"(if(char=? c_0 '#\\/)"
"(let-values()"
"(if(not prev-was-slash?_0)"
"(loop_0(sub1 i_0) #t #t saw-dot?_0)"
" #f))"
"(if(char=? c_0 '#\\.)"
"(let-values()"
"(if(if dots-dir-ok?_0"
"(let-values(((post-c_0)"
"(if(<(add1 i_0) len_0)"
"(if(char=?"
"(string-ref v_0(add1 i_0))"
" '#\\/)"
"(let-values() 0)"
"(if(char=?"
"(string-ref v_0(add1 i_0))"
" '#\\.)"
"(let-values() 1)"
"(let-values() 2)))"
" 0))"
"((pre-c_0)"
"(if(> i_0 0)"
"(if(char=?"
"(string-ref v_0(sub1 i_0))"
" '#\\/)"
"(let-values() 0)"
"(if(char=?"
"(string-ref v_0(sub1 i_0))"
" '#\\.)"
"(let-values() 1)"
"(let-values() 2)))"
" 0)))"
"(<=(+ post-c_0 pre-c_0) 1))"
" #f)"
"(loop_0(sub1 i_0) #f saw-slash?_0 saw-dot?_0)"
"(if(not saw-slash?_0)"
"(loop_0(sub1 i_0) #f saw-slash?_0 #t)"
" #f)))"
"(if(let-values(((or-part_0)(plain-char? c_0)))"
"(if or-part_0"
" or-part_0"
"(if(char=? c_0 '#\\%)"
"(if(<(+ i_0 2) len_0)"
"(hex-sequence? v_0(add1 i_0))"
" #f)"
" #f)))"
"(let-values()"
"(loop_0(sub1 i_0) #f saw-slash?_0 saw-dot?_0))"
"(if(if(>= i_0 start-package-version-pos_0)"
"(< i_0 end-package-version-pos_0)"
" #f)"
"(let-values()"
"(loop_0(sub1 i_0) #f saw-slash?_0 saw-dot?_0))"
"(let-values() #f)))))))"
"(let-values()"
"(let-values(((or-part_0) just-file-ok?_0))"
"(if or-part_0"
" or-part_0"
"(not(if saw-dot?_0(not saw-slash?_0) #f))))))))))"
" loop_0)"
"(sub1 len_0)"
" #f"
"(not file-end-ok?_0)"
" #f)"
" #f))"
" #f)"
" #f)"
" #f)))))))))))"
"(define-values"
"(planet-user/pkg-string?)"
"(lambda(v_0)"
"(begin"
"(if(string? v_0)"
"(let-values(((len_0)(string-length v_0)))"
"(if(positive? len_0)"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-string vec_0)))"
"(values vec_0(unsafe-string-length vec_0)))))"
"((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0 pos_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(unsafe-fx< pos_0 len_1) #t #f)"
"(let-values(((c_0)(string-ref vec_0 pos_0))((i_0) pos_1))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((or-part_0)"
"(plain-char? c_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(char=? '#\\. c_0)))"
"(if or-part_1"
" or-part_1"
"(if(char=? '#\\% c_0)"
"(if(< i_0(- len_0 2))"
"(hex-sequence? v_0(add1 i_0))"
" #f)"
" #f)))))))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) c_0))"
"(if(not((lambda x_0(not result_2)) i_0))(not #f) #f)"
" #f)"
"(for-loop_0 result_2(unsafe-fx+ 1 pos_0)(+ pos_1 1))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" 0"
" start_0))))"
" #f))"
" #f))))"
"(define-values"
"(plain-char?)"
"(lambda(c_0)"
"(begin"
"(let-values(((or-part_0)(char<=? '#\\a c_0 '#\\z)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char<=? '#\\A c_0 '#\\Z)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(char<=? '#\\0 c_0 '#\\9)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(char=? '#\\- c_0)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(char=? '#\\_ c_0)))"
"(if or-part_4 or-part_4(char=? '#\\+ c_0))))))))))))))"
"(define-values"
"(hex-sequence?)"
"(lambda(s_0 i_0)"
"(begin"
"(let-values(((c1_0)(string-ref s_0 i_0)))"
"(let-values(((c2_0)(string-ref s_0(add1 i_0))))"
"(if(hex-char? c1_0)"
"(if(hex-char? c2_0)"
"(let-values(((c_0)(integer->char(+(*(hex-char->integer c1_0) 16)(hex-char->integer c2_0)))))"
"(not(plain-char? c_0)))"
" #f)"
" #f))))))"
"(define-values"
"(hex-char?)"
"(lambda(c_0)"
"(begin(let-values(((or-part_0)(char<=? '#\\a c_0 '#\\f)))(if or-part_0 or-part_0(char<=? '#\\0 c_0 '#\\9))))))"
"(define-values"
"(hex-char->integer)"
"(lambda(c_0)"
"(begin"
"(if(char<=? '#\\a c_0 '#\\f)"
"(let-values()(-(char->integer c_0)(+ 10(char->integer '#\\a))))"
"(if(char<=? '#\\A c_0 '#\\F)"
"(let-values()(-(char->integer c_0)(+ 10(char->integer '#\\A))))"
"(let-values()(-(char->integer c_0)(char->integer '#\\0))))))))"
"(define-values"
"(check-planet-part)"
"(lambda(v_0 len_0)"
"(begin"
"(let-values(((start-package-version-pos_0 end-package-version-pos_0 colon1-pos_0 colon2-pos_0)"
"((letrec-values(((loop_0)"
"(lambda(j_0"
" start-package-version-pos_0"
" end-package-version-pos_0"
" colon1-pos_0"
" colon2-pos_0)"
"(begin"
" 'loop"
"(if(= j_0 len_0)"
"(let-values()"
"(values"
" start-package-version-pos_0"
"(let-values(((or-part_0) end-package-version-pos_0))"
"(if or-part_0 or-part_0 j_0))"
" colon1-pos_0"
" colon2-pos_0))"
"(let-values()"
"(let-values(((tmp_0)(string-ref v_0 j_0)))"
"(if(equal? tmp_0 '#\\/)"
"(let-values()"
"(loop_0"
"(add1 j_0)"
"(let-values(((or-part_0) start-package-version-pos_0))"
"(if or-part_0 or-part_0(add1 j_0)))"
"(if start-package-version-pos_0"
"(let-values(((or-part_0) end-package-version-pos_0))"
"(if or-part_0 or-part_0 j_0))"
" #f)"
" colon1-pos_0"
" colon2-pos_0))"
"(if(equal? tmp_0 '#\\:)"
"(let-values()"
"(if colon2-pos_0"
"(let-values()(values #f #f #f #f))"
"(if colon1-pos_0"
"(let-values()"
"(loop_0"
"(add1 j_0)"
" start-package-version-pos_0"
" end-package-version-pos_0"
" colon1-pos_0"
" j_0))"
"(let-values()"
"(loop_0"
"(add1 j_0)"
" start-package-version-pos_0"
" end-package-version-pos_0"
" j_0"
" #f)))))"
"(let-values()"
"(loop_0"
"(add1 j_0)"
" start-package-version-pos_0"
" end-package-version-pos_0"
" colon1-pos_0"
" colon2-pos_0)))))))))))"
" loop_0)"
" 0"
" #f"
" #f"
" #f"
" #f)))"
"(if(if start-package-version-pos_0"
"(if(> end-package-version-pos_0 start-package-version-pos_0)"
"(let-values(((or-part_0)(not colon2-pos_0)))"
"(if or-part_0 or-part_0(<(add1 colon2-pos_0) end-package-version-pos_0)))"
" #f)"
" #f)"
"(let-values()"
"(if colon1-pos_0"
"(let-values()"
"(let-values(((colon1-end_0)"
"(let-values(((or-part_0) colon2-pos_0))"
"(if or-part_0 or-part_0 end-package-version-pos_0))))"
"(if(if(integer-sequence? v_0(add1 colon1-pos_0) colon1-end_0)"
"(let-values(((or-part_0)(not colon2-pos_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((tmp_0)(string-ref v_0(add1 colon2-pos_0))))"
"(if(equal? tmp_0 '#\\=)"
"(let-values()(integer-sequence? v_0(+ 2 colon2-pos_0) end-package-version-pos_0))"
"(if(if(equal? tmp_0 '#\\>) #t(equal? tmp_0 '#\\<))"
"(let-values()"
"(if(if(<(+ 2 colon2-pos_0) end-package-version-pos_0)"
"(char=? '#\\=(string-ref v_0(+ colon2-pos_0 2)))"
" #f)"
"(let-values()"
"(integer-sequence? v_0(+ 3 colon2-pos_0) end-package-version-pos_0))"
"(let-values()"
"(integer-sequence? v_0(+ 2 colon2-pos_0) end-package-version-pos_0))))"
"(let-values()"
"(integer-range-sequence? v_0(add1 colon2-pos_0) end-package-version-pos_0)))))))"
" #f)"
"(let-values()(values colon1-pos_0 end-package-version-pos_0))"
"(let-values()(values #f #f)))))"
"(let-values()(values 0 0))))"
"(let-values()(values #f #f)))))))"
"(define-values"
"(integer-sequence?)"
"(lambda(s_0 start_0 end_0)"
"(begin"
"(if(< start_0 end_0)"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((start_1) start_0)((end_1) end_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_1 end_1 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_1)"
"(let-values(((i_0) pos_0))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(char<=? '#\\0(string-ref s_0 i_0) '#\\9)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) i_0))(not #f) #f)"
"(for-loop_0 result_2(+ pos_0 inc_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" start_1))))"
" #f))))"
"(define-values"
"(integer-range-sequence?)"
"(lambda(s_0 start_0 end_0)"
"(begin"
"(if(< start_0 end_0)"
"(if(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((start_1) start_0)((end_1) end_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_1 end_1 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_1)"
"(let-values(((i_0) pos_0))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((c_0)(string-ref s_0 i_0)))"
"(let-values(((or-part_0)"
"(char=? c_0 '#\\-)))"
"(if or-part_0"
" or-part_0"
"(char<=? '#\\0 c_0 '#\\9))))))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) i_0))(not #f) #f)"
"(for-loop_0 result_2(+ pos_0 inc_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" start_1))))"
"(>="
" 1"
"(let-values(((result_0)(let-values(((result_0) 0)) result_0)))"
"(let-values(((start_1) start_0)((end_1) end_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_1 end_1 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_1)"
"(let-values(((i_0) pos_0))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(+"
" result_1"
"(let-values()"
"(if(char=?(string-ref s_0 i_0) '#\\-)"
" 1"
" 0))))))"
"(values result_2))))"
"(if(not #f)(for-loop_0 result_2(+ pos_0 inc_0)) result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" start_1)))))"
" #f)"
" #f))))"
"(define-values"
"(struct:weak-intern-table weak-intern-table1.1 weak-intern-table? weak-intern-table-box)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'weak-intern-table"
" #f"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'weak-intern-table)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'box))))"
"(define-values"
"(struct:table table2.1 table? table-ht table-count table-prune-at)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'table"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'table)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'ht)"
"(make-struct-field-accessor -ref_0 1 'count)"
"(make-struct-field-accessor -ref_0 2 'prune-at))))"
"(define-values(make-weak-intern-table)(lambda()(begin(weak-intern-table1.1(box(table2.1(hasheqv) 0 128))))))"
"(define-values"
"(weak-intern!)"
"(lambda(tt_0 v_0)"
"(begin"
"(let-values(((b_0)(weak-intern-table-box tt_0)))"
"(let-values(((t_0)(unbox b_0)))"
"(let-values(((code_0)(equal-hash-code v_0)))"
"(let-values(((vals_0)(hash-ref(table-ht t_0) code_0 null)))"
"(let-values(((or-part_0)"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0) vals_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((b_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((bv_0)"
"(weak-box-value"
" b_1)))"
"(if(equal? bv_0 v_0)"
" bv_0"
" #f))))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) b_1))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))))"
"(if or-part_0"
" or-part_0"
"(let-values(((pruned-t_0)(if(=(table-count t_0)(table-prune-at t_0))(prune-table t_0) t_0)))"
"(let-values(((ht_0)(table-ht pruned-t_0)))"
"(let-values(((new-t_0)"
"(table2.1"
"(hash-set ht_0 code_0(cons(make-weak-box v_0)(hash-ref ht_0 code_0 null)))"
"(add1(table-count pruned-t_0))"
"(table-prune-at pruned-t_0))))"
"(let-values(((or-part_1)(if(box-cas! b_0 t_0 new-t_0) v_0 #f)))"
"(if or-part_1 or-part_1(weak-intern! tt_0 v_0)))))))))))))))"
"(define-values"
"(prune-table)"
"(lambda(t_0)"
"(begin"
"(let-values(((new-ht_0)"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0)(table-ht t_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 vals_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((id*_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0) vals_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((b_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(if(weak-box-value"
" b_0)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" b_0)"
" fold-var_1))))"
"(values"
" fold-var_2))"
" fold-var_1)))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_1)"
" fold-var_0"
" lst_0)))))))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2)"
"(begin"
" 'for-loop"
"(let-values(((new-vals_0)"
" id*_0))"
"(let-values(((table_3)"
"(if(pair?"
" new-vals_0)"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" k_0"
" new-vals_0))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values"
" table_3))"
" table_2)))"
" table_3))))))"
" for-loop_1)"
" table_1))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values(((count_0)"
"(let-values(((result_0)(let-values(((result_0) 0)) result_0)))"
"(let-values(((ht_0) new-ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 vals_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(+"
" result_1"
"(let-values()"
"(length vals_0))))))"
"(values result_2))))"
"(if(not #f)"
"(for-loop_0 result_2(hash-iterate-next ht_0 i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(hash-iterate-first ht_0)))))))"
"(table2.1 new-ht_0 count_0(max 128(* 2 count_0))))))))"
"(define-values"
"(struct:resolved-module-path resolved-module-path1.1 1/resolved-module-path? 1/resolved-module-path-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'resolved-module-path"
" #f"
" 1"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(r_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:resolved-module-path)"
"(ser-push!_0(1/resolved-module-path-name r_0)))))"
"(cons"
" prop:custom-write"
"(lambda(r_0 port_0 mode_0)"
"(begin"
"                           (if mode_0 (let-values () (write-string \"#<resolved-module-path:\" port_0)) (void))"
"                           (fprintf port_0 \"~a\" (format-resolved-module-path-name (1/resolved-module-path-name r_0)))"
"                           (if mode_0 (let-values () (write-string \">\" port_0)) (void)))))"
"(cons"
" prop:equal+hash"
"(list"
"(lambda(a_0 b_0 eql?_0)"
"(eql?_0(1/resolved-module-path-name a_0)(1/resolved-module-path-name b_0)))"
"(lambda(a_0 hash-code_0)(hash-code_0(1/resolved-module-path-name a_0)))"
"(lambda(a_0 hash-code_0)(hash-code_0(1/resolved-module-path-name a_0))))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'resolved-module-path)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'name))))"
"(define-values"
"(format-resolved-module-path-name)"
"(lambda(p_0)"
"(begin"
"(if(path? p_0)"
"        (let-values () (string-append \"\\\"\" (path->string p_0) \"\\\"\"))"
"(if(symbol? p_0)"
"(let-values()(format-symbol p_0))"
"(let-values()(format-submod(format-resolved-module-path-name(car p_0))(cdr p_0))))))))"
"(define-values"
"(format-symbol)"
"  (lambda (p_0) (begin (format \"'~s~a\" p_0 (if (symbol-interned? p_0) \"\" (format \"[~a]\" (eq-hash-code p_0)))))))"
"(define-values"
"(format-submod)"
"(lambda(base_0 syms_0)"
"(begin"
"(format"
"       \"(submod ~a~a)\""
" base_0"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"                                                                          (let-values () (format \" ~s\" i_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))"
"(define-values"
"(safe-resolved-module-path-name)"
"(let-values(((resolved-module-path-name_0)"
"(lambda(v_0)"
"(begin"
" 'resolved-module-path-name"
"(begin"
"(if(1/resolved-module-path? v_0)"
"(void)"
"                        (let-values () (raise-argument-error 'resolved-module-path-name \"resolved-module-path?\" v_0)))"
"(1/resolved-module-path-name v_0))))))"
" resolved-module-path-name_0))"
"(define-values"
"(resolved-module-path-root-name)"
"(lambda(r_0)"
"(begin(let-values(((name_0)(1/resolved-module-path-name r_0)))(if(pair? name_0)(car name_0) name_0)))))"
"(define-values(resolved-module-paths)(make-weak-intern-table))"
"(define-values"
"(1/make-resolved-module-path)"
"(lambda(p_0)"
"(begin"
" 'make-resolved-module-path"
"(begin"
"(if(let-values(((or-part_0)(symbol? p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(path? p_0)(complete-path? p_0) #f)))"
"(if or-part_1"
" or-part_1"
"(if(pair? p_0)"
"(if(pair?(cdr p_0))"
"(if(list? p_0)"
"(if(let-values(((or-part_2)(symbol?(car p_0))))"
"(if or-part_2 or-part_2(if(path?(car p_0))(complete-path?(car p_0)) #f)))"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0)(cdr p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(symbol? s_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) s_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f)"
" #f)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-resolved-module-path"
"(string-append"
"              \"(or/c symbol?\\n\""
"              \"      (and/c path? complete-path?)\\n\""
"              \"      (cons/c (or/c symbol?\\n\""
"              \"                    (and/c path? complete-path?))\\n\""
"              \"              (non-empty-listof symbol?)))\")"
" p_0)))"
"(weak-intern! resolved-module-paths(resolved-module-path1.1 p_0))))))"
"(define-values"
"(resolved-module-path->module-path)"
"(lambda(r_0)"
"(begin"
"(let-values(((name_0)(1/resolved-module-path-name r_0)))"
"(let-values(((root-name_0)(if(pair? name_0)(car name_0) name_0)))"
"(let-values(((root-mod-path_0)(if(path? root-name_0) root-name_0(list 'quote root-name_0))))"
"(if(pair? name_0)(list* 'submod root-mod-path_0(cdr name_0)) root-mod-path_0)))))))"
"(define-values"
"(struct:module-path-index"
" module-path-index2.1"
" 1/module-path-index?"
" module-path-index-path"
" module-path-index-base"
" module-path-index-resolved"
" module-path-index-shift-cache"
" set-module-path-index-resolved!"
" set-module-path-index-shift-cache!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-path-index"
" #f"
" 4"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:custom-write"
"(lambda(r_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<module-path-index\" port_0)"
"(if(top-level-module-path-index? r_0)"
"                             (let-values () (fprintf port_0 \":top-level\"))"
"(if(module-path-index-path r_0)"
"(let-values()"
"(let-values(((l_0)"
"((letrec-values(((loop_0)"
"(lambda(r_1)"
"(begin"
" 'loop"
"(if(not r_1)"
"(let-values() null)"
"(if(1/resolved-module-path? r_1)"
"                                                                         (let-values () (list \"+\" (format \"~a\" r_1)))"
"(if(module-path-index-path r_1)"
"(let-values()"
"(cons"
"((letrec-values(((loop_1)"
"(lambda(v_0)"
"(begin"
" 'loop"
"(if(if(pair? v_0)"
"(if(eq?"
" 'quote"
"(car"
" v_0))"
"(null?"
"(cddr v_0))"
" #f)"
" #f)"
"(let-values()"
"(format-symbol"
"(cadr v_0)))"
"(if(if(pair?"
" v_0)"
"(eq?"
" 'submod"
"(car v_0))"
" #f)"
"(let-values()"
"(format-submod"
"(loop_1"
"(cadr v_0))"
"(cddr v_0)))"
"(let-values()"
"(format"
"                                                                                                           \"~.s\""
" v_0))))))))"
" loop_1)"
"(module-path-index-path r_1))"
"(loop_0(module-path-index-base r_1))))"
"(if(module-path-index-resolved r_1)"
"(let-values()"
"(list"
"                                                                                \"+\""
"(format"
"                                                                                 \"~a\""
"(module-path-index-resolved r_1))))"
"(let-values() null)))))))))"
" loop_0)"
" r_0)))"
"(fprintf"
" port_0"
"                                    \":~.a\""
"(apply"
" string-append"
"(car l_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(cdr l_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(format"
"                                                                                                          \" ~a\""
" i_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))"
"(if(module-path-index-resolved r_0)"
"                                 (let-values () (fprintf port_0 \"=~a\" (module-path-index-resolved r_0)))"
"(void))))"
"                           (write-string \">\" port_0))))"
"(cons"
" prop:equal+hash"
"(list"
"(lambda(a_0 b_0 eql?_0)"
"(if(eql?_0(module-path-index-path a_0)(module-path-index-path b_0))"
"(eql?_0(module-path-index-base a_0)(module-path-index-base b_0))"
" #f))"
"(lambda(a_0 hash-code_0)"
"(+(hash-code_0(module-path-index-path a_0))(hash-code_0(module-path-index-base a_0))))"
"(lambda(a_0 hash-code_0)"
"(+(hash-code_0(module-path-index-path a_0))(hash-code_0(module-path-index-base a_0)))))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'module-path-index)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'path)"
"(make-struct-field-accessor -ref_0 1 'base)"
"(make-struct-field-accessor -ref_0 2 'resolved)"
"(make-struct-field-accessor -ref_0 3 'shift-cache)"
"(make-struct-field-mutator -set!_0 2 'resolved)"
"(make-struct-field-mutator -set!_0 3 'shift-cache))))"
"(define-values(empty-shift-cache) '())"
"(define-values"
"(deserialize-module-path-index)"
"(case-lambda"
"((path_0 base_0)(begin(module-path-index-join* path_0 base_0)))"
"((name_0)(make-self-module-path-index(1/make-resolved-module-path name_0)))"
"(() top-level-module-path-index)))"
"(define-values"
"(1/module-path-index-resolve)"
"(let-values(((module-path-index-resolve_0)"
"(lambda(mpi5_0 load?3_0 stx4_0)"
"(begin"
" 'module-path-index-resolve"
"(let-values(((mpi_0) mpi5_0))"
"(let-values(((load?_0) load?3_0))"
"(let-values(((stx_0) stx4_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/module-path-index? mpi_0)"
"(void)"
"(let-values()"
"                                      (raise-argument-error 'module-path-index-resolve \"module-path-index?\" mpi_0)))"
"(let-values(((or-part_0)(module-path-index-resolved mpi_0)))"
"(if or-part_0"
" or-part_0"
"(if(module-path-index-path mpi_0)"
"(let-values()"
"(let-values(((mod-name_0)"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'eval 'resolver))"
"(void))"
"(begin0"
"(let-values()"
"((1/current-module-name-resolver)"
"(module-path-index-path mpi_0)"
"(module-path-index-resolve/maybe"
"(module-path-index-base mpi_0)"
" load?_0)"
" stx_0"
" load?_0))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(begin"
"(if(1/resolved-module-path? mod-name_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'module-path-index-resolve"
"                                                   \"current module name resolver's result is not a resolved module path\""
"                                                   \"result\""
" mod-name_0)))"
"(set-module-path-index-resolved! mpi_0 mod-name_0)"
" mod-name_0)))"
"(let-values()"
"(raise-arguments-error"
" 'module-path-index-resolve"
"                                           \"\\\"self\\\" index has no resolution\""
"                                           \"module path index\""
" mpi_0))))))))))))))))"
"(case-lambda"
"((mpi_0)(begin 'module-path-index-resolve(module-path-index-resolve_0 mpi_0 #f #f)))"
"((mpi_0 load?_0 stx4_0)(module-path-index-resolve_0 mpi_0 load?_0 stx4_0))"
"((mpi_0 load?3_0)(module-path-index-resolve_0 mpi_0 load?3_0 #f)))))"
"(define-values"
"(1/module-path-index-join)"
"(let-values(((module-path-index-join_0)"
"(lambda(mod-path7_0 base8_0 submod6_0)"
"(begin"
" 'module-path-index-join"
"(let-values(((mod-path_0) mod-path7_0))"
"(let-values(((base_0) base8_0))"
"(let-values(((submod_0) submod6_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(1/module-path? x_0))))"
" mod-path_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-path-index-join"
"                                       \"(or/c #f module-path?)\""
" mod-path_0)))"
"(if(let-values(((or-part_0)(not base_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/resolved-module-path? base_0)))"
"(if or-part_1 or-part_1(1/module-path-index? base_0)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-path-index-join"
"                                       \"(or/c #f resolved-module-path? module-path-index?)\""
" base_0)))"
"(if(let-values(((or-part_0)(not submod_0)))"
"(if or-part_0"
" or-part_0"
"(if(pair? submod_0)(if(list? submod_0)(andmap2 symbol? submod_0) #f) #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-path-index-join"
"                                       \"(or/c #f (non-empty-listof symbol?))\""
" submod_0)))"
"(if(if(not mod-path_0) base_0 #f)"
"(let-values()"
"(raise-arguments-error"
" 'module-path-index-join"
"                                       \"cannot combine #f path with non-#f base\""
"                                       \"given base\""
" base_0))"
"(void))"
"(if(if submod_0 mod-path_0 #f)"
"(let-values()"
"(raise-arguments-error"
" 'module-path-index-join"
"                                       \"cannot combine #f submodule list with non-#f module path\""
"                                       \"given module path\""
" mod-path_0"
"                                       \"given submodule list\""
" submod_0))"
"(void))"
"(if submod_0"
"(let-values()"
"(make-self-module-path-index"
"(1/make-resolved-module-path(cons generic-module-name submod_0))))"
"(let-values()(module-path-index-join* mod-path_0 base_0))))))))))))))"
"(case-lambda"
"((mod-path_0 base_0)(begin 'module-path-index-join(module-path-index-join_0 mod-path_0 base_0 #f)))"
"((mod-path_0 base_0 submod6_0)(module-path-index-join_0 mod-path_0 base_0 submod6_0)))))"
"(define-values"
"(module-path-index-join*)"
"(lambda(mod-path_0 base_0)"
"(begin"
"(let-values(((keep-base_0)"
"((letrec-values(((loop_0)"
"(lambda(mod-path_1)"
"(begin"
" 'loop"
"(if(path? mod-path_1)"
"(let-values() #f)"
"(if(if(pair? mod-path_1)(eq? 'quote(car mod-path_1)) #f)"
"(let-values() #f)"
"(if(symbol? mod-path_1)"
"(let-values() #f)"
"(if(if(pair? mod-path_1)(eq? 'lib(car mod-path_1)) #f)"
"(let-values() #f)"
"(if(if(pair? mod-path_1)(eq? 'submod(car mod-path_1)) #f)"
"(let-values()(loop_0(cadr mod-path_1)))"
"(let-values() base_0))))))))))"
" loop_0)"
" mod-path_0)))"
"(module-path-index2.1 mod-path_0 keep-base_0 #f empty-shift-cache)))))"
"(define-values"
"(module-path-index-resolve/maybe)"
"(lambda(base_0 load?_0)"
"(begin(if(1/module-path-index? base_0)(1/module-path-index-resolve base_0 load?_0) base_0))))"
"(define-values"
"(1/module-path-index-split)"
"(lambda(mpi_0)"
"(begin"
" 'module-path-index-split"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/module-path-index? mpi_0)"
"(void)"
"              (let-values () (raise-argument-error 'module-path-index-split \"module-path-index?\" mpi_0)))"
"(values(module-path-index-path mpi_0)(module-path-index-base mpi_0))))))))"
"(define-values"
"(1/module-path-index-submodule)"
"(lambda(mpi_0)"
"(begin"
" 'module-path-index-submodule"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/module-path-index? mpi_0)"
"(void)"
"              (let-values () (raise-argument-error 'module-path-index-submodule \"module-path-index?\" mpi_0)))"
"(if(not(module-path-index-path mpi_0))"
"(let-values(((r_0)(module-path-index-resolved mpi_0)))"
"(if r_0(let-values(((p_0)(1/resolved-module-path-name r_0)))(if(pair? p_0)(cdr p_0) #f)) #f))"
" #f)))))))"
"(define-values"
"(make-self-module-path-index)"
"(case-lambda"
"((name_0)(begin(module-path-index2.1 #f #f name_0 empty-shift-cache)))"
"((name_0 enclosing_0)"
"(make-self-module-path-index"
"(let-values(((name20_0) name_0)((temp21_0)(if enclosing_0(1/module-path-index-resolve enclosing_0) #f)))"
"(build-module-name.1 unsafe-undefined name20_0 temp21_0))))))"
"(define-values(cell.1$9)(unsafe-make-place-local(make-weak-hash)))"
"(define-values(generic-module-name) '|expanded module|)"
"(define-values(module-path-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$9(make-weak-hash)))))"
"(define-values"
"(make-generic-self-module-path-index)"
"(lambda(self_0)"
"(begin"
"(let-values(((r_0)(resolved-module-path-to-generic-resolved-module-path(module-path-index-resolved self_0))))"
"(begin"
"(start-atomic)"
"(begin0"
"(let-values(((or-part_0)"
"(let-values(((e_0)(hash-ref(unsafe-place-local-ref cell.1$9) r_0 #f)))"
"(if e_0(ephemeron-value e_0) #f))))"
"(if or-part_0"
" or-part_0"
"(let-values(((mpi_0)(module-path-index2.1 #f #f r_0 empty-shift-cache)))"
"(begin(hash-set!(unsafe-place-local-ref cell.1$9) r_0(make-ephemeron r_0 mpi_0)) mpi_0))))"
"(end-atomic)))))))"
"(define-values"
"(resolved-module-path-to-generic-resolved-module-path)"
"(lambda(r_0)"
"(begin"
"(let-values(((name_0)(1/resolved-module-path-name r_0)))"
"(1/make-resolved-module-path"
"(if(symbol? name_0) generic-module-name(cons generic-module-name(cdr name_0))))))))"
"(define-values"
"(imitate-generic-module-path-index!)"
"(lambda(mpi_0)"
"(begin"
"(let-values(((r_0)(module-path-index-resolved mpi_0)))"
"(if r_0"
"(let-values()"
"(set-module-path-index-resolved! mpi_0(resolved-module-path-to-generic-resolved-module-path r_0)))"
"(void))))))"
"(define-values"
"(module-path-index-shift*)"
"(lambda(mpi_0 from-mpi_0 to-mpi_0 freshen-cache_0)"
"(begin"
"(if(eq? mpi_0 from-mpi_0)"
"(let-values() to-mpi_0)"
"(let-values()"
"(let-values(((base_0)(module-path-index-base mpi_0)))"
"(let-values(((result-mpi_0)"
"(if(not base_0)"
"(let-values() mpi_0)"
"(let-values()"
"(let-values(((shifted-base_0)"
"(module-path-index-shift* base_0 from-mpi_0 to-mpi_0 freshen-cache_0)))"
"(if(eq? shifted-base_0 base_0)"
"(let-values() mpi_0)"
"(let-values(((c1_0)"
"(shift-cache-ref(module-path-index-shift-cache shifted-base_0) mpi_0)))"
"(if c1_0"
" c1_0"
"(let-values()"
"(let-values(((shifted-mpi_0)"
"(module-path-index-join*"
"(module-path-index-path mpi_0)"
" shifted-base_0)))"
"(begin"
"(shift-cache-set! shifted-base_0 shifted-mpi_0)"
" shifted-mpi_0)))))))))))"
"(begin"
"(if(if freshen-cache_0(not(hash-ref freshen-cache_0 result-mpi_0 #f)) #f)"
"(let-values()"
"(let-values(((result-base_0)(module-path-index-base result-mpi_0)))"
"(let-values(((fresh-base_0)(hash-ref freshen-cache_0 result-base_0 #f)))"
"(let-values(((fresh-mpi_0)"
"(module-path-index2.1"
"(module-path-index-path result-mpi_0)"
"(let-values(((or-part_0) fresh-base_0))(if or-part_0 or-part_0 result-base_0))"
" #f"
" empty-shift-cache)))"
"(begin"
"(if fresh-base_0(let-values()(shift-cache-set! fresh-base_0 fresh-mpi_0))(void))"
"(hash-set! freshen-cache_0 result-mpi_0 fresh-mpi_0))))))"
"(void))"
" result-mpi_0))))))))"
"(define-values"
"(module-path-index-shift)"
"(lambda(mpi_0 from-mpi_0 to-mpi_0)(begin(module-path-index-shift* mpi_0 from-mpi_0 to-mpi_0 #f))))"
"(define-values"
"(module-path-index-shift/resolved)"
"(lambda(mpi_0 from-mpi_0 to-mpi_0 freshen-cache_0 rp_0)"
"(begin"
"(let-values(((new-mpi_0)(module-path-index-shift* mpi_0 from-mpi_0 to-mpi_0 freshen-cache_0)))"
"(let-values(((fresh-mpi_0)(hash-ref freshen-cache_0 new-mpi_0)))"
"(begin"
"(if rp_0"
"(let-values()"
"(if(module-path-index-resolved fresh-mpi_0)"
"(void)"
"(let-values()(set-module-path-index-resolved! fresh-mpi_0 rp_0))))"
"(void))"
" fresh-mpi_0))))))"
"(define-values"
"(shift-cache-ref)"
"(lambda(cache_0 mpi_0)"
"(begin"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0) cache_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((wb_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((v_0)(weak-box-value wb_0)))"
"(if v_0"
"(if(equal?"
"(module-path-index-path v_0)"
"(module-path-index-path mpi_0))"
" v_0"
" #f)"
" #f))))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) wb_0))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0)))))))"
"(define-values"
"(shift-cache-set!)"
"(lambda(base_0 v_0)"
"(begin"
"(let-values(((new-cache_0)"
"(cons"
"(make-weak-box v_0)"
"((letrec-values(((loop_0)"
"(lambda(n_0 l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
"(let-values() null)"
"(if(eqv? n_0 0)"
"(let-values() null)"
"(if(not(weak-box-value(car l_0)))"
"(let-values()(loop_0 n_0(cdr l_0)))"
"(let-values()"
"(let-values(((r_0)(loop_0(fx- n_0 1)(cdr l_0))))"
"(if(eq? r_0(cdr l_0)) l_0(cons(car l_0) r_0)))))))))))"
" loop_0)"
" 32"
"(module-path-index-shift-cache base_0)))))"
"(set-module-path-index-shift-cache! base_0 new-cache_0)))))"
"(define-values(top-level-module-path-index)(make-self-module-path-index(1/make-resolved-module-path 'top-level)))"
"(define-values(top-level-module-path-index?)(lambda(mpi_0)(begin(eq? top-level-module-path-index mpi_0))))"
"(define-values(non-self-module-path-index?)(lambda(mpi_0)(begin(if(module-path-index-path mpi_0) #t #f))))"
"(define-values"
"(non-self-derived-module-path-index?)"
"(lambda(mpi_0)"
"(begin"
"(if(non-self-module-path-index? mpi_0)"
"(let-values(((base_0)(module-path-index-base mpi_0)))"
"(let-values(((or-part_0)(not base_0)))"
"(if or-part_0 or-part_0(non-self-derived-module-path-index? base_0))))"
" #f))))"
"(define-values"
"(inside-module-context?)"
"(lambda(mpi_0 inside-mpi_0)"
"(begin"
"(let-values(((or-part_0)(eq? mpi_0 inside-mpi_0)))"
"(if or-part_0"
" or-part_0"
"(if(1/module-path-index? mpi_0)"
"(if(1/module-path-index? inside-mpi_0)"
"(if(module-path-index-resolved mpi_0)"
"(eq?(module-path-index-resolved mpi_0)(module-path-index-resolved inside-mpi_0))"
" #f)"
" #f)"
" #f))))))"
"(define-values"
"(core-module-name-resolver)"
"(case-lambda"
"((name_0 from-namespace_0)(begin(void)))"
"((p_0 enclosing_0 source-stx-stx_0 load?_0)"
"(begin"
"(if(1/module-path? p_0)"
"(void)"
"        (let-values () (raise-argument-error 'core-module-name-resolver \"module-path?\" p_0)))"
"(if(let-values(((or-part_0)(not enclosing_0)))(if or-part_0 or-part_0(1/resolved-module-path? enclosing_0)))"
"(void)"
"        (let-values () (raise-argument-error 'core-module-name-resolver \"resolved-module-path?\" enclosing_0)))"
"(if(if(list? p_0)(if(=(length p_0) 2)(if(eq? 'quote(car p_0))(symbol?(cadr p_0)) #f) #f) #f)"
"(let-values()(1/make-resolved-module-path(cadr p_0)))"
"        (if (if (list? p_0) (if (eq? 'submod (car p_0)) (equal? \"..\" (cadr p_0)) #f) #f)"
"(let-values()"
"(let-values(((enclosing_1)(let-values(((enclosing_1) enclosing_0)) enclosing_1)))"
"(let-values(((lst_0)(cdr p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(enclosing_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((enclosing_3)"
"(let-values(((enclosing_3)"
"(let-values()"
"(let-values(((s22_0) s_0)"
"((enclosing23_0) enclosing_2)"
"((p24_0) p_0))"
"(build-module-name.1"
" p24_0"
" s22_0"
" enclosing23_0)))))"
"(values enclosing_3))))"
"(if(not #f)(for-loop_0 enclosing_3 rest_0) enclosing_3)))"
" enclosing_2))))))"
" for-loop_0)"
" enclosing_1"
" lst_0)))))"
"          (if (if (list? p_0) (if (eq? 'submod (car p_0)) (equal? \".\" (cadr p_0)) #f) #f)"
"(let-values()"
"(let-values(((enclosing_1)(let-values(((enclosing_1) enclosing_0)) enclosing_1)))"
"(let-values(((lst_0)(cddr p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(enclosing_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((enclosing_3)"
"(let-values(((enclosing_3)"
"(let-values()"
"(let-values(((s25_0) s_0)"
"((enclosing26_0) enclosing_2)"
"((p27_0) p_0))"
"(build-module-name.1"
" p27_0"
" s25_0"
" enclosing26_0)))))"
"(values enclosing_3))))"
"(if(not #f)(for-loop_0 enclosing_3 rest_0) enclosing_3)))"
" enclosing_2))))))"
" for-loop_0)"
" enclosing_1"
" lst_0)))))"
"(if(if(list? p_0)(eq? 'submod(car p_0)) #f)"
"(let-values()"
"(let-values(((base_0)((1/current-module-name-resolver)(cadr p_0) enclosing_0 #f #f)))"
"(let-values(((enclosing_1)(let-values(((enclosing_1) base_0)) enclosing_1)))"
"(let-values(((lst_0)(cddr p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(enclosing_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((enclosing_3)"
"(let-values(((enclosing_3)"
"(let-values()"
"(let-values(((s28_0) s_0)"
"((enclosing29_0)"
" enclosing_2)"
"((p30_0) p_0))"
"(build-module-name.1"
" p30_0"
" s28_0"
" enclosing29_0)))))"
"(values enclosing_3))))"
"(if(not #f)(for-loop_0 enclosing_3 rest_0) enclosing_3)))"
" enclosing_2))))))"
" for-loop_0)"
" enclosing_1"
" lst_0))))))"
"              (let-values () (error 'core-module-name-resolver \"not a supported module path: ~v\" p_0))))))))))"
"(define-values"
"(build-module-name.1)"
"(lambda(original9_0 name11_0 enclosing12_0)"
"(begin"
" 'build-module-name"
"(let-values(((name_0) name11_0))"
"(let-values(((enclosing_0) enclosing12_0))"
"(let-values(((orig-name_0)(if(eq? original9_0 unsafe-undefined) name_0 original9_0)))"
"(let-values()"
"(let-values(((enclosing-module-name_0)(if enclosing_0(1/resolved-module-path-name enclosing_0) #f)))"
"(1/make-resolved-module-path"
"                 (if (equal? name_0 \"..\")"
"(let-values()"
"(if(not(pair? enclosing-module-name_0))"
"                       (let-values () (error \"too many \\\"..\\\"s:\" orig-name_0))"
"(if(= 2(length enclosing-module-name_0))"
"(let-values()(car enclosing-module-name_0))"
"(let-values()(reverse$1(cdr(reverse$1 enclosing-module-name_0)))))))"
"(if(not enclosing-module-name_0)"
"(let-values() name_0)"
"(if(pair? enclosing-module-name_0)"
"(let-values()(append enclosing-module-name_0(list name_0)))"
"(let-values()(list enclosing-module-name_0 name_0))))))))))))))"
"(define-values"
"(1/current-module-name-resolver)"
"(make-parameter"
" core-module-name-resolver"
"(lambda(v_0)"
"(begin"
"(if(if(procedure? v_0)(if(procedure-arity-includes? v_0 2)(procedure-arity-includes? v_0 4) #f) #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'current-module-name-resolver"
"            \"(and/c (procedure-arity-includes/c 2) (procedure-arity-includes/c 4))\""
" v_0)))"
" v_0))"
" 'current-module-name-resolver))"
"(define-values"
"(1/current-module-declare-name)"
"(make-parameter"
" #f"
"(lambda(r_0)"
"(begin"
"(if(let-values(((or-part_0)(not r_0)))(if or-part_0 or-part_0(1/resolved-module-path? r_0)))"
"(void)"
"         (let-values () (raise-argument-error 'current-module-declare-name \"(or/c #f resolved-module-path?)\" r_0)))"
" r_0))"
" 'current-module-declare-name))"
"(define-values"
"(1/current-module-declare-source)"
"(make-parameter"
" #f"
"(lambda(s_0)"
"(begin"
"(if(let-values(((or-part_0)(not s_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? s_0)))"
"(if or-part_1 or-part_1(if(path? s_0)(complete-path? s_0) #f)))))"
"(void)"
"(let-values()"
"           (raise-argument-error 'current-module-declare-source \"(or/c #f symbol? (and/c path? complete-path?))\" s_0)))"
" s_0))"
" 'current-module-declare-source))"
"(define-values"
"(substitute-module-declare-name)"
"(lambda(default-name_0)"
"(begin"
"(let-values(((current-name_0)(1/current-module-declare-name)))"
"(let-values(((root-name_0)"
"(if current-name_0"
"(resolved-module-path-root-name current-name_0)"
"(if(pair? default-name_0)(car default-name_0) default-name_0))))"
"(1/make-resolved-module-path"
"(if(pair? default-name_0)(cons root-name_0(cdr default-name_0)) root-name_0)))))))"
"(define-values"
"(struct:promise promise1.1 promise? promise-val promise-status set-promise-val! set-promise-status!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'promise"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'promise)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'val)"
"(make-struct-field-accessor -ref_0 1 'status)"
"(make-struct-field-mutator -set!_0 0 'val)"
"(make-struct-field-mutator -set!_0 1 'status))))"
"(define-values"
"(force)"
"(lambda(v_0)"
"(begin"
"(if(promise? v_0)"
"(let-values()"
"(let-values(((s_0)(promise-status v_0)))"
"(if(not s_0)"
"(let-values()"
"(let-values(((result_0)((promise-val v_0))))"
"(begin(set-promise-val! v_0 result_0)(set-promise-status! v_0 #t) result_0)))"
"(let-values()(promise-val v_0)))))"
"(let-values() v_0)))))"
"(define-values"
"(phase?)"
"(lambda(v_0)(begin(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(exact-integer? v_0))))))"
"(define-values(interned-symbol?)(lambda(v_0)(begin(if(symbol? v_0)(symbol-interned? v_0) #f))))"
"(define-values"
"(space?)"
"(lambda(v_0)(begin(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(interned-symbol? v_0))))))"
"(define-values"
"(phase+space?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(phase? v_0)))"
"(if or-part_0 or-part_0(if(pair? v_0)(if(interned-symbol?(cdr v_0))(phase?(car v_0)) #f) #f))))))"
"(define-values"
"(phase+space-shift?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(phase? v_0)))"
"(if or-part_0"
" or-part_0"
"(if(pair? v_0)"
"(if(let-values(((or-part_1)(not(cdr v_0))))(if or-part_1 or-part_1(interned-symbol?(cdr v_0))))"
"(phase?(car v_0))"
" #f)"
" #f))))))"
"(define-values"
"(phase+space-phase)"
"(lambda(p+s_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"          (if (phase+space? p+s_0) (void) (raise-argument-error 'phase+space-phase \"phase+space?\" p+s_0)))"
"(if(pair? p+s_0)(car p+s_0) p+s_0)))))"
"(define-values"
"(phase+space-space)"
"(lambda(p+s_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"          (if (phase+space? p+s_0) (void) (raise-argument-error 'phase+space-space \"phase+space?\" p+s_0)))"
"(if(pair? p+s_0)(cdr p+s_0) #f)))))"
"(define-values"
"(phase+space+$1)"
"(lambda(p+s_0 s_0)"
"(begin"
" 'phase+space+"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(begin"
"            (if (phase+space? p+s_0) (void) (raise-argument-error 'phase+space+ \"phase+space?\" p+s_0))"
"            (if (phase+space-shift? s_0) (void) (raise-argument-error 'phase+space+ \"phase+space-shift?\" s_0))))"
"(let-values(((p1_0)(if(pair? p+s_0)(car p+s_0) p+s_0))"
"((p2_0)(if(pair? s_0)(car s_0) s_0))"
"((sp1_0)(if(pair? p+s_0)(cdr p+s_0) #f)))"
"(let-values(((p_0)(if p1_0(if p2_0(+ p1_0 p2_0) #f) #f))((sp_0)(if(pair? s_0)(cdr s_0) sp1_0)))"
"(if sp_0(cons p_0 sp_0) p_0)))))))"
"(define-values(phase+)(lambda(a_0 b_0)(begin(if a_0(if b_0(+ a_0 b_0) #f) #f))))"
"(define-values(phase-)(lambda(a_0 b_0)(begin(if a_0(if b_0(- a_0 b_0) #f) #f))))"
"(define-values"
"(phase<?)"
"(lambda(a_0 b_0)"
"(begin(if(not b_0)(let-values() #f)(if(not a_0)(let-values() #t)(let-values()(< a_0 b_0)))))))"
"(define-values(zero-phase?)(lambda(a_0)(begin(eq? a_0 0))))"
"(define-values(label-phase?)(lambda(a_0)(begin(not a_0))))"
" (define-values (phase?-string) \"phase?\")"
"(define-values(make-small-hasheq)(lambda()(begin(box '#hasheq()))))"
"(define-values(make-small-hasheqv)(lambda()(begin(box '#hasheqv()))))"
"(define-values"
"(small-hash-ref)"
"(lambda(small-ht_0 key_0 default_0)(begin(hash-ref(unbox small-ht_0) key_0 default_0))))"
"(define-values"
"(small-hash-set!)"
"(lambda(small-ht_0 key_0 val_0)(begin(set-box! small-ht_0(hash-set(unbox small-ht_0) key_0 val_0)))))"
"(define-values(small-hash-keys)(lambda(small-ht_0)(begin(hash-keys(unbox small-ht_0)))))"
"(define-values"
"(struct:serialize-state"
" serialize-state1.1"
" serialize-state?"
" serialize-state-reachable-scopes"
" serialize-state-implicitly-reachable-scopes"
" serialize-state-bindings-intern"
" serialize-state-bulk-bindings-intern"
" serialize-state-scopes"
" serialize-state-shifted-multi-scopes"
" serialize-state-multi-scope-tables"
" serialize-state-mpi-shifts"
" serialize-state-drop-shifts?"
" serialize-state-context-triples"
" serialize-state-props"
" serialize-state-interned-props"
" serialize-state-syntax-context"
" serialize-state-sharing-syntaxes"
" serialize-state-preserve-prop-keys"
" serialize-state-keep-provides?"
" serialize-state-map-binding-symbol)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'serialize-state"
" #f"
" 17"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)"
" #f"
" 'serialize-state)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'reachable-scopes)"
"(make-struct-field-accessor -ref_0 1 'implicitly-reachable-scopes)"
"(make-struct-field-accessor -ref_0 2 'bindings-intern)"
"(make-struct-field-accessor -ref_0 3 'bulk-bindings-intern)"
"(make-struct-field-accessor -ref_0 4 'scopes)"
"(make-struct-field-accessor -ref_0 5 'shifted-multi-scopes)"
"(make-struct-field-accessor -ref_0 6 'multi-scope-tables)"
"(make-struct-field-accessor -ref_0 7 'mpi-shifts)"
"(make-struct-field-accessor -ref_0 8 'drop-shifts?)"
"(make-struct-field-accessor -ref_0 9 'context-triples)"
"(make-struct-field-accessor -ref_0 10 'props)"
"(make-struct-field-accessor -ref_0 11 'interned-props)"
"(make-struct-field-accessor -ref_0 12 'syntax-context)"
"(make-struct-field-accessor -ref_0 13 'sharing-syntaxes)"
"(make-struct-field-accessor -ref_0 14 'preserve-prop-keys)"
"(make-struct-field-accessor -ref_0 15 'keep-provides?)"
"(make-struct-field-accessor -ref_0 16 'map-binding-symbol))))"
"(define-values"
"(make-serialize-state)"
"(lambda(reachable-scopes_0"
" implicitly-reachable-scopes_0"
" preserve-prop-keys_0"
" keep-provides?_0"
" drop-shifts?_0"
" map-binding-symbol_0)"
"(begin"
"(let-values(((state_0)"
"(serialize-state1.1"
" reachable-scopes_0"
" implicitly-reachable-scopes_0"
"(make-hasheq)"
"(make-hasheq)"
"(make-hash)"
"(make-hash)"
"(make-hasheq)"
"(make-hasheq)"
" drop-shifts?_0"
"(make-hasheq)"
"(make-hasheq)"
"(make-hash)"
"(box null)"
"(make-hasheq)"
" preserve-prop-keys_0"
" keep-provides?_0"
" map-binding-symbol_0)))"
"(let-values(((empty-seteq_0)(seteq)))"
"(begin"
"(hash-set!(serialize-state-scopes state_0) empty-seteq_0 empty-seteq_0)"
"(hash-set!(serialize-state-shifted-multi-scopes state_0) empty-seteq_0 empty-seteq_0)"
"(hash-set!(serialize-state-interned-props state_0) empty-seteq_0 empty-seteq_0)"
" state_0))))))"
"(define-values"
"(intern-scopes)"
"(lambda(scs_0 state_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(serialize-state-scopes state_0) scs_0 #f)))"
"(if or-part_0 or-part_0(begin(hash-set!(serialize-state-scopes state_0) scs_0 scs_0) scs_0))))))"
"(define-values"
"(intern-shifted-multi-scopes)"
"(lambda(sms_0 state_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(serialize-state-shifted-multi-scopes state_0) sms_0 #f)))"
"(if or-part_0"
" or-part_0"
"(begin(hash-set!(serialize-state-shifted-multi-scopes state_0) sms_0 sms_0) sms_0))))))"
"(define-values"
"(intern-mpi-shifts)"
"(lambda(mpi-shifts_0 state_0)"
"(begin"
"(if(null? mpi-shifts_0)"
"(let-values() null)"
"(let-values()"
"(let-values(((tail_0)(intern-mpi-shifts(cdr mpi-shifts_0) state_0)))"
"(let-values(((tail-table_0)"
"(let-values(((or-part_0)(hash-ref(serialize-state-mpi-shifts state_0) tail_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))"
"(begin(hash-set!(serialize-state-mpi-shifts state_0) tail_0 ht_0) ht_0))))))"
"(let-values(((or-part_0)(hash-ref tail-table_0(car mpi-shifts_0) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((v_0)(cons(car mpi-shifts_0) tail_0)))"
"(begin(hash-set! tail-table_0(car mpi-shifts_0) v_0) v_0)))))))))))"
"(define-values"
"(intern-context-triple)"
"(lambda(scs_0 sms_0 mpi-shifts_0 state_0)"
"(begin"
"(let-values(((scs-ht_0)"
"(let-values(((or-part_0)(hash-ref(serialize-state-context-triples state_0) scs_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))"
"(begin(hash-set!(serialize-state-context-triples state_0) scs_0 ht_0) ht_0))))))"
"(let-values(((sms-ht_0)"
"(let-values(((or-part_0)(hash-ref scs-ht_0 sms_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))(begin(hash-set! scs-ht_0 sms_0 ht_0) ht_0))))))"
"(let-values(((or-part_0)(hash-ref sms-ht_0 mpi-shifts_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((vec_0)(vector-immutable scs_0 sms_0 mpi-shifts_0)))"
"(begin(hash-set! sms-ht_0 mpi-shifts_0 vec_0) vec_0)))))))))"
"(define-values"
"(intern-properties)"
"(lambda(all-props_0 get-preserved-props_0 state_0)"
"(begin"
"(let-values(((v_0)(hash-ref(serialize-state-props state_0) all-props_0 'no)))"
"(if(eq? v_0 'no)"
"(let-values()"
"(let-values(((preserved-props_0)(get-preserved-props_0)))"
"(let-values(((p_0)"
"(if(zero?(hash-count preserved-props_0))"
"(let-values() #f)"
"(let-values(((c1_0)"
"(hash-ref(serialize-state-interned-props state_0) preserved-props_0 #f)))"
"(if c1_0"
"((lambda(p_0) p_0) c1_0)"
"(let-values()"
"(begin"
"(hash-set!"
"(serialize-state-interned-props state_0)"
" preserved-props_0"
" preserved-props_0)"
" preserved-props_0)))))))"
"(begin(hash-set!(serialize-state-props state_0) all-props_0 p_0) p_0))))"
"(let-values() v_0))))))"
"(define-values"
"(push-syntax-context!)"
"(lambda(state_0 v_0)"
"(begin(let-values(((b_0)(serialize-state-syntax-context state_0)))(set-box! b_0(cons v_0(unbox b_0)))))))"
"(define-values"
"(get-syntax-context)"
"(lambda(state_0)"
"(begin"
"(let-values(((b_0)(serialize-state-syntax-context state_0)))(if(null?(unbox b_0)) #f(car(unbox b_0)))))))"
"(define-values"
"(pop-syntax-context!)"
"(lambda(state_0)"
"(begin(let-values(((b_0)(serialize-state-syntax-context state_0)))(set-box! b_0(cdr(unbox b_0)))))))"
"(define-values(root-tag)(unsafe-root-continuation-prompt-tag))"
"(define-values(default-val.1$2) #f)"
"(define-values"
"(current-module-code-inspector)"
"(lambda()(begin(continuation-mark-set-first #f current-module-code-inspector default-val.1$2 root-tag))))"
"(define-values"
"(immutable-prefab-struct-key)"
"(lambda(v_0)"
"(begin(let-values(((k_0)(prefab-struct-key v_0)))(if k_0(if(all-fields-immutable?$1 k_0) k_0 #f) #f)))))"
"(define-values"
"(prefab-key-all-fields-immutable?)"
"(lambda(k_0)"
"(begin"
"(begin"
"(if(prefab-key? k_0)"
"(void)"
"          (let-values () (raise-argument-error 'prefab-key-all-fields-immutable? \"prefab-key?\" k_0)))"
"(all-fields-immutable?$1 k_0)))))"
"(define-values"
"(all-fields-immutable?$1)"
"(lambda(k_0)"
"(begin"
" 'all-fields-immutable?"
"(let-values(((or-part_0)(symbol? k_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(null? k_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((rk_0)(cdr k_0)))"
"(let-values(((rk_1)(if(if(pair? rk_0)(exact-integer?(car rk_0)) #f)(cdr rk_0) rk_0)))"
"(let-values(((rk_2)"
"(if(if(pair? rk_1)(pair?(car rk_1)) #f)"
"(if(zero?(caar rk_1))(cdr rk_1)(cons '#(1)(cdr rk_1)))"
" rk_1)))"
"(if(if(pair? rk_2)(vector?(car rk_2)) #f)"
"(if(zero?(vector-length(car rk_2)))(all-fields-immutable?$1(cdr rk_2)) #f)"
"(all-fields-immutable?$1 rk_2))))))))))))"
"(define-values(all-fields-immutable?)(lambda(k_0)(begin(prefab-key-all-fields-immutable? k_0))))"
"(define-values"
"(datum-map-slow)"
"(lambda(tail?_0 s_0 f_0 seen_0 known-pairs_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(tail?_1 s_1 prev-seen_0)"
"(begin"
" 'loop"
"(let-values(((seen_1)"
"(if(if prev-seen_0(datum-has-elements? s_1) #f)"
"(let-values()"
"(if(hash-ref prev-seen_0 s_1 #f)"
"(let-values()((hash-ref prev-seen_0 'cycle-fail) s_1))"
"(let-values()(hash-set prev-seen_0 s_1 #t))))"
"(let-values() prev-seen_0))))"
"(if(null? s_1)"
"(let-values()(f_0 tail?_1 s_1))"
"(if(pair? s_1)"
"(let-values()"
"(if(if known-pairs_0(if tail?_1(hash-ref known-pairs_0 s_1 #f) #f) #f)"
"(let-values() s_1)"
"(let-values()"
"(f_0"
" tail?_1"
"(cons"
"(loop_0 #f(car s_1) seen_1)"
"(loop_0(if tail?_1(fx+ 1 tail?_1) 1)(cdr s_1) seen_1))))))"
"(if(let-values(((or-part_0)(symbol? s_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? s_1)))"
"(if or-part_1 or-part_1(number? s_1)))))"
"(let-values()(f_0 #f s_1))"
"(if(vector? s_1)"
"(let-values()"
"(f_0"
" #f"
"(vector->immutable-vector"
"(let-values(((len_0)(vector-length s_1)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(1/raise-argument-error"
" 'for/vector"
"                                                   \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) s_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_1)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values(((i_2)"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(loop_0"
" #f"
" e_0"
" seen_1)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values i_2))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_2"
" len_0))"
" e_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_2"
"(unsafe-fx+ 1 pos_0))"
" i_2)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" 0)))))"
" v_0)))))))"
"(if(box? s_1)"
"(let-values()(f_0 #f(box-immutable(loop_0 #f(unbox s_1) seen_1))))"
"(let-values(((c1_0)(immutable-prefab-struct-key s_1)))"
"(if c1_0"
"((lambda(key_0)"
"(f_0"
" #f"
"(apply"
" make-prefab-struct"
" key_0"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((v*_0 start*_0 stop*_0 step*_0)"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(unsafe-normalise-inputs"
" unsafe-vector-length"
"(struct->vector s_1)"
" 1"
" #f"
" 1)"
"(normalise-inputs"
" 'in-vector"
"                                                                     \"vector\""
"(lambda(x_0)(vector? x_0))"
"(lambda(x_0)(unsafe-vector-length x_0))"
"(struct->vector s_1)"
" 1"
" #f"
" 1))))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 idx_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< idx_0 stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0"
" #f"
" e_0"
" seen_1))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
"(unsafe-fx+ idx_0 1))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" start*_0)))))))"
" c1_0)"
"(if(if(hash? s_1)(immutable? s_1) #f)"
"(let-values()"
"(f_0"
" #f"
"(let-values(((s6_0) s_1)"
"((temp7_0)"
"(lambda(k_0 v_0)(values k_0(loop_0 #f v_0 seen_1))))"
"((temp8_0) 'immutable))"
"(hash-map/copy.1 temp8_0 s6_0 temp7_0))))"
"(let-values()(f_0 #f s_1)))))))))))))))"
" loop_0)"
" tail?_0"
" s_0"
" seen_0))))"
"(define-values"
"(datum-has-elements?)"
"(lambda(d_0)"
"(begin"
"(let-values(((or-part_0)(pair? d_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(vector? d_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(box? d_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(immutable-prefab-struct-key d_0)))"
"(if or-part_3"
" or-part_3"
"(if(hash? d_0)(if(immutable? d_0)(positive?(hash-count d_0)) #f) #f))))))))))))"
"(define-values"
"(struct:preserved-property-value"
" preserved-property-value1.1"
" preserved-property-value?"
" preserved-property-value-content)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'preserved-property-value"
" #f"
" 1"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'preserved-property-value)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'content))))"
"(define-values"
"(plain-property-value)"
"(lambda(v_0)(begin(if(preserved-property-value? v_0)(preserved-property-value-content v_0) v_0))))"
"(define-values"
"(check-value-to-preserve)"
"(lambda(v_0 syntax?_0)"
"(begin"
"(let-values(((check-preserve_0)"
"(lambda(tail?_0 v_1)"
"(begin"
" 'check-preserve"
"(begin"
"(if(let-values(((or-part_0)(null? v_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? v_1)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(symbol? v_1)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(number? v_1)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(char? v_1)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(string? v_1)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(bytes? v_1)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(regexp? v_1)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(syntax?_0 v_1)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(pair? v_1)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(vector? v_1)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(box? v_1)))"
"(if or-part_11"
" or-part_11"
"(let-values(((or-part_12)(hash? v_1)))"
"(if or-part_12"
" or-part_12"
"(immutable-prefab-struct-key"
" v_1)))))))))))))))))))))))))))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'write"
"                               \"disallowed value in preserved syntax property\""
"                               \"value\""
" v_1)))"
" v_1)))))"
"(let-values(((s_0) v_0)"
"((f_0) check-preserve_0)"
"((gf_0) check-preserve_0)"
"((seen_0) disallow-cycles$1)"
"((known-pairs_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_1 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_0(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_1"
"(lambda(tail?_1 s_2)(gf_0 tail?_1 s_2))"
" seen_0"
" known-pairs_0))"
"(if(null? s_1)"
"(let-values()(f_0 tail?_0 s_1))"
"(if(pair? s_1)"
"(let-values()"
"(f_0"
" tail?_0"
"(cons(loop_0 #f(car s_1) depth_0)(loop_0 1(cdr s_1) depth_0))))"
"(if(symbol? s_1)"
"(let-values()(f_0 #f s_1))"
"(if(boolean? s_1)"
"(let-values()(f_0 #f s_1))"
"(if(number? s_1)"
"(let-values()(f_0 #f s_1))"
"(if(let-values(((or-part_0)(vector? s_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_1)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(prefab-struct-key s_1)))"
"(if or-part_2 or-part_2(hash? s_1)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_1"
"(lambda(tail?_1 s_2)(gf_0 tail?_1 s_2))"
" seen_0"
" known-pairs_0))"
"(let-values()(gf_0 #f s_1))))))))))))))"
" loop_0)"
" #f"
" s_0"
" 0))))))"
"(define-values"
"(disallow-cycles$1)"
"(hash"
" 'cycle-fail"
"   (lambda (v_0) (raise-arguments-error 'write \"disallowed cycle in preserved syntax property\" \"at\" v_0))))"
"(define-values"
"(taint?)"
"(lambda(v_0)(begin(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(symbol? v_0))))))"
"(define-values"
"(tainted-for-content)"
"(lambda(v_0)(begin(if(datum-has-elements? v_0) 'tainted/need-propagate 'tainted))))"
"(define-values(taint-needs-propagate?)(lambda(t_0)(begin(eq? t_0 'tainted/need-propagate))))"
"(define-values(taint-propagated)(lambda(t_0)(begin(if(eq? t_0 'tainted/need-propagate) 'tainted t_0))))"
"(define-values"
"(struct:modified-content"
" modified-content1.1"
" modified-content?"
" modified-content-content"
" modified-content-scope-propagations+taint)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'modified-content"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'modified-content)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'content)"
"(make-struct-field-accessor -ref_0 1 'scope-propagations+taint))))"
"(define-values"
"(struct:syntax"
" syntax2.1"
" syntax?$1"
" syntax-content*"
" syntax-scopes"
" syntax-shifted-multi-scopes"
" syntax-mpi-shifts"
" syntax-srcloc$1"
" syntax-props"
" syntax-inspector"
" set-syntax-content*!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'syntax"
" #f"
" 7"
" 0"
" #f"
"(list"
"(cons prop:sealed #t)"
"(cons prop:authentic #t)"
"(cons"
" prop:reach-scopes"
"(lambda(s_0 bulk-shifts_0 reach_0)"
"(let-values(((content*_0)(syntax-content* s_0)))"
"(let-values((()"
"(begin"
"(reach_0"
"(if(modified-content? content*_0)"
"(let-values(((prop_0)"
"(modified-content-scope-propagations+taint content*_0)))"
"(if(propagation?$1 prop_0)"
"((propagation-ref prop_0) s_0)"
"(modified-content-content content*_0)))"
" content*_0)"
" bulk-shifts_0)"
"(values))))"
"(let-values(((shifts_0)"
"(if bulk-shifts_0(append bulk-shifts_0(syntax-mpi-shifts s_0)) #f)))"
"(begin"
"(reach_0(syntax-scopes s_0) shifts_0)"
"(reach_0(syntax-shifted-multi-scopes s_0) shifts_0)"
"(let-values()"
"(let-values(((ht_0)(syntax-props s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(if(preserved-property-value? v_0)"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(reach_0"
"(plain-property-value"
" v_0)"
" bulk-shifts_0))"
"(values)))))"
"(values))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
"(void)"
"(reach_0(syntax-srcloc$1 s_0) bulk-shifts_0)))))))"
"(cons"
" prop:serialize"
"(lambda(s_0 ser-push!_0 state_0)"
"(let-values(((content*_0)(syntax-content* s_0)))"
"(let-values(((content_0)"
"(if(modified-content? content*_0)"
"(let-values(((prop_0)"
"(modified-content-scope-propagations+taint content*_0)))"
"(if(propagation?$1 prop_0)"
"((propagation-ref prop_0) s_0)"
"(modified-content-content content*_0)))"
" content*_0)))"
"(let-values(((properties_0)"
"(intern-properties"
"(syntax-props s_0)"
"(lambda()"
"(let-values(((preserve-keys_0)"
"(serialize-state-preserve-prop-keys state_0)))"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0)(syntax-props s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(if(let-values(((or-part_0)"
"(preserved-property-value?"
" v_0)))"
"(if or-part_0"
" or-part_0"
"(hash-ref"
" preserve-keys_0"
" k_0"
" #f)))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" k_0"
"(check-value-to-preserve"
"(plain-property-value"
" v_0)"
" syntax?$1)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))"
" table_1)))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
" state_0)))"
"(let-values(((taint_0)(syntax-taintness s_0)))"
"(let-values(((context-triple_0)"
"(intern-context-triple"
"(intern-scopes(syntax-scopes s_0) state_0)"
"(intern-shifted-multi-scopes(syntax-shifted-multi-scopes s_0) state_0)"
"(if(serialize-state-drop-shifts? state_0)"
" null"
"(intern-mpi-shifts(syntax-mpi-shifts s_0) state_0))"
" state_0)))"
"(let-values(((stx-state_0)(get-syntax-context state_0)))"
"(if(let-values(((or-part_0) properties_0))(if or-part_0 or-part_0 taint_0))"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:syntax+props)"
"(push-syntax-context! state_0 #f)"
"(ser-push!_0 content_0)"
"(pop-syntax-context! state_0)"
"(ser-push!_0 'reference context-triple_0)"
"(ser-push!_0 'reference(syntax-srcloc$1 s_0))"
"(ser-push!_0 properties_0)"
"(ser-push!_0 taint_0)"
"(if stx-state_0"
"(let-values()(set-syntax-state-all-sharing?! stx-state_0 #f))"
"(void))))"
"(let-values()"
"(let-values(((sharing-mode_0)"
"(hash-ref"
"(serialize-state-sharing-syntaxes state_0)"
" s_0"
" 'unknown)))"
"(begin"
"(if(eq? sharing-mode_0 'share)"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:datum->syntax)"
"(ser-push!_0(syntax->datum$1 s_0))))"
"(if(eq? sharing-mode_0 'unknown)"
"(let-values()"
"(let-values((()(begin(ser-push!_0 'tag '#:syntax)(values))))"
"(let-values(((this-state_0)"
"(if(no-pair-syntax-in-cdr? content_0)"
"(syntax-state17.1"
" #t"
" context-triple_0"
"(syntax-srcloc$1 s_0))"
" #f)))"
"(let-values((()"
"(begin"
"(push-syntax-context! state_0 this-state_0)"
"(values))))"
"(let-values((()(begin(ser-push!_0 content_0)(values))))"
"(let-values((()"
"(begin"
"(pop-syntax-context! state_0)"
"(values))))"
"(let-values(((new-sharing-mode_0)"
"(if(if this-state_0"
"(syntax-state-all-sharing?"
" this-state_0)"
" #f)"
" 'share"
" 'none)))"
"(begin"
"(hash-set!"
"(serialize-state-sharing-syntaxes state_0)"
" s_0"
"(if(datum-has-elements? content_0)"
" new-sharing-mode_0"
" 'none))"
"(if(if stx-state_0(eq? new-sharing-mode_0 'none) #f)"
"(let-values()"
"(set-syntax-state-all-sharing?! stx-state_0 #f))"
"(void))))))))))"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:syntax)"
"(push-syntax-context! state_0 #f)"
"(ser-push!_0 content_0)"
"(pop-syntax-context! state_0)))))"
"(ser-push!_0 'reference context-triple_0)"
"(ser-push!_0 'reference(syntax-srcloc$1 s_0))"
"(if stx-state_0"
"(let-values()"
"(if(if(eq?"
" context-triple_0"
"(syntax-state-context-triple stx-state_0))"
"(equal?(syntax-srcloc$1 s_0)(syntax-state-srcloc stx-state_0))"
" #f)"
"(void)"
"(let-values()(set-syntax-state-all-sharing?! stx-state_0 #f))))"
"(void))))))))))))))"
"(cons"
" prop:custom-write"
"(lambda(s_0 port_0 mode_0)"
"                         (let-values ((() (begin (write-string \"#<syntax\" port_0) (values))))"
"(let-values(((srcloc_0)(syntax-srcloc$1 s_0)))"
"(let-values((()"
"(begin"
"(if srcloc_0"
"(let-values()"
"(let-values(((srcloc-str_0)(srcloc->string srcloc_0)))"
"(if srcloc-str_0"
"                                                     (let-values () (fprintf port_0 \":~a\" srcloc-str_0))"
"(void))))"
"(void))"
"(values))))"
"(let-values(((width_0)(print-syntax-width)))"
"(begin"
"(if(eqv? width_0 0)"
"(let-values()(void))"
"(if(eqv? width_0 +inf.0)"
"                                       (let-values () (fprintf port_0 \" ~s\" (syntax->datum$1 s_0)))"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" error-print-width"
" width_0)"
"                                          (let-values () (fprintf port_0 \" ~.s\" (syntax->datum$1 s_0)))))))"
"                                   (write-string \">\" port_0)))))))))"
"(current-inspector)"
" #f"
" '(1 2 3 4 5 6)"
" #f"
" 'syntax)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'content*)"
"(make-struct-field-accessor -ref_0 1 'scopes)"
"(make-struct-field-accessor -ref_0 2 'shifted-multi-scopes)"
"(make-struct-field-accessor -ref_0 3 'mpi-shifts)"
"(make-struct-field-accessor -ref_0 4 'srcloc)"
"(make-struct-field-accessor -ref_0 5 'props)"
"(make-struct-field-accessor -ref_0 6 'inspector)"
"(make-struct-field-mutator -set!_0 0 'content*))))"
"(define-values(prop:propagation propagation?$1 propagation-ref)(make-struct-type-property 'propagation))"
"(define-values"
"(prop:propagation-taint propagation-taint? propagation-taint-ref)"
"(make-struct-type-property 'propagation-taint))"
"(define-values"
"(prop:propagation-set-taint propagation-set-taint? propagation-set-taint-ref)"
"(make-struct-type-property 'propagation-set-taint))"
"(define-values"
"(syntax-content)"
"(lambda(s_0)"
"(begin"
"(let-values(((content*_0)(syntax-content* s_0)))"
"(if(modified-content? content*_0)(modified-content-content content*_0) content*_0)))))"
"(define-values"
"(syntax-taintness)"
"(lambda(s_0)"
"(begin"
"(let-values(((content*_0)(syntax-content* s_0)))"
"(if(modified-content? content*_0)"
"(let-values()"
"(let-values(((v_0)(modified-content-scope-propagations+taint content*_0)))"
"(if(taint? v_0) v_0((propagation-taint-ref v_0) v_0))))"
"(let-values() #f))))))"
"(define-values(syntax-content*-cas!)(lambda(stx_0 old_0 new_0)(begin(unsafe-struct*-cas! stx_0 0 old_0 new_0))))"
"(define-values"
"(re-modify-content)"
"(lambda(s_0 d_0)"
"(begin"
"(let-values(((content*_0)(syntax-content* s_0)))"
"(if(modified-content? content*_0)"
"(modified-content1.1 d_0(modified-content-scope-propagations+taint content*_0))"
" d_0)))))"
"(define-values(empty-scopes)(seteq))"
"(define-values(empty-shifted-multi-scopes)(seteq))"
"(define-values(empty-mpi-shifts) null)"
"(define-values(empty-props) '#hasheq())"
"(define-values"
"(empty-syntax)"
"(syntax2.1 #f empty-scopes empty-shifted-multi-scopes empty-mpi-shifts #f empty-props #f))"
"(define-values(identifier?)(lambda(s_0)(begin(if(syntax?$1 s_0)(symbol?(syntax-content s_0)) #f))))"
"(define-values(syntax-identifier?)(lambda(s_0)(begin(symbol?(syntax-content s_0)))))"
"(define-values"
"(syntax->datum$1)"
"(lambda(s_0)"
"(begin"
" 'syntax->datum"
"(let-values(((s_1) s_0)"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((d->s_0)(lambda(s_1 d_0)(begin 'd->s d_0)))"
"((s-e_0) syntax-content)"
"((seen_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(s_2)"
"(begin"
" 'loop"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(d->s_0 v_0(loop_0(s-e_0 v_0))))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0)"
"((known-pairs_0) #f))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1"
" known-pairs_0))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1 1(cdr s_4) depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)(vector? s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key s_4)))"
"(if or-part_2"
" or-part_2"
"(hash? s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1"
" known-pairs_0))"
"(let-values()(gf_0 #f s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0))))))"
" loop_0)"
" s_1)))))"
"(define-values(cell.1$8)(unsafe-make-place-local(make-weak-hasheq)))"
"(define-values"
"(immediate-datum->syntax)"
"(lambda(stx-c_0 content_0 stx-l_0 props_0 insp_0)"
"(begin"
"(syntax2.1"
"(if(if stx-c_0(syntax-taintness stx-c_0) #f)"
"(modified-content1.1 content_0(tainted-for-content content_0))"
" content_0)"
"(if stx-c_0(syntax-scopes stx-c_0) empty-scopes)"
"(if stx-c_0(syntax-shifted-multi-scopes stx-c_0) empty-shifted-multi-scopes)"
"(if stx-c_0(syntax-mpi-shifts stx-c_0) empty-mpi-shifts)"
"(if stx-l_0(syntax-srcloc$1 stx-l_0) #f)"
" props_0"
"(if insp_0"
"(if stx-c_0"
"(let-values(((a_0) insp_0)((b_0)(syntax-inspector stx-c_0)))"
"(if(eq? a_0 b_0)"
"(let-values() a_0)"
"(if(not a_0)"
"(let-values() #f)"
"(if(not b_0)"
"(let-values() #f)"
"(if(inspector-superior? a_0 b_0)"
"(let-values() b_0)"
"(if(inspector-superior? b_0 a_0)(let-values() a_0)(let-values() #f)))))))"
" #f)"
" #f)))))"
"(define-values"
"(datum->syntax$1)"
"(let-values(((datum->syntax_0)"
"(lambda(stx-c5_0 s6_0 stx-l3_0 stx-p4_0)"
"(begin"
" 'datum->syntax"
"(let-values(((stx-c_0) stx-c5_0))"
"(let-values(((s_0) s6_0))"
"(let-values(((stx-l_0) stx-l3_0))"
"(let-values(((stx-p_0) stx-p4_0))"
"(let-values()"
"(if(syntax?$1 s_0)"
"(let-values() s_0)"
"(let-values()"
"(let-values(((insp_0)(current-module-code-inspector)))"
"(let-values(((wrap_0)"
"(lambda(content_0)"
"(begin"
" 'wrap"
"(let-values(((content_1)(datum-intern-literal content_0)))"
"(immediate-datum->syntax"
" stx-c_0"
" content_1"
" stx-l_0"
" empty-props"
" insp_0))))))"
"(let-values(((result-s_0)"
"(let-values(((s_1) s_0)"
"((f_0)"
"(lambda(tail?_0 x_0)"
"(begin"
" 'f"
"(if tail?_0"
"(let-values()"
"(begin"
"(if(if(fx> tail?_0 32)"
"(fx="
" 0"
"(fxand tail?_0(fx- tail?_0 1)))"
" #f)"
"(let-values()"
"(hash-set!"
"(unsafe-place-local-ref cell.1$8)"
" x_0"
" #t))"
"(void))"
" x_0))"
"(let-values()(wrap_0 x_0))))))"
"((s->_0)(lambda(s_1)(begin 's-> s_1)))"
"((seen_0) disallow-cycles)"
"((known-pairs_0)(unsafe-place-local-ref cell.1$8)))"
"(let-values(((s_2) s_1)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(s->_0 v_0))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0)"
"((known-pairs_1) known-pairs_0))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_3 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)"
"(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)"
"(gf_0 tail?_1 s_4))"
" seen_1"
" known-pairs_1))"
"(if(null? s_3)"
"(let-values()(f_1 tail?_0 s_3))"
"(if(pair? s_3)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_0 #f(car s_3) depth_0)"
"(loop_0"
" 1"
"(cdr s_3)"
" depth_0))))"
"(if(symbol? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(boolean? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(number? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(let-values(((or-part_0)"
"(vector?"
" s_3)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box?"
" s_3)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_3)))"
"(if or-part_2"
" or-part_2"
"(hash?"
" s_3)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)"
"(gf_0 tail?_1 s_4))"
" seen_1"
" known-pairs_1))"
"(let-values()"
"(gf_0"
" #f"
" s_3))))))))))))))"
" loop_0)"
" #f"
" s_2"
" 0)))))"
"(if(if stx-p_0(not(eq?(syntax-props stx-p_0) empty-props)) #f)"
"(let-values(((the-struct_0) result-s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props20_0)(syntax-props stx-p_0)))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
" props20_0"
"(syntax-inspector the-struct_0)))"
"                                              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
" result-s_0)))))))))))))))"
"(case-lambda"
"((stx-c_0 s_0)(begin 'datum->syntax(datum->syntax_0 stx-c_0 s_0 #f #f)))"
"((stx-c_0 s_0 stx-l_0 stx-p4_0)(datum->syntax_0 stx-c_0 s_0 stx-l_0 stx-p4_0))"
"((stx-c_0 s_0 stx-l3_0)(datum->syntax_0 stx-c_0 s_0 stx-l3_0 #f)))))"
"(define-values"
"(disallow-cycles)"
"(hasheq"
" 'cycle-fail"
"   (lambda (s_0) (raise-arguments-error 'datum->syntax \"cannot create syntax from cyclic datum\" \"datum\" s_0))))"
"(define-values(syntax-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$8(make-weak-hasheq)))))"
"(define-values"
"(struct:syntax-state"
" syntax-state17.1"
" syntax-state?"
" syntax-state-all-sharing?"
" syntax-state-context-triple"
" syntax-state-srcloc"
" set-syntax-state-all-sharing?!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'syntax-state"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(1 2)"
" #f"
" 'syntax-state)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'all-sharing?)"
"(make-struct-field-accessor -ref_0 1 'context-triple)"
"(make-struct-field-accessor -ref_0 2 'srcloc)"
"(make-struct-field-mutator -set!_0 0 'all-sharing?))))"
"(define-values"
"(no-pair-syntax-in-cdr?)"
"(lambda(content_0)"
"(begin"
"(if(pair? content_0)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(content_1)"
"(begin"
" 'loop"
"(if(if(syntax?$1 content_1)(pair?(syntax-content content_1)) #f)"
"(let-values() #f)"
"(if(pair? content_1)"
"(let-values()(loop_0(cdr content_1)))"
"(let-values() #t)))))))"
" loop_0)"
"(cdr content_0)))"
"(let-values() #t)))))"
"(define-values"
"(deserialize-syntax)"
"(lambda(content_0 context-triple_0 srcloc_0 props_0 taint_0 inspector_0)"
"(begin"
"(syntax2.1"
"(if taint_0(modified-content1.1 content_0 taint_0) content_0)"
"(vector*-ref context-triple_0 0)"
"(vector*-ref context-triple_0 1)"
"(vector*-ref context-triple_0 2)"
" srcloc_0"
"(if props_0"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0) props_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" k_0"
"(preserved-property-value1.1"
" v_0)))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
" empty-props)"
" inspector_0))))"
"(define-values"
"(deserialize-datum->syntax)"
"(lambda(content_0 context-triple_0 srcloc_0 inspector_0)"
"(begin"
"(let-values(((s_0)(deserialize-syntax #f context-triple_0 srcloc_0 #f #f inspector_0)))"
"(datum->syntax$1 s_0 content_0 s_0 s_0)))))"
"(define-values"
"(struct:full-binding full-binding1.1 full-binding? full-binding-frame-id full-binding-free=id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'full-binding"
" #f"
" 2"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons prop:binding-reach-scopes(lambda(b_0)(binding-free=id b_0))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'full-binding)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'frame-id)"
"(make-struct-field-accessor -ref_0 1 'free=id))))"
"(define-values(binding-frame-id)(lambda(b_0)(begin(if(full-binding? b_0)(full-binding-frame-id b_0) #f))))"
"(define-values(binding-free=id)(lambda(b_0)(begin(if(full-binding? b_0)(full-binding-free=id b_0) #f))))"
"(define-values(cell.1$7)(unsafe-make-place-local(make-weak-hash)))"
"(define-values(phase+space-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$7(make-weak-hash)))))"
"(define-values"
"(intern)"
"(lambda(new-key_0)"
"(begin"
"(let-values((()(begin(start-atomic)(values))))"
"(let-values(((old-key_0)(hash-ref-key(unsafe-place-local-ref cell.1$7) new-key_0 #f)))"
"(begin"
"(if old-key_0(void)(let-values()(hash-set!(unsafe-place-local-ref cell.1$7) new-key_0 #t)))"
"(end-atomic)"
"(let-values(((or-part_0) old-key_0))(if or-part_0 or-part_0 new-key_0))))))))"
"(define-values(space+)(lambda(s_0 s-level_0)(begin(if(eq? s-level_0 '#:none) s_0 s-level_0))))"
"(define-values"
"(intern-phase+space)"
"(case-lambda"
"((phase_0 space_0)"
"(begin(if(not space_0)(let-values() phase_0)(let-values()(intern(cons phase_0 space_0))))))"
"((phase+space_0)(intern phase+space_0))))"
"(define-values"
"(intern-phase+space-shift)"
"(case-lambda"
"((phase-level_0 space-level_0)"
"(begin"
"(if(eq? space-level_0 '#:none)"
"(let-values() phase-level_0)"
"(let-values()(intern(cons phase-level_0 space-level_0))))))"
"((phase+space-shift_0)(intern phase+space-shift_0))))"
"(define-values(phase+space-shift-phase-level)(lambda(level_0)(begin(if(pair? level_0)(car level_0) level_0))))"
"(define-values(phase+space+)(lambda(p+s_0 level_0)(begin(intern-phase+space(phase+space+$1 p+s_0 level_0)))))"
" (define-values (phase+space?-string) \"phase+space?\")"
" (define-values (phase+space-shift?-string) \"phase+space-shift?\")"
"(define-values"
"(phase+space<?)"
"(lambda(a_0 b_0)"
"(begin"
"(let-values(((phase-a_0)(phase+space-phase a_0)))"
"(let-values(((phase-b_0)(phase+space-phase b_0)))"
"(let-values(((or-part_0)(phase<? phase-a_0 phase-b_0)))"
"(if or-part_0"
" or-part_0"
"(if(eqv? phase-a_0 phase-b_0)"
"(let-values()"
"(let-values(((space-a_0)(phase+space-space a_0)))"
"(let-values(((space-b_0)(phase+space-space b_0)))"
"(let-values(((or-part_1)(not space-a_0)))"
"(if or-part_1 or-part_1(if space-b_0(symbol<? space-a_0 space-b_0) #f))))))"
"(let-values() #f)))))))))"
"(define-values"
"(make-module-binding.1)"
"(lambda(extra-inspector7_0"
" extra-nominal-bindings8_0"
" frame-id5_0"
" free=id6_0"
" nominal-module1_0"
" nominal-phase+space2_0"
" nominal-require-phase+space-shift4_0"
" nominal-sym3_0"
" module17_0"
" phase18_0"
" sym19_0)"
"(begin"
" 'make-module-binding"
"(let-values(((module_0) module17_0))"
"(let-values(((phase_0) phase18_0))"
"(let-values(((sym_0) sym19_0))"
"(let-values(((nominal-module_0)(if(eq? nominal-module1_0 unsafe-undefined) module_0 nominal-module1_0)))"
"(let-values(((nominal-phase+space_0)"
"(if(eq? nominal-phase+space2_0 unsafe-undefined) phase_0 nominal-phase+space2_0)))"
"(let-values(((nominal-sym_0)(if(eq? nominal-sym3_0 unsafe-undefined) sym_0 nominal-sym3_0)))"
"(let-values(((nominal-require-phase+space-shift_0) nominal-require-phase+space-shift4_0))"
"(let-values(((frame-id_0) frame-id5_0))"
"(let-values(((free=id_0) free=id6_0))"
"(let-values(((extra-inspector_0) extra-inspector7_0))"
"(let-values(((extra-nominal-bindings_0) extra-nominal-bindings8_0))"
"(let-values()"
"(if(let-values(((or-part_0) frame-id_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1) free=id_0))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2) extra-inspector_0))"
"(if or-part_2"
" or-part_2"
"(not"
"(if(eqv? nominal-phase+space_0 phase_0)"
"(if(eq? nominal-sym_0 sym_0)"
"(if(eqv? nominal-require-phase+space-shift_0 0)"
"(null? extra-nominal-bindings_0)"
" #f)"
" #f)"
" #f))))))))"
"(let-values()"
"(full-module-binding45.1"
" frame-id_0"
" free=id_0"
" module_0"
" phase_0"
" sym_0"
" nominal-module_0"
" nominal-phase+space_0"
" nominal-sym_0"
" nominal-require-phase+space-shift_0"
" extra-inspector_0"
" extra-nominal-bindings_0))"
"(let-values()"
"(simple-module-binding46.1 module_0 phase_0 sym_0 nominal-module_0))))))))))))))))))"
"(define-values"
"(module-binding-update.1)"
"(lambda(extra-inspector30_0"
" extra-nominal-bindings31_0"
" frame-id28_0"
" free=id29_0"
" module21_0"
" nominal-module24_0"
" nominal-phase+space25_0"
" nominal-require-phase+space-shift27_0"
" nominal-sym26_0"
" phase22_0"
" sym23_0"
" b43_0)"
"(begin"
" 'module-binding-update"
"(let-values(((b_0) b43_0))"
"(let-values(((module_0)(if(eq? module21_0 unsafe-undefined)(module-binding-module b_0) module21_0)))"
"(let-values(((phase_0)(if(eq? phase22_0 unsafe-undefined)(module-binding-phase b_0) phase22_0)))"
"(let-values(((sym_0)(if(eq? sym23_0 unsafe-undefined)(module-binding-sym b_0) sym23_0)))"
"(let-values(((nominal-module_0)"
"(if(eq? nominal-module24_0 unsafe-undefined)"
"(module-binding-nominal-module b_0)"
" nominal-module24_0)))"
"(let-values(((nominal-phase+space_0)"
"(if(eq? nominal-phase+space25_0 unsafe-undefined)"
"(module-binding-nominal-phase+space b_0)"
" nominal-phase+space25_0)))"
"(let-values(((nominal-sym_0)"
"(if(eq? nominal-sym26_0 unsafe-undefined)"
"(module-binding-nominal-sym b_0)"
" nominal-sym26_0)))"
"(let-values(((nominal-require-phase+space-shift_0)"
"(if(eq? nominal-require-phase+space-shift27_0 unsafe-undefined)"
"(module-binding-nominal-require-phase+space-shift b_0)"
" nominal-require-phase+space-shift27_0)))"
"(let-values(((frame-id_0)"
"(if(eq? frame-id28_0 unsafe-undefined)(binding-frame-id b_0) frame-id28_0)))"
"(let-values(((free=id_0)"
"(if(eq? free=id29_0 unsafe-undefined)(binding-free=id b_0) free=id29_0)))"
"(let-values(((extra-inspector_0)"
"(if(eq? extra-inspector30_0 unsafe-undefined)"
"(module-binding-extra-inspector b_0)"
" extra-inspector30_0)))"
"(let-values(((extra-nominal-bindings_0)"
"(if(eq? extra-nominal-bindings31_0 unsafe-undefined)"
"(module-binding-extra-nominal-bindings b_0)"
" extra-nominal-bindings31_0)))"
"(let-values()"
"(let-values(((module47_0) module_0)"
"((phase48_0) phase_0)"
"((sym49_0) sym_0)"
"((nominal-module50_0) nominal-module_0)"
"((nominal-phase+space51_0) nominal-phase+space_0)"
"((nominal-sym52_0) nominal-sym_0)"
"((nominal-require-phase+space-shift53_0)"
" nominal-require-phase+space-shift_0)"
"((frame-id54_0) frame-id_0)"
"((free=id55_0) free=id_0)"
"((extra-inspector56_0) extra-inspector_0)"
"((extra-nominal-bindings57_0) extra-nominal-bindings_0))"
"(make-module-binding.1"
" extra-inspector56_0"
" extra-nominal-bindings57_0"
" frame-id54_0"
" free=id55_0"
" nominal-module50_0"
" nominal-phase+space51_0"
" nominal-require-phase+space-shift53_0"
" nominal-sym52_0"
" module47_0"
" phase48_0"
" sym49_0))))))))))))))))))"
"(define-values"
"(module-binding?)"
"(lambda(b_0)"
"(begin"
"(let-values(((or-part_0)(simple-module-binding? b_0)))(if or-part_0 or-part_0(full-module-binding? b_0))))))"
"(define-values"
"(struct:full-module-binding"
" full-module-binding45.1"
" full-module-binding?"
" full-module-binding-module"
" full-module-binding-phase"
" full-module-binding-sym"
" full-module-binding-nominal-module"
" full-module-binding-nominal-phase+space"
" full-module-binding-nominal-sym"
" full-module-binding-nominal-require-phase+space-shift"
" full-module-binding-extra-inspector"
" full-module-binding-extra-nominal-bindings)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'full-module-binding"
" struct:full-binding"
" 9"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:binding-shift-report"
"(lambda(b_0 bulk-shifts_0 report-shifts_0)"
"(begin"
"(report-shifts_0(full-module-binding-module b_0) bulk-shifts_0)"
"(report-shifts_0(full-module-binding-nominal-module b_0) bulk-shifts_0)"
"(let-values()"
"(let-values(((lst_0)(full-module-binding-extra-nominal-bindings b_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((b_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(binding-shift-report?"
" b_1)"
"(let-values()"
"((binding-shift-report-ref"
" b_1)"
" b_1"
" bulk-shifts_0"
" report-shifts_0))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))))"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 state_0)"
"(let-values(((simplified-b_0)"
"(if(full-binding-frame-id b_0)"
"(let-values(((b59_0) b_0)((temp60_0) #f))"
"(module-binding-update.1"
" unsafe-undefined"
" unsafe-undefined"
" temp60_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" b59_0))"
" b_0)))"
"(if(full-module-binding? simplified-b_0)"
"(let-values()"
"(let-values((()(begin(ser-push!_0 'tag '#:module-binding)(values))))"
"(let-values((()(begin(ser-push!_0(full-module-binding-module b_0))(values))))"
"(let-values(((sym_0 phase_0)"
"((serialize-state-map-binding-symbol state_0)"
"(full-module-binding-module b_0)"
"(full-module-binding-sym b_0)"
"(full-module-binding-phase b_0))))"
"(begin"
"(ser-push!_0 sym_0)"
"(ser-push!_0 phase_0)"
"(ser-push!_0(full-module-binding-nominal-module b_0))"
"(ser-push!_0(full-module-binding-nominal-phase+space b_0))"
"(ser-push!_0(full-module-binding-nominal-sym b_0))"
"(ser-push!_0(full-module-binding-nominal-require-phase+space-shift b_0))"
"(ser-push!_0(full-binding-free=id b_0))"
"(if(full-module-binding-extra-inspector b_0)"
"(ser-push!_0 'tag '#:inspector)"
"(ser-push!_0 #f))"
"(ser-push!_0(full-module-binding-extra-nominal-bindings b_0)))))))"
"(let-values()(ser-push!_0 simplified-b_0)))))))"
" #f"
" #f"
" '(0 1 2 3 4 5 6 7 8)"
" #f"
" 'full-module-binding)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'sym)"
"(make-struct-field-accessor -ref_0 3 'nominal-module)"
"(make-struct-field-accessor -ref_0 4 'nominal-phase+space)"
"(make-struct-field-accessor -ref_0 5 'nominal-sym)"
"(make-struct-field-accessor -ref_0 6 'nominal-require-phase+space-shift)"
"(make-struct-field-accessor -ref_0 7 'extra-inspector)"
"(make-struct-field-accessor -ref_0 8 'extra-nominal-bindings))))"
"(define-values"
"(struct:simple-module-binding"
" simple-module-binding46.1"
" simple-module-binding?"
" simple-module-binding-module"
" simple-module-binding-phase"
" simple-module-binding-sym"
" simple-module-binding-nominal-module)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'simple-module-binding"
" #f"
" 4"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:binding-shift-report"
"(lambda(b_0 bulk-shifts_0 report-shifts_0)"
"(begin"
"(report-shifts_0(simple-module-binding-module b_0) bulk-shifts_0)"
"(report-shifts_0(simple-module-binding-nominal-module b_0) bulk-shifts_0))))"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 state_0)"
"(let-values((()(begin(ser-push!_0 'tag '#:simple-module-binding)(values))))"
"(let-values((()(begin(ser-push!_0(simple-module-binding-module b_0))(values))))"
"(let-values(((sym_0 phase_0)"
"((serialize-state-map-binding-symbol state_0)"
"(simple-module-binding-module b_0)"
"(simple-module-binding-sym b_0)"
"(simple-module-binding-phase b_0))))"
"(begin"
"(ser-push!_0 sym_0)"
"(ser-push!_0 phase_0)"
"(ser-push!_0(simple-module-binding-nominal-module b_0)))))))))"
" #f"
" #f"
" '(0 1 2 3)"
" #f"
" 'simple-module-binding)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'sym)"
"(make-struct-field-accessor -ref_0 3 'nominal-module))))"
"(define-values"
"(deserialize-full-module-binding)"
"(lambda(module_0"
" sym_0"
" phase_0"
" nominal-module_0"
" nominal-phase+space_0"
" nominal-sym_0"
" nominal-require-phase+space-shift_0"
" free=id_0"
" extra-inspector_0"
" extra-nominal-bindings_0)"
"(begin"
"(let-values(((module62_0) module_0)"
"((phase63_0) phase_0)"
"((sym64_0) sym_0)"
"((nominal-module65_0) nominal-module_0)"
"((temp66_0)(intern-phase+space nominal-phase+space_0))"
"((nominal-sym67_0) nominal-sym_0)"
"((temp68_0)(intern-phase+space-shift nominal-require-phase+space-shift_0))"
"((free=id69_0) free=id_0)"
"((extra-inspector70_0) extra-inspector_0)"
"((extra-nominal-bindings71_0) extra-nominal-bindings_0))"
"(make-module-binding.1"
" extra-inspector70_0"
" extra-nominal-bindings71_0"
" #f"
" free=id69_0"
" nominal-module65_0"
" temp66_0"
" temp68_0"
" nominal-sym67_0"
" module62_0"
" phase63_0"
" sym64_0)))))"
"(define-values"
"(deserialize-simple-module-binding)"
"(lambda(module_0 sym_0 phase_0 nominal-module_0)"
"(begin(simple-module-binding46.1 module_0 phase_0 sym_0 nominal-module_0))))"
"(define-values"
"(module-binding-maybe-intern)"
"(lambda(v_0 interns_0 map-binding-symbol_0 mpi->index_0)"
"(begin"
"(let-values(((key_0)"
"(if(simple-module-binding? v_0)"
"(let-values()"
"(let-values(((sym_0 phase_0)"
"(map-binding-symbol_0"
"(simple-module-binding-module v_0)"
"(simple-module-binding-sym v_0)"
"(simple-module-binding-phase v_0))))"
"(list"
"(mpi->index_0(simple-module-binding-module v_0))"
" phase_0"
" sym_0"
"(mpi->index_0(simple-module-binding-nominal-module v_0)))))"
"(if(full-module-binding? v_0)"
"(let-values()"
"(let-values(((sym_0 phase_0)"
"(map-binding-symbol_0"
"(full-module-binding-module v_0)"
"(full-module-binding-sym v_0)"
"(full-module-binding-phase v_0))))"
"(list"
"(mpi->index_0(full-module-binding-module v_0))"
" phase_0"
" sym_0"
"(mpi->index_0(full-module-binding-nominal-module v_0))"
"(full-module-binding-nominal-phase+space v_0)"
"(full-module-binding-nominal-sym v_0)"
"(full-module-binding-nominal-require-phase+space-shift v_0)"
"(full-module-binding-extra-inspector v_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((pos->vals_0"
" pos-pre-inc_0"
" pos-next_0"
" init_0"
" pos-cont?_0"
" val-cont?_0"
" all-cont?_0)"
"(make-sequence '(b)(full-module-binding-extra-nominal-bindings v_0))))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if pos-cont?_0(pos-cont?_0 pos_0) #t)"
"(let-values(((b_0 all-cont?/pos_0)"
"(let-values(((b_0)(pos->vals_0 pos_0)))"
"(values"
" b_0"
"(if all-cont?_0"
"(lambda(pos_1)(all-cont?_0 pos_1 b_0))"
" #f))))"
"((pos_1)"
"(if pos-pre-inc_0"
"(pos-pre-inc_0 pos_0)"
" pos_0)))"
"(if(if val-cont?_0(val-cont?_0 b_0) #t)"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((or-part_0)"
"(module-binding-maybe-intern"
" b_0"
" interns_0"
" map-binding-symbol_0"
" mpi->index_0)))"
"(if or-part_0"
" or-part_0"
" b_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(if(if all-cont?/pos_0"
"(all-cont?/pos_0 pos_1)"
" #t)"
"(not #f)"
" #f)"
"(for-loop_0 fold-var_2(pos-next_0 pos_1))"
" fold-var_2))"
" fold-var_1))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" init_0)))))))"
"(void)))))"
"(let-values(((new-v_0)(hash-ref interns_0 key_0 #f)))"
"(if(not new-v_0)"
"(let-values()(begin(hash-set! interns_0 key_0 v_0) #f))"
"(if(eq? new-v_0 v_0)(let-values() #f)(let-values() new-v_0))))))))"
"(define-values"
"(module-binding-module)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0)(simple-module-binding-module b_0)(full-module-binding-module b_0)))))"
"(define-values"
"(module-binding-phase)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0)(simple-module-binding-phase b_0)(full-module-binding-phase b_0)))))"
"(define-values"
"(module-binding-sym)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0)(simple-module-binding-sym b_0)(full-module-binding-sym b_0)))))"
"(define-values"
"(module-binding-nominal-module)"
"(lambda(b_0)"
"(begin"
"(if(simple-module-binding? b_0)"
"(simple-module-binding-nominal-module b_0)"
"(full-module-binding-nominal-module b_0)))))"
"(define-values"
"(module-binding-nominal-phase+space)"
"(lambda(b_0)"
"(begin"
"(if(simple-module-binding? b_0)"
"(simple-module-binding-phase b_0)"
"(full-module-binding-nominal-phase+space b_0)))))"
"(define-values"
"(module-binding-nominal-sym)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0)(simple-module-binding-sym b_0)(full-module-binding-nominal-sym b_0)))))"
"(define-values"
"(module-binding-nominal-require-phase+space-shift)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0) 0(full-module-binding-nominal-require-phase+space-shift b_0)))))"
"(define-values"
"(module-binding-extra-inspector)"
"(lambda(b_0)(begin(if(simple-module-binding? b_0) #f(full-module-binding-extra-inspector b_0)))))"
"(define-values"
"(module-binding-extra-nominal-bindings)"
"(lambda(b_0)(begin(if(simple-module-binding? b_0) null(full-module-binding-extra-nominal-bindings b_0)))))"
"(define-values"
"(struct:like-ambiguous-binding like-ambiguous-binding1.1 like-ambiguous-binding?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'like-ambiguous-binding"
" #f"
" 0"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 state_0)(ser-push!_0 'tag '#:like-ambiguous-binding))))"
" #f"
" #f"
" '()"
" #f"
" 'like-ambiguous-binding)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values(empty-binding-table) '#hasheq())"
"(define-values"
"(struct:table-with-bulk-bindings"
" table-with-bulk-bindings1.1"
" table-with-bulk-bindings?"
" table-with-bulk-bindings-syms"
" table-with-bulk-bindings-syms/serialize"
" table-with-bulk-bindings-bulk-bindings)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'table-with-bulk-bindings"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(twbb_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:table-with-bulk-bindings)"
"(ser-push!_0(table-with-bulk-bindings-syms/serialize twbb_0))"
"(ser-push!_0(table-with-bulk-bindings-bulk-bindings twbb_0))))))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'table-with-bulk-bindings)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'syms)"
"(make-struct-field-accessor -ref_0 1 'syms/serialize)"
"(make-struct-field-accessor -ref_0 2 'bulk-bindings))))"
"(define-values"
"(deserialize-table-with-bulk-bindings)"
"(lambda(syms_0 bulk-bindings_0)(begin(table-with-bulk-bindings1.1 syms_0 syms_0 bulk-bindings_0))))"
"(define-values"
"(struct:bulk-binding-at bulk-binding-at2.1 bulk-binding-at? bulk-binding-at-scopes bulk-binding-at-bulk)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-binding-at"
" #f"
" 2"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"                      (cons prop:reach-scopes (lambda (sms_0 extra-scopes_0 reach_0) (error \"shouldn't get here\")))"
"(cons"
" prop:serialize"
"(lambda(bba_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:bulk-binding-at)"
"(ser-push!_0(bulk-binding-at-scopes bba_0))"
"(ser-push!_0(bulk-binding-at-bulk bba_0))))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'bulk-binding-at)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'scopes)"
"(make-struct-field-accessor -ref_0 1 'bulk))))"
"(define-values(deserialize-bulk-binding-at)(lambda(scopes_0 bulk_0)(begin(bulk-binding-at2.1 scopes_0 bulk_0))))"
"(define-values(prop:bulk-binding bulk-binding?$1 bulk-binding-ref)(make-struct-type-property 'bulk-binding))"
"(define-values"
"(struct:bulk-binding-class"
" bulk-binding-class3.1"
" bulk-binding-class?"
" bulk-binding-class-get-symbols"
" bulk-binding-class-create"
" bulk-binding-class-modname"
" bulk-binding-class-report-shifts)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-binding-class"
" #f"
" 4"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'bulk-binding-class)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'get-symbols)"
"(make-struct-field-accessor -ref_0 1 'create)"
"(make-struct-field-accessor -ref_0 2 'modname)"
"(make-struct-field-accessor -ref_0 3 'report-shifts))))"
"(define-values"
"(bulk-binding-symbols)"
"(lambda(b_0 s_0 extra-shifts_0)"
"(begin"
"((bulk-binding-class-get-symbols(bulk-binding-ref b_0))"
" b_0"
"(append extra-shifts_0(if s_0(syntax-mpi-shifts s_0) null))))))"
"(define-values(bulk-binding-create)(lambda(b_0)(begin(bulk-binding-class-create(bulk-binding-ref b_0)))))"
"(define-values"
"(force-bulk-bindings)"
"(lambda(b_0 bulk-shifts_0)"
"(begin"
"(let-values(((modname-ht_0)(car bulk-shifts_0)))"
"(let-values(((extra-shifts_0)(cdr bulk-shifts_0)))"
"(begin"
"(hash-set! modname-ht_0 b_0((bulk-binding-class-modname(bulk-binding-ref b_0)) b_0 extra-shifts_0))"
"(bulk-binding-symbols b_0 #f extra-shifts_0)))))))"
"(define-values"
"(bulk-binding-report-shifts)"
"(lambda(b_0 bulk-shifts_0 report-shifts_0)"
"(begin((bulk-binding-class-report-shifts(bulk-binding-ref b_0)) b_0 bulk-shifts_0 report-shifts_0))))"
"(define-values(binding-table-empty?)(lambda(bt_0)(begin(if(hash? bt_0)(zero?(hash-count bt_0)) #f))))"
"(define-values"
"(binding-table-add)"
"(lambda(bt_0 scopes_0 sym_0 binding_0 just-for-nominal?_0)"
"(begin"
"(if(hash? bt_0)"
"(let-values()(hash-set bt_0 sym_0(hash-set(hash-ref bt_0 sym_0 '#hash()) scopes_0 binding_0)))"
"(let-values()"
"(let-values(((new-syms_0)"
"(binding-table-add"
"(table-with-bulk-bindings-syms bt_0)"
" scopes_0"
" sym_0"
" binding_0"
" just-for-nominal?_0)))"
"(let-values(((new-syms/serialize_0)"
"(if just-for-nominal?_0"
"(let-values()(table-with-bulk-bindings-syms/serialize bt_0))"
"(if(eq?"
"(table-with-bulk-bindings-syms bt_0)"
"(table-with-bulk-bindings-syms/serialize bt_0))"
"(let-values() new-syms_0)"
"(let-values()"
"(binding-table-add"
"(table-with-bulk-bindings-syms/serialize bt_0)"
" scopes_0"
" sym_0"
" binding_0"
" #f))))))"
"(let-values(((the-struct_0) bt_0))"
"(if(table-with-bulk-bindings? the-struct_0)"
"(let-values(((syms45_0) new-syms_0)((syms/serialize46_0) new-syms/serialize_0))"
"(table-with-bulk-bindings1.1"
" syms45_0"
" syms/serialize46_0"
"(table-with-bulk-bindings-bulk-bindings the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"table-with-bulk-bindings?\" the-struct_0))))))))))"
"(define-values"
"(prop:implicitly-reachable implicitly-reachable? implicitly-reachable-ref)"
"(make-struct-type-property 'implicitly-reachable))"
"(define-values"
"(binding-table-add-bulk.1)"
"(lambda(shadow-except4_0 bt6_0 scopes7_0 bulk8_0)"
"(begin"
" 'binding-table-add-bulk"
"(let-values(((bt_0) bt6_0))"
"(let-values(((scopes_0) scopes7_0))"
"(let-values(((bulk_0) bulk8_0))"
"(let-values(((shadow-except_0) shadow-except4_0))"
"(let-values()"
"(if(table-with-bulk-bindings? bt_0)"
"(let-values()"
"(let-values(((new-syms_0)"
"(let-values(((temp47_0)(table-with-bulk-bindings-syms bt_0))"
"((scopes48_0) scopes_0)"
"((bulk49_0) bulk_0)"
"((shadow-except50_0) shadow-except_0))"
"(remove-matching-bindings.1 shadow-except50_0 temp47_0 scopes48_0 bulk49_0))))"
"(let-values(((new-syms/serialize_0)"
"(if(eq?"
"(table-with-bulk-bindings-syms bt_0)"
"(table-with-bulk-bindings-syms/serialize bt_0))"
" new-syms_0"
"(let-values(((temp51_0)(table-with-bulk-bindings-syms/serialize bt_0))"
"((scopes52_0) scopes_0)"
"((bulk53_0) bulk_0)"
"((shadow-except54_0) shadow-except_0))"
"(remove-matching-bindings.1 shadow-except54_0 temp51_0 scopes52_0 bulk53_0)))))"
"(table-with-bulk-bindings1.1"
" new-syms_0"
" new-syms/serialize_0"
"(cons(bulk-binding-at2.1 scopes_0 bulk_0)(table-with-bulk-bindings-bulk-bindings bt_0))))))"
"(let-values()"
"(let-values(((temp55_0)(table-with-bulk-bindings1.1 bt_0 bt_0 null))"
"((scopes56_0) scopes_0)"
"((bulk57_0) bulk_0))"
"(binding-table-add-bulk.1 #f temp55_0 scopes56_0 bulk57_0))))))))))))"
"(define-values"
"(remove-matching-bindings.1)"
"(lambda(except10_0 syms12_0 scopes13_0 bulk14_0)"
"(begin"
" 'remove-matching-bindings"
"(let-values(((syms_0) syms12_0))"
"(let-values(((scopes_0) scopes13_0))"
"(let-values(((bulk_0) bulk14_0))"
"(let-values(((except_0) except10_0))"
"(let-values()"
"(let-values(((bulk-symbols_0)(bulk-binding-symbols bulk_0 #f null)))"
"(if(<(hash-count syms_0)(hash-count bulk-symbols_0))"
"(let-values()"
"(let-values(((syms_1)(let-values(((syms_1) syms_0)) syms_1)))"
"(let-values(((ht_0) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(syms_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0 sym-bindings_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((syms_3)"
"(let-values(((syms_3)"
"(let-values()"
"(if(hash-ref"
" bulk-symbols_0"
" sym_0"
" #f)"
"(let-values(((syms58_0) syms_2)"
"((sym59_0) sym_0)"
"((sym-bindings60_0)"
" sym-bindings_0)"
"((scopes61_0)"
" scopes_0)"
"((except62_0)"
" except_0))"
"(remove-matching-binding.1"
" except62_0"
" syms58_0"
" sym59_0"
" sym-bindings60_0"
" scopes61_0))"
" syms_2))))"
"(values syms_3))))"
"(if(not #f)"
"(for-loop_0"
" syms_3"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" syms_3)))"
" syms_2))))))"
" for-loop_0)"
" syms_1"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(let-values()"
"(let-values(((syms_1)(let-values(((syms_1) syms_0)) syms_1)))"
"(let-values(((ht_0) bulk-symbols_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(syms_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0)"
"(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((syms_3)"
"(let-values(((syms_3)"
"(let-values()"
"(let-values(((sym-bindings_0)"
"(hash-ref"
" syms_2"
" sym_0"
" #f)))"
"(if sym-bindings_0"
"(let-values(((syms63_0)"
" syms_2)"
"((sym64_0) sym_0)"
"((sym-bindings65_0)"
" sym-bindings_0)"
"((scopes66_0)"
" scopes_0)"
"((except67_0)"
" except_0))"
"(remove-matching-binding.1"
" except67_0"
" syms63_0"
" sym64_0"
" sym-bindings65_0"
" scopes66_0))"
" syms_2)))))"
"(values syms_3))))"
"(if(not #f)"
"(for-loop_0"
" syms_3"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" syms_3)))"
" syms_2))))))"
" for-loop_0)"
" syms_1"
"(unsafe-immutable-hash-iterate-first ht_0))))))))))))))))"
"(define-values"
"(remove-matching-binding.1)"
"(lambda(except16_0 syms18_0 sym19_0 sym-bindings20_0 scopes21_0)"
"(begin"
" 'remove-matching-binding"
"(let-values(((syms_0) syms18_0))"
"(let-values(((sym_0) sym19_0))"
"(let-values(((sym-bindings_0) sym-bindings20_0))"
"(let-values(((scopes_0) scopes21_0))"
"(let-values(((except_0) except16_0))"
"(let-values()"
"(if(if except_0"
"(let-values(((b_0)(hash-ref sym-bindings_0 scopes_0 #f)))"
"(let-values(((or-part_0)"
"(if(module-binding? b_0)(eq? except_0(module-binding-module b_0)) #f)))"
"(if or-part_0 or-part_0(like-ambiguous-binding? b_0))))"
" #f)"
"(let-values() syms_0)"
"(let-values()(hash-set syms_0 sym_0(hash-remove sym-bindings_0 scopes_0)))))))))))))"
"(define-values"
"(next-state-in-full-binding-table)"
"(lambda(sym-ht_0 sym-i_0)"
"(begin"
"(if sym-i_0"
"(let-values(((ht_0)(hash-iterate-value sym-ht_0 sym-i_0)))"
"(let-values(((i_0)(hash-iterate-first ht_0)))"
"(if i_0"
"(cons(vector sym-i_0(hash-iterate-key sym-ht_0 sym-i_0) ht_0) i_0)"
"(next-state-in-full-binding-table sym-ht_0(hash-iterate-next sym-ht_0 sym-i_0)))))"
" '(#f . #f)))))"
"(define-values"
"(binding-table-symbols.1)"
"(lambda(exactly?24_0 only-interned?23_0 table27_0 scs28_0 s29_0 extra-shifts30_0)"
"(begin"
" 'binding-table-symbols"
"(let-values(((table_0) table27_0))"
"(let-values(((scs_0) scs28_0))"
"(let-values(((s_0) s29_0))"
"(let-values(((extra-shifts_0) extra-shifts30_0))"
"(let-values(((only-interned?_0) only-interned?23_0))"
"(let-values(((exactly?_0) exactly?24_0))"
"(let-values()"
"(let-values(((ht_0 bulk-bindings_0)"
"(if(hash? table_0)"
"(values table_0 null)"
"(values"
"(table-with-bulk-bindings-syms table_0)"
"(table-with-bulk-bindings-bulk-bindings table_0)))))"
"(set-union"
"(let-values(((table_1)(let-values(((table_1) '#hasheq())) table_1)))"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0 at-sym_0)"
"(hash-iterate-key+value ht_1 i_0)))"
"(let-values(((table_3)"
"(if(let-values(((or-part_0)"
"(not only-interned?_0)))"
"(if or-part_0"
" or-part_0"
"(symbol-interned? sym_0)))"
"(if(let-values(((result_0)"
"(let-values(((result_0) #f))"
" result_0)))"
"(let-values(((ht_2) at-sym_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys ht_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(result_1"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((an-scs_0)"
"(hash-iterate-key"
" ht_2"
" i_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if exactly?_0"
"(set=?"
" an-scs_0"
" scs_0)"
"(subset?"
" an-scs_0"
" scs_0))))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
" result_2)"
" an-scs_0))"
"(not"
" #f)"
" #f)"
"(for-loop_1"
" result_2"
"(hash-iterate-next"
" ht_2"
" i_1))"
" result_2)))"
" result_1))))))"
" for-loop_1)"
" result_0"
"(hash-iterate-first ht_2)))))"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
" sym_0)"
" #t))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values table_3))"
" table_2)"
" table_2)))"
"(if(not #f)"
"(for-loop_0 table_3(hash-iterate-next ht_1 i_0))"
" table_3)))"
" table_2))))))"
" for-loop_0)"
" table_1"
"(hash-iterate-first ht_1)))))"
"(let-values(((table_1)(let-values(((table_1) '#hasheq())) table_1)))"
"(let-values(((lst_0) bulk-bindings_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((bba_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_3)"
"(if(if exactly?_0"
"(set=?"
"(bulk-binding-at-scopes bba_0)"
" scs_0)"
"(subset?"
"(bulk-binding-at-scopes bba_0)"
" scs_0))"
"(let-values(((ht_1)"
"(bulk-binding-symbols"
"(bulk-binding-at-bulk bba_0)"
" s_0"
" extra-shifts_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_3 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)"
"(hash-iterate-key"
" ht_1"
" i_0)))"
"(let-values(((table_4)"
"(if(let-values(((or-part_0)"
"(not"
" only-interned?_0)))"
"(if or-part_0"
" or-part_0"
"(symbol-interned?"
" sym_0)))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(let-values()"
" sym_0)"
" #t))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))"
" table_3)))"
"(if(not #f)"
"(for-loop_1"
" table_4"
"(hash-iterate-next"
" ht_1"
" i_0))"
" table_4)))"
" table_3)))))"
" for-loop_1)"
" table_2"
"(hash-iterate-first ht_1))))"
" table_2)))"
"(if(not #f)(for-loop_0 table_3 rest_0) table_3)))"
" table_2))))))"
" for-loop_0)"
" table_1"
" lst_0))))))))))))))))"
"(define-values"
"(binding-table-interned-scope-keys.1)"
"(lambda(exactly?32_0 table34_0 scs35_0 sym36_0 s37_0 extra-shifts38_0 interned-scope?39_0 interned-scope-key40_0)"
"(begin"
" 'binding-table-interned-scope-keys"
"(let-values(((table_0) table34_0))"
"(let-values(((scs_0) scs35_0))"
"(let-values(((sym_0) sym36_0))"
"(let-values(((s_0) s37_0))"
"(let-values(((extra-shifts_0) extra-shifts38_0))"
"(let-values(((interned-scope?_0) interned-scope?39_0))"
"(let-values(((interned-scope-key_0) interned-scope-key40_0))"
"(let-values(((exactly?_0) exactly?32_0))"
"(let-values()"
"(let-values(((ht_0 bulk-bindings_0)"
"(if(hash? table_0)"
"(values table_0 null)"
"(values"
"(table-with-bulk-bindings-syms table_0)"
"(table-with-bulk-bindings-bulk-bindings table_0)))))"
"(set-union"
"(let-values(((table_1)(let-values(((table_1) '#hasheq())) table_1)))"
"(let-values(((ht_1)(hash-ref ht_0 sym_0 '#hasheq())))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((an-scs_0)(hash-iterate-key ht_1 i_0)))"
"(let-values(((table_3)"
"(let-values(((ht_2) an-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys ht_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_3 i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_2"
" i_1)))"
"(let-values(((table_4)"
"(if(if(interned-scope?_0"
" sc_0)"
"(if(not"
"(set-member?"
" scs_0"
" sc_0))"
"(if exactly?_0"
"(set=?"
" an-scs_0"
"(set-add"
" scs_0"
" sc_0))"
"(subset?"
" an-scs_0"
"(set-add"
" scs_0"
" sc_0)))"
" #f)"
" #f)"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(let-values()"
"(interned-scope-key_0"
" sc_0))"
" #t))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))"
" table_3)))"
"(if(not #f)"
"(for-loop_1"
" table_4"
"(unsafe-immutable-hash-iterate-next"
" ht_2"
" i_1))"
" table_4)))"
" table_3)))))"
" for-loop_1)"
" table_2"
"(unsafe-immutable-hash-iterate-first"
" ht_2))))))"
"(if(not #f)"
"(for-loop_0 table_3(hash-iterate-next ht_1 i_0))"
" table_3)))"
" table_2))))))"
" for-loop_0)"
" table_1"
"(hash-iterate-first ht_1)))))"
"(let-values(((table_1)(let-values(((table_1) '#hasheq())) table_1)))"
"(let-values(((lst_0) bulk-bindings_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((bba_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_3)"
"(if(hash-ref"
"(bulk-binding-symbols"
"(bulk-binding-at-bulk bba_0)"
" s_0"
" extra-shifts_0)"
" sym_0"
" #f)"
"(let-values()"
"(let-values(((an-scs_0)"
"(bulk-binding-at-scopes"
" bba_0)))"
"(let-values(((ht_1) an-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_3"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_1"
" i_0)))"
"(let-values(((table_4)"
"(if(if(interned-scope?_0"
" sc_0)"
"(if(not"
"(set-member?"
" scs_0"
" sc_0))"
"(if exactly?_0"
"(set=?"
" an-scs_0"
"(set-add"
" scs_0"
" sc_0))"
"(subset?"
" an-scs_0"
"(set-add"
" scs_0"
" sc_0)))"
" #f)"
" #f)"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(let-values()"
"(interned-scope-key_0"
" sc_0))"
" #t))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))"
" table_3)))"
"(if(not"
" #f)"
"(for-loop_1"
" table_4"
"(unsafe-immutable-hash-iterate-next"
" ht_1"
" i_0))"
" table_4)))"
" table_3)))))"
" for-loop_1)"
" table_2"
"(unsafe-immutable-hash-iterate-first"
" ht_1))))))"
" table_2)))"
"(if(not #f)(for-loop_0 table_3 rest_0) table_3)))"
" table_2))))))"
" for-loop_0)"
" table_1"
" lst_0))))))))))))))))))"
"(define-values"
"(binding-table-prune-to-reachable)"
"(lambda(bt_0 state_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(serialize-state-bindings-intern state_0) bt_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((reachable-scopes_0)(serialize-state-reachable-scopes state_0)))"
"(let-values(((new-syms_0)"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0)(if(hash? bt_0) bt_0(table-with-bulk-bindings-syms/serialize bt_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0 bindings-for-sym_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((id*_0)"
"(let-values(((table_2)"
"(let-values(((table_2)"
" '#hash()))"
" table_2)))"
"(let-values(((ht_1)"
" bindings-for-sym_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_3"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((scopes_0"
" binding_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((table_4)"
"(if(subset?"
" scopes_0"
" reachable-scopes_0)"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(intern-scopes"
" scopes_0"
" state_0)"
" binding_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))"
" table_3)))"
"(if(not"
" #f)"
"(for-loop_1"
" table_4"
"(unsafe-immutable-hash-iterate-next"
" ht_1"
" i_1))"
" table_4)))"
" table_3))))))"
" for-loop_1)"
" table_2"
"(unsafe-immutable-hash-iterate-first"
" ht_1)))))))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2)"
"(begin"
" 'for-loop"
"(let-values(((new-bindings-for-sym_0)"
" id*_0))"
"(let-values(((table_3)"
"(if(positive?"
"(hash-count"
" new-bindings-for-sym_0))"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
" new-bindings-for-sym_0))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values"
" table_3))"
" table_2)))"
" table_3))))))"
" for-loop_1)"
" table_1))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(let-values(((new-bulk-bindings_0)"
"(if(hash? bt_0)"
" null"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(table-with-bulk-bindings-bulk-bindings bt_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((bba_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(if(subset?"
"(bulk-binding-at-scopes bba_0)"
" reachable-scopes_0)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((the-struct_0)"
" bba_0))"
"(if(bulk-binding-at?"
" the-struct_0)"
"(let-values(((scopes68_0)"
"(intern-scopes"
"(bulk-binding-at-scopes"
" bba_0)"
" state_0)))"
"(bulk-binding-at2.1"
" scopes68_0"
"(bulk-binding-at-bulk"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                         \"bulk-binding-at?\""
" the-struct_0))))"
" fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(let-values(((new-bt_0)"
"(if(pair? new-bulk-bindings_0)"
"(table-with-bulk-bindings1.1 new-syms_0 new-syms_0 new-bulk-bindings_0)"
" new-syms_0)))"
"(begin(hash-set!(serialize-state-bulk-bindings-intern state_0) bt_0 new-bt_0) new-bt_0))))))))))"
"(define-values"
"(binding-table-register-reachable)"
"(lambda(bt_0 get-reachable-scopes_0 bulk-shifts_0 reach_0 register-trigger_0 reach-implicitly_0 report-shifts_0)"
"(begin"
"(begin"
"(let-values()"
"(let-values(((ht_0)(if(hash? bt_0) bt_0(table-with-bulk-bindings-syms/serialize bt_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 bindings-for-sym_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values(((ht_1) bindings-for-sym_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((scopes_0 binding_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if report-shifts_0"
"(binding-shift-report?"
" binding_0)"
" #f)"
"(let-values()"
"((binding-shift-report-ref"
" binding_0)"
" binding_0"
" bulk-shifts_0"
" report-shifts_0))"
"(void))"
"(values))))"
"(let-values(((v_0)"
"(if(binding-reach-scopes?"
" binding_0)"
"((binding-reach-scopes-ref"
" binding_0)"
" binding_0)"
" #f)))"
"(scopes-register-reachable"
" scopes_0"
" v_0"
" get-reachable-scopes_0"
" bulk-shifts_0"
" reach_0"
" register-trigger_0"
" reach-implicitly_0))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_1"
"(unsafe-immutable-hash-iterate-next"
" ht_1"
" i_1))"
"(values))))"
"(values))))))"
" for-loop_1)"
"(unsafe-immutable-hash-iterate-first ht_1))))))"
"(if(not #f)"
"(for-loop_0(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
"(void)"
"(if(table-with-bulk-bindings? bt_0)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)(table-with-bulk-bindings-bulk-bindings bt_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((bba_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(if bulk-shifts_0"
"(let-values()"
"(force-bulk-bindings"
"(bulk-binding-at-bulk bba_0)"
" bulk-shifts_0))"
"(void))"
"(if report-shifts_0"
"(let-values()"
"(bulk-binding-report-shifts"
"(bulk-binding-at-bulk bba_0)"
" bulk-shifts_0"
" report-shifts_0))"
"(void))"
"(scopes-register-reachable"
"(bulk-binding-at-scopes bba_0)"
" #f"
" get-reachable-scopes_0"
" bulk-shifts_0"
" reach_0"
" register-trigger_0"
" reach-implicitly_0)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))"
"(void))))))"
"(define-values"
"(scopes-register-reachable)"
"(lambda(scopes_0 v_0 get-reachable-scopes_0 bulk-shifts_0 reach_0 register-trigger_0 reach-implicitly_0)"
"(begin"
"(let-values(((reachable-scopes_0)(get-reachable-scopes_0)))"
"(if(subset? scopes_0 reachable-scopes_0)"
"(let-values()(reach_0 v_0 bulk-shifts_0))"
"(let-values()"
"(let-values(((pending-scopes_0)"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((table_2)"
"(if(let-values(((or-part_0)"
"(set-member?"
" reachable-scopes_0"
" sc_0)))"
"(if or-part_0"
" or-part_0"
"(implicitly-reachable? sc_0)))"
" table_1"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
" sc_0)"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(let-values(((check-trigger_0)"
"(lambda(reach_1)"
"(begin"
" 'check-trigger"
"(if(zero?(hash-count pending-scopes_0))"
"(let-values()"
"(begin"
"(reach_1 v_0 bulk-shifts_0)"
"(let-values()"
"(let-values(((ht_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(implicitly-reachable?"
" sc_0)"
"(let-values()"
"(if(not"
" bulk-shifts_0)"
"(let-values()"
"(reach_1"
" sc_0"
" bulk-shifts_0))"
"(let-values()"
"(reach-implicitly_0"
" sc_0))))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
"(void)))"
"(void))))))"
"(begin"
"(let-values()"
"(let-values(((ht_0) pending-scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(register-trigger_0"
" sc_0"
"(lambda(reach_1)"
"(begin"
"(set! pending-scopes_0"
"(hash-remove"
" pending-scopes_0"
" sc_0))"
"(check-trigger_0 reach_1)))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
"(void)"
"(check-trigger_0 reach_0))))))))))"
"(define-values"
"(taint-content)"
"(lambda(d_0)"
"(begin"
"(let-values(((s_0) d_0)"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((s->_0)"
"(lambda(sub-s_0)"
"(begin"
" 's->"
"(if(syntax-taintness sub-s_0)"
"(let-values() sub-s_0)"
"(let-values()"
"(let-values(((stx_0) sub-s_0))"
"(let-values(((t_0)(tainted-for-content(syntax-content sub-s_0))))"
"(let-values(((content*_0)(syntax-content* stx_0)))"
"(let-values(((content_0)"
"(if(modified-content? content*_0)"
"(modified-content-content content*_0)"
" content*_0)))"
"(let-values(((p_0)"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content*1_0)"
"(let-values(((new-p_0)"
"(if(taint? p_0)"
" t_0"
"((propagation-set-taint-ref p_0) p_0 t_0))))"
"(if new-p_0"
"(modified-content1.1 content_0 new-p_0)"
" content_0))))"
"(syntax2.1"
" content*1_0"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                          (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))))))))"
"((seen_0) #f)"
"((known-pairs_0) #f))"
"(let-values(((s_1) s_0)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin 'gf(if(syntax?$1 v_0)(let-values()(s->_0 v_0))(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0)"
"((known-pairs_1) known-pairs_0))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_2 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_2"
"(lambda(tail?_1 s_3)(gf_0 tail?_1 s_3))"
" seen_1"
" known-pairs_1))"
"(if(null? s_2)"
"(let-values()(f_1 tail?_0 s_2))"
"(if(pair? s_2)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons(loop_0 #f(car s_2) depth_0)(loop_0 1(cdr s_2) depth_0))))"
"(if(symbol? s_2)"
"(let-values()(f_1 #f s_2))"
"(if(boolean? s_2)"
"(let-values()(f_1 #f s_2))"
"(if(number? s_2)"
"(let-values()(f_1 #f s_2))"
"(if(let-values(((or-part_0)(vector? s_2)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_2)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(prefab-struct-key s_2)))"
"(if or-part_2 or-part_2(hash? s_2)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_2"
"(lambda(tail?_1 s_3)(gf_0 tail?_1 s_3))"
" seen_1"
" known-pairs_1))"
"(let-values()(gf_0 #f s_2))))))))))))))"
" loop_0)"
" #f"
" s_1"
" 0))))))"
"(define-values(syntax-tainted?$1)(lambda(s_0)(begin 'syntax-tainted?(if(syntax-taintness s_0) #t #f))))"
"(define-values(syntax-clean?)(lambda(s_0)(begin(not(syntax-taintness s_0)))))"
"(define-values"
"(syntax-taint$1)"
"(lambda(s_0)"
"(begin"
" 'syntax-taint"
"(if(syntax-taintness s_0)"
" s_0"
"(let-values(((stx_0) s_0))"
"(let-values(((t_0)(tainted-for-content(syntax-content s_0))))"
"(let-values(((content*_0)(syntax-content* stx_0)))"
"(let-values(((content_0)"
"(if(modified-content? content*_0)(modified-content-content content*_0) content*_0)))"
"(let-values(((p_0)"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content*2_0)"
"(let-values(((new-p_0)"
"(if(taint? p_0) t_0((propagation-set-taint-ref p_0) p_0 t_0))))"
"(if new-p_0(modified-content1.1 content_0 new-p_0) content_0))))"
"(syntax2.1"
" content*2_0"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                      (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))))))"
"(define-values"
"(syntax-property$1)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((s_0 key_0)"
"(begin"
" 'syntax-property"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-property \"syntax?\" s_0)))"
"(values))))"
"(let-values(((v_0)(hash-ref(syntax-props s_0) key_0 #f)))"
"(let-values(((plain-v_0)(plain-property-value v_0)))"
"(if(syntax-taintness s_0)(taint-content plain-v_0) plain-v_0))))))"
"((s_0 key_0 val_0)"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                          (let-values () (raise-argument-error 'syntax-property \"syntax?\" s_0)))"
"(values))))"
"(let-values(((pval_0)(if(eq? key_0 'paren-shape)(preserved-property-value1.1 val_0) val_0)))"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props2_0)(hash-set(syntax-props s_0) key_0 pval_0)))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
" props2_0"
"(syntax-inspector the-struct_0)))"
"                (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"((s_0 key_0 val_0 preserved?_0)"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                          (let-values () (raise-argument-error 'syntax-property \"syntax?\" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if preserved?_0"
"(let-values()"
"(if(if(symbol? key_0)(symbol-interned? key_0) #f)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-property"
"                                   \"key for a preserved property must be an interned symbol\""
"                                   \"given key\""
" key_0"
"                                   \"given value\""
" val_0))))"
"(void))"
"(values))))"
"(let-values(((pval_0)(if preserved?_0(preserved-property-value1.1 val_0) val_0)))"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props3_0)(hash-set(syntax-props s_0) key_0 pval_0)))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
" props3_0"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))))))"
"(define-values"
"(1/syntax-property-preserved?)"
"(lambda(s_0 key_0)"
"(begin"
" 'syntax-property-preserved?"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-property-preserved? \"syntax?\" s_0)))"
"(if(if(symbol? key_0)(symbol-interned? key_0) #f)"
"(void)"
"(let-values()"
"                (raise-argument-error 'syntax-property-preserved? \"(and/c symbol? symbol-interned?)\" key_0)))"
"(preserved-property-value?(hash-ref(syntax-props s_0) key_0 #f))))))))"
"(define-values"
"(1/syntax-property-symbol-keys)"
"(lambda(s_0)"
"(begin"
" 'syntax-property-symbol-keys"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-property-symbol-keys \"syntax\" s_0)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0)(syntax-props s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_2)"
"(if(if(symbol? k_0)(symbol-interned? k_0) #f)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons(let-values() k_0) fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)"
"(for-loop_0 fold-var_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))))))"
"(define-values"
"(1/syntax-property-remove)"
"(lambda(s_0 key_0)"
"(begin"
" 'syntax-property-remove"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-property-remove \"syntax?\" s_0)))"
"(if(hash-has-key?(syntax-props s_0) key_0)"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props7_0)(hash-remove(syntax-props s_0) key_0)))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
" props7_0"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
" s_0)))))))"
"(define-values(syntax-has-property?)(lambda(from-s_0 key_0)(begin(hash-ref(syntax-props from-s_0) key_0 #f))))"
"(define-values"
"(struct:fallback fallback1.1 fallback? fallback-search-list)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'fallback #f 1 0 #f null 'prefab #f '(0) #f 'fallback)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'search-list))))"
"(define-values"
"(fallback-first)"
"(lambda(smss_0)(begin(if(fallback? smss_0)(car(fallback-search-list smss_0)) smss_0))))"
"(define-values"
"(fallback-rest)"
"(lambda(smss_0)"
"(begin"
"(let-values(((l_0)(cdr(fallback-search-list smss_0))))(if(null?(cdr l_0))(car l_0)(fallback1.1 l_0))))))"
"(define-values"
"(fallback-push)"
"(lambda(smss_0 smss/maybe-fallback_0)"
"(begin"
"(fallback1.1"
"(cons"
" smss_0"
"(if(fallback? smss/maybe-fallback_0)"
"(fallback-search-list smss/maybe-fallback_0)"
"(list smss/maybe-fallback_0)))))))"
"(define-values"
"(fallback-update-first)"
"(lambda(smss_0 f_0)"
"(begin"
"(if(fallback? smss_0)"
"(let-values(((l_0)(fallback-search-list smss_0)))(fallback1.1(cons(f_0(car l_0))(cdr l_0))))"
"(f_0 smss_0)))))"
"(define-values"
"(fallback-map)"
"(lambda(smss_0 f_0)"
"(begin"
"(if(fallback? smss_0)"
"(fallback1.1"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(fallback-search-list smss_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((smss_1)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()(f_0 smss_1))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
"(f_0 smss_0)))))"
"(define-values"
"(fallback->list)"
"(lambda(smss_0)(begin(if(fallback? smss_0)(fallback-search-list smss_0)(list smss_0)))))"
"(define-values(make-cache$1)(lambda()(begin 'make-cache(box(make-weak-box #f)))))"
"(define-values(cell.1$6)(unsafe-make-place-local(make-cache$1)))"
"(define-values(resolve-cache-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$6(make-cache$1)))))"
"(define-values"
"(clear-resolve-cache!)"
"(case-lambda"
"((sym_0)"
"(begin"
"(let-values(((c_0)(weak-box-value(unbox*(unsafe-place-local-ref cell.1$6)))))"
"(begin"
"(if c_0(let-values()(hash-remove! c_0 sym_0))(void))"
"(set-box*!(unsafe-place-local-ref cell.2$3) #f)))))"
"(()"
"(let-values(((c_0)(weak-box-value(unbox*(unsafe-place-local-ref cell.1$6)))))"
"(begin(if c_0(let-values()(hash-clear! c_0))(void))(set-box*!(unsafe-place-local-ref cell.2$3) #f))))))"
"(define-values"
"(struct:entry entry1.1 entry? entry-scs entry-smss entry-phase entry-binding)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'entry"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'entry)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'scs)"
"(make-struct-field-accessor -ref_0 1 'smss)"
"(make-struct-field-accessor -ref_0 2 'phase)"
"(make-struct-field-accessor -ref_0 3 'binding))))"
"(define-values"
"(resolve-cache-get)"
"(lambda(sym_0 phase_0 scs_0 smss_0)"
"(begin"
"(let-values(((c_0)(weak-box-value(unbox*(unsafe-place-local-ref cell.1$6)))))"
"(if c_0"
"(let-values(((v_0)(hash-ref c_0 sym_0 #f)))"
"(if v_0"
"(if(eqv? phase_0(entry-phase v_0))"
"(if(set=? scs_0(entry-scs v_0))(if(set=? smss_0(entry-smss v_0))(entry-binding v_0) #f) #f)"
" #f)"
" #f))"
" #f)))))"
"(define-values"
"(resolve-cache-set!)"
"(lambda(sym_0 phase_0 scs_0 smss_0 b_0)"
"(begin"
"(let-values(((wb_0)(unbox*(unsafe-place-local-ref cell.1$6))))"
"(let-values(((c_0)(weak-box-value wb_0)))"
"(if(not c_0)"
"(let-values()"
"(begin"
"(box-cas!(unsafe-place-local-ref cell.1$6) wb_0(make-weak-box(make-hasheq)))"
"(resolve-cache-set! sym_0 phase_0 scs_0 smss_0 b_0)))"
"(let-values()(hash-set! c_0 sym_0(entry1.1 scs_0 smss_0 phase_0 b_0)))))))))"
"(define-values(SHIFTED-CACHE-SIZE) 16)"
"(define-values(cell.2$3)(unsafe-make-place-local(box #f)))"
"(define-values(cell.3$1)(unsafe-make-place-local 0))"
"(define-values"
"(struct:shifted-entry shifted-entry2.1 shifted-entry? shifted-entry-s shifted-entry-phase shifted-entry-binding)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'shifted-entry"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'shifted-entry)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'binding))))"
"(define-values"
"(shifted-cache-vector)"
"(lambda()"
"(begin"
"(let-values(((wb_0)(unbox*(unsafe-place-local-ref cell.2$3))))"
"(let-values(((c1_0)(if wb_0(weak-box-value wb_0) #f)))"
"(if c1_0"
"((lambda(vec_0) vec_0) c1_0)"
"(let-values()"
"(let-values(((vec_0)(make-vector SHIFTED-CACHE-SIZE #f)))"
"(begin(set-box*!(unsafe-place-local-ref cell.2$3)(make-weak-box vec_0)) vec_0)))))))))"
"(define-values"
"(resolve+shift-cache-get)"
"(lambda(s_0 phase_0)"
"(begin"
"(let-values(((vec_0)(shifted-cache-vector)))"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1) vec_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_1)))"
"(values vec_1(unsafe-vector-length vec_1))))))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((e_0)(unsafe-vector-ref vec_1 pos_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if e_0"
"(if(eq? s_0(shifted-entry-s e_0))"
"(if(eqv? phase_0(shifted-entry-phase e_0))"
"(shifted-entry-binding e_0)"
" #f)"
" #f)"
" #f)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) e_0))(not #f) #f)"
"(for-loop_0 result_2(unsafe-fx+ 1 pos_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" 0)))))))"
"(define-values"
"(resolve+shift-cache-set!)"
"(lambda(s_0 phase_0 b_0)"
"(begin"
"(let-values(((vec_0)(shifted-cache-vector)))"
"(let-values(((p_0)(unsafe-place-local-ref cell.3$1)))"
"(begin"
"(vector*-set! vec_0 p_0(shifted-entry2.1 s_0 phase_0 b_0))"
"(unsafe-place-local-set! cell.3$1(fxand(fx+ 1 p_0)(fx- SHIFTED-CACHE-SIZE 1)))))))))"
"(define-values(NUM-CACHE-SLOTS) 8)"
"(define-values(make-cached-sets)(lambda()(begin(make-weak-box(make-vector NUM-CACHE-SLOTS #f)))))"
"(define-values(cell.4$1)(unsafe-make-place-local(make-cached-sets)))"
"(define-values(cell.5$1)(unsafe-make-place-local 0))"
"(define-values(make-cached-hashes)(lambda()(begin(make-weak-box(make-vector NUM-CACHE-SLOTS #f)))))"
"(define-values(cell.6$1)(unsafe-make-place-local(make-cached-hashes)))"
"(define-values(cell.7)(unsafe-make-place-local 0))"
"(define-values"
"(sets-place-init!)"
"(lambda()"
"(begin"
"(begin"
"(unsafe-place-local-set! cell.4$1(make-cached-sets))"
"(unsafe-place-local-set! cell.6$1(make-cached-hashes))))))"
"(define-values"
"(cache-or-reuse-set)"
"(lambda(s_0)"
"(begin"
"(let-values(((vec_0)"
"(let-values(((or-part_0)(weak-box-value(unsafe-place-local-ref cell.4$1))))"
"(if or-part_0"
" or-part_0"
"(let-values(((vec_0)(make-vector NUM-CACHE-SLOTS #f)))"
"(begin(unsafe-place-local-set! cell.4$1(make-weak-box vec_0)) vec_0))))))"
"(let-values(((or-part_0)"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1) vec_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_1)))"
"(values vec_1(unsafe-vector-length vec_1))))))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((s2_0)(unsafe-vector-ref vec_1 pos_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if s2_0"
"(if(set=? s_0 s2_0) s2_0 #f)"
" #f)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) s2_0))(not #f) #f)"
"(for-loop_0 result_2(unsafe-fx+ 1 pos_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" 0)))))"
"(if or-part_0"
" or-part_0"
"(begin"
"(vector*-set! vec_0(unsafe-place-local-ref cell.5$1) s_0)"
"(unsafe-place-local-set!"
" cell.5$1"
"(fxand(fx+ 1(unsafe-place-local-ref cell.5$1))(fx- NUM-CACHE-SLOTS 1)))"
" s_0)))))))"
"(define-values"
"(cache-or-reuse-hash)"
"(lambda(s_0)"
"(begin"
"(let-values(((vec_0)"
"(let-values(((or-part_0)(weak-box-value(unsafe-place-local-ref cell.6$1))))"
"(if or-part_0"
" or-part_0"
"(let-values(((vec_0)(make-vector NUM-CACHE-SLOTS #f)))"
"(begin(unsafe-place-local-set! cell.6$1(make-weak-box vec_0)) vec_0))))))"
"(let-values(((or-part_0)"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1) vec_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_1)))"
"(values vec_1(unsafe-vector-length vec_1))))))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((s2_0)(unsafe-vector-ref vec_1 pos_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if s2_0"
"(if(equal? s_0 s2_0) s2_0 #f)"
" #f)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) s2_0))(not #f) #f)"
"(for-loop_0 result_2(unsafe-fx+ 1 pos_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" 0)))))"
"(if or-part_0"
" or-part_0"
"(begin"
"(vector*-set! vec_0(unsafe-place-local-ref cell.7) s_0)"
"(unsafe-place-local-set! cell.7(fxand(fx+ 1(unsafe-place-local-ref cell.7))(fx- NUM-CACHE-SLOTS 1)))"
" s_0)))))))"
"(define-values(cache-place-init!)(lambda()(begin(begin(resolve-cache-place-init!)(sets-place-init!)))))"
"(define-values"
"(struct:scope scope1.1 scope? scope-id scope-kind scope-binding-table set-scope-binding-table!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'scope"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:scope-with-bindings"
"(lambda(s_0"
" get-reachable-scopes_0"
" extra-shifts_0"
" reach_0"
" register-trigger_0"
" reach-implicitly_0"
" report-shifts_0)"
"(binding-table-register-reachable"
"(scope-binding-table s_0)"
" get-reachable-scopes_0"
" extra-shifts_0"
" reach_0"
" register-trigger_0"
" reach-implicitly_0"
" report-shifts_0)))"
"(cons prop:reach-scopes(lambda(s_0 extra-shifts_0 reach_0)(void)))"
"(cons"
" prop:serialize-fill!"
"(lambda(s_0 ser-push!_0 state_0)"
"(if(binding-table-empty?(scope-binding-table s_0))"
"(let-values()(ser-push!_0 'tag #f))"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:scope-fill!)"
"(ser-push!_0(binding-table-prune-to-reachable(scope-binding-table s_0) state_0)))))))"
"(cons"
" prop:serialize"
"(lambda(s_0 ser-push!_0 state_0)"
"(begin"
"(if(set-member?(serialize-state-reachable-scopes state_0) s_0)"
"(void)"
"                             (let-values () (error \"internal error: found supposedly unreachable scope\")))"
"(if(eq? s_0 top-level-common-scope)"
"(let-values()(ser-push!_0 'tag '#:scope))"
"(let-values()(begin(ser-push!_0 'tag '#:scope+kind)(ser-push!_0(scope-kind s_0))))))))"
"(cons"
" prop:custom-write"
"(lambda(sc_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<scope:\" port_0)"
"(display(scope-id sc_0) port_0)"
"                           (write-string \":\" port_0)"
"(display(scope-kind sc_0) port_0)"
"                           (write-string \">\" port_0)))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'scope)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'kind)"
"(make-struct-field-accessor -ref_0 2 'binding-table)"
"(make-struct-field-mutator -set!_0 2 'binding-table))))"
"(define-values"
"(deserialize-scope)"
"(case-lambda"
"(()(begin top-level-common-scope))"
"((kind_0)(scope1.1(new-deserialize-scope-id!) kind_0 empty-binding-table))))"
"(define-values(deserialize-scope-fill!)(lambda(s_0 bt_0)(begin(set-scope-binding-table! s_0 bt_0))))"
"(define-values"
"(struct:interned-scope interned-scope2.1 interned-scope? interned-scope-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'interned-scope"
" struct:scope"
" 1"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(s_0 ser-push!_0 state_0)"
"(begin"
"(if(set-member?(serialize-state-reachable-scopes state_0) s_0)"
"(void)"
"                             (let-values () (error \"internal error: found supposedly unreachable scope\")))"
"(ser-push!_0 'tag '#:interned-scope)"
"(ser-push!_0(interned-scope-key s_0)))))"
"(cons"
" prop:custom-write"
"(lambda(sc_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<scope:\" port_0)"
"(display(scope-id sc_0) port_0)"
"                           (write-string \":\" port_0)"
"(display(scope-kind sc_0) port_0)"
"                           (write-string \" \" port_0)"
"(display(interned-scope-key sc_0) port_0)"
"                           (write-string \">\" port_0)))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'interned-scope)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'key))))"
"(define-values"
"(struct:multi-scope"
" multi-scope3.1"
" multi-scope?"
" multi-scope-id"
" multi-scope-name"
" multi-scope-scopes"
" multi-scope-shifted"
" multi-scope-label-shifted)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'multi-scope"
" #f"
" 5"
" 0"
" #f"
"(list"
"(cons prop:sealed #t)"
"(cons prop:authentic #t)"
"(cons"
" prop:scope-with-bindings"
"(lambda(ms_0"
" get-reachable-scopes_0"
" bulk-shifts_0"
" reach_0"
" register-trigger_0"
" reach-implicitly_0"
" report-shifts_0)"
"(begin"
"(let-values()"
"(let-values(((ht_0)(unbox(multi-scope-scopes ms_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-values ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(hash-iterate-value ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(binding-table-empty?"
"(scope-binding-table"
" sc_0))"
"(void)"
"(let-values()"
"(reach_0"
" sc_0"
" bulk-shifts_0))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void))))"
"(cons prop:reach-scopes(lambda(s_0 extra-shifts_0 reach_0)(void)))"
"(cons"
" prop:serialize"
"(lambda(ms_0 ser-push!_0 state_0)"
"(let-values((()(begin(ser-push!_0 'tag '#:multi-scope)(values))))"
"(let-values((()(begin(ser-push!_0(multi-scope-name ms_0))(values))))"
"(let-values(((multi-scope-tables_0)(serialize-state-multi-scope-tables state_0)))"
"(ser-push!_0"
"(let-values(((or-part_0)(hash-ref multi-scope-tables_0(multi-scope-scopes ms_0) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)"
"(let-values(((table_0)"
"(let-values(((table_0) '#hasheqv())) table_0)))"
"(let-values(((ht_0)(unbox(multi-scope-scopes ms_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 sc_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(if(let-values(((or-part_1)"
"(set-member?"
"(serialize-state-reachable-scopes"
" state_0)"
" sc_0)))"
"(if or-part_1"
" or-part_1"
"(set-member?"
"(serialize-state-implicitly-reachable-scopes"
" state_0)"
" sc_0)))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_0"
" sc_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))"
" table_1)))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(begin"
"(hash-set! multi-scope-tables_0(multi-scope-scopes ms_0) ht_0)"
" ht_0)))))))))))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4)"
" #f"
" 'multi-scope)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'name)"
"(make-struct-field-accessor -ref_0 2 'scopes)"
"(make-struct-field-accessor -ref_0 3 'shifted)"
"(make-struct-field-accessor -ref_0 4 'label-shifted))))"
"(define-values"
"(deserialize-multi-scope)"
"(lambda(name_0 scopes_0)"
"(begin(multi-scope3.1(new-deserialize-scope-id!) name_0(box scopes_0)(box(hasheqv))(box(hash))))))"
"(define-values"
"(struct:representative-scope"
" representative-scope4.1"
" representative-scope?"
" representative-scope-owner"
" representative-scope-phase"
" set-representative-scope-owner!"
" set-representative-scope-phase!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'representative-scope"
" struct:scope"
" 2"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons prop:implicitly-reachable #t)"
"(cons"
" prop:reach-scopes"
"(lambda(s_0 bulk-shifts_0 reach_0)(reach_0(representative-scope-owner s_0) bulk-shifts_0)))"
"(cons"
" prop:serialize-fill!"
"(lambda(s_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:representative-scope-fill!)"
"(if(set-member?(serialize-state-reachable-scopes state_0) s_0)"
"(ser-push!_0(binding-table-prune-to-reachable(scope-binding-table s_0) state_0))"
"(ser-push!_0 empty-binding-table))"
"(ser-push!_0(representative-scope-owner s_0)))))"
"(cons"
" prop:serialize"
"(lambda(s_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:representative-scope)"
"(ser-push!_0(scope-kind s_0))"
"(ser-push!_0(representative-scope-phase s_0)))))"
"(cons"
" prop:custom-write"
"(lambda(sc_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<scope:\" port_0)"
"(display(scope-id sc_0) port_0)"
"(if(representative-scope-owner sc_0)"
"(let-values()"
"(begin"
"                                 (write-string \"=\" port_0)"
"(display(multi-scope-id(representative-scope-owner sc_0)) port_0)))"
"(void))"
"                           (write-string \"@\" port_0)"
"(display(representative-scope-phase sc_0) port_0)"
"                           (write-string \">\" port_0)))))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'representative-scope)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'owner)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-mutator -set!_0 0 'owner)"
"(make-struct-field-mutator -set!_0 1 'phase))))"
"(define-values"
"(deserialize-representative-scope)"
"(lambda(kind_0 phase_0)"
"(begin(let-values(((v_0)(representative-scope4.1(new-deserialize-scope-id!) kind_0 #f #f phase_0))) v_0))))"
"(define-values"
"(deserialize-representative-scope-fill!)"
"(lambda(s_0 bt_0 owner_0)"
"(begin(begin(deserialize-scope-fill! s_0 bt_0)(set-representative-scope-owner! s_0 owner_0)))))"
"(define-values"
"(struct:shifted-multi-scope"
" shifted-multi-scope5.1"
" shifted-multi-scope?"
" shifted-multi-scope-phase"
" shifted-multi-scope-multi-scope)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'shifted-multi-scope"
" #f"
" 2"
" 0"
" #f"
"(list"
"(cons prop:sealed #t)"
"(cons prop:authentic #t)"
"(cons"
" prop:reach-scopes"
"(lambda(sms_0 bulk-shifts_0 reach_0)"
"(reach_0(shifted-multi-scope-multi-scope sms_0) bulk-shifts_0)))"
"(cons"
" prop:serialize"
"(lambda(sms_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:shifted-multi-scope)"
"(ser-push!_0(shifted-multi-scope-phase sms_0))"
"(ser-push!_0(shifted-multi-scope-multi-scope sms_0)))))"
"(cons"
" prop:custom-write"
"(lambda(sms_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<scope:\" port_0)"
"(display(multi-scope-id(shifted-multi-scope-multi-scope sms_0)) port_0)"
"                           (write-string \"@\" port_0)"
"(display(shifted-multi-scope-phase sms_0) port_0)"
"                           (write-string \">\" port_0)))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'shifted-multi-scope)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'phase)"
"(make-struct-field-accessor -ref_0 1 'multi-scope))))"
"(define-values"
"(deserialize-shifted-multi-scope)"
"(lambda(phase_0 multi-scope_0)(begin(intern-shifted-multi-scope phase_0 multi-scope_0))))"
"(define-values"
"(intern-shifted-multi-scope)"
"(lambda(phase_0 multi-scope_0)"
"(begin"
"(letrec-values(((transaction-loop_0)"
"(lambda(boxed-table_0 key_0 make_0)"
"(begin"
" 'transaction-loop"
"(let-values(((or-part_0)(hash-ref(unbox boxed-table_0) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((val_0)(make_0)))"
"(let-values(((current_0)(unbox boxed-table_0)))"
"(let-values(((next_0)(hash-set current_0 key_0 val_0)))"
"(if(box-cas! boxed-table_0 current_0 next_0)"
" val_0"
"(transaction-loop_0 boxed-table_0 key_0 make_0)))))))))))"
"(if(phase? phase_0)"
"(let-values()"
"(let-values(((or-part_0)(hash-ref(unbox(multi-scope-shifted multi-scope_0)) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(transaction-loop_0"
"(multi-scope-shifted multi-scope_0)"
" phase_0"
"(lambda()(shifted-multi-scope5.1 phase_0 multi-scope_0))))))"
"(let-values()"
"(let-values(((or-part_0)(hash-ref(unbox(multi-scope-label-shifted multi-scope_0)) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(transaction-loop_0"
"(multi-scope-label-shifted multi-scope_0)"
" phase_0"
"(lambda()(shifted-multi-scope5.1 phase_0 multi-scope_0)))))))))))"
"(define-values"
"(struct:shifted-to-label-phase shifted-to-label-phase6.1 shifted-to-label-phase? shifted-to-label-phase-from)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'shifted-to-label-phase"
" #f"
" 1"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0)"
" #f"
" 'shifted-to-label-phase)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'from))))"
"(define-values(cell.1$5)(unsafe-make-place-local 0))"
"(define-values"
"(new-scope-id!)"
"(lambda()"
"(begin"
"(begin"
"(unsafe-place-local-set! cell.1$5(add1(unsafe-place-local-ref cell.1$5)))"
"(unsafe-place-local-ref cell.1$5)))))"
"(define-values(new-deserialize-scope-id!)(lambda()(begin(-(new-scope-id!)))))"
"(define-values"
"(make-representative-scope-id)"
"(lambda(scope-id_0 phase_0)"
"(begin"
"(if(eqv? phase_0 0)"
"(let-values()(+ scope-id_0 1/2))"
"(if(not phase_0)"
"(let-values()(+ scope-id_0 7/8))"
"(if(> phase_0 0)"
"(let-values()(+ scope-id_0(/ 1(+ 2 phase_0))))"
"(let-values()(+ scope-id_0 1/2(/ 1(- 2 phase_0))))))))))"
"(define-values(top-level-common-scope)(scope1.1 0 'module empty-binding-table))"
"(define-values(new-scope)(lambda(kind_0)(begin(scope1.1(new-scope-id!) kind_0 empty-binding-table))))"
"(define-values(cell.2$2)(unsafe-make-place-local(make-ephemeron-hasheq)))"
"(define-values"
"(interned-scope-symbols)"
"(lambda()(begin(call-as-atomic(lambda()(hash-keys(unsafe-place-local-ref cell.2$2)))))))"
"(define-values"
"(interned-scopes)"
"(lambda()"
"(begin"
"(call-as-atomic"
"(lambda()"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0)(unsafe-place-local-ref cell.2$2)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-values ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((s_0)(hash-iterate-value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values() s_0)"
" #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2(hash-iterate-next ht_0 i_0)) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0))))))))))"
"(define-values(scope-place-init!)(lambda()(begin(unsafe-place-local-set! cell.2$2(make-ephemeron-hasheq)))))"
"(define-values"
"(make-interned-scope)"
"(lambda(sym_0)"
"(begin"
"(let-values(((make_0)"
"(lambda()"
"(begin 'make(interned-scope2.1(-(new-scope-id!)) 'interned empty-binding-table sym_0)))))"
"(call-as-atomic"
"(lambda()"
"(let-values(((or-part_0)(hash-ref!(unsafe-place-local-ref cell.2$2) sym_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((new_0)(make_0)))"
"(begin(hash-set!(unsafe-place-local-ref cell.2$2) sym_0 new_0) new_0))))))))))"
"(define-values"
"(syntax-has-interned-scope?)"
"(lambda(s_0)"
"(begin"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((ht_0)(syntax-scopes s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()(interned-scope? sc_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) sc_0))(not #f) #f)"
"(for-loop_0 result_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(new-multi-scope)"
"(let-values(((new-multi-scope_0)"
"(lambda(name7_0)"
"(begin"
" 'new-multi-scope"
"(let-values(((name_0) name7_0))"
"(let-values()"
"(intern-shifted-multi-scope"
" 0"
"(multi-scope3.1(new-scope-id!) name_0(box(hasheqv))(box(hasheqv))(box(hash))))))))))"
"(case-lambda(()(begin(new-multi-scope_0 #f)))((name7_0)(new-multi-scope_0 name7_0)))))"
"(define-values"
"(multi-scope-to-scope-at-phase)"
"(lambda(ms_0 phase_0)"
"(begin"
"(let-values(((scopes_0)(unbox(multi-scope-scopes ms_0))))"
"(let-values(((or-part_0)(hash-ref scopes_0 phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((s_0)"
"(representative-scope4.1"
"(make-representative-scope-id(multi-scope-id ms_0) phase_0)"
" 'module"
" empty-binding-table"
" ms_0"
" phase_0)))"
"(if(box-cas!(multi-scope-scopes ms_0) scopes_0(hash-set scopes_0 phase_0 s_0))"
" s_0"
"(multi-scope-to-scope-at-phase ms_0 phase_0)))))))))"
"(define-values(scope>?)(lambda(sc1_0 sc2_0)(begin(>(scope-id sc1_0)(scope-id sc2_0)))))"
"(define-values(scope<?)(lambda(sc1_0 sc2_0)(begin(<(scope-id sc1_0)(scope-id sc2_0)))))"
"(define-values"
"(shifted-multi-scope<?)"
"(lambda(sms1_0 sms2_0)"
"(begin"
"(let-values(((ms1_0)(shifted-multi-scope-multi-scope sms1_0)))"
"(let-values(((ms2_0)(shifted-multi-scope-multi-scope sms2_0)))"
"(if(eq? ms1_0 ms2_0)"
"(let-values(((p1_0)(shifted-multi-scope-phase sms1_0))((p2_0)(shifted-multi-scope-phase sms2_0)))"
"(if(shifted-to-label-phase? p1_0)"
"(let-values()"
"(if(shifted-to-label-phase? p2_0)"
"(let-values()(phase<?(shifted-to-label-phase-from p1_0)(shifted-to-label-phase-from p2_0)))"
"(let-values() #f)))"
"(if(shifted-to-label-phase? p2_0)(let-values() #t)(let-values()(phase<? p1_0 p2_0)))))"
"(<(multi-scope-id ms1_0)(multi-scope-id ms2_0))))))))"
"(define-values"
"(syntax-propagated-content*)"
"(lambda(s_0)"
"(begin"
"(let-values(((content*_0)(syntax-content* s_0)))"
"(if(not(modified-content? content*_0))"
"(let-values() content*_0)"
"(let-values()"
"(let-values(((prop_0)(modified-content-scope-propagations+taint content*_0)))"
"(if(let-values(((or-part_0)(propagation? prop_0)))"
"(if or-part_0 or-part_0(taint-needs-propagate? prop_0)))"
"(let-values()"
"(let-values(((content_0)(modified-content-content content*_0)))"
"(let-values(((new-content_0)"
"(if(propagation? prop_0)"
"(let-values()"
"(let-values(((s_1) content_0)"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((s->_0)"
"(lambda(sub-s_0)"
"(begin"
" 's->"
"(let-values(((sub-content*_0)(syntax-content* sub-s_0)))"
"(let-values(((sub-content_0)"
"(if(modified-content? sub-content*_0)"
"(modified-content-content sub-content*_0)"
" sub-content*_0)))"
"(let-values(((scope-propagations+taint_0)"
"(propagation-merge"
" sub-content_0"
" prop_0"
"(if(modified-content? sub-content*_0)"
"(modified-content-scope-propagations+taint"
" sub-content*_0)"
" #f)"
"(syntax-scopes sub-s_0)"
"(syntax-shifted-multi-scopes sub-s_0)"
"(syntax-mpi-shifts sub-s_0))))"
"(let-values(((the-struct_0) sub-s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scopes41_0)"
"(propagation-apply"
" prop_0"
"(syntax-scopes sub-s_0)"
" s_0))"
"((shifted-multi-scopes42_0)"
"(propagation-apply-shifted"
" prop_0"
"(syntax-shifted-multi-scopes sub-s_0)"
" s_0))"
"((mpi-shifts43_0)"
"(propagation-apply-mpi-shifts"
" prop_0"
"(syntax-mpi-shifts sub-s_0)"
" s_0))"
"((inspector44_0)"
"(propagation-apply-inspector"
" prop_0"
"(syntax-inspector sub-s_0)))"
"((content*45_0)"
"(if scope-propagations+taint_0"
"(modified-content1.1"
" sub-content_0"
" scope-propagations+taint_0)"
" sub-content_0)))"
"(syntax2.1"
" content*45_0"
" scopes41_0"
" shifted-multi-scopes42_0"
" mpi-shifts43_0"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
" inspector44_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                   \"syntax?\""
" the-struct_0)))))))))"
"((seen_0) #f)"
"((known-pairs_0) #f))"
"(let-values(((s_2) s_1)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(s->_0 v_0))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0)"
"((known-pairs_1) known-pairs_0))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_3 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)(gf_0 tail?_1 s_4))"
" seen_1"
" known-pairs_1))"
"(if(null? s_3)"
"(let-values()(f_1 tail?_0 s_3))"
"(if(pair? s_3)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_0 #f(car s_3) depth_0)"
"(loop_0 1(cdr s_3) depth_0))))"
"(if(symbol? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(boolean? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(number? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(let-values(((or-part_0)"
"(vector? s_3)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box? s_3)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_3)))"
"(if or-part_2"
" or-part_2"
"(hash? s_3)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)"
"(gf_0 tail?_1 s_4))"
" seen_1"
" known-pairs_1))"
"(let-values()"
"(gf_0 #f s_3))))))))))))))"
" loop_0)"
" #f"
" s_2"
" 0))))"
"(let-values()"
"(let-values(((s_1) content_0)"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((s->_0)"
"(lambda(sub-s_0)"
"(begin"
" 's->"
"(let-values(((stx_0) sub-s_0))"
"(let-values(((t_0)"
"(tainted-for-content(syntax-content sub-s_0))))"
"(let-values(((content*_1)(syntax-content* stx_0)))"
"(let-values(((content_1)"
"(if(modified-content? content*_1)"
"(modified-content-content content*_1)"
" content*_1)))"
"(let-values(((p_0)"
"(if(modified-content? content*_1)"
"(modified-content-scope-propagations+taint"
" content*_1)"
" #f)))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content*46_0)"
"(let-values(((new-p_0)"
"(if(taint? p_0)"
" t_0"
"((propagation-set-taint-ref"
" p_0)"
" p_0"
" t_0))))"
"(if new-p_0"
"(modified-content1.1"
" content_1"
" new-p_0)"
" content_1))))"
"(syntax2.1"
" content*46_0"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                       \"syntax?\""
" the-struct_0)))))))))))"
"((seen_0) #f)"
"((known-pairs_0) #f))"
"(let-values(((s_2) s_1)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(s->_0 v_0))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0)"
"((known-pairs_1) known-pairs_0))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_3 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)(gf_0 tail?_1 s_4))"
" seen_1"
" known-pairs_1))"
"(if(null? s_3)"
"(let-values()(f_1 tail?_0 s_3))"
"(if(pair? s_3)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_0 #f(car s_3) depth_0)"
"(loop_0 1(cdr s_3) depth_0))))"
"(if(symbol? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(boolean? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(number? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(let-values(((or-part_0)"
"(vector? s_3)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box? s_3)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_3)))"
"(if or-part_2"
" or-part_2"
"(hash? s_3)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)"
"(gf_0 tail?_1 s_4))"
" seen_1"
" known-pairs_1))"
"(let-values()"
"(gf_0 #f s_3))))))))))))))"
" loop_0)"
" #f"
" s_2"
" 0)))))))"
"(let-values(((new-taint_0)"
"(taint-propagated(if(propagation? prop_0)(propagation-taint prop_0) prop_0))))"
"(let-values(((new-content*_0)"
"(if new-taint_0(modified-content1.1 new-content_0 new-taint_0) new-content_0)))"
"(if(syntax-content*-cas! s_0 content*_0 new-content*_0)"
" new-content*_0"
"(syntax-propagated-content* s_0)))))))"
"(let-values() content*_0)))))))))"
"(define-values"
"(syntax-e$1)"
"(lambda(s_0)"
"(begin"
" 'syntax-e"
"(let-values(((e_0)(syntax-content* s_0)))"
"(if(symbol? e_0)"
"(let-values() e_0)"
"(let-values()"
"(let-values(((content*_0)(syntax-propagated-content* s_0)))"
"(if(modified-content? content*_0)(modified-content-content content*_0) content*_0))))))))"
"(define-values"
"(generalize-scope)"
"(lambda(sc_0)"
"(begin"
"(if(representative-scope? sc_0)"
"(intern-shifted-multi-scope(representative-scope-phase sc_0)(representative-scope-owner sc_0))"
" sc_0))))"
"(define-values"
"(add-scope)"
"(lambda(s_0 sc_0)"
"(begin"
"(let-values(((s_1) s_0)((sc_1)(generalize-scope sc_0))((op_0) set-add)((prop-op_0) propagation-add))"
"(let-values(((content*_0)(syntax-content* s_1)))"
"(let-values(((content_0)"
"(if(modified-content? content*_0)(modified-content-content content*_0) content*_0)))"
"(if(shifted-multi-scope? sc_1)"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((shifted-multi-scopes47_0)"
"(fallback-update-first"
"(syntax-shifted-multi-scopes s_1)"
"(lambda(smss_0)(op_0(fallback-first smss_0) sc_1))))"
"((content*48_0)"
"(if(datum-has-elements? content_0)"
"(let-values(((prop_0)"
"(prop-op_0"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))))"
"(if prop_0(modified-content1.1 content_0 prop_0) content_0))"
" content*_0)))"
"(syntax2.1"
" content*48_0"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes47_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scopes49_0)(op_0(syntax-scopes s_1) sc_1))"
"((content*50_0)"
"(if(datum-has-elements? content_0)"
"(let-values(((prop_0)"
"(prop-op_0"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))))"
"(if prop_0(modified-content1.1 content_0 prop_0) content_0))"
" content*_0)))"
"(syntax2.1"
" content*50_0"
" scopes49_0"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))))"
"(define-values"
"(add-scopes)"
"(lambda(s_0 scs_0)"
"(begin"
"(let-values(((s_1)(let-values(((s_1) s_0)) s_1)))"
"(let-values(((lst_0) scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sc_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_3)"
"(let-values(((s_3)(let-values()(add-scope s_2 sc_0))))"
"(values s_3))))"
"(if(not #f)(for-loop_0 s_3 rest_0) s_3)))"
" s_2))))))"
" for-loop_0)"
" s_1"
" lst_0)))))))"
"(define-values"
"(remove-scope)"
"(lambda(s_0 sc_0)"
"(begin"
"(let-values(((s_1) s_0)((sc_1)(generalize-scope sc_0))((op_0) set-remove)((prop-op_0) propagation-remove))"
"(let-values(((content*_0)(syntax-content* s_1)))"
"(let-values(((content_0)"
"(if(modified-content? content*_0)(modified-content-content content*_0) content*_0)))"
"(if(shifted-multi-scope? sc_1)"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((shifted-multi-scopes51_0)"
"(fallback-update-first"
"(syntax-shifted-multi-scopes s_1)"
"(lambda(smss_0)(op_0(fallback-first smss_0) sc_1))))"
"((content*52_0)"
"(if(datum-has-elements? content_0)"
"(let-values(((prop_0)"
"(prop-op_0"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))))"
"(if prop_0(modified-content1.1 content_0 prop_0) content_0))"
" content*_0)))"
"(syntax2.1"
" content*52_0"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes51_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scopes53_0)(op_0(syntax-scopes s_1) sc_1))"
"((content*54_0)"
"(if(datum-has-elements? content_0)"
"(let-values(((prop_0)"
"(prop-op_0"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))))"
"(if prop_0(modified-content1.1 content_0 prop_0) content_0))"
" content*_0)))"
"(syntax2.1"
" content*54_0"
" scopes53_0"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))))"
"(define-values"
"(remove-scopes)"
"(lambda(s_0 scs_0)"
"(begin"
"(let-values(((s_1)(let-values(((s_1) s_0)) s_1)))"
"(let-values(((lst_0) scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sc_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_3)"
"(let-values(((s_3)(let-values()(remove-scope s_2 sc_0))))"
"(values s_3))))"
"(if(not #f)(for-loop_0 s_3 rest_0) s_3)))"
" s_2))))))"
" for-loop_0)"
" s_1"
" lst_0)))))))"
"(define-values(set-flip)(lambda(s_0 e_0)(begin(if(set-member? s_0 e_0)(set-remove s_0 e_0)(set-add s_0 e_0)))))"
"(define-values"
"(flip-scope)"
"(lambda(s_0 sc_0)"
"(begin"
"(let-values(((s_1) s_0)((sc_1)(generalize-scope sc_0))((op_0) set-flip)((prop-op_0) propagation-flip))"
"(let-values(((content*_0)(syntax-content* s_1)))"
"(let-values(((content_0)"
"(if(modified-content? content*_0)(modified-content-content content*_0) content*_0)))"
"(if(shifted-multi-scope? sc_1)"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((shifted-multi-scopes55_0)"
"(fallback-update-first"
"(syntax-shifted-multi-scopes s_1)"
"(lambda(smss_0)(op_0(fallback-first smss_0) sc_1))))"
"((content*56_0)"
"(if(datum-has-elements? content_0)"
"(let-values(((prop_0)"
"(prop-op_0"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))))"
"(if prop_0(modified-content1.1 content_0 prop_0) content_0))"
" content*_0)))"
"(syntax2.1"
" content*56_0"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes55_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scopes57_0)(op_0(syntax-scopes s_1) sc_1))"
"((content*58_0)"
"(if(datum-has-elements? content_0)"
"(let-values(((prop_0)"
"(prop-op_0"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))))"
"(if prop_0(modified-content1.1 content_0 prop_0) content_0))"
" content*_0)))"
"(syntax2.1"
" content*58_0"
" scopes57_0"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))))"
"(define-values"
"(flip-scopes)"
"(lambda(s_0 scs_0)"
"(begin"
"(let-values(((s_1)(let-values(((s_1) s_0)) s_1)))"
"(let-values(((lst_0) scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sc_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_3)"
"(let-values(((s_3)(let-values()(flip-scope s_2 sc_0))))"
"(values s_3))))"
"(if(not #f)(for-loop_0 s_3 rest_0) s_3)))"
" s_2))))))"
" for-loop_0)"
" s_1"
" lst_0)))))))"
"(define-values"
"(push-scope)"
"(lambda(s_0 sms_0)"
"(begin"
"(let-values(((smss/maybe-fallbacks59_0) #f))"
"(let-values(((prev-result_0) #f))"
"(let-values(((push_0)"
"(lambda(smss/maybe-fallbacks_0)"
"(begin"
" 'push"
"(if(eq? smss/maybe-fallbacks59_0 smss/maybe-fallbacks_0)"
"(let-values() prev-result_0)"
"(let-values()"
"(let-values(((r_0)"
"(let-values()"
"(let-values(((smss_0)(fallback-first smss/maybe-fallbacks_0)))"
"(if(set-empty? smss_0)"
"(let-values()(set-add smss_0 sms_0))"
"(if(set-member? smss_0 sms_0)"
"(let-values() smss/maybe-fallbacks_0)"
"(let-values()"
"(fallback-push"
"(set-add smss_0 sms_0)"
" smss/maybe-fallbacks_0))))))))"
"(begin"
"(set! smss/maybe-fallbacks59_0 smss/maybe-fallbacks_0)"
"(set! prev-result_0 r_0)"
" r_0))))))))"
"(let-values(((s_1) s_0)"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((d->s_0)"
"(lambda(s_1 d_0)"
"(begin"
" 'd->s"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content*60_0)(re-modify-content s_1 d_0))"
"((shifted-multi-scopes61_0)(push_0(syntax-shifted-multi-scopes s_1))))"
"(syntax2.1"
" content*60_0"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes61_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"((s-e_0) syntax-e$1)"
"((seen_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(s_2)"
"(begin"
" 'loop"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(d->s_0 v_0(loop_0(s-e_0 v_0))))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0)"
"((known-pairs_0) #f))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1"
" known-pairs_0))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1 1(cdr s_4) depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)(vector? s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_4)))"
"(if or-part_2"
" or-part_2"
"(hash? s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1"
" known-pairs_0))"
"(let-values()(gf_0 #f s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0))))))"
" loop_0)"
" s_1))))))))"
"(define-values"
"(struct:propagation"
" propagation12.1"
" propagation?"
" propagation-prev-scs"
" propagation-prev-smss"
" propagation-scope-ops"
" propagation-prev-mss"
" propagation-add-mpi-shifts"
" propagation-inspector"
" propagation-taint)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'propagation"
" #f"
" 7"
" 0"
" #f"
"(list"
"(cons prop:sealed #t)"
"(cons prop:authentic #t)"
"(cons prop:propagation-set-taint(lambda(p_0 v_0)(propagation-set-taint p_0 v_0)))"
"(cons prop:propagation-taint(lambda(p_0)(propagation-taint p_0)))"
"(cons prop:propagation syntax-e$1))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'propagation)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'prev-scs)"
"(make-struct-field-accessor -ref_0 1 'prev-smss)"
"(make-struct-field-accessor -ref_0 2 'scope-ops)"
"(make-struct-field-accessor -ref_0 3 'prev-mss)"
"(make-struct-field-accessor -ref_0 4 'add-mpi-shifts)"
"(make-struct-field-accessor -ref_0 5 'inspector)"
"(make-struct-field-accessor -ref_0 6 'taint))))"
"(define-values"
"(propagation-add)"
"(lambda(prop_0 sc_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((scope-ops63_0)(hash-set(propagation-scope-ops prop_0) sc_0 'add)))"
"(propagation12.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
" scope-ops63_0"
"(propagation-prev-mss the-struct_0)"
"(propagation-add-mpi-shifts the-struct_0)"
"(propagation-inspector the-struct_0)"
"(propagation-taint the-struct_0)))"
"            (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))"
"(propagation12.1 prev-scs_0 prev-smss_0(hasheq sc_0 'add) prev-mss_0 #f #f prop_0)))))"
"(define-values"
"(propagation-remove)"
"(lambda(prop_0 sc_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((scope-ops64_0)(hash-set(propagation-scope-ops prop_0) sc_0 'remove)))"
"(propagation12.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
" scope-ops64_0"
"(propagation-prev-mss the-struct_0)"
"(propagation-add-mpi-shifts the-struct_0)"
"(propagation-inspector the-struct_0)"
"(propagation-taint the-struct_0)))"
"            (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))"
"(propagation12.1 prev-scs_0 prev-smss_0(hasheq sc_0 'remove) prev-mss_0 #f #f prop_0)))))"
"(define-values"
"(propagation-flip)"
"(lambda(prop_0 sc_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((ops_0)(propagation-scope-ops prop_0)))"
"(let-values(((current-op_0)(hash-ref ops_0 sc_0 #f)))"
"(if(if(eq? current-op_0 'flip)"
"(if(= 1(hash-count ops_0))"
"(if(not(propagation-inspector prop_0))(not(propagation-add-mpi-shifts prop_0)) #f)"
" #f)"
" #f)"
"(let-values()(propagation-taint prop_0))"
"(let-values()"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((scope-ops65_0)"
"(if(eq? current-op_0 'flip)"
"(hash-remove ops_0 sc_0)"
"(hash-set"
" ops_0"
" sc_0"
"(let-values(((tmp_0) current-op_0))"
"(if(equal? tmp_0 'add)"
"(let-values() 'remove)"
"(if(equal? tmp_0 'remove)(let-values() 'add)(let-values() 'flip))))))))"
"(propagation12.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
" scope-ops65_0"
"(propagation-prev-mss the-struct_0)"
"(propagation-add-mpi-shifts the-struct_0)"
"(propagation-inspector the-struct_0)"
"(propagation-taint the-struct_0)))"
"                    (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))))))"
"(propagation12.1 prev-scs_0 prev-smss_0(hasheq sc_0 'flip) prev-mss_0 #f #f prop_0)))))"
"(define-values"
"(propagation-mpi-shift)"
"(lambda(prop_0 add_0 inspector_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((add-mpi-shifts66_0)"
"(let-values(((base-add_0)(propagation-add-mpi-shifts prop_0)))"
"(if(if add_0 base-add_0 #f)"
"(lambda(mss_0)(begin 'add-mpi-shifts66(add_0(base-add_0 mss_0))))"
"(let-values(((or-part_0) add_0))(if or-part_0 or-part_0 base-add_0)))))"
"((inspector67_0)"
"(let-values(((or-part_0)(propagation-inspector prop_0)))"
"(if or-part_0 or-part_0 inspector_0))))"
"(propagation12.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
"(propagation-scope-ops the-struct_0)"
"(propagation-prev-mss the-struct_0)"
" add-mpi-shifts66_0"
" inspector67_0"
"(propagation-taint the-struct_0)))"
"            (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))"
"(propagation12.1 prev-scs_0 prev-smss_0 '#hasheq() prev-mss_0 add_0 inspector_0 prop_0)))))"
"(define-values"
"(propagation-apply)"
"(lambda(prop_0 scs_0 parent-s_0)"
"(begin"
"(if(eq?(propagation-prev-scs prop_0) scs_0)"
"(let-values()(syntax-scopes parent-s_0))"
"(let-values()"
"(let-values(((new-scs_0)"
"(let-values(((scs_1)(let-values(((scs_1) scs_0)) scs_1)))"
"(let-values(((ht_0)(propagation-scope-ops prop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(scs_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0 op_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((scs_3)"
"(if(not(shifted-multi-scope? sc_0))"
"(let-values(((scs_3)"
"(let-values()"
"(let-values(((tmp_0) op_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(set-add scs_2 sc_0))"
"(if(equal? tmp_0 'remove)"
"(let-values()"
"(set-remove"
" scs_2"
" sc_0))"
"(let-values()"
"(set-flip"
" scs_2"
" sc_0))))))))"
"(values scs_3))"
" scs_2)))"
"(if(not #f)"
"(for-loop_0"
" scs_3"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" scs_3)))"
" scs_2))))))"
" for-loop_0)"
" scs_1"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(if(set=? new-scs_0(syntax-scopes parent-s_0))"
"(syntax-scopes parent-s_0)"
"(cache-or-reuse-set new-scs_0))))))))"
"(define-values"
"(propagation-apply-shifted)"
"(lambda(prop_0 smss_0 parent-s_0)"
"(begin"
"(if(eq?(propagation-prev-smss prop_0) smss_0)"
"(let-values()(syntax-shifted-multi-scopes parent-s_0))"
"(let-values()"
"(let-values(((new-smss_0)"
"(let-values(((smss_1)(let-values(((smss_1) smss_0)) smss_1)))"
"(let-values(((ht_0)(propagation-scope-ops prop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(smss_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sms_0 op_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((smss_3)"
"(if(shifted-multi-scope? sms_0)"
"(let-values(((smss_3)"
"(let-values()"
"(fallback-update-first"
" smss_2"
"(lambda(smss_3)"
"(let-values(((tmp_0)"
" op_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(set-add"
" smss_3"
" sms_0))"
"(if(equal?"
" tmp_0"
" 'remove)"
"(let-values()"
"(set-remove"
" smss_3"
" sms_0))"
"(let-values()"
"(set-flip"
" smss_3"
" sms_0))))))))))"
"(values smss_3))"
" smss_2)))"
"(if(not #f)"
"(for-loop_0"
" smss_3"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" smss_3)))"
" smss_2))))))"
" for-loop_0)"
" smss_1"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(let-values(((parent-smss_0)(syntax-shifted-multi-scopes parent-s_0)))"
"(if(if(set? new-smss_0)(if(set? parent-smss_0)(set=? new-smss_0 parent-smss_0) #f) #f)"
" parent-smss_0"
"(cache-or-reuse-hash new-smss_0)))))))))"
"(define-values"
"(propagation-apply-mpi-shifts)"
"(lambda(prop_0 mss_0 parent-s_0)"
"(begin"
"(if(eq?(propagation-prev-mss prop_0) mss_0)"
"(let-values()(syntax-mpi-shifts parent-s_0))"
"(let-values()(let-values(((add_0)(propagation-add-mpi-shifts prop_0)))(if add_0(add_0 mss_0) mss_0)))))))"
"(define-values"
"(propagation-apply-inspector)"
"(lambda(prop_0 i_0)"
"(begin(let-values(((or-part_0) i_0))(if or-part_0 or-part_0(propagation-inspector prop_0))))))"
"(define-values"
"(propagation-set-taint)"
"(lambda(prop_0 t_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((taint68_0) t_0))"
"(propagation12.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
"(propagation-scope-ops the-struct_0)"
"(propagation-prev-mss the-struct_0)"
"(propagation-add-mpi-shifts the-struct_0)"
"(propagation-inspector the-struct_0)"
" taint68_0))"
"            (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))"
" t_0))))"
"(define-values"
"(propagation-merge)"
"(lambda(content_0 prop_0 base-prop_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(not(datum-has-elements? content_0))"
"(let-values()(if(propagation-taint prop_0) 'tainted base-prop_0))"
"(if(not(propagation? base-prop_0))"
"(let-values()"
"(if(if(eq?(propagation-prev-scs prop_0) prev-scs_0)"
"(if(eq?(propagation-prev-smss prop_0) prev-smss_0)"
"(if(eq?(propagation-prev-mss prop_0) prev-mss_0)(eq?(propagation-taint prop_0) base-prop_0) #f)"
" #f)"
" #f)"
"(let-values() prop_0)"
"(let-values()"
"(propagation12.1"
" prev-scs_0"
" prev-smss_0"
"(propagation-scope-ops prop_0)"
" prev-mss_0"
"(propagation-add-mpi-shifts prop_0)"
"(propagation-inspector prop_0)"
"(if(propagation-taint prop_0) 'tainted/need-propagate base-prop_0)))))"
"(let-values()"
"(let-values(((new-ops_0)"
"(let-values(((ops_0)(let-values(((ops_0)(propagation-scope-ops base-prop_0))) ops_0)))"
"(let-values(((ht_0)(propagation-scope-ops prop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ops_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0 op_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((ops_2)"
"(let-values(((ops_2)"
"(let-values()"
"(let-values(((tmp_0) op_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'add))"
"(if(equal? tmp_0 'remove)"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'remove))"
"(let-values()"
"(let-values(((current-op_0)"
"(hash-ref"
" ops_1"
" sc_0"
" #f)))"
"(let-values(((tmp_1)"
" current-op_0))"
"(if(equal?"
" tmp_1"
" 'add)"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'remove))"
"(if(equal?"
" tmp_1"
" 'remove)"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'add))"
"(if(equal?"
" tmp_1"
" 'flip)"
"(let-values()"
"(hash-remove"
" ops_1"
" sc_0))"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'flip))))))))))))))"
"(values ops_2))))"
"(if(not #f)"
"(for-loop_0"
" ops_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" ops_2)))"
" ops_1))))))"
" for-loop_0)"
" ops_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(let-values(((add_0)(propagation-add-mpi-shifts prop_0)))"
"(let-values(((base-add_0)(propagation-add-mpi-shifts base-prop_0)))"
"(let-values(((new-taint_0)"
"(if(let-values(((or-part_0)(propagation-taint prop_0)))"
"(if or-part_0 or-part_0(propagation-taint base-prop_0)))"
" 'tainted/need-propagate"
"(propagation-taint base-prop_0))))"
"(if(if(zero?(hash-count new-ops_0))"
"(if(not add_0)"
"(if(not base-add_0)"
"(if(not(propagation-inspector prop_0))(not(propagation-inspector base-prop_0)) #f)"
" #f)"
" #f)"
" #f)"
" new-taint_0"
"(let-values(((the-struct_0) base-prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((scope-ops69_0) new-ops_0)"
"((add-mpi-shifts70_0)"
"(if(if add_0 base-add_0 #f)"
"(lambda(mss_0)(begin 'add-mpi-shifts70(add_0(base-add_0 mss_0))))"
"(let-values(((or-part_0) add_0))(if or-part_0 or-part_0 base-add_0))))"
"((inspector71_0)"
"(let-values(((or-part_0)(propagation-inspector base-prop_0)))"
"(if or-part_0 or-part_0(propagation-inspector prop_0))))"
"((taint72_0) new-taint_0))"
"(propagation12.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
" scope-ops69_0"
"(propagation-prev-mss the-struct_0)"
" add-mpi-shifts70_0"
" inspector71_0"
" taint72_0))"
"                          (raise-argument-error 'struct-copy \"propagation?\" the-struct_0))))))))))))))"
"(define-values"
"(shift-multi-scope)"
"(lambda(sms_0 delta_0)"
"(begin"
"(if(zero-phase? delta_0)"
"(let-values() sms_0)"
"(if(label-phase? delta_0)"
"(let-values()"
"(if(shifted-to-label-phase?(shifted-multi-scope-phase sms_0))"
"(let-values() #f)"
"(let-values()"
"(intern-shifted-multi-scope"
"(shifted-to-label-phase6.1(phase- 0(shifted-multi-scope-phase sms_0)))"
"(shifted-multi-scope-multi-scope sms_0)))))"
"(if(shifted-to-label-phase?(shifted-multi-scope-phase sms_0))"
"(let-values() sms_0)"
"(let-values()"
"(intern-shifted-multi-scope"
"(phase+ delta_0(shifted-multi-scope-phase sms_0))"
"(shifted-multi-scope-multi-scope sms_0)))))))))"
"(define-values"
"(syntax-shift-phase-level$1)"
"(lambda(s_0 phase_0)"
"(begin"
" 'syntax-shift-phase-level"
"(if(eqv? phase_0 0)"
" s_0"
"(let-values()"
"(let-values(((smss73_0) #f))"
"(let-values(((prev-result_0) #f))"
"(let-values(((shift-all_0)"
"(lambda(smss_0)"
"(begin"
" 'shift-all"
"(if(eq? smss73_0 smss_0)"
"(let-values() prev-result_0)"
"(let-values()"
"(let-values(((r_0)"
"(let-values()"
"(fallback-map"
" smss_0"
"(lambda(smss_1)"
"(let-values(((table_0)"
"(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0) smss_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sms_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((id*_0)"
"(shift-multi-scope"
" sms_0"
" phase_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2)"
"(begin"
" 'for-loop"
"(let-values(((new-sms_0)"
" id*_0))"
"(let-values(((table_3)"
"(if new-sms_0"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(let-values()"
" new-sms_0)"
" #t))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values"
" table_3))"
" table_2)))"
" table_3))))))"
" for-loop_1)"
" table_1))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))))"
"(begin(set! smss73_0 smss_0)(set! prev-result_0 r_0) r_0))))))))"
"(let-values(((s_1) s_0)"
"((f_0)(lambda(tail?_0 d_0)(begin 'f d_0)))"
"((d->s_0)"
"(lambda(s_1 d_0)"
"(begin"
" 'd->s"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content*74_0)(re-modify-content s_1 d_0))"
"((shifted-multi-scopes75_0)"
"(shift-all_0(syntax-shifted-multi-scopes s_1))))"
"(syntax2.1"
" content*74_0"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes75_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                      (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"((s-e_0) syntax-e$1)"
"((seen_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(s_2)"
"(begin"
" 'loop"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(d->s_0 v_0(loop_0(s-e_0 v_0))))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0)"
"((known-pairs_0) #f))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1"
" known-pairs_0))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1 1(cdr s_4) depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)"
"(vector? s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box? s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_4)))"
"(if or-part_2"
" or-part_2"
"(hash? s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)"
"(gf_0 tail?_1 s_5))"
" seen_1"
" known-pairs_0))"
"(let-values()"
"(gf_0 #f s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0))))))"
" loop_0)"
" s_1))))))))))"
"(define-values"
"(shifted-multi-scope-add-binding-phases)"
"(lambda(sms_0 phases_0)"
"(begin"
"(let-values(((ms_0)(shifted-multi-scope-multi-scope sms_0)))"
"(let-values(((phase_0)(shifted-multi-scope-phase sms_0)))"
"(if(shifted-to-label-phase? phase_0)"
"(let-values()(set-add phases_0 #f))"
"(let-values()"
"(let-values(((phases_1)(let-values(((phases_1) phases_0)) phases_1)))"
"(let-values(((ht_0)(unbox(multi-scope-scopes ms_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(phases_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((ph_0)(hash-iterate-key ht_0 i_0)))"
"(let-values(((phases_3)"
"(let-values(((phases_3)"
"(let-values()"
"(if(label-phase? ph_0)"
"(set-add phases_2 #f)"
"(set-add"
" phases_2"
"(phase- phase_0 ph_0))))))"
"(values phases_3))))"
"(if(not #f)"
"(for-loop_0 phases_3(hash-iterate-next ht_0 i_0))"
" phases_3)))"
" phases_2))))))"
" for-loop_0)"
" phases_1"
"(hash-iterate-first ht_0))))))))))))"
"(define-values"
"(syntax-swap-scopes)"
"(lambda(s_0 src-scopes_0 dest-scopes_0)"
"(begin"
"(if(equal? src-scopes_0 dest-scopes_0)"
" s_0"
"(let-values(((src-smss_0 src-scs_0)"
"(set-partition"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0) src-scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
"(generalize-scope"
" sc_0))"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
" shifted-multi-scope?"
"(seteq)"
"(seteq)))"
"((dest-smss_0 dest-scs_0)"
"(set-partition"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0) dest-scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
"(generalize-scope"
" sc_0))"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
" shifted-multi-scope?"
"(seteq)"
"(seteq))))"
"(let-values(((scs76_0) #f))"
"(let-values(((prev-result_0) #f))"
"(let-values(((swap-scs_0)"
"(lambda(scs_0)"
"(begin"
" 'swap-scs"
"(if(eq? scs76_0 scs_0)"
"(let-values() prev-result_0)"
"(let-values()"
"(let-values(((r_0)"
"(let-values()"
"(if(subset? src-scs_0 scs_0)"
"(set-union(set-subtract scs_0 src-scs_0) dest-scs_0)"
" scs_0))))"
"(begin(set! scs76_0 scs_0)(set! prev-result_0 r_0) r_0))))))))"
"(let-values(((smss77_0) #f))"
"(let-values(((prev-result_1) #f))"
"(let-values(((swap-smss_0)"
"(lambda(smss_0)"
"(begin"
" 'swap-smss"
"(if(eq? smss77_0 smss_0)"
"(let-values() prev-result_1)"
"(let-values()"
"(let-values(((r_0)"
"(let-values()"
"(fallback-update-first"
" smss_0"
"(lambda(smss_1)"
"(if(subset? src-smss_0 smss_1)"
"(set-union(set-subtract smss_1 src-smss_0) dest-smss_0)"
" smss_1))))))"
"(begin(set! smss77_0 smss_0)(set! prev-result_1 r_0) r_0))))))))"
"(let-values(((s_1) s_0)"
"((f_0)(lambda(tail?_0 d_0)(begin 'f d_0)))"
"((d->s_0)"
"(lambda(s_1 d_0)"
"(begin"
" 'd->s"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content*78_0)(re-modify-content s_1 d_0))"
"((scopes79_0)(swap-scs_0(syntax-scopes s_1)))"
"((shifted-multi-scopes80_0)"
"(swap-smss_0(syntax-shifted-multi-scopes s_1))))"
"(syntax2.1"
" content*78_0"
" scopes79_0"
" shifted-multi-scopes80_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                            (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"((s-e_0) syntax-e$1)"
"((seen_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(s_2)"
"(begin"
" 'loop"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(d->s_0 v_0(loop_0(s-e_0 v_0))))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0)"
"((known-pairs_0) #f))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1"
" known-pairs_0))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1 1(cdr s_4) depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)"
"(vector? s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box? s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_4)))"
"(if or-part_2"
" or-part_2"
"(hash? s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)"
"(gf_0 tail?_1 s_5))"
" seen_1"
" known-pairs_0))"
"(let-values()"
"(gf_0 #f s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0))))))"
" loop_0)"
" s_1)))))))))))))"
"(define-values"
"(syntax-scope-set)"
"(lambda(s_0 phase_0)(begin(scope-set-at-fallback s_0(fallback-first(syntax-shifted-multi-scopes s_0)) phase_0))))"
"(define-values"
"(scope-set-at-fallback)"
"(lambda(s_0 smss_0 phase_0)"
"(begin"
"(let-values(((scopes_0)(let-values(((scopes_0)(syntax-scopes s_0))) scopes_0)))"
"(let-values(((ht_0) smss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(scopes_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sms_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((scopes_2)"
"(if(let-values(((or-part_0)(label-phase? phase_0)))"
"(if or-part_0"
" or-part_0"
"(not"
"(shifted-to-label-phase?"
"(shifted-multi-scope-phase sms_0)))))"
"(let-values(((scopes_2)"
"(let-values()"
"(set-add"
" scopes_1"
"(multi-scope-to-scope-at-phase"
"(shifted-multi-scope-multi-scope sms_0)"
"(let-values(((ph_0)"
"(shifted-multi-scope-phase"
" sms_0)))"
"(if(shifted-to-label-phase? ph_0)"
"(shifted-to-label-phase-from ph_0)"
"(phase- ph_0 phase_0))))))))"
"(values scopes_2))"
" scopes_1)))"
"(if(not #f)"
"(for-loop_0 scopes_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" scopes_2)))"
" scopes_1))))))"
" for-loop_0)"
" scopes_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(find-max-scope)"
"(lambda(scopes_0)"
"(begin"
"(begin"
"        (if (set-empty? scopes_0) (let-values () (error \"cannot bind in empty scope set\")) (void))"
"(let-values(((max-sc_0)(let-values(((max-sc_0)(set-first scopes_0))) max-sc_0)))"
"(let-values(((ht_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(max-sc_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((max-sc_2)"
"(let-values(((max-sc_2)"
"(let-values()"
"(if(scope>? sc_0 max-sc_1) sc_0 max-sc_1))))"
"(values max-sc_2))))"
"(if(not #f)"
"(for-loop_0 max-sc_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" max-sc_2)))"
" max-sc_1))))))"
" for-loop_0)"
" max-sc_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))"
"(define-values"
"(add-binding-in-scopes!.1)"
"(lambda(just-for-nominal?13_0 scopes15_0 sym16_0 binding17_0)"
"(begin"
" 'add-binding-in-scopes!"
"(let-values(((scopes_0) scopes15_0))"
"(let-values(((sym_0) sym16_0))"
"(let-values(((binding_0) binding17_0))"
"(let-values(((just-for-nominal?_0) just-for-nominal?13_0))"
"(let-values()"
"(let-values(((max-sc_0)(find-max-scope scopes_0)))"
"(let-values(((bt_0)"
"(binding-table-add"
"(scope-binding-table max-sc_0)"
" scopes_0"
" sym_0"
" binding_0"
" just-for-nominal?_0)))"
"(begin(set-scope-binding-table! max-sc_0 bt_0)(clear-resolve-cache! sym_0))))))))))))"
"(define-values"
"(add-bulk-binding-in-scopes!.1)"
"(lambda(shadow-except19_0 scopes21_0 bulk-binding22_0)"
"(begin"
" 'add-bulk-binding-in-scopes!"
"(let-values(((scopes_0) scopes21_0))"
"(let-values(((bulk-binding_0) bulk-binding22_0))"
"(let-values(((shadow-except_0) shadow-except19_0))"
"(let-values()"
"(let-values(((max-sc_0)(find-max-scope scopes_0)))"
"(let-values(((bt_0)"
"(let-values(((temp81_0)(scope-binding-table max-sc_0))"
"((scopes82_0) scopes_0)"
"((bulk-binding83_0) bulk-binding_0)"
"((shadow-except84_0) shadow-except_0))"
"(binding-table-add-bulk.1 shadow-except84_0 temp81_0 scopes82_0 bulk-binding83_0))))"
"(begin(set-scope-binding-table! max-sc_0 bt_0)(clear-resolve-cache!)))))))))))"
"(define-values"
"(syntax-any-macro-scopes?)"
"(lambda(s_0)"
"(begin"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((ht_0)(syntax-scopes s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()(eq?(scope-kind sc_0) 'macro)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) sc_0))(not #f) #f)"
"(for-loop_0 result_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(resolve.1)"
"(lambda(ambiguous-value24_0 exactly?25_0 extra-shifts27_0 get-scopes?26_0 s32_0 phase33_0)"
"(begin"
" 'resolve"
"(let-values(((s_0) s32_0))"
"(let-values(((phase_0) phase33_0))"
"(let-values(((ambiguous-value_0) ambiguous-value24_0))"
"(let-values(((exactly?_0) exactly?25_0))"
"(let-values(((get-scopes?_0) get-scopes?26_0))"
"(let-values(((extra-shifts_0) extra-shifts27_0))"
"(let-values()"
"(let-values(((sym_0)(syntax-content s_0)))"
"((letrec-values(((fallback-loop_0)"
"(lambda(smss_0)"
"(begin"
" 'fallback-loop"
"(let-values(((c1_0)"
"(if(not exactly?_0)"
"(if(not get-scopes?_0)"
"(resolve-cache-get"
" sym_0"
" phase_0"
"(syntax-scopes s_0)"
"(fallback-first smss_0))"
" #f)"
" #f)))"
"(if c1_0"
"((lambda(b_0)"
"(if(eq? b_0 '#:none)"
"(let-values()"
"(if(fallback? smss_0)"
"(fallback-loop_0(fallback-rest smss_0))"
" #f))"
"(let-values() b_0)))"
" c1_0)"
"(let-values()"
"(let-values(((scopes_0)"
"(scope-set-at-fallback"
" s_0"
"(fallback-first smss_0)"
" phase_0)))"
"(let-values(((best-scopes_0 best-binding_0)"
"(let-values(((best-scopes_0)"
"(let-values(((best-scopes_0) #f))"
" best-scopes_0))"
"((best-binding_0)"
"(let-values(((best-binding_0) #f))"
" best-binding_0)))"
"(let-values(((ht_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(best-scopes_1"
" best-binding_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((best-scopes_2"
" best-binding_2)"
"(let-values(((ht_1"
" bulk-bindings_0)"
"(let-values(((table_0)"
"(scope-binding-table"
" sc_0)))"
"(if(hash?"
" table_0)"
"(values"
"(hash-ref"
" table_0"
" sym_0"
" '#hash())"
" null)"
"(values"
"(hash-ref"
"(table-with-bulk-bindings-syms"
" table_0)"
" sym_0"
" '#hash())"
"(table-with-bulk-bindings-bulk-bindings"
" table_0)))))"
"((s_1)"
" s_0)"
"((extra-shifts_1)"
" extra-shifts_0))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(best-scopes_2"
" best-binding_2"
" i_1)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" i_1))"
"(let-values(((b-scopes_0)"
"(if(pair?"
" i_1)"
"(let-values()"
"(bulk-binding-at-scopes"
"(car"
" i_1)))"
"(let-values()"
"(hash-iterate-key"
" ht_1"
" i_1))))"
"((binding_0)"
"(if(pair?"
" i_1)"
"(let-values()"
"(let-values(((bulk_0)"
"(bulk-binding-at-bulk"
"(car"
" i_1))))"
"(let-values(((b-info_0)"
"(if(symbol-interned?"
" sym_0)"
"(hash-ref"
"(bulk-binding-symbols"
" bulk_0"
" s_1"
" extra-shifts_1)"
" sym_0"
" #f)"
" #f)))"
"(if b-info_0"
"((bulk-binding-create"
" bulk_0)"
" bulk_0"
" b-info_0"
" sym_0)"
" #f))))"
"(let-values()"
"(hash-iterate-value"
" ht_1"
" i_1)))))"
"(let-values(((best-scopes_3"
" best-binding_3)"
"(if(if b-scopes_0"
"(if binding_0"
"(subset?"
" b-scopes_0"
" scopes_0)"
" #f)"
" #f)"
"(let-values(((best-scopes_3"
" best-binding_3)"
"(let-values()"
"(if(pair?"
" best-scopes_2)"
"(let-values()"
"(if(let-values(((result_0)"
"(let-values(((result_0)"
" #t))"
" result_0)))"
"(let-values(((lst_0)"
" best-scopes_2))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_2)"
"(lambda(result_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((amb-scopes_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(subset?"
" amb-scopes_0"
" b-scopes_0)))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" amb-scopes_0))"
"(not"
" #f)"
" #f)"
"(for-loop_2"
" result_2"
" rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_2)"
" result_0"
" lst_0))))"
"(let-values()"
"(values"
" b-scopes_0"
" binding_0))"
"(let-values()"
"(values"
"(cons"
" b-scopes_0"
" best-scopes_2)"
" #f))))"
"(if(not"
" best-scopes_2)"
"(let-values()"
"(values"
" b-scopes_0"
" binding_0))"
"(if(subset?"
" b-scopes_0"
" best-scopes_2)"
"(let-values()"
"(values"
" best-scopes_2"
" best-binding_2))"
"(if(subset?"
" best-scopes_2"
" b-scopes_0)"
"(let-values()"
"(values"
" b-scopes_0"
" binding_0))"
"(let-values()"
"(values"
"(list"
" best-scopes_2"
" b-scopes_0)"
" #f)))))))))"
"(values"
" best-scopes_3"
" best-binding_3))"
"(values"
" best-scopes_2"
" best-binding_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" best-scopes_3"
" best-binding_3"
"(if(pair?"
" i_1)"
"(let-values()"
"(cdr"
" i_1))"
"(let-values()"
"(let-values(((or-part_0)"
"(hash-iterate-next"
" ht_1"
" i_1)))"
"(if or-part_0"
" or-part_0"
" bulk-bindings_0)))))"
"(values"
" best-scopes_3"
" best-binding_3))))"
"(values"
" best-scopes_2"
" best-binding_2))))))"
" for-loop_1)"
" best-scopes_1"
" best-binding_1"
"(let-values(((or-part_0)"
"(hash-iterate-first"
" ht_1)))"
"(if or-part_0"
" or-part_0"
" bulk-bindings_0)))))))"
"(if(not #f)"
"(for-loop_0"
" best-scopes_2"
" best-binding_2"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
"(values"
" best-scopes_2"
" best-binding_2))))"
"(values"
" best-scopes_1"
" best-binding_1)))))))"
" for-loop_0)"
" best-scopes_0"
" best-binding_0"
"(unsafe-immutable-hash-iterate-first"
" ht_0)))))))"
"(if(pair? best-scopes_0)"
"(let-values()"
"(if(fallback? smss_0)"
"(fallback-loop_0(fallback-rest smss_0))"
" ambiguous-value_0))"
"(if best-scopes_0"
"(let-values()"
"(begin"
"(resolve-cache-set!"
" sym_0"
" phase_0"
"(syntax-scopes s_0)"
"(fallback-first smss_0)"
" best-binding_0)"
"(if(let-values(((or-part_0)(not exactly?_0)))"
"(if or-part_0"
" or-part_0"
"(eqv?"
"(set-count scopes_0)"
"(set-count best-scopes_0))))"
"(if get-scopes?_0 best-scopes_0 best-binding_0)"
" #f)))"
"(let-values()"
"(begin"
"(resolve-cache-set!"
" sym_0"
" phase_0"
"(syntax-scopes s_0)"
"(fallback-first smss_0)"
" '#:none)"
"(if(fallback? smss_0)"
"(fallback-loop_0(fallback-rest smss_0))"
" #f))))))))))))))"
" fallback-loop_0)"
"(syntax-shifted-multi-scopes s_0)))))))))))))"
"(define-values"
"(bound-identifier=?$1)"
"(lambda(a_0 b_0 phase_0)"
"(begin"
" 'bound-identifier=?"
"(if(eq?(syntax-e$1 a_0)(syntax-e$1 b_0))"
"(equal?(syntax-scope-set a_0 phase_0)(syntax-scope-set b_0 phase_0))"
" #f))))"
"(define-values"
"(local-binding?)"
"(lambda(b_0)(begin(let-values(((or-part_0)(full-local-binding? b_0)))(if or-part_0 or-part_0(symbol? b_0))))))"
"(define-values"
"(struct:full-local-binding full-local-binding1.1 full-local-binding? full-local-binding-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'full-local-binding"
" struct:full-binding"
" 1"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:local-binding)"
"(ser-push!_0(full-local-binding-key b_0))"
"(ser-push!_0(full-binding-free=id b_0))))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'full-local-binding)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'key))))"
"(define-values"
"(deserialize-full-local-binding)"
"(lambda(key_0 free=id_0)(begin(full-local-binding1.1 #f free=id_0 key_0))))"
"(define-values"
"(make-local-binding.1)"
"(lambda(frame-id2_0 free=id3_0 key6_0)"
"(begin"
" 'make-local-binding"
"(let-values(((key_0) key6_0))"
"(let-values(((frame-id_0) frame-id2_0))"
"(let-values(((free=id_0) free=id3_0))"
"(let-values()"
"(if(if(not frame-id_0)(not free=id_0) #f)"
"(let-values() key_0)"
"(let-values()(full-local-binding1.1 frame-id_0 free=id_0 key_0))))))))))"
"(define-values"
"(local-binding-update.1)"
"(lambda(frame-id9_0 free=id10_0 key8_0 b14_0)"
"(begin"
" 'local-binding-update"
"(let-values(((b_0) b14_0))"
"(let-values(((key_0)(if(eq? key8_0 unsafe-undefined)(local-binding-key b_0) key8_0)))"
"(let-values(((frame-id_0)(if(eq? frame-id9_0 unsafe-undefined)(binding-frame-id b_0) frame-id9_0)))"
"(let-values(((free=id_0)(if(eq? free=id10_0 unsafe-undefined)(binding-free=id b_0) free=id10_0)))"
"(let-values()"
"(let-values(((key17_0) key_0)((frame-id18_0) frame-id_0)((free=id19_0) free=id_0))"
"(make-local-binding.1 frame-id18_0 free=id19_0 key17_0))))))))))"
"(define-values"
"(local-binding-key)"
"(lambda(b_0)(begin(if(full-local-binding? b_0)(full-local-binding-key b_0) b_0))))"
"(define-values"
"(1/prop:rename-transformer 1/rename-transformer? rename-transformer-value)"
"(make-struct-type-property"
" 'rename-transformer"
"(lambda(v_0 info_0)"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(exact-nonnegative-integer? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(identifier? v_0)))"
"(if or-part_1 or-part_1(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'guard-for-prop:rename-transformer"
"(string-append"
"                           \"(or/c exact-nonnegative-integer?\\n\""
"                           \"      identifier?\\n\""
"                           \"      (procedure-arity-includes? proc 1))\")"
" v_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(exact-nonnegative-integer? v_0)"
"(let-values()"
"(begin"
"(if(<= v_0(list-ref info_0 1))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'guard-for-prop:rename-transformer"
"                                  \"field index >= initialized-field count for structure type\""
"                                  \"field index\""
" v_0"
"                                  \"initialized-field count\""
"(list-ref info_0 1))))"
"(if(member v_0(list-ref info_0 5))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'guard-for-prop:rename-transformer"
"                                  \"field index not declared immutable\""
"                                  \"field index\""
" v_0)))))"
"(void))"
"(values))))"
"(let-values(((ref_0)(list-ref info_0 3)))"
"(if(identifier? v_0)"
"(let-values()(lambda(t_0) v_0))"
"(if(integer? v_0)"
"(let-values()"
"(lambda(t_0)"
"(let-values(((val_0)(ref_0 t_0 v_0)))(if(identifier? val_0) val_0(datum->syntax$1 #f '?)))))"
"(let-values()"
"(lambda(t_0)"
"(let-values(((id_0)(call-with-continuation-barrier(lambda()(v_0 t_0)))))"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'prop:rename-transformer"
"                            \"contract violation for given value; expected an identifier\""
"                            \"given\""
" id_0)))"
" id_0))))))))))))"
"(define-values"
"(struct:id-rename-transformer id-rename-transformer1.1 id-rename-transformer? id-rename-transformer-id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'rename-transformer"
" #f"
" 1"
" 0"
" #f"
"(list(cons 1/prop:rename-transformer 0))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'id-rename-transformer)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'id))))"
"(define-values"
"(1/make-rename-transformer)"
"(lambda(id_0)"
"(begin"
" 'make-rename-transformer"
"(begin"
"(if(identifier? id_0)"
"(void)"
"          (let-values () (raise-argument-error 'make-rename-transformer \"identifier?\" id_0)))"
"(id-rename-transformer1.1 id_0)))))"
"(define-values"
"(1/rename-transformer-target)"
"(lambda(t_0)(begin 'rename-transformer-target((rename-transformer-value t_0) t_0))))"
"(define-values"
"(free-identifier=?$1)"
"(lambda(a_0 b_0 a-phase_0 b-phase_0)"
"(begin"
" 'free-identifier=?"
"(let-values(((ab_0)"
"(toplevel-as-symbol"
"(let-values(((a46_0) a_0)((a-phase47_0) a-phase_0)((temp48_0) #t))"
"(resolve+shift.1 #f #f null unsafe-undefined temp48_0 a46_0 a-phase47_0)))))"
"(let-values(((bb_0)"
"(toplevel-as-symbol"
"(let-values(((b49_0) b_0)((b-phase50_0) b-phase_0)((temp51_0) #t))"
"(resolve+shift.1 #f #f null unsafe-undefined temp51_0 b49_0 b-phase50_0)))))"
"(if(let-values(((or-part_0)(symbol? ab_0)))(if or-part_0 or-part_0(symbol? bb_0)))"
"(let-values()(eq? ab_0 bb_0))"
"(let-values()(same-binding? ab_0 bb_0))))))))"
"(define-values"
"(toplevel-as-symbol)"
"(lambda(b_0)"
"(begin"
"(if(if(module-binding? b_0)(top-level-module-path-index?(module-binding-module b_0)) #f)"
"(module-binding-sym b_0)"
" b_0))))"
"(define-values"
"(same-binding?)"
"(lambda(ab_0 bb_0)"
"(begin"
"(if(module-binding? ab_0)"
"(let-values()"
"(if(module-binding? bb_0)"
"(if(eq?(module-binding-sym ab_0)(module-binding-sym bb_0))"
"(if(eqv?(module-binding-phase ab_0)(module-binding-phase bb_0))"
"(eq?"
"(1/module-path-index-resolve(module-binding-module ab_0))"
"(1/module-path-index-resolve(module-binding-module bb_0)))"
" #f)"
" #f)"
" #f))"
"(if(local-binding? ab_0)"
"(let-values()(if(local-binding? bb_0)(eq?(local-binding-key ab_0)(local-binding-key bb_0)) #f))"
"          (let-values () (error \"bad binding\" ab_0)))))))"
"(define-values"
"(same-binding-nominals?)"
"(lambda(ab_0 bb_0)"
"(begin"
"(if(eq?"
"(1/module-path-index-resolve(module-binding-nominal-module ab_0))"
"(1/module-path-index-resolve(module-binding-nominal-module bb_0)))"
"(if(eqv?"
"(module-binding-nominal-require-phase+space-shift ab_0)"
"(module-binding-nominal-require-phase+space-shift bb_0))"
"(eqv?(module-binding-nominal-sym ab_0)(module-binding-nominal-sym bb_0))"
" #f)"
" #f))))"
"(define-values"
"(identifier-binding-symbol$1)"
"(lambda(id_0 phase_0)"
"(begin"
" 'identifier-binding-symbol"
"(let-values(((b_0)"
"(let-values(((id52_0) id_0)((phase53_0) phase_0)((temp54_0) #t))"
"(resolve+shift.1 #f #f null unsafe-undefined temp54_0 id52_0 phase53_0))))"
"(if(symbol? b_0)"
"(let-values() b_0)"
"(if(module-binding? b_0)"
"(let-values()(module-binding-sym b_0))"
"(if(local-binding? b_0)(let-values()(local-binding-key b_0))(let-values()(syntax-e$1 id_0)))))))))"
"(define-values"
"(identifier-binding.1)"
"(lambda(exactly?1_0 id4_0 phase5_0 top-level-symbol?3_0)"
"(begin"
" 'identifier-binding"
"(let-values(((id_0) id4_0))"
"(let-values(((phase_0) phase5_0))"
"(let-values(((top-level-symbol?_0) top-level-symbol?3_0))"
"(let-values(((exactly?_0) exactly?1_0))"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id55_0) id_0)((phase56_0) phase_0)((exactly?57_0) exactly?_0))"
"(resolve+shift.1 #f exactly?57_0 null unsafe-undefined #f id55_0 phase56_0))))"
"(if(module-binding? b_0)"
"(let-values()"
"(if(top-level-module-path-index?(module-binding-module b_0))"
"(if top-level-symbol?_0(list(module-binding-nominal-sym b_0)) #f)"
"(list"
"(module-binding-module b_0)"
"(module-binding-sym b_0)"
"(module-binding-nominal-module b_0)"
"(module-binding-nominal-sym b_0)"
"(module-binding-phase b_0)"
"(module-binding-nominal-require-phase+space-shift b_0)"
"(module-binding-nominal-phase+space b_0))))"
"(if(local-binding? b_0)(let-values() 'lexical)(let-values() #f))))))))))))"
"(define-values"
"(identifier-distinct-binding$1)"
"(let-values(((identifier-distinct-binding_0)"
"(lambda(id8_0 other-id9_0 phase10_0 top-level-symbol?7_0)"
"(begin"
" 'identifier-distinct-binding"
"(let-values(((id_0) id8_0))"
"(let-values(((other-id_0) other-id9_0))"
"(let-values(((phase_0) phase10_0))"
"(let-values(((top-level-symbol?_0) top-level-symbol?7_0))"
"(let-values()"
"(let-values(((scs_0)"
"(let-values(((id58_0) id_0)((phase59_0) phase_0)((temp60_0) #t))"
"(resolve.1 #f #f null temp60_0 id58_0 phase59_0))))"
"(if(not scs_0)"
"(let-values() #f)"
"(let-values()"
"(let-values(((other-scs_0)(syntax-scope-set other-id_0 phase_0)))"
"(if(not(subset? scs_0 other-scs_0))"
"(let-values(((id61_0) id_0)"
"((phase62_0) phase_0)"
"((top-level-symbol?63_0) top-level-symbol?_0))"
"(identifier-binding.1 #f id61_0 phase62_0 top-level-symbol?63_0))"
" #f))))))))))))))"
"(case-lambda"
"((id_0 other-id_0 phase_0)"
"(begin 'identifier-distinct-binding(identifier-distinct-binding_0 id_0 other-id_0 phase_0 #f)))"
"((id_0 other-id_0 phase_0 top-level-symbol?7_0)"
"(identifier-distinct-binding_0 id_0 other-id_0 phase_0 top-level-symbol?7_0)))))"
"(define-values"
"(identifier-binding-uses-scope?)"
"(lambda(id_0 scope_0 phase_0)"
"(begin"
"(let-values(((scs_0)"
"(let-values(((id64_0) id_0)((phase65_0) phase_0)((temp66_0) #t))"
"(resolve.1 #f #f null temp66_0 id64_0 phase65_0))))"
"(if scs_0(set-member? scs_0 scope_0) #f)))))"
"(define-values"
"(maybe-install-free=id!)"
"(lambda(val_0 id_0 phase_0)"
"(begin"
"(if(1/rename-transformer? val_0)"
"(let-values()"
"(let-values(((free=id_0)(1/rename-transformer-target val_0)))"
"(if(syntax-property$1 free=id_0 'not-free-identifier=?)"
"(void)"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id70_0) id_0)((phase71_0) phase_0)((temp72_0) #t)((temp73_0) #t))"
"(resolve+shift.1 #f temp72_0 null temp73_0 #f id70_0 phase71_0))))"
"(let-values(((temp67_0)(syntax-scope-set id_0 phase_0))"
"((temp68_0)(syntax-e$1 id_0))"
"((temp69_0)(binding-set-free=id b_0 free=id_0)))"
"(add-binding-in-scopes!.1 #f temp67_0 temp68_0 temp69_0)))))))"
"(void)))))"
"(define-values"
"(binding-set-free=id)"
"(lambda(b_0 free=id_0)"
"(begin"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((b74_0) b_0)((free=id75_0) free=id_0))"
"(module-binding-update.1"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" free=id75_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" b74_0)))"
"(if(local-binding? b_0)"
"(let-values()"
"(let-values(((b76_0) b_0)((free=id77_0) free=id_0))"
"(local-binding-update.1 unsafe-undefined free=id77_0 unsafe-undefined b76_0)))"
"          (let-values () (error \"bad binding for free=id:\" b_0)))))))"
"(define-values"
"(struct:non-source-shift non-source-shift11.1 non-source-shift? non-source-shift-from non-source-shift-to)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'non-source-shift #f 2 0 #f null 'prefab #f '(0 1) #f 'non-source-shift)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'from)"
"(make-struct-field-accessor -ref_0 1 'to))))"
"(define-values(shift-from)(lambda(s_0)(begin(if(pair? s_0)(car s_0)(non-source-shift-from s_0)))))"
"(define-values(shift-to)(lambda(s_0)(begin(if(pair? s_0)(cdr s_0)(non-source-shift-to s_0)))))"
"(define-values"
"(syntax-module-path-index-shift.1)"
"(lambda(non-source?12_0 s15_0 from-mpi16_0 to-mpi17_0 inspector14_0)"
"(begin"
" 'syntax-module-path-index-shift"
"(let-values(((s_0) s15_0))"
"(let-values(((from-mpi_0) from-mpi16_0))"
"(let-values(((to-mpi_0) to-mpi17_0))"
"(let-values(((inspector_0) inspector14_0))"
"(let-values(((non-source?_0) non-source?12_0))"
"(let-values()"
"(if(eq? from-mpi_0 to-mpi_0)"
"(let-values()(if inspector_0(syntax-set-inspector s_0 inspector_0) s_0))"
"(let-values()"
"(let-values(((shift_0)"
"(if non-source?_0"
"(non-source-shift11.1 from-mpi_0 to-mpi_0)"
"(cons from-mpi_0 to-mpi_0))))"
"(let-values(((content*_0)(syntax-content* s_0)))"
"(let-values(((content_0)"
"(if(modified-content? content*_0)"
"(modified-content-content content*_0)"
" content*_0)))"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((mpi-shifts79_0)(shift-cons shift_0(syntax-mpi-shifts s_0)))"
"((inspector80_0)"
"(let-values(((or-part_0)(syntax-inspector s_0)))"
"(if or-part_0 or-part_0 inspector_0)))"
"((content*81_0)"
"(if(datum-has-elements? content_0)"
"(modified-content1.1"
" content_0"
"(propagation-mpi-shift"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)"
"(lambda(s_1)(shift-cons shift_0 s_1))"
" inspector_0"
"(syntax-scopes s_0)"
"(syntax-shifted-multi-scopes s_0)"
"(syntax-mpi-shifts s_0)))"
" content*_0)))"
"(syntax2.1"
" content*81_0"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" mpi-shifts79_0"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
" inspector80_0))"
"                                (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))))))))))))"
"(define-values"
"(shift-cons)"
"(lambda(shift_0 shifts_0)"
"(begin"
"(if(if(pair? shifts_0)(eq?(shift-from shift_0)(shift-from(car shifts_0))) #f)"
"(let-values() shifts_0)"
"(let-values()(cons shift_0 shifts_0))))))"
"(define-values"
"(binding-free=id-phase)"
"(lambda(immediate-b_0)(begin(if(module-binding? immediate-b_0)(module-binding-phase immediate-b_0) 0))))"
"(define-values"
"(resolve+shift.1)"
"(lambda(ambiguous-value19_0 exactly?20_0 extra-shifts23_0 immediate?21_0 unbound-sym?22_0 s29_0 phase30_0)"
"(begin"
" 'resolve+shift"
"(let-values(((s_0) s29_0))"
"(let-values(((phase_0) phase30_0))"
"(let-values(((ambiguous-value_0) ambiguous-value19_0))"
"(let-values(((exactly?_0) exactly?20_0))"
"(let-values(((immediate?_0)(if(eq? immediate?21_0 unsafe-undefined) exactly?_0 immediate?21_0)))"
"(let-values(((unbound-sym?_0) unbound-sym?22_0))"
"(let-values(((extra-shifts_0) extra-shifts23_0))"
"(let-values()"
"(let-values(((can-cache?_0)"
"(if(not exactly?_0)(if(not immediate?_0)(null? extra-shifts_0) #f) #f)))"
"(let-values(((c1_0)(if can-cache?_0(resolve+shift-cache-get s_0 phase_0) #f)))"
"(if c1_0"
"((lambda(b_0)(if(eq? b_0 '#:none)(if unbound-sym?_0(syntax-content s_0) #f) b_0)) c1_0)"
"(let-values()"
"(let-values(((immediate-b_0)"
"(let-values(((s82_0) s_0)"
"((phase83_0) phase_0)"
"((ambiguous-value84_0) ambiguous-value_0)"
"((exactly?85_0) exactly?_0)"
"((extra-shifts86_0) extra-shifts_0))"
"(resolve.1"
" ambiguous-value84_0"
" exactly?85_0"
" extra-shifts86_0"
" #f"
" s82_0"
" phase83_0))))"
"(let-values(((b_0)"
"(if(if immediate-b_0"
"(if(not immediate?_0)(binding-free=id immediate-b_0) #f)"
" #f)"
"(let-values(((temp87_0)(binding-free=id immediate-b_0))"
"((temp88_0)(binding-free=id-phase immediate-b_0))"
"((temp89_0)"
"(append extra-shifts_0(syntax-mpi-shifts s_0)))"
"((ambiguous-value90_0) ambiguous-value_0)"
"((exactly?91_0) exactly?_0)"
"((unbound-sym?92_0) unbound-sym?_0))"
"(resolve+shift.1"
" ambiguous-value90_0"
" exactly?91_0"
" temp89_0"
" unsafe-undefined"
" unbound-sym?92_0"
" temp87_0"
" temp88_0))"
" immediate-b_0)))"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((mpi-shifts_0)(syntax-mpi-shifts s_0)))"
"(if(null? mpi-shifts_0)"
"(let-values() b_0)"
"(let-values()"
"(let-values(((mod_0)(module-binding-module b_0)))"
"(let-values(((shifted-mod_0)(apply-syntax-shifts mod_0 mpi-shifts_0)))"
"(let-values(((nominal-mod_0)(module-binding-nominal-module b_0)))"
"(let-values(((shifted-nominal-mod_0)"
"(if(eq? mod_0 nominal-mod_0)"
" shifted-mod_0"
"(apply-syntax-shifts nominal-mod_0 mpi-shifts_0))))"
"(let-values(((result-b_0)"
"(if(if(eq? mod_0 shifted-mod_0)"
"(if(eq? nominal-mod_0 shifted-nominal-mod_0)"
"(if(not(binding-free=id b_0))"
"(null?"
"(module-binding-extra-nominal-bindings"
" b_0))"
" #f)"
" #f)"
" #f)"
" b_0"
"(let-values(((b93_0) b_0)"
"((shifted-mod94_0) shifted-mod_0)"
"((shifted-nominal-mod95_0)"
" shifted-nominal-mod_0)"
"((temp96_0)"
"(if(binding-free=id b_0)"
"(let-values(((temp98_0)"
"(binding-free=id b_0))"
"((s99_0) s_0))"
"(syntax-transfer-shifts.1"
" #f"
" temp98_0"
" s99_0"
" #f))"
" #f))"
"((temp97_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
"(module-binding-extra-nominal-bindings"
" b_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((b_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(apply-syntax-shifts-to-binding"
" b_1"
" mpi-shifts_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(module-binding-update.1"
" unsafe-undefined"
" temp97_0"
" unsafe-undefined"
" temp96_0"
" shifted-mod94_0"
" shifted-nominal-mod95_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" b93_0)))))"
"(begin"
"(if can-cache?_0"
"(let-values()"
"(resolve+shift-cache-set! s_0 phase_0 result-b_0))"
"(void))"
" result-b_0))))))))))"
"(if(like-ambiguous-binding? b_0)"
"(let-values()(if unbound-sym?_0(syntax-content s_0) ambiguous-value_0))"
"(let-values()"
"(begin"
"(if can-cache?_0"
"(let-values()"
"(resolve+shift-cache-set!"
" s_0"
" phase_0"
"(let-values(((or-part_0) b_0))(if or-part_0 or-part_0 '#:none))))"
"(void))"
"(let-values(((or-part_0) b_0))"
"(if or-part_0"
" or-part_0"
"(if unbound-sym?_0(syntax-content s_0) #f))))))))))))))))))))))))"
"(define-values"
"(apply-syntax-shifts)"
"(lambda(mpi_0 shifts_0)"
"(begin"
"(if(null? shifts_0)"
"(let-values() mpi_0)"
"(let-values()"
"(let-values(((shifted-mpi_0)(apply-syntax-shifts mpi_0(cdr shifts_0))))"
"(let-values(((shift_0)(car shifts_0)))"
"(module-path-index-shift shifted-mpi_0(shift-from shift_0)(shift-to shift_0)))))))))"
"(define-values"
"(apply-syntax-shifts-to-binding)"
"(lambda(b_0 shifts_0)"
"(begin"
"(if(null? shifts_0)"
"(let-values() b_0)"
"(let-values()"
"(let-values(((shifted-b_0)(apply-syntax-shifts-to-binding b_0(cdr shifts_0))))"
"(let-values(((shift_0)(car shifts_0)))"
"(binding-module-path-index-shift shifted-b_0(shift-from shift_0)(shift-to shift_0)))))))))"
"(define-values"
"(binding-module-path-index-shift)"
"(lambda(b_0 from-mpi_0 to-mpi_0)"
"(begin"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((b100_0) b_0)"
"((temp101_0)(module-path-index-shift(module-binding-module b_0) from-mpi_0 to-mpi_0))"
"((temp102_0)(module-path-index-shift(module-binding-nominal-module b_0) from-mpi_0 to-mpi_0))"
"((temp103_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(module-binding-extra-nominal-bindings b_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((b_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(binding-module-path-index-shift"
" b_1"
" from-mpi_0"
" to-mpi_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(module-binding-update.1"
" unsafe-undefined"
" temp103_0"
" unsafe-undefined"
" unsafe-undefined"
" temp101_0"
" temp102_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" b100_0)))"
"(let-values() b_0)))))"
"(define-values"
"(syntax-transfer-shifts.1)"
"(lambda(non-source?32_0 to-s35_0 from-s36_0 inspector34_0)"
"(begin"
" 'syntax-transfer-shifts"
"(let-values(((to-s_0) to-s35_0))"
"(let-values(((from-s_0) from-s36_0))"
"(let-values(((inspector_0) inspector34_0))"
"(let-values(((non-source?_0) non-source?32_0))"
"(let-values()"
"(let-values(((to-s104_0) to-s_0)"
"((temp105_0)(syntax-mpi-shifts from-s_0))"
"((inspector106_0) inspector_0)"
"((non-source?107_0) non-source?_0))"
"(syntax-add-shifts.1 non-source?107_0 to-s104_0 temp105_0 inspector106_0))))))))))"
"(define-values"
"(syntax-add-shifts.1)"
"(lambda(non-source?38_0 to-s41_0 shifts42_0 inspector40_0)"
"(begin"
" 'syntax-add-shifts"
"(let-values(((to-s_0) to-s41_0))"
"(let-values(((shifts_0) shifts42_0))"
"(let-values(((inspector_0) inspector40_0))"
"(let-values(((non-source?_0) non-source?38_0))"
"(let-values()"
"(if(if(null? shifts_0) inspector_0 #f)"
"(let-values()(syntax-set-inspector to-s_0 inspector_0))"
"(let-values()"
"(let-values(((s_0)(let-values(((s_0) to-s_0)) s_0)))"
"(let-values(((lst_0)(reverse$1 shifts_0))((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((shift_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values(((s_2)"
"(let-values(((s_2)"
"(let-values()"
"(let-values(((s108_0) s_1)"
"((temp109_0)"
"(shift-from shift_0))"
"((temp110_0)"
"(shift-to shift_0))"
"((temp111_0)"
"(if(zero? i_0)"
" inspector_0"
" #f))"
"((non-source?112_0)"
" non-source?_0))"
"(syntax-module-path-index-shift.1"
" non-source?112_0"
" s108_0"
" temp109_0"
" temp110_0"
" temp111_0)))))"
"(values s_2))))"
"(if(not #f)(for-loop_0 s_2 rest_0(+ pos_0 1)) s_2)))"
" s_1))))))"
" for-loop_0)"
" s_0"
" lst_0"
" start_0))))))))))))))"
"(define-values"
"(syntax-set-inspector)"
"(lambda(s_0 insp_0)"
"(begin"
"(let-values(((content*_0)(syntax-content* s_0)))"
"(let-values(((content_0)(if(modified-content? content*_0)(modified-content-content content*_0) content*_0)))"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((inspector113_0)"
"(let-values(((or-part_0)(syntax-inspector s_0)))(if or-part_0 or-part_0 insp_0)))"
"((content*114_0)"
"(if(datum-has-elements? content_0)"
"(modified-content1.1"
" content_0"
"(propagation-mpi-shift"
"(if(modified-content? content*_0)"
"(modified-content-scope-propagations+taint content*_0)"
" #f)"
" #f"
" insp_0"
"(syntax-scopes s_0)"
"(syntax-shifted-multi-scopes s_0)"
"(syntax-mpi-shifts s_0)))"
" content*_0)))"
"(syntax2.1"
" content*114_0"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
" inspector113_0))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))"
"(define-values"
"(1/syntax-source-module)"
"(let-values(((syntax-source-module_0)"
"(lambda(s45_0 source?44_0)"
"(begin"
" 'syntax-source-module"
"(let-values(((s_0) s45_0))"
"(let-values(((source?_0) source?44_0))"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                              (let-values () (raise-argument-error 'syntax-track-origin \"syntax?\" s_0)))"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0)(reverse$1(syntax-mpi-shifts s_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((shift_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(if(non-source-shift? shift_0)"
" result_1"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((from-mpi_0)"
"(car"
" shift_0)))"
"(let-values(((path_0"
" base_0)"
"(1/module-path-index-split"
" from-mpi_0)))"
"(if(not path_0)"
"(if(module-path-index-resolved"
" from-mpi_0)"
"(let-values(((mpi_0)"
"(apply-syntax-shifts"
" from-mpi_0"
"(syntax-mpi-shifts"
" s_0))))"
"(if source?_0"
"(1/resolved-module-path-name"
"(1/module-path-index-resolve"
" mpi_0"
" #f))"
" mpi_0))"
" #f)"
" #f)))))))"
"(values result_2)))))"
"(if(if(not((lambda x_0 result_2) shift_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-source-module(syntax-source-module_0 s_0 #f)))"
"((s_0 source?44_0)(syntax-source-module_0 s_0 source?44_0)))))"
"(define-values"
"(1/identifier-prune-to-source-module)"
"(lambda(id_0)"
"(begin"
" 'identifier-prune-to-source-module"
"(begin"
"(if(identifier? id_0)"
"(void)"
"          (let-values () (raise-argument-error 'identifier-prune-to-source-module \"identifier?\" id_0)))"
"(let-values(((the-struct_0)(datum->syntax$1 #f(syntax-e$1 id_0) id_0 id_0)))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((mpi-shifts115_0)(syntax-mpi-shifts id_0)))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" mpi-shifts115_0"
"(syntax-srcloc$1 the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"            (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))"
"(define-values"
"(struct:provided provided1.1 provided? provided-binding provided-protected? provided-syntax?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'provided"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(p_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:provided)"
"(ser-push!_0(provided-binding p_0))"
"(ser-push!_0(provided-protected? p_0))"
"(ser-push!_0(provided-syntax? p_0))))))"
" #f"
" #f"
" '(0 1 2)"
" #f"
" 'provided)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'binding)"
"(make-struct-field-accessor -ref_0 1 'protected?)"
"(make-struct-field-accessor -ref_0 2 'syntax?))))"
"(define-values(provided-as-binding)(lambda(v_0)(begin(if(provided? v_0)(provided-binding v_0) v_0))))"
"(define-values(provided-as-protected?)(lambda(v_0)(begin(if(provided? v_0)(provided-protected? v_0) #f))))"
"(define-values(provided-as-transformer?)(lambda(v_0)(begin(if(provided? v_0)(provided-syntax? v_0) #f))))"
"(define-values"
"(deserialize-provided)"
"(lambda(binding_0 protected?_0 syntax?_0)(begin(provided1.1 binding_0 protected?_0 syntax?_0))))"
"(define-values"
"(provide-binding-to-require-binding.1)"
"(lambda(mpi2_0 phase+space-shift4_0 provide-phase+space3_0 self1_0 binding/p9_0 sym10_0)"
"(begin"
" 'provide-binding-to-require-binding"
"(let-values(((binding/p_0) binding/p9_0))"
"(let-values(((sym_0) sym10_0))"
"(let-values(((self_0) self1_0))"
"(let-values(((mpi_0) mpi2_0))"
"(let-values(((provide-phase+space_0) provide-phase+space3_0))"
"(let-values(((phase+space-shift_0) phase+space-shift4_0))"
"(let-values()"
"(let-values(((binding_0)(provided-as-binding binding/p_0)))"
"(let-values(((from-mod_0)(module-binding-module binding_0)))"
"(let-values(((binding15_0) binding_0)"
"((temp16_0)(module-path-index-shift from-mod_0 self_0 mpi_0))"
"((mpi17_0) mpi_0)"
"((provide-phase+space18_0) provide-phase+space_0)"
"((sym19_0) sym_0)"
"((phase+space-shift20_0) phase+space-shift_0)"
"((temp21_0) #f)"
"((temp22_0)"
"(if(not(provided-as-protected? binding/p_0))"
"(module-binding-extra-inspector binding_0)"
" #f))"
"((null23_0) null))"
"(module-binding-update.1"
" temp22_0"
" null23_0"
" temp21_0"
" unsafe-undefined"
" temp16_0"
" mpi17_0"
" provide-phase+space18_0"
" phase+space-shift20_0"
" sym19_0"
" unsafe-undefined"
" unsafe-undefined"
" binding15_0))))))))))))))"
"(define-values"
"(struct:bulk-binding"
" bulk-binding12.1"
" bulk-binding?"
" bulk-binding-provides"
" bulk-binding-prefix"
" bulk-binding-excepts"
" bulk-binding-self"
" bulk-binding-mpi"
" bulk-binding-provide-phase+space"
" bulk-binding-phase+space-shift"
" bulk-binding-bulk-binding-registry"
" set-bulk-binding-provides!"
" set-bulk-binding-self!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-binding"
" #f"
" 8"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 state_0)"
"(let-values(((clear-registry?_0)"
"(if(let-values(((or-part_0)(not(bulk-binding-bulk-binding-registry b_0))))"
"(if or-part_0"
" or-part_0"
"(if(serialize-state-keep-provides? state_0)"
"((serialize-state-keep-provides? state_0) b_0)"
" #f)))"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:bulk-binding+provides)"
"(ser-push!_0(bulk-binding-provides b_0))"
"(ser-push!_0(bulk-binding-self b_0))"
" #t))"
"(let-values()(begin(ser-push!_0 'tag '#:bulk-binding) #f)))))"
"(begin"
"(ser-push!_0(bulk-binding-prefix b_0))"
"(ser-push!_0(bulk-binding-excepts b_0))"
"(ser-push!_0(bulk-binding-mpi b_0))"
"(ser-push!_0(bulk-binding-provide-phase+space b_0))"
"(ser-push!_0(bulk-binding-phase+space-shift b_0))"
"(if clear-registry?_0(ser-push!_0 #f)(ser-push!_0 'tag '#:bulk-binding-registry))))))"
"(cons"
" prop:bulk-binding"
"(bulk-binding-class3.1"
"(lambda(b_0 mpi-shifts_0)"
"(let-values(((or-part_0)(bulk-binding-provides b_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((mod-name_0)(bulk-binding-module-name b_0 mpi-shifts_0)))"
"(let-values((()"
"(begin"
"(if(bulk-binding-bulk-binding-registry b_0)"
"(void)"
"(let-values()"
"(error"
"                                                     \"namespace mismatch: no bulk-binding registry available:\""
" mod-name_0)))"
"(values))))"
"(let-values(((table_0)"
"(bulk-binding-registry-table(bulk-binding-bulk-binding-registry b_0))))"
"(let-values(((bulk-provide_0)(hash-ref table_0 mod-name_0 #f)))"
"(let-values((()"
"(begin"
"(if bulk-provide_0"
"(void)"
"(let-values()"
"(error"
"                                                           \"namespace mismatch: bulk bindings not found in registry for module:\""
" mod-name_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(set-bulk-binding-self! b_0(bulk-provide-self bulk-provide_0))"
"(values))))"
"(let-values(((provides_0)"
"(hash-ref"
"(bulk-provide-provides bulk-provide_0)"
"(bulk-binding-provide-phase+space b_0)"
" '#hasheq())))"
"(let-values(((excepts_0)(bulk-binding-excepts b_0)))"
"(let-values(((prefix_0)(bulk-binding-prefix b_0)))"
"(let-values(((adjusted-provides_0)"
"(if(let-values(((or-part_1) prefix_0))"
"(if or-part_1"
" or-part_1"
"(positive?(hash-count excepts_0))))"
"(let-values()"
"(bulk-provides-add-prefix-remove-exceptions"
" provides_0"
" prefix_0"
" excepts_0))"
"(let-values() provides_0))))"
"(begin"
"(set-bulk-binding-provides! b_0 adjusted-provides_0)"
" adjusted-provides_0))))))))))))))"
"(lambda(b_0 binding_0 sym_0)"
"(let-values(((binding25_0) binding_0)"
"((temp26_0)"
"(if(bulk-binding-prefix b_0)"
"(string->symbol"
"(substring"
"(symbol->string sym_0)"
"(string-length(symbol->string(bulk-binding-prefix b_0)))))"
" sym_0))"
"((temp27_0)(bulk-binding-self b_0))"
"((temp28_0)(bulk-binding-mpi b_0))"
"((temp29_0)(bulk-binding-provide-phase+space b_0))"
"((temp30_0)(bulk-binding-phase+space-shift b_0)))"
"(provide-binding-to-require-binding.1"
" temp28_0"
" temp30_0"
" temp29_0"
" temp27_0"
" binding25_0"
" temp26_0)))"
"(lambda(b_0 mpi-shifts_0)(bulk-binding-module-name b_0 mpi-shifts_0))"
"(lambda(b_0 bulk-shifts_0 report-shifts_0)"
"(let-values((()(begin(report-shifts_0(bulk-binding-mpi b_0) bulk-shifts_0)(values))))"
"(let-values(((more-bulk-shifts_0)"
"(append"
" bulk-shifts_0"
"(list(cons(bulk-binding-self b_0)(bulk-binding-mpi b_0))))))"
"(let-values((()"
"(begin"
"(report-shifts_0(bulk-binding-self b_0) more-bulk-shifts_0)"
"(values))))"
"(let-values(((provides_0)(bulk-binding-provides b_0)))"
"(if provides_0"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-values ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((binding/p_0)"
"(hash-iterate-value ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((binding_0)"
"(provided-as-binding"
" binding/p_0)))"
"(if(binding-shift-report?"
" binding_0)"
"(let-values()"
"((binding-shift-report-ref"
" binding_0)"
" binding_0"
" more-bulk-shifts_0"
" report-shifts_0))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)))"
"(void))))))))))"
"(current-inspector)"
" #f"
" '(1 2 4 5 6 7)"
" #f"
" 'bulk-binding)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'provides)"
"(make-struct-field-accessor -ref_0 1 'prefix)"
"(make-struct-field-accessor -ref_0 2 'excepts)"
"(make-struct-field-accessor -ref_0 3 'self)"
"(make-struct-field-accessor -ref_0 4 'mpi)"
"(make-struct-field-accessor -ref_0 5 'provide-phase+space)"
"(make-struct-field-accessor -ref_0 6 'phase+space-shift)"
"(make-struct-field-accessor -ref_0 7 'bulk-binding-registry)"
"(make-struct-field-mutator -set!_0 0 'provides)"
"(make-struct-field-mutator -set!_0 3 'self))))"
"(define-values"
"(deserialize-bulk-binding)"
"(lambda(prefix_0 excepts_0 mpi_0 provide-phase+space_0 phase-level_0 bulk-binding-registry_0)"
"(begin"
"(bulk-binding12.1"
" #f"
" prefix_0"
" excepts_0"
" #f"
" mpi_0"
"(intern-phase+space provide-phase+space_0)"
" phase-level_0"
" bulk-binding-registry_0))))"
"(define-values"
"(deserialize-bulk-binding+provides)"
"(lambda(provides_0 self_0 prefix_0 excepts_0 mpi_0 provide-phase+space_0 phase-level_0 bulk-binding-registry_0)"
"(begin"
"(bulk-binding12.1"
" provides_0"
" prefix_0"
" excepts_0"
" self_0"
" mpi_0"
"(intern-phase+space provide-phase+space_0)"
" phase-level_0"
" bulk-binding-registry_0))))"
"(define-values"
"(bulk-provides-add-prefix-remove-exceptions)"
"(lambda(provides_0 prefix_0 excepts_0)"
"(begin"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0 val_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(if(hash-ref excepts_0 sym_0 #f)"
" table_1"
"(if(symbol-interned? sym_0)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_1)"
"(let-values()"
"(values"
"(if prefix_0"
"(string->symbol"
"(format"
"                                                                                               \"~a~a\""
" prefix_0"
" sym_0))"
" sym_0)"
" val_0))))"
"(hash-set table_1 key_0 val_1)))))"
"(values table_2))"
" table_1))))"
"(if(not #f)(for-loop_0 table_2(hash-iterate-next ht_0 i_0)) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0))))))))"
"(define-values"
"(bulk-binding-module-name)"
"(lambda(b_0 mpi-shifts_0)"
"(begin(1/module-path-index-resolve(apply-syntax-shifts(bulk-binding-mpi b_0) mpi-shifts_0)))))"
"(define-values"
"(struct:bulk-provide bulk-provide13.1 bulk-provide? bulk-provide-self bulk-provide-provides)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'bulk-provide #f 2 0 #f null(current-inspector) #f '(0 1) #f 'bulk-provide)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'self)"
"(make-struct-field-accessor -ref_0 1 'provides))))"
"(define-values"
"(struct:bulk-binding-registry bulk-binding-registry14.1 bulk-binding-registry? bulk-binding-registry-table)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-binding-registry"
" #f"
" 1"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'bulk-binding-registry)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'table))))"
"(define-values(make-bulk-binding-registry)(lambda()(begin(bulk-binding-registry14.1(make-hasheq)))))"
"(define-values"
"(register-bulk-provide!)"
"(lambda(bulk-binding-registry_0 mod-name_0 self_0 provides_0)"
"(begin"
"(hash-set!"
"(bulk-binding-registry-table bulk-binding-registry_0)"
" mod-name_0"
"(bulk-provide13.1 self_0 provides_0)))))"
"(define-values"
"(registered-bulk-provide?)"
"(lambda(bulk-binding-registry_0 mod-name_0)"
"(begin(if(hash-ref(bulk-binding-registry-table bulk-binding-registry_0) mod-name_0 #f) #t #f))))"
"(define-values(generate-lift-key)(lambda()(begin(gensym 'lift))))"
"(define-values"
"(struct:root-expand-context/outer"
" root-expand-context/outer1.1"
" root-expand-context/outer?"
" root-expand-context/outer-inner"
" root-expand-context/outer-post-expansion"
" root-expand-context/outer-use-site-scopes"
" root-expand-context/outer-frame-id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'root-expand-context"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'root-expand-context/outer)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'inner)"
"(make-struct-field-accessor -ref_0 1 'post-expansion)"
"(make-struct-field-accessor -ref_0 2 'use-site-scopes)"
"(make-struct-field-accessor -ref_0 3 'frame-id))))"
"(define-values"
"(struct:root-expand-context/inner"
" root-expand-context/inner2.1"
" root-expand-context/inner?"
" root-expand-context/inner-self-mpi"
" root-expand-context/inner-module-scopes"
" root-expand-context/inner-top-level-bind-scope"
" root-expand-context/inner-all-scopes-stx"
" root-expand-context/inner-defined-syms"
" root-expand-context/inner-counter"
" root-expand-context/inner-lift-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'root-expand-context/inner"
" #f"
" 7"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'root-expand-context/inner)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'self-mpi)"
"(make-struct-field-accessor -ref_0 1 'module-scopes)"
"(make-struct-field-accessor -ref_0 2 'top-level-bind-scope)"
"(make-struct-field-accessor -ref_0 3 'all-scopes-stx)"
"(make-struct-field-accessor -ref_0 4 'defined-syms)"
"(make-struct-field-accessor -ref_0 5 'counter)"
"(make-struct-field-accessor -ref_0 6 'lift-key))))"
"(define-values"
"(root-expand-context/make)"
"(lambda(self-mpi_0"
" module-scopes_0"
" post-expansion_0"
" top-level-bind-scope_0"
" all-scopes-stx_0"
" use-site-scopes_0"
" defined-syms_0"
" frame-id_0"
" counter_0"
" lift-key_0)"
"(begin"
"(root-expand-context/outer1.1"
"(root-expand-context/inner2.1"
" self-mpi_0"
" module-scopes_0"
" top-level-bind-scope_0"
" all-scopes-stx_0"
" defined-syms_0"
" counter_0"
" lift-key_0)"
" post-expansion_0"
" use-site-scopes_0"
" frame-id_0))))"
"(define-values"
"(root-expand-context-post-expansion)"
"(lambda(v_0)(begin(root-expand-context/outer-post-expansion v_0))))"
"(define-values"
"(root-expand-context-use-site-scopes)"
"(lambda(v_0)(begin(root-expand-context/outer-use-site-scopes v_0))))"
"(define-values(root-expand-context-frame-id)(lambda(v_0)(begin(root-expand-context/outer-frame-id v_0))))"
"(define-values"
"(root-expand-context-self-mpi)"
"(lambda(v_0)(begin(root-expand-context/inner-self-mpi(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-module-scopes)"
"(lambda(v_0)(begin(root-expand-context/inner-module-scopes(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-top-level-bind-scope)"
"(lambda(v_0)(begin(root-expand-context/inner-top-level-bind-scope(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-all-scopes-stx)"
"(lambda(v_0)(begin(root-expand-context/inner-all-scopes-stx(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-defined-syms)"
"(lambda(v_0)(begin(root-expand-context/inner-defined-syms(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-counter)"
"(lambda(v_0)(begin(root-expand-context/inner-counter(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-lift-key)"
"(lambda(v_0)(begin(root-expand-context/inner-lift-key(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(make-root-expand-context.1)"
"(lambda(all-scopes-stx7_0 initial-scopes4_0 outside-scope5_0 post-expansion-scope6_0 self-mpi3_0)"
"(begin"
" 'make-root-expand-context"
"(let-values(((self-mpi_0) self-mpi3_0))"
"(let-values(((initial-scopes_0) initial-scopes4_0))"
"(let-values(((outside-scope_0)"
"(if(eq? outside-scope5_0 unsafe-undefined) top-level-common-scope outside-scope5_0)))"
"(let-values(((post-expansion-scope_0)"
"(if(eq? post-expansion-scope6_0 unsafe-undefined)"
"(new-multi-scope 'top-level)"
" post-expansion-scope6_0)))"
"(let-values(((all-scopes-stx_0) all-scopes-stx7_0))"
"(let-values()"
"(let-values(((module-scopes_0)(list* post-expansion-scope_0 outside-scope_0 initial-scopes_0)))"
"(root-expand-context/make"
" self-mpi_0"
" module-scopes_0"
" post-expansion-scope_0"
"(new-scope 'module)"
"(let-values(((or-part_0) all-scopes-stx_0))"
"(if or-part_0 or-part_0(add-scopes empty-syntax module-scopes_0)))"
"(box null)"
"(make-hasheqv)"
"                     (string->uninterned-symbol \"root-frame\")"
"(box 0)"
"(generate-lift-key))))))))))))"
"(define-values"
"(apply-post-expansion)"
"(lambda(pe_0 s_0)"
"(begin"
"(if(not pe_0)"
"(let-values() s_0)"
"(if(shifted-multi-scope? pe_0)"
"(let-values()(push-scope s_0 pe_0))"
"(if(pair? pe_0)"
"(let-values()"
"(let-values(((temp16_0)(push-scope s_0(car pe_0)))((temp17_0)(cdr pe_0)))"
"(syntax-add-shifts.1 #f temp16_0 temp17_0 #f)))"
"(let-values()(pe_0 s_0))))))))"
"(define-values"
"(post-expansion-scope)"
"(lambda(pe_0)"
"(begin"
"(if(shifted-multi-scope? pe_0)"
"(let-values() pe_0)"
"(if(pair? pe_0)"
"(let-values()(car pe_0))"
"          (let-values () (error 'post-expansion-scope \"internal error: cannot extract scope from ~s\" pe_0)))))))"
"(define-values"
"(root-expand-context-encode-for-module)"
"(lambda(ctx_0 orig-self_0 new-self_0)"
"(begin"
"(datum->syntax$1"
" #f"
"(vector"
"(add-scopes empty-syntax(root-expand-context-module-scopes ctx_0))"
"(apply-post-expansion(root-expand-context-post-expansion ctx_0) empty-syntax)"
"(let-values(((temp18_0)(root-expand-context-all-scopes-stx ctx_0))"
"((orig-self19_0) orig-self_0)"
"((new-self20_0) new-self_0))"
"(syntax-module-path-index-shift.1 #f temp18_0 orig-self19_0 new-self20_0 #f))"
"(add-scopes empty-syntax(unbox(root-expand-context-use-site-scopes ctx_0)))"
"(let-values(((table_0)(let-values(((table_0) '#hasheqv())) table_0)))"
"(let-values(((ht_0)(root-expand-context-defined-syms ctx_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 ht_1)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values phase_0 ht_1))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2(hash-iterate-next ht_0 i_0)) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))"
"(root-expand-context-frame-id ctx_0)"
"(unbox(root-expand-context-counter ctx_0)))))))"
"(define-values"
"(root-expand-context-decode-for-module)"
"(lambda(vec-s_0 self_0)"
"(begin"
"(let-values(((vec_0)(if(syntax?$1 vec-s_0)(syntax-e$1 vec-s_0) #f)))"
"(begin"
"(if(if(vector? vec_0)"
"(if(=(vector-length vec_0) 7)"
"(if(syntax?$1(vector-ref vec_0 0))"
"(if(syntax-with-one-scope?(vector-ref vec_0 1))"
"(if(syntax?$1(vector-ref vec_0 2))"
"(if(syntax?$1(vector-ref vec_0 3))"
"(if(defined-syms-hash?(syntax-e$1(vector-ref vec_0 4)))"
"(if(symbol?(syntax-e$1(vector-ref vec_0 5)))"
"(exact-nonnegative-integer?(syntax-e$1(vector-ref vec_0 6)))"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
"(void)"
"            (let-values () (error 'root-expand-context-decode-for-module \"bad encoding: ~s\" vec-s_0)))"
"(root-expand-context/make"
" self_0"
"(extract-scope-list(vector-ref vec_0 0))"
"(cons(extract-scope(vector-ref vec_0 1))(extract-shifts(vector-ref vec_0 1)))"
"(new-scope 'module)"
"(vector-ref vec_0 2)"
"(box(extract-scope-list(vector-ref vec_0 3)))"
"(unpack-defined-syms(vector-ref vec_0 4))"
"(syntax-e$1(vector-ref vec_0 5))"
"(box(syntax-e$1(vector-ref vec_0 6)))"
"(generate-lift-key)))))))"
"(define-values"
"(defined-syms-hash?)"
"(lambda(v_0)"
"(begin"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((ht_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 ht-s_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(phase? phase_0)"
"(if(hash?(syntax-e$1 ht-s_0))"
"(let-values(((result_2)"
"(let-values(((result_2) #t))"
" result_2)))"
"(let-values(((ht_1)(syntax-e$1 ht-s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(result_3"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((sym_0"
" id_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((result_4)"
"(let-values(((result_4)"
"(let-values()"
"(let-values()"
"(if(symbol?"
" sym_0)"
"(identifier?"
" id_0)"
" #f)))))"
"(values"
" result_4))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_4))"
" sym_0"
" id_0))"
"(not"
" #f)"
" #f)"
"(for-loop_1"
" result_4"
"(hash-iterate-next"
" ht_1"
" i_1))"
" result_4)))"
" result_3))))))"
" for-loop_1)"
" result_2"
"(hash-iterate-first ht_1)))))"
" #f)"
" #f)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) phase_0 ht-s_0))(not #f) #f)"
"(for-loop_0 result_2(hash-iterate-next ht_0 i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(hash-iterate-first ht_0))))))))"
"(define-values"
"(extract-scope-list)"
"(lambda(stx_0)(begin(map2 generalize-scope(set->list(syntax-scope-set stx_0 0))))))"
"(define-values"
"(syntax-with-one-scope?)"
"(lambda(stx_0)(begin(if(syntax?$1 stx_0)(= 1(set-count(syntax-scope-set stx_0 0))) #f))))"
"(define-values"
"(extract-scope)"
"(lambda(stx_0)(begin(let-values(((s_0)(syntax-scope-set stx_0 0)))(generalize-scope(set-first s_0))))))"
"(define-values(extract-shifts)(lambda(stx_0)(begin(syntax-mpi-shifts stx_0))))"
"(define-values"
"(unpack-defined-syms)"
"(lambda(v_0)"
"(begin"
"(hash-copy"
"(let-values(((table_0)(let-values(((table_0) '#hasheqv())) table_0)))"
"(let-values(((ht_0)(syntax-e$1 v_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 ht-s_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" phase_0"
"(hash-copy"
"(let-values(((table_2)"
"(let-values(((table_2)"
" '#hash()))"
" table_2)))"
"(let-values(((ht_1)"
"(syntax-e$1"
" ht-s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_3"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((sym_0"
" id_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((table_4)"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
" id_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_4"
"(hash-iterate-next"
" ht_1"
" i_1))"
" table_4)))"
" table_3))))))"
" for-loop_1)"
" table_2"
"(hash-iterate-first"
" ht_1))))))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2(hash-iterate-next ht_0 i_0)) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))))"
"(define-values(1/primitive-table) primitive-table)"
"(define-values(1/primitive->compiled-position) primitive->compiled-position)"
"(define-values(1/compiled-position->primitive) compiled-position->primitive)"
"(define-values(1/primitive-in-category?) primitive-in-category?)"
"(define-values(1/primitive-lookup) primitive-lookup)"
"(define-values(linklet?$1) linklet?)"
"(define-values(1/compile-linklet) compile-linklet)"
"(define-values(recompile-linklet$1) recompile-linklet)"
"(define-values(eval-linklet$1) eval-linklet)"
"(define-values(instantiate-linklet$1) instantiate-linklet)"
"(define-values(linklet-import-variables$1) linklet-import-variables)"
"(define-values(linklet-export-variables$1) linklet-export-variables)"
"(define-values(1/linklet-add-target-machine-info) linklet-add-target-machine-info)"
"(define-values(1/linklet-summarize-target-machine-info) linklet-summarize-target-machine-info)"
"(define-values(1/instance?) instance?)"
"(define-values(1/make-instance) make-instance)"
"(define-values(1/instance-name) instance-name)"
"(define-values(1/instance-data) instance-data)"
"(define-values(1/instance-variable-names) instance-variable-names)"
"(define-values(1/instance-variable-value) instance-variable-value)"
"(define-values(1/instance-set-variable-value!) instance-set-variable-value!)"
"(define-values(1/instance-unset-variable!) instance-unset-variable!)"
"(define-values(1/instance-describe-variable!) instance-describe-variable!)"
"(define-values(1/linklet-virtual-machine-bytes) linklet-virtual-machine-bytes)"
"(define-values(1/linklet-cross-machine-type) linklet-cross-machine-type)"
"(define-values(1/write-linklet-bundle-hash) write-linklet-bundle-hash)"
"(define-values(1/read-linklet-bundle-hash) read-linklet-bundle-hash)"
"(define-values(1/variable-reference?) variable-reference?)"
"(define-values(1/variable-reference->instance) variable-reference->instance)"
"(define-values(1/variable-reference-constant?) variable-reference-constant?)"
"(define-values(1/variable-reference-from-unsafe?) variable-reference-from-unsafe?)"
"(void"
"(if 1/variable-reference-constant?"
"(void)"
"    (let-values () (error \"broken '#%linklet primitive table; maybe you need to use \\\"bootstrap-run.rkt\\\"\"))))"
"(define-values"
"(struct:module-registry module-registry1.1 module-registry? module-registry-declarations module-registry-lock-box)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-registry"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'module-registry)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'declarations)"
"(make-struct-field-accessor -ref_0 1 'lock-box))))"
"(define-values(make-module-registry)(lambda()(begin(module-registry1.1(make-hasheq)(box #f)))))"
"(define-values"
"(registry-call-with-lock)"
"(lambda(r_0 proc_0)"
"(begin"
"(let-values(((lock-box_0)(module-registry-lock-box r_0)))"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((v_0)(unbox lock-box_0)))"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0"
" or-part_0"
"(sync/timeout"
" 0"
"(car v_0)"
"(let-values(((or-part_1)(weak-box-value(cdr v_0))))"
"(if or-part_1 or-part_1 never-evt)))))"
"(let-values()"
"(let-values(((sema_0)(make-semaphore)))"
"(let-values(((lock_0)"
"(cons"
"(semaphore-peek-evt sema_0)"
"(make-weak-box(current-thread)))))"
"((dynamic-wind"
" void"
"(lambda()"
"(if(box-cas! lock-box_0 v_0 lock_0)"
"(let-values()"
"(call-with-values"
" proc_0"
"(lambda results_0(lambda()(apply values results_0)))))"
"(let-values()(lambda()(loop_0)))))"
"(lambda()(semaphore-post sema_0)))))))"
"(if(eq?(current-thread)(weak-box-value(cdr v_0)))"
"(let-values()(proc_0))"
"(let-values()"
"(begin"
"(sync"
"(car v_0)"
"(let-values(((or-part_0)(weak-box-value(cdr v_0))))"
"(if or-part_0 or-part_0 never-evt)))"
"(loop_0))))))))))"
" loop_0))))))"
"(define-values"
"(struct:namespace"
" namespace1.1"
" 1/namespace?"
" namespace-mpi"
" namespace-source-name"
" namespace-root-expand-ctx"
" namespace-phase"
" namespace-0-phase"
" namespace-phase-to-namespace"
" namespace-phase-level-to-definitions"
" namespace-module-registry$1"
" namespace-module-instance-shifted-requires"
" namespace-bulk-binding-registry"
" namespace-submodule-declarations"
" namespace-root-namespace"
" namespace-declaration-inspector"
" namespace-inspector"
" namespace-available-module-instances"
" namespace-available-cross-phase-module-instances"
" namespace-module-instances"
" set-namespace-inspector!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'namespace"
" #f"
" 17"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:custom-write"
"(lambda(ns_0 port_0 mode_0)"
"                         (let-values ((() (begin (write-string \"#<namespace\" port_0) (values))))"
"(let-values(((n_0)(namespace-source-name ns_0)))"
"(let-values((()"
"(begin"
"(if n_0"
"                                               (let-values () (fprintf port_0 \":~a\" (namespace->name ns_0)))"
"(void))"
"(values))))"
"(let-values(((0-phase_0)(namespace-0-phase ns_0)))"
"(let-values(((phase-level_0)(phase-(namespace-phase ns_0) 0-phase_0)))"
"(begin"
"(if(zero-phase? phase-level_0)"
"(void)"
"                                       (let-values () (fprintf port_0 \":~s\" phase-level_0)))"
"(if(zero-phase? 0-phase_0)"
"(void)"
"(let-values()"
"                                         (fprintf port_0 \"~a~s\" (if (positive? 0-phase_0) \"+\" \"\") 0-phase_0)))"
"                                     (write-string \">\" port_0))))))))))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12 14 15 16)"
" #f"
" 'namespace)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'mpi)"
"(make-struct-field-accessor -ref_0 1 'source-name)"
"(make-struct-field-accessor -ref_0 2 'root-expand-ctx)"
"(make-struct-field-accessor -ref_0 3 'phase)"
"(make-struct-field-accessor -ref_0 4 '0-phase)"
"(make-struct-field-accessor -ref_0 5 'phase-to-namespace)"
"(make-struct-field-accessor -ref_0 6 'phase-level-to-definitions)"
"(make-struct-field-accessor -ref_0 7 'module-registry)"
"(make-struct-field-accessor -ref_0 8 'module-instance-shifted-requires)"
"(make-struct-field-accessor -ref_0 9 'bulk-binding-registry)"
"(make-struct-field-accessor -ref_0 10 'submodule-declarations)"
"(make-struct-field-accessor -ref_0 11 'root-namespace)"
"(make-struct-field-accessor -ref_0 12 'declaration-inspector)"
"(make-struct-field-accessor -ref_0 13 'inspector)"
"(make-struct-field-accessor -ref_0 14 'available-module-instances)"
"(make-struct-field-accessor -ref_0 15 'available-cross-phase-module-instances)"
"(make-struct-field-accessor -ref_0 16 'module-instances)"
"(make-struct-field-mutator -set!_0 13 'inspector))))"
"(define-values"
"(struct:definitions definitions2.1 definitions? definitions-variables definitions-transformers)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'definitions"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'definitions)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'variables)"
"(make-struct-field-accessor -ref_0 1 'transformers))))"
"(define-values(make-namespace)(lambda()(begin(let-values()(new-namespace.1 #t unsafe-undefined #f)))))"
"(define-values"
"(new-namespace.1)"
"(lambda(register?4_0 root-expand-ctx3_0 share-from-ns7_0)"
"(begin"
" 'new-namespace"
"(let-values(((share-from-ns_0) share-from-ns7_0))"
"(let-values(((root-expand-ctx_0)"
"(if(eq? root-expand-ctx3_0 unsafe-undefined)"
"(let-values(((top-level-module-path-index16_0) top-level-module-path-index))"
"(make-root-expand-context.1"
" #f"
" null"
" unsafe-undefined"
" unsafe-undefined"
" top-level-module-path-index16_0))"
" root-expand-ctx3_0)))"
"(let-values(((register?_0) register?4_0))"
"(let-values()"
"(let-values(((phase_0)(if share-from-ns_0(namespace-phase share-from-ns_0) 0)))"
"(let-values(((ns_0)"
"(namespace1.1"
" top-level-module-path-index"
" #f"
"(box root-expand-ctx_0)"
" phase_0"
" phase_0"
"(make-small-hasheqv)"
"(make-small-hasheqv)"
"(if share-from-ns_0(namespace-module-registry$1 share-from-ns_0)(make-module-registry))"
"(if share-from-ns_0"
"(namespace-module-instance-shifted-requires share-from-ns_0)"
"(make-hasheq))"
"(if share-from-ns_0"
"(namespace-bulk-binding-registry share-from-ns_0)"
"(make-bulk-binding-registry))"
"(make-small-hasheq)"
"(if share-from-ns_0"
"(let-values(((or-part_0)(namespace-root-namespace share-from-ns_0)))"
"(if or-part_0 or-part_0 share-from-ns_0))"
" #f)"
" #f"
"(make-inspector(current-code-inspector))"
"(if share-from-ns_0"
"(namespace-available-module-instances share-from-ns_0)"
"(make-hasheqv))"
"(if share-from-ns_0"
"(namespace-available-cross-phase-module-instances share-from-ns_0)"
"(box null))"
"(if share-from-ns_0(namespace-module-instances share-from-ns_0)(make-hasheqv)))))"
"(begin"
"(if register?_0"
"(let-values()(small-hash-set!(namespace-phase-to-namespace ns_0) phase_0 ns_0))"
"(void))"
" ns_0))))))))))"
"(define-values"
"(1/current-namespace)"
"(make-parameter"
"(make-namespace)"
"(lambda(v_0)"
"(begin"
"       (if (1/namespace? v_0) (void) (let-values () (raise-argument-error 'current-namespace \"namespace?\" v_0)))"
" v_0))"
" 'current-namespace))"
"(define-values"
"(namespace-get-root-expand-ctx)"
"(lambda(ns_0)(begin(force(unbox(namespace-root-expand-ctx ns_0))))))"
"(define-values"
"(namespace-set-root-expand-ctx!)"
"(lambda(ns_0 root-ctx_0)(begin(set-box!(namespace-root-expand-ctx ns_0) root-ctx_0))))"
"(define-values"
"(namespace-self-mpi)"
"(lambda(ns_0)(begin(root-expand-context-self-mpi(namespace-get-root-expand-ctx ns_0)))))"
"(define-values"
"(namespace-self-mpi/no-top-level)"
"(lambda(ns_0)"
"(begin"
"(let-values(((mpi_0)(root-expand-context-self-mpi(namespace-get-root-expand-ctx ns_0))))"
"(if(if mpi_0(top-level-module-path-index? mpi_0) #f) #f mpi_0)))))"
"(define-values"
"(namespace->module)"
"(lambda(ns_0 name_0)"
"(begin"
"(let-values(((or-part_0)(small-hash-ref(namespace-submodule-declarations ns_0) name_0 #f)))"
"(if or-part_0"
" or-part_0"
"(hash-ref(module-registry-declarations(namespace-module-registry$1 ns_0)) name_0 #f))))))"
"(define-values"
"(namespace->namespace-at-phase)"
"(lambda(ns_0 phase_0)"
"(begin"
"(let-values(((or-part_0)(small-hash-ref(namespace-phase-to-namespace ns_0) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((p-ns_0)"
"(let-values(((the-struct_0) ns_0))"
"(if(1/namespace? the-struct_0)"
"(let-values(((phase17_0) phase_0)"
"((root-namespace18_0)"
"(let-values(((or-part_1)(namespace-root-namespace ns_0)))"
"(if or-part_1 or-part_1 ns_0))))"
"(namespace1.1"
"(namespace-mpi the-struct_0)"
"(namespace-source-name the-struct_0)"
"(namespace-root-expand-ctx the-struct_0)"
" phase17_0"
"(namespace-0-phase the-struct_0)"
"(namespace-phase-to-namespace the-struct_0)"
"(namespace-phase-level-to-definitions the-struct_0)"
"(namespace-module-registry$1 the-struct_0)"
"(namespace-module-instance-shifted-requires the-struct_0)"
"(namespace-bulk-binding-registry the-struct_0)"
"(namespace-submodule-declarations the-struct_0)"
" root-namespace18_0"
"(namespace-declaration-inspector the-struct_0)"
"(namespace-inspector the-struct_0)"
"(namespace-available-module-instances the-struct_0)"
"(namespace-available-cross-phase-module-instances the-struct_0)"
"(namespace-module-instances the-struct_0)))"
"                            (raise-argument-error 'struct-copy \"namespace?\" the-struct_0)))))"
"(begin(small-hash-set!(namespace-phase-to-namespace ns_0) phase_0 p-ns_0) p-ns_0)))))))"
"(define-values"
"(namespace->name)"
"(lambda(ns_0)"
"(begin"
"(let-values(((n_0)(namespace-source-name ns_0)))"
"(let-values(((s_0)"
"(if(not n_0)"
"(let-values() 'top-level)"
"(if(symbol? n_0)"
"                          (let-values () (format \"'~s\" n_0))"
"                          (let-values () (string-append \"\\\"\" (path->string n_0) \"\\\"\"))))))"
"(let-values(((r_0)(1/resolved-module-path-name(1/module-path-index-resolve(namespace-mpi ns_0)))))"
"            (if (pair? r_0) (string-append \"(submod \" s_0 \" \" (substring (format \"~s\" (cdr r_0)) 1)) s_0)))))))"
"(define-values"
"(namespace->definitions)"
"(lambda(ns_0 phase-level_0)"
"(begin"
"(let-values(((d_0)(small-hash-ref(namespace-phase-level-to-definitions ns_0) phase-level_0 #f)))"
"(let-values(((or-part_0) d_0))"
"(if or-part_0"
" or-part_0"
"(let-values()"
"(let-values(((p-ns_0)"
"(namespace->namespace-at-phase ns_0(phase+(namespace-0-phase ns_0) phase-level_0))))"
"(let-values(((d_1)(definitions2.1(1/make-instance(namespace->name p-ns_0) p-ns_0)(make-hasheq))))"
"(begin(small-hash-set!(namespace-phase-level-to-definitions ns_0) phase-level_0 d_1) d_1))))))))))"
"(define-values"
"(namespace-set-variable!)"
"(let-values(((namespace-set-variable!_0)"
"(lambda(ns10_0 phase-level11_0 name12_0 val13_0 as-constant?9_0)"
"(begin"
" 'namespace-set-variable!"
"(let-values(((ns_0) ns10_0))"
"(let-values(((phase-level_0) phase-level11_0))"
"(let-values(((name_0) name12_0))"
"(let-values(((val_0) val13_0))"
"(let-values(((as-constant?_0) as-constant?9_0))"
"(let-values()"
"(let-values(((d_0)(namespace->definitions ns_0 phase-level_0)))"
"(1/instance-set-variable-value!"
"(definitions-variables d_0)"
" name_0"
" val_0"
"(if as-constant?_0 'constant #f)))))))))))))"
"(case-lambda"
"((ns_0 phase-level_0 name_0 val_0)(begin(namespace-set-variable!_0 ns_0 phase-level_0 name_0 val_0 #f)))"
"((ns_0 phase-level_0 name_0 val_0 as-constant?9_0)"
"(namespace-set-variable!_0 ns_0 phase-level_0 name_0 val_0 as-constant?9_0)))))"
"(define-values"
"(namespace-set-consistent!)"
"(lambda(ns_0 phase-level_0 name_0 val_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0 phase-level_0)))"
"(1/instance-set-variable-value!(definitions-variables d_0) name_0 val_0 'consistent)))))"
"(define-values"
"(namespace-unset-variable!)"
"(lambda(ns_0 phase-level_0 name_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0 phase-level_0)))"
"(1/instance-unset-variable!(definitions-variables d_0) name_0)))))"
"(define-values"
"(namespace-set-transformer!)"
"(lambda(ns_0 phase-level_0 name_0 val_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0(if phase-level_0(add1 phase-level_0) #f))))"
"(hash-set!(definitions-transformers d_0) name_0 val_0)))))"
"(define-values"
"(namespace-unset-transformer!)"
"(lambda(ns_0 phase-level_0 name_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0(add1 phase-level_0))))"
"(hash-remove!(definitions-transformers d_0) name_0)))))"
"(define-values"
"(namespace-get-variable)"
"(lambda(ns_0 phase-level_0 name_0 fail-k_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0 phase-level_0)))"
"(1/instance-variable-value(definitions-variables d_0) name_0 fail-k_0)))))"
"(define-values"
"(namespace-get-transformer)"
"(lambda(ns_0 phase-level_0 name_0 fail-k_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0(if phase-level_0(add1 phase-level_0) #f))))"
"(hash-ref(definitions-transformers d_0) name_0 fail-k_0)))))"
"(define-values"
"(namespace->instance)"
"(lambda(ns_0 phase-shift_0)(begin(definitions-variables(namespace->definitions ns_0 phase-shift_0)))))"
"(define-values"
"(namespace-same-instance?)"
"(lambda(a-ns_0 b-ns_0 phase-level_0)"
"(begin"
"(eq?"
"(small-hash-ref(namespace-phase-level-to-definitions a-ns_0) phase-level_0 'no-a)"
"(small-hash-ref(namespace-phase-level-to-definitions b-ns_0) phase-level_0 'no-b)))))"
"(define-values(original-property-sym)(gensym 'original))"
"(define-values"
"(syntax->list$1)"
"(lambda(s_0)"
"(begin"
" 'syntax->list"
"(let-values(((l_0)"
"((letrec-values(((loop_0)"
"(lambda(s_1)"
"(begin"
" 'loop"
"(if(pair? s_1)"
"(let-values()(cons(car s_1)(loop_0(cdr s_1))))"
"(if(syntax?$1 s_1)"
"(let-values()(loop_0(syntax-e$1 s_1)))"
"(let-values() s_1)))))))"
" loop_0)"
" s_0)))"
"(if(list? l_0) l_0 #f)))))"
"(define-values(missing$1)(gensym))"
"(define-values"
"(syntax-track-origin$1)"
"(let-values(((syntax-track-origin_0)"
"(lambda(new-stx2_0 old-stx3_0 id1_0)"
"(begin"
" 'syntax-track-origin"
"(let-values(((new-stx_0) new-stx2_0))"
"(let-values(((old-stx_0) old-stx3_0))"
"(let-values(((id_0)"
"(if(eq? id1_0 unsafe-undefined)"
"(if(identifier? old-stx_0)"
" old-stx_0"
"(let-values(((v_0)(syntax-e$1 old-stx_0)))(if(pair? v_0)(car v_0) #f)))"
" id1_0)))"
"(let-values()"
"(let-values(((old-props_0)(hash-remove(syntax-props old-stx_0) original-property-sym)))"
"(if(zero?(hash-count old-props_0))"
"(let-values()"
"(if id_0"
"(syntax-property$1"
" new-stx_0"
" 'origin"
"(cons id_0(hash-ref(syntax-props new-stx_0) 'origin null)))"
" new-stx_0))"
"(let-values()"
"(let-values(((new-props_0)(syntax-props new-stx_0)))"
"(if(zero?(hash-count new-props_0))"
"(let-values()"
"(if id_0"
"(let-values()"
"(let-values(((old-origin_0)"
"(plain-property-value"
"(hash-ref old-props_0 'origin missing$1))))"
"(let-values(((origin_0)"
"(if(eq? old-origin_0 missing$1)"
"(list id_0)"
"(cons id_0 old-origin_0))))"
"(let-values(((the-struct_0) new-stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props4_0)(hash-set old-props_0 'origin origin_0)))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
" props4_0"
"(syntax-inspector the-struct_0)))"
"                                                    (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"(let-values()"
"(let-values(((the-struct_0) new-stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props5_0) old-props_0))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
" props5_0"
"(syntax-inspector the-struct_0)))"
"                                                (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"(let-values()"
"(let-values(((old-props-with-origin_0)"
"(if id_0"
"(hash-set"
" old-props_0"
" 'origin"
"(cons id_0(hash-ref old-props_0 'origin null)))"
" old-props_0)))"
"(let-values(((updated-props_0)"
"(if(<"
"(hash-count old-props-with-origin_0)"
"(hash-count new-props_0))"
"(let-values()"
"(let-values(((new-props_1)"
"(let-values(((new-props_1) new-props_0))"
" new-props_1)))"
"(let-values(((ht_0) old-props-with-origin_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(new-props_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((new-props_3)"
"(let-values(((new-props_3)"
"(let-values()"
"(let-values(((new-v_0)"
"(hash-ref"
" new-props_2"
" k_0"
" missing$1)))"
"(hash-set"
" new-props_2"
" k_0"
"(if(eq?"
" new-v_0"
" missing$1)"
" v_0"
"(cons/preserve"
" new-v_0"
" v_0)))))))"
"(values"
" new-props_3))))"
"(if(not #f)"
"(for-loop_0"
" new-props_3"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" new-props_3)))"
" new-props_2))))))"
" for-loop_0)"
" new-props_1"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(let-values()"
"(let-values(((old-props_1)"
"(let-values(((old-props_1)"
" old-props-with-origin_0))"
" old-props_1)))"
"(let-values(((ht_0) new-props_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(old-props_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((old-props_3)"
"(let-values(((old-props_3)"
"(let-values()"
"(let-values(((old-v_0)"
"(hash-ref"
" old-props_2"
" k_0"
" missing$1)))"
"(hash-set"
" old-props_2"
" k_0"
"(if(eq?"
" old-v_0"
" missing$1)"
" v_0"
"(cons/preserve"
" v_0"
" old-v_0)))))))"
"(values"
" old-props_3))))"
"(if(not #f)"
"(for-loop_0"
" old-props_3"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" old-props_3)))"
" old-props_2))))))"
" for-loop_0)"
" old-props_1"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))"
"(let-values(((the-struct_0) new-stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props6_0) updated-props_0))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc$1 the-struct_0)"
" props6_0"
"(syntax-inspector the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                 \"syntax?\""
" the-struct_0)))))))))))))))))))"
"(case-lambda"
"((new-stx_0 old-stx_0)(begin 'syntax-track-origin(syntax-track-origin_0 new-stx_0 old-stx_0 unsafe-undefined)))"
"((new-stx_0 old-stx_0 id1_0)(syntax-track-origin_0 new-stx_0 old-stx_0 id1_0)))))"
"(define-values"
"(cons/preserve)"
"(lambda(a_0 b_0)"
"(begin"
"(if(let-values(((or-part_0)(preserved-property-value? a_0)))"
"(if or-part_0 or-part_0(preserved-property-value? b_0)))"
"(preserved-property-value1.1(cons(plain-property-value a_0)(plain-property-value b_0)))"
"(cons a_0 b_0)))))"
"(define-values"
"(syntax-track-origin*)"
"(lambda(old-stxes_0 new-stx_0)"
"(begin"
"(let-values(((new-stx_1)(let-values(((new-stx_1) new-stx_0)) new-stx_1)))"
"(let-values(((lst_0) old-stxes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(new-stx_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((old-stx_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((new-stx_3)"
"(let-values(((new-stx_3)"
"(let-values()"
"(syntax-track-origin$1 new-stx_2 old-stx_0))))"
"(values new-stx_3))))"
"(if(not #f)(for-loop_0 new-stx_3 rest_0) new-stx_3)))"
" new-stx_2))))))"
" for-loop_0)"
" new-stx_1"
" lst_0)))))))"
"(define-values"
"(struct:syntax-binding-set syntax-binding-set1.1 1/syntax-binding-set? syntax-binding-set-binds)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'syntax-binding-set"
" #f"
" 1"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'syntax-binding-set)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'binds))))"
"(define-values"
"(struct:bind bind2.1 bind? bind-sym bind-phase bind-binding)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'bind #f 3 0 #f null(current-inspector) #f '(0 1 2) #f 'bind)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'sym)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'binding))))"
"(define-values"
"(syntax-binding-set-extend$1)"
"(lambda(bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase+space_0"
" nominal-sym_0"
" nominal-require-phase+space-shift_0"
" inspector_0)"
"(begin"
" 'syntax-binding-set-extend"
"(let-values(((the-struct_0) bs_0))"
"(if(1/syntax-binding-set? the-struct_0)"
"(let-values(((binds5_0)"
"(cons"
"(bind2.1"
" as-sym_0"
" as-phase_0"
"(let-values(((mpi6_0) mpi_0)"
"((phase7_0) phase_0)"
"((sym8_0) sym_0)"
"((inspector9_0) inspector_0)"
"((nominal-mpi10_0) nominal-mpi_0)"
"((nominal-phase+space11_0) nominal-phase+space_0)"
"((nominal-sym12_0) nominal-sym_0)"
"((nominal-require-phase+space-shift13_0) nominal-require-phase+space-shift_0))"
"(make-module-binding.1"
" inspector9_0"
" null"
" #f"
" #f"
" nominal-mpi10_0"
" nominal-phase+space11_0"
" nominal-require-phase+space-shift13_0"
" nominal-sym12_0"
" mpi6_0"
" phase7_0"
" sym8_0)))"
"(syntax-binding-set-binds bs_0))))"
"(syntax-binding-set1.1 binds5_0))"
"          (raise-argument-error 'struct-copy \"syntax-binding-set?\" the-struct_0))))))"
"(define-values"
"(syntax-binding-set->syntax$1)"
"(lambda(bs_0 datum_0)"
"(begin"
" 'syntax-binding-set->syntax"
"(let-values(((s_0)(add-scope(datum->syntax$1 #f datum_0)(new-multi-scope 'binding-set))))"
"(begin"
"(let-values()"
"(let-values(((lst_0)(syntax-binding-set-binds bs_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((bind_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((temp14_0)"
"(syntax-scope-set"
" s_0"
"(bind-phase bind_0)))"
"((temp15_0)(bind-sym bind_0))"
"((temp16_0)"
"(bind-binding bind_0)))"
"(add-binding-in-scopes!.1"
" #f"
" temp14_0"
" temp15_0"
" temp16_0)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
" s_0)))))"
"(define-values"
"(1/struct:exn:fail:syntax make-exn:fail:syntax$1 1/exn:fail:syntax? 1/exn:fail:syntax-exprs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'exn:fail:syntax"
" struct:exn:fail"
" 1"
" 0"
" #f"
"(list"
"(cons"
" prop:exn:srclocs"
"(lambda(e_0)(filter values(map2 syntax-srcloc$1(1/exn:fail:syntax-exprs e_0))))))"
" #f"
" #f"
" '(0)"
"(lambda(str_0 cm_0 exprs_0 info_0)"
"(begin"
"(if(if(list? exprs_0)(andmap2 syntax?$1 exprs_0) #f)"
"(void)"
"                           (let-values () (raise-argument-error 'exn:fail:syntax \"(listof syntax?)\" exprs_0)))"
"(values str_0 cm_0 exprs_0)))"
" 'exn:fail:syntax)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'exprs))))"
"(define-values"
"(1/struct:exn:fail:syntax:unbound make-exn:fail:syntax:unbound$1 1/exn:fail:syntax:unbound?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'exn:fail:syntax:unbound"
" 1/struct:exn:fail:syntax"
" 0"
" 0"
" #f"
" null"
" #f"
" #f"
" '()"
" #f"
" 'exn:fail:syntax:unbound)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(raise-syntax-error$1)"
"(let-values(((raise-syntax-error_0)"
"(lambda(given-name5_0 message6_0 expr1_0 sub-expr2_0 extra-sources3_0 message-suffix4_0)"
"(begin"
" 'raise-syntax-error"
"(let-values(((given-name_0) given-name5_0))"
"(let-values(((message_0) message6_0))"
"(let-values(((expr_0) expr1_0))"
"(let-values(((sub-expr_0) sub-expr2_0))"
"(let-values(((extra-sources_0) extra-sources3_0))"
"(let-values(((message-suffix_0) message-suffix4_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(1/do-raise-syntax-error"
" 'raise-syntax-error"
" make-exn:fail:syntax$1"
" given-name_0"
" message_0"
" expr_0"
" sub-expr_0"
" extra-sources_0"
" message-suffix_0))))))))))))))"
"(case-lambda"
"     ((given-name_0 message_0) (begin 'raise-syntax-error (raise-syntax-error_0 given-name_0 message_0 #f #f null \"\")))"
"((given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix4_0)"
"(raise-syntax-error_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix4_0))"
"((given-name_0 message_0 expr_0 sub-expr_0 extra-sources3_0)"
"      (raise-syntax-error_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources3_0 \"\"))"
"((given-name_0 message_0 expr_0 sub-expr2_0)"
"      (raise-syntax-error_0 given-name_0 message_0 expr_0 sub-expr2_0 null \"\"))"
"     ((given-name_0 message_0 expr1_0) (raise-syntax-error_0 given-name_0 message_0 expr1_0 #f null \"\")))))"
"(define-values"
"(raise-unbound-syntax-error)"
"(let-values(((raise-unbound-syntax-error_0)"
"(lambda(given-name11_0 message12_0 expr7_0 sub-expr8_0 extra-sources9_0 message-suffix10_0)"
"(begin"
" 'raise-unbound-syntax-error"
"(let-values(((given-name_0) given-name11_0))"
"(let-values(((message_0) message12_0))"
"(let-values(((expr_0) expr7_0))"
"(let-values(((sub-expr_0) sub-expr8_0))"
"(let-values(((extra-sources_0) extra-sources9_0))"
"(let-values(((message-suffix_0) message-suffix10_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(1/do-raise-syntax-error"
" 'raise-unbound-syntax-error"
" make-exn:fail:syntax:unbound$1"
" given-name_0"
" message_0"
" expr_0"
" sub-expr_0"
" extra-sources_0"
" message-suffix_0))))))))))))))"
"(case-lambda"
"     ((given-name_0 message_0) (begin (raise-unbound-syntax-error_0 given-name_0 message_0 #f #f null \"\")))"
"((given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix10_0)"
"(raise-unbound-syntax-error_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix10_0))"
"((given-name_0 message_0 expr_0 sub-expr_0 extra-sources9_0)"
"      (raise-unbound-syntax-error_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources9_0 \"\"))"
"((given-name_0 message_0 expr_0 sub-expr8_0)"
"      (raise-unbound-syntax-error_0 given-name_0 message_0 expr_0 sub-expr8_0 null \"\"))"
"     ((given-name_0 message_0 expr7_0) (raise-unbound-syntax-error_0 given-name_0 message_0 expr7_0 #f null \"\")))))"
"(define-values"
"(1/do-raise-syntax-error)"
"(lambda(who_0 exn:fail:syntax_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix_0)"
"(begin"
" 'do-raise-syntax-error"
"(let-values((()"
"(begin"
"(if((lambda(x_0)(let-values(((or-part_0)(not x_0)))(if or-part_0 or-part_0(symbol? x_0))))"
" given-name_0)"
"(void)"
"                        (let-values () (raise-argument-error who_0 \"(or/c symbol? #f)\" given-name_0)))"
"(values))))"
"(let-values((()"
"(begin"
"                        (if (string? message_0) (void) (let-values () (raise-argument-error who_0 \"string?\" message_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(if(list? extra-sources_0)(andmap2 syntax?$1 extra-sources_0) #f)"
"(void)"
"                            (let-values () (raise-argument-error who_0 \"(listof syntax?)\" extra-sources_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(string? message-suffix_0)"
"(void)"
"                              (let-values () (raise-argument-error who_0 \"string?\" message-suffix_0)))"
"(values))))"
"(let-values(((name_0)"
"(format"
"                             \"~a\""
"(let-values(((or-part_0) given-name_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(extract-form-name expr_0)))"
"(if or-part_1 or-part_1 '?)))))))"
"(let-values(((unbound-message_0)"
"(let-values(((ids_0)(current-previously-unbound)))"
"(let-values(((or-part_0)"
"(if(pair? ids_0)"
"(format"
"                                                 \"\\n  after encountering unbound identifier~a (which is possibly the real problem):~a\""
"                                                 (if (null? (cdr ids_0)) \"\" \"s\")"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(format"
"                                                                                                                       \"\\n   ~s\""
"(syntax-e$1"
" id_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
" #f)))"
"                                  (if or-part_0 or-part_0 \"\")))))"
"(let-values(((at-message_0)"
"(let-values(((or-part_0)"
"(if sub-expr_0"
"(if(error-print-source-location)"
"                                                  (string-append \"\\n  at:\" (syntax->string sub-expr_0))"
" #f)"
" #f)))"
"                                  (if or-part_0 or-part_0 \"\"))))"
"(let-values(((in-message_0)"
"(let-values(((or-part_0)"
"(if expr_0"
"(if(error-print-source-location)"
"                                                    (string-append \"\\n  in:\" (syntax->string expr_0))"
" #f)"
" #f)))"
"                                    (if or-part_0 or-part_0 \"\"))))"
"(let-values(((src-loc-str_0)"
"(let-values(((or-part_0)"
"(if(error-print-source-location)"
"(let-values(((or-part_0)(extract-source-location sub-expr_0)))"
"(if or-part_0 or-part_0(extract-source-location expr_0)))"
" #f)))"
"                                      (if or-part_0 or-part_0 \"\"))))"
"(let-values(((e_0)"
"(exn:fail:syntax_0"
"(string-append"
" src-loc-str_0"
" name_0"
"                                        \": \""
" message_0"
" unbound-message_0"
" at-message_0"
" in-message_0"
" message-suffix_0)"
"(current-continuation-marks)"
"(map2"
" syntax-taint$1"
"(if(let-values(((or-part_0) sub-expr_0))(if or-part_0 or-part_0 expr_0))"
"(let-values(((with-handlers-predicate17_0) exn:fail:contract?)"
"((with-handlers-handler18_0)"
"(lambda(exn_0)"
"(begin 'with-handlers-handler18 extra-sources_0))))"
"(let-values(((bpz_0)(continuation-mark-set-first #f break-enabled-key)))"
"(call-handled-body"
" bpz_0"
"(lambda(e_0)"
"(select-handler/no-breaks"
" e_0"
" bpz_0"
"(list(cons with-handlers-predicate17_0 with-handlers-handler18_0))))"
"(lambda()"
"(cons"
"(datum->syntax$1"
" #f"
"(let-values(((or-part_0) sub-expr_0))"
"(if or-part_0 or-part_0 expr_0)))"
" extra-sources_0)))))"
" extra-sources_0)))))"
"(begin"
"(if(1/exn:fail:syntax? e_0)"
"(void)"
"                              (let-values () (raise-result-error who_0 \"exn:fail:syntax?\" e_0)))"
"(raise e_0)))))))))))))))"
"(define-values"
"(extract-form-name)"
"(lambda(s_0)(begin(if(syntax?$1 s_0)(let-values()((error-syntax->name-handler) s_0))(let-values() #f)))))"
"(define-values"
"(extract-source-location)"
"(lambda(s_0)"
"(begin"
"(if(syntax?$1 s_0)"
"(if(syntax-srcloc$1 s_0)"
"          (let-values (((str_0) (srcloc->string (syntax-srcloc$1 s_0)))) (if str_0 (string-append str_0 \": \") #f))"
" #f)"
" #f))))"
"(define-values"
"(->datum)"
"(lambda(expr_0)"
"(begin"
"(let-values(((with-handlers-predicate19_0) exn:fail:contract?)"
"((with-handlers-handler20_0)(lambda(exn_0)(begin 'with-handlers-handler20 expr_0))))"
"(let-values(((bpz_0)(continuation-mark-set-first #f break-enabled-key)))"
"(call-handled-body"
" bpz_0"
"(lambda(e_0)"
"(select-handler/no-breaks e_0 bpz_0(list(cons with-handlers-predicate19_0 with-handlers-handler20_0))))"
"(lambda()(syntax->datum$1(datum->syntax$1 #f expr_0)))))))))"
"(define-values(current-previously-unbound)(lambda()(begin #f)))"
"(define-values(set-current-previously-unbound!)(lambda(proc_0)(begin(set! current-previously-unbound proc_0))))"
"(define-values"
"(syntax->string)"
"(lambda(v_0)"
"(begin"
"(let-values(((str_0)((error-syntax->string-handler) v_0(error-print-width))))"
"        (if (regexp-match? '#rx\"\\n\" str_0)"
"          (string-append \"\\n   \" (regexp-replace* '#rx\"\\n\" str_0 \"\\n   \"))"
"          (string-append \" \" str_0))))))"
"(define-values"
"(install-error-syntax->string-handler!)"
"(lambda()"
"(begin"
"(begin"
"(error-syntax->name-handler"
"(lambda(s_0)"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                             (let-values () (raise-argument-error 'default-error-syntax->name-handler \"syntax?\" s_0)))"
"(values))))"
"(let-values(((e_0)(syntax-e$1 s_0)))"
"(if(symbol? e_0)"
"(let-values() e_0)"
"(if(if(pair? e_0)(identifier?(car e_0)) #f)"
"(let-values()(syntax-e$1(car e_0)))"
"(let-values() #f)))))))"
"(error-syntax->string-handler"
"(let-values(((default-error-syntax->string-handler_0)"
"(lambda(v_0 len_0)"
"(begin"
" 'default-error-syntax->string-handler"
"(begin"
"(if(let-values(((or-part_0)(not len_0)))"
"(if or-part_0 or-part_0(exact-nonnegative-integer? len_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'default-error-syntax->string-handler"
"                                  \"(or/c exact-nonnegative-integer? #f)\""
" len_0)))"
"(if len_0"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" error-print-width"
"(max 3 len_0))"
"                                (let-values () (format \"~.s\" (->datum v_0))))"
"                               (format \"~s\" (->datum v_0))))))))"
" default-error-syntax->string-handler_0))))))"
"(define-values"
"(struct:module-use module-use1.1 module-use? module-use-module module-use-phase)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-use"
" #f"
" 2"
" 0"
" #f"
"(list"
"(cons"
" prop:equal+hash"
"(list"
"(lambda(a_0 b_0 eql?_0)"
"(let-values(((a-mod_0)(module-use-module a_0)))"
"(let-values(((b-mod_0)(module-use-module b_0)))"
"(if(eql?_0 a-mod_0 b-mod_0)"
"(if(eql?_0(module-use-phase a_0)(module-use-phase b_0))"
"(let-values(((a-path_0 a-base_0)(1/module-path-index-split a-mod_0))"
"((b-path_0 b-base_0)(1/module-path-index-split b-mod_0)))"
"(let-values(((or-part_0) a-path_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1) b-path_0))"
"(if or-part_1"
" or-part_1"
"(eq?"
"(module-path-index-resolved a-mod_0)"
"(module-path-index-resolved b-mod_0)))))))"
" #f)"
" #f))))"
"(lambda(a_0 hash-code_0)"
"(+(hash-code_0(module-use-module a_0))(hash-code_0(module-use-phase a_0))))"
"(lambda(a_0 hash-code_0)"
"(+(hash-code_0(module-use-module a_0))(hash-code_0(module-use-phase a_0)))))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'module-use)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module)"
"(make-struct-field-accessor -ref_0 1 'phase))))"
"(define-values"
"(struct:portal-syntax portal-syntax1.1 1/portal-syntax? portal-syntax-get-content portal-syntax-pos)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'portal-syntax"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'portal-syntax)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'get-content)"
"(make-struct-field-accessor -ref_0 1 'pos))))"
"(define-values"
"(1/make-portal-syntax)"
"(lambda(stx_0)"
"(begin"
" 'make-portal-syntax"
"(begin"
"        (if (syntax?$1 stx_0) (void) (let-values () (raise-argument-error 'make-portal-syntax \"syntax?\" stx_0)))"
"(portal-syntax1.1 stx_0 #f)))))"
"(define-values"
"(1/portal-syntax-content)"
"(lambda(p_0)"
"(begin"
" 'portal-syntax-content"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/portal-syntax? p_0)"
"(void)"
"                            (let-values () (raise-argument-error 'portal-syntax-content \"portal-syntax?\" p_0)))"
"(values))))"
"(let-values(((pos_0)(portal-syntax-pos p_0)))"
"(if pos_0((portal-syntax-get-content p_0) pos_0)(portal-syntax-get-content p_0)))))))))"
"(define-values"
"(struct:module"
" module1.1"
" module?"
" module-source-name"
" module-self"
" module-requires"
" module-recur-requires"
" module-flattened-requires"
" module-provides"
" module-access"
" module-language-info"
" module-realm"
" module-min-phase-level"
" module-max-phase-level"
" module-phase-level-linklet-info-callback"
" module-force-bulk-binding"
" module-prepare-instance"
" module-instantiate-phase"
" module-primitive?"
" module-is-predefined?"
" module-cross-phase-persistent?"
" module-no-protected?"
" module-inspector"
" module-submodule-names"
" module-supermodule-name"
" module-get-all-variables"
" module-get-portal-syntax-callback"
" set-module-access!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module"
" #f"
" 24"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23)"
" #f"
" 'module)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'source-name)"
"(make-struct-field-accessor -ref_0 1 'self)"
"(make-struct-field-accessor -ref_0 2 'requires)"
"(make-struct-field-accessor -ref_0 3 'recur-requires)"
"(make-struct-field-accessor -ref_0 4 'flattened-requires)"
"(make-struct-field-accessor -ref_0 5 'provides)"
"(make-struct-field-accessor -ref_0 6 'access)"
"(make-struct-field-accessor -ref_0 7 'language-info)"
"(make-struct-field-accessor -ref_0 8 'realm)"
"(make-struct-field-accessor -ref_0 9 'min-phase-level)"
"(make-struct-field-accessor -ref_0 10 'max-phase-level)"
"(make-struct-field-accessor -ref_0 11 'phase-level-linklet-info-callback)"
"(make-struct-field-accessor -ref_0 12 'force-bulk-binding)"
"(make-struct-field-accessor -ref_0 13 'prepare-instance)"
"(make-struct-field-accessor -ref_0 14 'instantiate-phase)"
"(make-struct-field-accessor -ref_0 15 'primitive?)"
"(make-struct-field-accessor -ref_0 16 'is-predefined?)"
"(make-struct-field-accessor -ref_0 17 'cross-phase-persistent?)"
"(make-struct-field-accessor -ref_0 18 'no-protected?)"
"(make-struct-field-accessor -ref_0 19 'inspector)"
"(make-struct-field-accessor -ref_0 20 'submodule-names)"
"(make-struct-field-accessor -ref_0 21 'supermodule-name)"
"(make-struct-field-accessor -ref_0 22 'get-all-variables)"
"(make-struct-field-accessor -ref_0 23 'get-portal-syntax-callback)"
"(make-struct-field-mutator -set!_0 6 'access))))"
"(define-values"
"(struct:module-linklet-info"
" module-linklet-info2.1"
" module-linklet-info?"
" module-linklet-info-linklet-or-instance"
" module-linklet-info-module-uses"
" module-linklet-info-self"
" module-linklet-info-inspector"
" module-linklet-info-extra-inspector"
" module-linklet-info-extra-inspectorsss)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-linklet-info"
" #f"
" 6"
" 0"
" #f"
"(list(cons prop:authentic #t))"
" #f"
" #f"
" '(0 1 2 3 4 5)"
" #f"
" 'module-linklet-info)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'linklet-or-instance)"
"(make-struct-field-accessor -ref_0 1 'module-uses)"
"(make-struct-field-accessor -ref_0 2 'self)"
"(make-struct-field-accessor -ref_0 3 'inspector)"
"(make-struct-field-accessor -ref_0 4 'extra-inspector)"
"(make-struct-field-accessor -ref_0 5 'extra-inspectorsss))))"
"(define-values"
"(make-module.1)"
"(lambda(cross-phase-persistent?19_0"
" flattened-requires7_0"
" force-bulk-binding-callback12_0"
" get-all-variables23_0"
" get-portal-syntax-callback24_0"
" instantiate-phase-callback11_0"
" language-info15_0"
" max-phase-level10_0"
" min-phase-level9_0"
" no-protected?20_0"
" phase-level-linklet-info-callback14_0"
" predefined?18_0"
" prepare-instance-callback13_0"
" primitive?17_0"
" provides8_0"
" realm16_0"
" recur-requires6_0"
" requires5_0"
" self4_0"
" source-name3_0"
" submodule-names21_0"
" supermodule-name22_0)"
"(begin"
" 'make-module"
"(let-values(((source-name_0) source-name3_0))"
"(let-values(((self_0) self4_0))"
"(let-values(((requires_0) requires5_0))"
"(let-values(((recur-requires_0)"
"(if(eq? recur-requires6_0 unsafe-undefined)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((phase+mps_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
"(cdr"
" phase+mps_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((mp_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
" #t)"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" recur-requires6_0)))"
"(let-values(((flattened-requires_0) flattened-requires7_0))"
"(let-values(((provides_0) provides8_0))"
"(let-values(((min-phase-level_0) min-phase-level9_0))"
"(let-values(((max-phase-level_0) max-phase-level10_0))"
"(let-values(((instantiate-phase_0) instantiate-phase-callback11_0))"
"(let-values(((force-bulk-binding_0) force-bulk-binding-callback12_0))"
"(let-values(((prepare-instance_0) prepare-instance-callback13_0))"
"(let-values(((phase-level-linklet-info-callback_0)"
"(if(eq? phase-level-linklet-info-callback14_0 unsafe-undefined)"
"(lambda(phase-level_0 ns_0 insp_0)"
"(begin 'phase-level-linklet-info-callback #f))"
" phase-level-linklet-info-callback14_0)))"
"(let-values(((language-info_0) language-info15_0))"
"(let-values(((realm_0) realm16_0))"
"(let-values(((primitive?_0) primitive?17_0))"
"(let-values(((predefined?_0) predefined?18_0))"
"(let-values(((cross-phase-persistent?_0)"
"(if(eq? cross-phase-persistent?19_0 unsafe-undefined)"
" primitive?_0"
" cross-phase-persistent?19_0)))"
"(let-values(((no-protected?_0) no-protected?20_0))"
"(let-values(((submodule-names_0) submodule-names21_0))"
"(let-values(((supermodule-name_0) supermodule-name22_0))"
"(let-values(((get-all-variables_0)"
"(if(eq? get-all-variables23_0 unsafe-undefined)"
"(lambda()(begin 'get-all-variables null))"
" get-all-variables23_0)))"
"(let-values(((get-portal-syntax-callback_0)"
"(if(eq? get-portal-syntax-callback24_0 unsafe-undefined)"
"(lambda(data-box_0 phase_0 sym_0)"
"(begin 'get-portal-syntax-callback #f))"
" get-portal-syntax-callback24_0)))"
"(let-values()"
"(module1.1"
" source-name_0"
" self_0"
" requires_0"
" recur-requires_0"
" flattened-requires_0"
" provides_0"
" #f"
" language-info_0"
" realm_0"
" min-phase-level_0"
" max-phase-level_0"
" phase-level-linklet-info-callback_0"
" force-bulk-binding_0"
" prepare-instance_0"
" instantiate-phase_0"
" primitive?_0"
" predefined?_0"
" cross-phase-persistent?_0"
" no-protected?_0"
"(current-code-inspector)"
" submodule-names_0"
" supermodule-name_0"
" get-all-variables_0"
" get-portal-syntax-callback_0)))))))))))))))))))))))))))"
"(define-values"
"(struct:module-instance"
" module-instance48.1"
" module-instance?"
" module-instance-namespace"
" module-instance-module"
" module-instance-shifted-requires"
" module-instance-phase-level-to-state"
" module-instance-made-available?"
" module-instance-attached?"
" module-instance-data-box"
" module-instance-portal-syntaxes"
" set-module-instance-shifted-requires!"
" set-module-instance-made-available?!"
" set-module-instance-attached?!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-instance"
" #f"
" 8"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 3 6 7)"
" #f"
" 'module-instance)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'namespace)"
"(make-struct-field-accessor -ref_0 1 'module)"
"(make-struct-field-accessor -ref_0 2 'shifted-requires)"
"(make-struct-field-accessor -ref_0 3 'phase-level-to-state)"
"(make-struct-field-accessor -ref_0 4 'made-available?)"
"(make-struct-field-accessor -ref_0 5 'attached?)"
"(make-struct-field-accessor -ref_0 6 'data-box)"
"(make-struct-field-accessor -ref_0 7 'portal-syntaxes)"
"(make-struct-field-mutator -set!_0 2 'shifted-requires)"
"(make-struct-field-mutator -set!_0 4 'made-available?)"
"(make-struct-field-mutator -set!_0 5 'attached?))))"
"(define-values"
"(make-module-instance)"
"(lambda(m-ns_0 m_0 portal-syntaxes_0)"
"(begin(module-instance48.1 m-ns_0 m_0 #f(make-small-hasheqv) #f #f(box #f) portal-syntaxes_0))))"
"(define-values"
"(make-module-namespace.1)"
"(lambda(for-submodule?51_0 mpi49_0 portal-syntaxes52_0 root-expand-context50_0 ns57_0)"
"(begin"
" 'make-module-namespace"
"(let-values(((ns_0) ns57_0))"
"(let-values(((name-mpi_0) mpi49_0))"
"(let-values(((root-expand-ctx_0) root-expand-context50_0))"
"(let-values(((for-submodule?_0) for-submodule?51_0))"
"(let-values(((portal-syntaxes_0) portal-syntaxes52_0))"
"(let-values()"
"(let-values(((phase_0) 0))"
"(let-values(((name_0)(1/module-path-index-resolve name-mpi_0)))"
"(let-values(((m-ns_0)"
"(let-values(((the-struct_0)"
"(let-values(((ns173_0) ns_0)"
"((root-expand-ctx174_0) root-expand-ctx_0)"
"((temp175_0) #f))"
"(new-namespace.1 temp175_0 root-expand-ctx174_0 ns173_0))))"
"(if(1/namespace? the-struct_0)"
"(let-values(((mpi164_0) name-mpi_0)"
"((source-name165_0)(resolved-module-path-root-name name_0))"
"((phase166_0) phase_0)"
"((0-phase167_0) phase_0)"
"((submodule-declarations168_0)"
"(if for-submodule?_0"
"(namespace-submodule-declarations ns_0)"
"(make-small-hasheq)))"
"((available-module-instances169_0)(make-hasheqv))"
"((available-cross-phase-module-instances170_0)(box null))"
"((module-instances171_0)(make-hasheqv))"
"((declaration-inspector172_0)(current-code-inspector)))"
"(namespace1.1"
" mpi164_0"
" source-name165_0"
"(namespace-root-expand-ctx the-struct_0)"
" phase166_0"
" 0-phase167_0"
"(namespace-phase-to-namespace the-struct_0)"
"(namespace-phase-level-to-definitions the-struct_0)"
"(namespace-module-registry$1 the-struct_0)"
"(namespace-module-instance-shifted-requires the-struct_0)"
"(namespace-bulk-binding-registry the-struct_0)"
" submodule-declarations168_0"
"(namespace-root-namespace the-struct_0)"
" declaration-inspector172_0"
"(namespace-inspector the-struct_0)"
" available-module-instances169_0"
" available-cross-phase-module-instances170_0"
" module-instances171_0))"
"                                        (raise-argument-error 'struct-copy \"namespace?\" the-struct_0)))))"
"(let-values((()"
"(begin"
"(small-hash-set!(namespace-phase-to-namespace m-ns_0) phase_0 m-ns_0)"
"(values))))"
"(let-values(((at-phase_0)(make-hasheq)))"
"(begin"
"(hash-set!(namespace-module-instances m-ns_0) phase_0 at-phase_0)"
"(hash-set! at-phase_0 name_0(make-module-instance m-ns_0 #f portal-syntaxes_0))"
" m-ns_0)))))))))))))))"
"(define-values"
"(declare-module!.1)"
"(lambda(with-submodules?59_0 ns61_0 m62_0 mod-name63_0)"
"(begin"
" 'declare-module!"
"(let-values(((ns_0) ns61_0))"
"(let-values(((m_0) m62_0))"
"(let-values(((mod-name_0) mod-name63_0))"
"(let-values(((with-submodules?_0) with-submodules?59_0))"
"(let-values()"
"(let-values(((prior-m_0)"
"(if with-submodules?_0"
"(hash-ref"
"(module-registry-declarations(namespace-module-registry$1 ns_0))"
" mod-name_0"
" #f)"
" #f)))"
"(let-values(((prior-mi_0)"
"(if prior-m_0"
"(if(not(eq? m_0 prior-m_0))"
"(let-values(((ns176_0) ns_0)"
"((mod-name177_0) mod-name_0)"
"((temp178_0)(namespace-phase ns_0)))"
"(namespace->module-instance.1 #f #f void ns176_0 mod-name177_0 temp178_0))"
" #f)"
" #f)))"
"(begin"
"(if(if prior-m_0(not(eq? m_0 prior-m_0)) #f)"
"(let-values()(check-redeclaration-ok prior-m_0 prior-mi_0 mod-name_0))"
"(void))"
"(if with-submodules?_0"
"(hash-set!(module-registry-declarations(namespace-module-registry$1 ns_0)) mod-name_0 m_0)"
"(small-hash-set!(namespace-submodule-declarations ns_0) mod-name_0 m_0))"
"(if with-submodules?_0"
"(let-values()"
"(begin"
"(register-bulk-provide!"
"(namespace-bulk-binding-registry ns_0)"
" mod-name_0"
"(module-self m_0)"
"(module-provides m_0))"
"((1/current-module-name-resolver) mod-name_0 #f)))"
"(void))"
"(if prior-mi_0"
"(let-values()"
"(let-values(((m-ns_0)(module-instance-namespace prior-mi_0)))"
"(let-values(((states_0)(module-instance-phase-level-to-state prior-mi_0)))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"(let-values(((visit?_0)(eq? 'started(small-hash-ref states_0(add1 phase_0) #f))))"
"(let-values(((run?_0)(eq? 'started(small-hash-ref states_0 phase_0 #f))))"
"(let-values(((at-phase_0)(hash-ref(namespace-module-instances ns_0) phase_0)))"
"(begin"
"(hash-set! at-phase_0 mod-name_0(make-module-instance m-ns_0 m_0 #f))"
"(set-module-instance-shifted-requires! prior-mi_0 #f)"
"(namespace-clear-shifted-requires! ns_0 mod-name_0)"
"(if visit?_0"
"(let-values()"
"(let-values(((ns179_0) ns_0)"
"((temp180_0)(namespace-mpi m-ns_0))"
"((phase181_0) phase_0))"
"(namespace-module-visit!.1"
" #f"
" unsafe-undefined"
" ns179_0"
" temp180_0"
" phase181_0)))"
"(void))"
"(if run?_0"
"(let-values()"
"(let-values(((ns182_0) ns_0)"
"((temp183_0)(namespace-mpi m-ns_0))"
"((phase184_0) phase_0))"
"(namespace-module-instantiate!.1"
" #f"
" #t"
" #t"
" unsafe-undefined"
" '#hasheq()"
" null"
" #f"
" #f"
" ns182_0"
" temp183_0"
" phase184_0)))"
"(void))))))))))"
"(void)))))))))))))"
"(define-values"
"(check-redeclaration-ok)"
"(lambda(prior-m_0 prior-mi_0 mod-name_0)"
"(begin"
"(begin"
"(if(module-cross-phase-persistent? prior-m_0)"
"(let-values()"
"(raise-arguments-error"
" 'module"
"             \"cannot redeclare cross-phase persistent module\""
"             \"module name\""
"(module-name->error-string mod-name_0)))"
"(void))"
"(if(if prior-mi_0"
"(let-values(((or-part_0)(module-instance-attached? prior-mi_0)))"
"(if or-part_0"
" or-part_0"
"(not"
"(inspector-superior?"
"(current-code-inspector)"
"(namespace-inspector(module-instance-namespace prior-mi_0))))))"
" #f)"
"(let-values()"
"(raise-arguments-error"
" 'module"
"             \"current code inspector cannot redeclare module\""
"             \"module name\""
"(module-name->error-string mod-name_0)))"
"(void))))))"
"(define-values"
"(raise-unknown-module-error)"
"(lambda(who_0 mod-name_0)"
"    (begin (raise-arguments-error who_0 \"unknown module\" \"module name\" (module-name->error-string mod-name_0)))))"
"(define-values"
"(namespace->module-linklet-info)"
"(lambda(ns_0 name_0 phase-level_0)"
"(begin"
"(let-values(((m_0)(namespace->module ns_0 name_0)))"
"(if m_0((module-phase-level-linklet-info-callback m_0) phase-level_0 ns_0(module-inspector m_0)) #f)))))"
"(define-values"
"(module-name->error-string)"
"  (lambda (mod-name_0) (begin (unquoted-printing-string (format \"~a\" mod-name_0)))))"
"(define-values"
"(namespace->module-instance.1)"
"(lambda(check-available-at-phase-level66_0"
" complain-on-failure?65_0"
" unavailable-callback67_0"
" ns71_0"
" name72_0"
" 0-phase73_0)"
"(begin"
" 'namespace->module-instance"
"(let-values(((ns_0) ns71_0))"
"(let-values(((name_0) name72_0))"
"(let-values(((0-phase_0) 0-phase73_0))"
"(let-values(((complain-on-failure?_0) complain-on-failure?65_0))"
"(let-values(((check-available-at-phase-level_0) check-available-at-phase-level66_0))"
"(let-values(((unavailable-callback_0) unavailable-callback67_0))"
"(let-values()"
"(let-values(((mi_0)"
"(let-values(((or-part_0)"
"(hash-ref"
"(hash-ref(namespace-module-instances ns_0) 0-phase_0 '#hasheq())"
" name_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(let-values(((c-ns_0)"
"(let-values(((or-part_1)"
"(namespace-root-namespace ns_0)))"
"(if or-part_1 or-part_1 ns_0))))"
"(hash-ref(namespace-module-instances c-ns_0) name_0 #f))))"
"(if or-part_1"
" or-part_1"
"(if complain-on-failure?_0"
"(error"
" 'require"
"(string-append"
"                                              \"namespace mismatch;\\n\""
"                                              \" reference to a module that is not instantiated\\n\""
"                                              \"  module: ~a\\n\""
"                                              \"  phase: ~a\")"
" name_0"
" 0-phase_0)"
" #f)))))))"
"(if(if mi_0 check-available-at-phase-level_0 #f)"
"(check-availablilty mi_0 check-available-at-phase-level_0 unavailable-callback_0)"
" mi_0))))))))))))"
"(define-values"
"(namespace-install-module-namespace!)"
"(lambda(ns_0 name_0 0-phase_0 m_0 existing-m-ns_0 run-phase_0)"
"(begin"
"(let-values(((m-ns_0)"
"(let-values(((the-struct_0) ns_0))"
"(if(1/namespace? the-struct_0)"
"(let-values(((mpi185_0)(namespace-mpi existing-m-ns_0))"
"((source-name186_0)(namespace-source-name existing-m-ns_0))"
"((root-expand-ctx187_0)(box(unbox(namespace-root-expand-ctx existing-m-ns_0))))"
"((phase188_0)(namespace-phase existing-m-ns_0))"
"((0-phase189_0)(namespace-0-phase existing-m-ns_0))"
"((phase-to-namespace190_0)(make-small-hasheqv))"
"((phase-level-to-definitions191_0)"
"(if(module-cross-phase-persistent? m_0)"
"(namespace-phase-level-to-definitions existing-m-ns_0)"
"(make-small-hasheqv)))"
"((declaration-inspector192_0)(module-inspector m_0))"
"((inspector193_0)(namespace-inspector existing-m-ns_0)))"
"(namespace1.1"
" mpi185_0"
" source-name186_0"
" root-expand-ctx187_0"
" phase188_0"
" 0-phase189_0"
" phase-to-namespace190_0"
" phase-level-to-definitions191_0"
"(namespace-module-registry$1 the-struct_0)"
"(namespace-module-instance-shifted-requires the-struct_0)"
"(namespace-bulk-binding-registry the-struct_0)"
"(namespace-submodule-declarations the-struct_0)"
"(namespace-root-namespace the-struct_0)"
" declaration-inspector192_0"
" inspector193_0"
"(namespace-available-module-instances the-struct_0)"
"(namespace-available-cross-phase-module-instances the-struct_0)"
"(namespace-module-instances the-struct_0)))"
"                        (raise-argument-error 'struct-copy \"namespace?\" the-struct_0)))))"
"(let-values(((mi_0)(make-module-instance m-ns_0 m_0 #f)))"
"(begin"
"(set-module-instance-attached?! mi_0 #t)"
"(if(module-cross-phase-persistent? m_0)"
"(let-values()"
"(begin"
"(small-hash-set!(namespace-phase-to-namespace m-ns_0) 0 m-ns_0)"
"(small-hash-set!"
"(namespace-phase-level-to-definitions m-ns_0)"
" 0"
"(namespace->definitions existing-m-ns_0 0))"
"(small-hash-set!(namespace-phase-to-namespace m-ns_0) 1(namespace->namespace-at-phase m-ns_0 1))"
"(small-hash-set!"
"(namespace-phase-level-to-definitions m-ns_0)"
" 1"
"(namespace->definitions existing-m-ns_0 1))"
"(hash-set!"
"(namespace-module-instances"
"(let-values(((or-part_0)(namespace-root-namespace ns_0)))(if or-part_0 or-part_0 ns_0)))"
" name_0"
" mi_0)"
"(small-hash-set!(module-instance-phase-level-to-state mi_0) 0 'started)))"
"(let-values()"
"(let-values(((run-phase-level_0)(phase- run-phase_0 0-phase_0)))"
"(let-values((()"
"(begin"
"(small-hash-set!(namespace-phase-to-namespace m-ns_0) 0-phase_0 m-ns_0)"
"(values))))"
"(let-values((()"
"(begin"
"(small-hash-set!"
"(namespace-phase-level-to-definitions m-ns_0)"
" run-phase-level_0"
"(namespace->definitions existing-m-ns_0 run-phase-level_0))"
"(values))))"
"(let-values((()"
"(begin"
"(small-hash-set!"
"(module-instance-phase-level-to-state mi_0)"
" run-phase-level_0"
" 'started)"
"(values))))"
"(let-values(((at-phase_0)"
"(let-values(((or-part_0)"
"(hash-ref(namespace-module-instances ns_0) 0-phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((at-phase_0)(make-hasheq)))"
"(begin"
"(hash-set!(namespace-module-instances ns_0) 0-phase_0 at-phase_0)"
" at-phase_0))))))"
"(hash-set! at-phase_0 name_0 mi_0))))))))))))))"
"(define-values"
"(namespace-create-module-instance!)"
"(lambda(ns_0 name_0 0-phase_0 m_0 mpi_0)"
"(begin"
"(let-values(((m-ns_0)"
"(let-values(((the-struct_0) ns_0))"
"(if(1/namespace? the-struct_0)"
"(let-values(((mpi194_0) mpi_0)"
"((source-name195_0)"
"(let-values(((or-part_0)(module-source-name m_0)))"
"(if or-part_0"
" or-part_0"
"(resolved-module-path-root-name(1/module-path-index-resolve mpi_0)))))"
"((root-expand-ctx196_0)(box #f))"
"((phase197_0) 0-phase_0)"
"((0-phase198_0) 0-phase_0)"
"((phase-to-namespace199_0)(make-small-hasheqv))"
"((phase-level-to-definitions200_0)(make-small-hasheqv))"
"((declaration-inspector201_0)(module-inspector m_0))"
"((inspector202_0)(make-inspector(module-inspector m_0))))"
"(namespace1.1"
" mpi194_0"
" source-name195_0"
" root-expand-ctx196_0"
" phase197_0"
" 0-phase198_0"
" phase-to-namespace199_0"
" phase-level-to-definitions200_0"
"(namespace-module-registry$1 the-struct_0)"
"(namespace-module-instance-shifted-requires the-struct_0)"
"(namespace-bulk-binding-registry the-struct_0)"
"(namespace-submodule-declarations the-struct_0)"
"(namespace-root-namespace the-struct_0)"
" declaration-inspector201_0"
" inspector202_0"
"(namespace-available-module-instances the-struct_0)"
"(namespace-available-cross-phase-module-instances the-struct_0)"
"(namespace-module-instances the-struct_0)))"
"                        (raise-argument-error 'struct-copy \"namespace?\" the-struct_0)))))"
"(let-values((()(begin(small-hash-set!(namespace-phase-to-namespace m-ns_0) 0-phase_0 m-ns_0)(values))))"
"(let-values(((mi_0)(make-module-instance m-ns_0 m_0 #f)))"
"(begin"
"(if(module-cross-phase-persistent? m_0)"
"(hash-set!(namespace-module-instances ns_0) name_0 mi_0)"
"(let-values(((at-phase_0)"
"(let-values(((or-part_0)(hash-ref(namespace-module-instances ns_0) 0-phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((at-phase_0)(make-hasheq)))"
"(begin"
"(hash-set!(namespace-module-instances ns_0) 0-phase_0 at-phase_0)"
" at-phase_0))))))"
"(hash-set! at-phase_0 name_0 mi_0)))"
" mi_0)))))))"
"(define-values"
"(check-availablilty)"
"(lambda(mi_0 check-available-at-phase-level_0 unavailable-callback_0)"
"(begin"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(if(if m_0"
"(if(<=(module-min-phase-level m_0)(add1 check-available-at-phase-level_0)(module-max-phase-level m_0))"
"(not"
"(small-hash-ref"
"(module-instance-phase-level-to-state mi_0)"
"(add1 check-available-at-phase-level_0)"
" #f))"
" #f)"
" #f)"
"(unavailable-callback_0 mi_0)"
" mi_0)))))"
"(define-values"
"(namespace->module-namespace.1)"
"(lambda(check-available-at-phase-level76_0"
" complain-on-failure?75_0"
" unavailable-callback77_0"
" ns81_0"
" name82_0"
" 0-phase83_0)"
"(begin"
" 'namespace->module-namespace"
"(let-values(((ns_0) ns81_0))"
"(let-values(((name_0) name82_0))"
"(let-values(((0-phase_0) 0-phase83_0))"
"(let-values(((complain-on-failure?_0) complain-on-failure?75_0))"
"(let-values(((check-available-at-phase-level_0) check-available-at-phase-level76_0))"
"(let-values(((unavailable-callback_0) unavailable-callback77_0))"
"(let-values()"
"(let-values(((mi_0)"
"(let-values(((ns203_0) ns_0)"
"((name204_0) name_0)"
"((0-phase205_0) 0-phase_0)"
"((complain-on-failure?206_0) complain-on-failure?_0)"
"((check-available-at-phase-level207_0) check-available-at-phase-level_0)"
"((unavailable-callback208_0) unavailable-callback_0))"
"(namespace->module-instance.1"
" check-available-at-phase-level207_0"
" complain-on-failure?206_0"
" unavailable-callback208_0"
" ns203_0"
" name204_0"
" 0-phase205_0))))"
"(if mi_0(module-instance-namespace mi_0) #f))))))))))))"
"(define-values"
"(namespace-record-module-instance-attached!)"
"(lambda(ns_0 mod-name_0 phase_0)"
"(begin"
"(let-values(((mi_0)"
"(let-values(((ns209_0) ns_0)((mod-name210_0) mod-name_0)((phase211_0) phase_0))"
"(namespace->module-instance.1 #f #f void ns209_0 mod-name210_0 phase211_0))))"
"(set-module-instance-attached?! mi_0 #t)))))"
"(define-values"
"(module-force-bulk-binding!)"
"(lambda(m_0 ns_0)(begin((module-force-bulk-binding m_0)(namespace-bulk-binding-registry ns_0)))))"
"(define-values"
"(module-instantiates-at-level?)"
"(lambda(m_0 phase-level_0)"
"(begin"
"(if(not(label-phase? phase-level_0))"
"(<=(module-min-phase-level m_0) phase-level_0(module-max-phase-level m_0))"
" #f))))"
"(define-values"
"(namespace-module-instantiate!.1)"
"(lambda(minimum-inspector91_0"
" otherwise-available?87_0"
" recur?90_0"
" run-phase85_0"
" seen88_0"
" seen-list89_0"
" skip-run?86_0"
" transitive-record92_0"
" ns101_0"
" mpi102_0"
" instance-phase103_0)"
"(begin"
" 'namespace-module-instantiate!"
"(let-values(((ns_0) ns101_0))"
"(let-values(((mpi_0) mpi102_0))"
"(let-values(((instance-phase_0) instance-phase103_0))"
"(let-values(((run-phase_0)(if(eq? run-phase85_0 unsafe-undefined)(namespace-phase ns_0) run-phase85_0)))"
"(let-values(((skip-run?_0) skip-run?86_0))"
"(let-values(((otherwise-available?_0) otherwise-available?87_0))"
"(let-values(((seen_0) seen88_0))"
"(let-values(((seen-list_0) seen-list89_0))"
"(let-values(((recur?_0) recur?90_0))"
"(let-values(((minimum-inspector_0) minimum-inspector91_0))"
"(let-values(((transitive-modules_0) transitive-record92_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/module-path-index? mpi_0)"
"(void)"
"                                                (let-values () (error \"not a module path index:\" mpi_0)))"
"(values))))"
"(let-values(((name_0)(1/module-path-index-resolve mpi_0 #t)))"
"(let-values((()"
"(begin"
"(if(if transitive-modules_0(pair? seen-list_0) #f)"
"(let-values()"
"(hash-set!"
" transitive-modules_0"
" name_0"
"(hash-set"
"(hash-ref transitive-modules_0 name_0 '#hasheqv())"
" instance-phase_0"
" #t)))"
"(void))"
"(values))))"
"(let-values(((m_0)(namespace->module ns_0 name_0)))"
"(let-values((()"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-unknown-module-error 'instantiate name_0)))"
"(values))))"
"(let-values(((instantiate!_0)"
"(lambda(instance-phase_1 run-phase_1 ns_1)"
"(begin"
" 'instantiate!"
"(let-values(((mi_0)"
"(let-values(((or-part_0)"
"(let-values(((ns222_0) ns_1)"
"((name223_0) name_0)"
"((instance-phase224_0)"
" instance-phase_1))"
"(namespace->module-instance.1"
" #f"
" #f"
" void"
" ns222_0"
" name223_0"
" instance-phase224_0))))"
"(if or-part_0"
" or-part_0"
"(namespace-create-module-instance!"
" ns_1"
" name_0"
" instance-phase_1"
" m_0"
" mpi_0)))))"
"(let-values(((mi212_0) mi_0)"
"((ns213_0) ns_1)"
"((run-phase214_0) run-phase_1)"
"((skip-run?215_0) skip-run?_0)"
"((otherwise-available?216_0)"
" otherwise-available?_0)"
"((seen217_0) seen_0)"
"((seen-list218_0) seen-list_0)"
"((recur?219_0) recur?_0)"
"((minimum-inspector220_0) minimum-inspector_0)"
"((transitive-modules221_0)"
" transitive-modules_0))"
"(run-module-instance!.1"
" minimum-inspector220_0"
" otherwise-available?216_0"
" recur?219_0"
" run-phase214_0"
" seen217_0"
" seen-list218_0"
" skip-run?215_0"
" transitive-modules221_0"
" mi212_0"
" ns213_0)))))))"
"(if(module-cross-phase-persistent? m_0)"
"(let-values()"
"(instantiate!_0"
" 0"
" 0"
"(let-values(((or-part_0)(namespace-root-namespace ns_0)))"
"(if or-part_0 or-part_0 ns_0))))"
"(let-values()"
"(instantiate!_0 instance-phase_0 run-phase_0 ns_0))))))))))))))))))))))))"
"(define-values"
"(namespace-module-visit!.1)"
"(lambda(transitive-record106_0 visit-phase105_0 ns109_0 mpi110_0 instance-phase111_0)"
"(begin"
" 'namespace-module-visit!"
"(let-values(((ns_0) ns109_0))"
"(let-values(((mpi_0) mpi110_0))"
"(let-values(((instance-phase_0) instance-phase111_0))"
"(let-values(((visit-phase_0)"
"(if(eq? visit-phase105_0 unsafe-undefined)(namespace-phase ns_0) visit-phase105_0)))"
"(let-values(((transitive-modules_0) transitive-record106_0))"
"(let-values()"
"(let-values(((ns225_0) ns_0)"
"((mpi226_0) mpi_0)"
"((instance-phase227_0) instance-phase_0)"
"((temp228_0)(add1 visit-phase_0))"
"((transitive-modules229_0) transitive-modules_0))"
"(namespace-module-instantiate!.1"
" #f"
" #t"
" #t"
" temp228_0"
" '#hasheq()"
" null"
" #f"
" transitive-modules229_0"
" ns225_0"
" mpi226_0"
" instance-phase227_0)))))))))))"
"(define-values"
"(namespace-module-make-available!.1)"
"(lambda(transitive-record114_0 visit-phase113_0 ns117_0 mpi118_0 instance-phase119_0)"
"(begin"
" 'namespace-module-make-available!"
"(let-values(((ns_0) ns117_0))"
"(let-values(((mpi_0) mpi118_0))"
"(let-values(((instance-phase_0) instance-phase119_0))"
"(let-values(((visit-phase_0)"
"(if(eq? visit-phase113_0 unsafe-undefined)(namespace-phase ns_0) visit-phase113_0)))"
"(let-values(((transitive-modules_0) transitive-record114_0))"
"(let-values()"
"(let-values(((ns230_0) ns_0)"
"((mpi231_0) mpi_0)"
"((instance-phase232_0) instance-phase_0)"
"((temp233_0)(add1 visit-phase_0))"
"((temp234_0) #t)"
"((transitive-modules235_0) transitive-modules_0))"
"(namespace-module-instantiate!.1"
" #f"
" #t"
" #t"
" temp233_0"
" '#hasheq()"
" null"
" temp234_0"
" transitive-modules235_0"
" ns230_0"
" mpi231_0"
" instance-phase232_0)))))))))))"
"(define-values"
"(namespace-module-get-portal-syntax-lookup)"
"(lambda(ns_0 mpi_0 phase-shift_0)"
"(begin"
"(let-values(((name_0)(1/module-path-index-resolve mpi_0 #t)))"
"(let-values(((ready-mi_0)"
"(let-values(((ns236_0) ns_0)((name237_0) name_0)((phase-shift238_0) phase-shift_0))"
"(namespace->module-instance.1 #f #f void ns236_0 name237_0 phase-shift238_0))))"
"(let-values(((try-namespace-lookup_0)"
"(lambda(ns_1 phase_0 sym_0)"
"(begin"
" 'try-namespace-lookup"
"(let-values(((v_0)(namespace-get-transformer ns_1 phase_0 sym_0(lambda() #f))))"
"(if(1/portal-syntax? v_0)(1/portal-syntax-content v_0) #f))))))"
"(let-values(((c1_0)(if ready-mi_0(module-instance-portal-syntaxes ready-mi_0) #f)))"
"(if c1_0"
"((lambda(portal-syntaxes_0)"
"(lambda(phase_0 sym_0)(hash-ref(hash-ref portal-syntaxes_0 phase_0 '#hasheqv()) sym_0 #f)))"
" c1_0)"
"(if(top-level-module-path-index? mpi_0)"
"(let-values()"
"(lambda(phase_0 sym_0)(try-namespace-lookup_0 ns_0(phase+ phase_0 phase-shift_0) sym_0)))"
"(if(non-self-module-path-index? mpi_0)"
"(let-values()"
"(let-values(((mi_0)"
"(let-values(((or-part_0) ready-mi_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((m_0)(namespace->module ns_0 name_0)))"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-unknown-module-error 'identifier-binding-portal-syntax name_0)))"
"(namespace-create-module-instance!"
" ns_0"
" name_0"
" phase-shift_0"
" m_0"
" mpi_0)))))))"
"(let-values(((m-ns_0)(module-instance-namespace mi_0)))"
"(let-values(((bulk-binding-registry_0)(namespace-bulk-binding-registry m-ns_0)))"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(let-values(((insp_0)(module-inspector m_0)))"
"(let-values(((data-box_0)(module-instance-data-box mi_0)))"
"(let-values(((prep_0)(module-prepare-instance m_0)))"
"(let-values((()"
"(begin"
"(prep_0"
" data-box_0"
" m-ns_0"
" phase-shift_0"
" mpi_0"
" bulk-binding-registry_0"
" insp_0)"
"(values))))"
"(let-values(((get_0)(module-get-portal-syntax-callback m_0)))"
"(lambda(phase_0 sym_0)"
"(let-values(((or-part_0)(get_0 data-box_0 phase_0 sym_0)))"
"(if or-part_0"
" or-part_0"
"(try-namespace-lookup_0 m-ns_0 phase_0 sym_0))))))))))))))"
"(let-values()(lambda(phase_0 sym_0)(try-namespace-lookup_0 ns_0 phase_0 sym_0)))))))))))))"
"(define-values"
"(run-module-instance!.1)"
"(lambda(minimum-inspector127_0"
" otherwise-available?123_0"
" recur?124_0"
" run-phase121_0"
" seen125_0"
" seen-list126_0"
" skip-run?122_0"
" transitive-record128_0"
" mi137_0"
" ns138_0)"
"(begin"
" 'run-module-instance!"
"(let-values(((mi_0) mi137_0))"
"(let-values(((ns_0) ns138_0))"
"(let-values(((run-phase_0) run-phase121_0))"
"(let-values(((skip-run?_0) skip-run?122_0))"
"(let-values(((otherwise-available?_0) otherwise-available?123_0))"
"(let-values(((recur?_0) recur?124_0))"
"(let-values(((seen_0) seen125_0))"
"(let-values(((seen-list_0) seen-list126_0))"
"(let-values(((minimum-inspector_0) minimum-inspector127_0))"
"(let-values(((transitive-modules_0) transitive-record128_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'eval 'requires))(void))"
"(begin0"
"(let-values()"
"(let-values(((m-ns_0)(module-instance-namespace mi_0)))"
"(let-values(((instance-phase_0)(namespace-0-phase m-ns_0)))"
"(let-values(((run-phase-level_0)(phase- run-phase_0 instance-phase_0)))"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(let-values(((inspector_0)(if m_0(module-inspector m_0) #f)))"
"(begin"
"(if(if minimum-inspector_0 inspector_0 #f)"
"(let-values()"
"(if(let-values(((or-part_0)(eq? inspector_0 minimum-inspector_0)))"
"(if or-part_0"
" or-part_0"
"(inspector-superior? inspector_0 minimum-inspector_0)))"
"(void)"
"(let-values()"
"(error"
" 'require"
"                                                       \"cannot import module with weaker code inspector\\n  module: ~a\""
"(1/module-path-index-resolve"
"(namespace-mpi(module-instance-namespace mi_0)))))))"
"(void))"
"(if(if(let-values(((or-part_0) skip-run?_0))"
"(if or-part_0"
" or-part_0"
"(eq?"
" 'started"
"(small-hash-ref"
"(module-instance-phase-level-to-state mi_0)"
" run-phase-level_0"
" #f))))"
"(if(let-values(((or-part_0)(not otherwise-available?_0)))"
"(if or-part_0"
" or-part_0"
"(module-instance-made-available? mi_0)))"
"(let-values(((or-part_0)(not transitive-modules_0)))"
"(if or-part_0"
" or-part_0"
"(not"
"(module-cross-phase-persistent?"
"(module-instance-module mi_0)))))"
" #f)"
" #f)"
"(void)"
"(let-values()"
"(let-values(((m_1)(module-instance-module mi_0)))"
"(let-values((()"
"(begin"
"(if m_1"
"(void)"
"(let-values()"
"(error"
" 'require"
"                                                                         \"import cycle detected; trying to run module being expanded\")))"
"(values))))"
"(let-values(((mpi_0)(namespace-mpi m-ns_0)))"
"(let-values(((phase-shift_0) instance-phase_0))"
"(let-values(((bulk-binding-registry_0)"
"(namespace-bulk-binding-registry m-ns_0)))"
"(begin"
"(if recur?_0"
"(let-values()"
"(let-values((()"
"(begin"
"(if(hash-ref seen_0 mi_0 #f)"
"(let-values()"
"(error"
" 'require"
"(apply"
" string-append"
"                                                                                        \"import cycle detected during module instantiation\\n\""
"                                                                                        \"  dependency chain:\""
"(module-instances->indented-module-names"
" mi_0"
" seen-list_0))))"
"(void))"
"(values))))"
"(let-values(((record-shifted-requires-at-name_0)"
"(if(module-instance-shifted-requires"
" mi_0)"
"(let-values() #f)"
"(let-values()"
"(let-values(((name_0)"
"(1/module-path-index-resolve"
" mpi_0)))"
"(let-values(((shifted-requires_0)"
"(build-module-instance-shifted-requires"
" ns_0"
" m_1"
" mpi_0"
" name_0)))"
"(begin"
"(set-module-instance-shifted-requires!"
" mi_0"
" shifted-requires_0)"
"(if(non-self-derived-module-path-index?"
" mpi_0)"
" name_0"
" #f))))))))"
"(let-values(((new-seen_0)"
"(hash-set seen_0 mi_0 #t)))"
"(let-values(((recur-instantiate!_0)"
"(lambda(req-mpi_0"
" req-phase_0"
" req-recur?_0)"
"(begin"
" 'recur-instantiate!"
"(let-values(((ns239_0) ns_0)"
"((req-mpi240_0)"
" req-mpi_0)"
"((temp241_0)"
"(phase+"
" instance-phase_0"
" req-phase_0))"
"((run-phase242_0)"
" run-phase_0)"
"((skip-run?243_0)"
" skip-run?_0)"
"((otherwise-available?244_0)"
" otherwise-available?_0)"
"((new-seen245_0)"
" new-seen_0)"
"((temp246_0)"
"(cons"
" mi_0"
" seen-list_0))"
"((req-recur?247_0)"
" req-recur?_0)"
"((inspector248_0)"
" inspector_0)"
"((transitive-modules249_0)"
" transitive-modules_0))"
"(namespace-module-instantiate!.1"
" inspector248_0"
" otherwise-available?244_0"
" req-recur?247_0"
" run-phase242_0"
" new-seen245_0"
" temp246_0"
" skip-run?243_0"
" transitive-modules249_0"
" ns239_0"
" req-mpi240_0"
" temp241_0))))))"
"(begin"
"(if(not(module-flattened-requires m_1))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(module-instance-shifted-requires"
" mi_0))"
"((lst_1)"
"(module-recur-requires"
" m_1)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((phase+mpis_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((recurs_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((req-phase_0)"
"(car"
" phase+mpis_0)))"
"(begin"
"(let-values()"
"(let-values(((lst_4)"
"(cdr"
" phase+mpis_0))"
"((lst_5)"
" recurs_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_5)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((req-mpi_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((recur_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values((()"
"(if req-mpi_0"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(recur-instantiate!_0"
" req-mpi_0"
" req-phase_0"
" recur_0))"
"(values)))))"
"(values))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_2"
" rest_3)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_4"
" lst_5))))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" lst_1))))"
"(void))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(module-instance-shifted-requires"
" mi_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((mpi+phases_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((req-mpi_0)"
"(vector-ref"
" mpi+phases_0"
" 0)))"
"(begin"
"(let-values()"
"(let-values(((lst_2)"
"(vector-ref"
" mpi+phases_0"
" 1)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((req-phase_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(recur-instantiate!_0"
" req-mpi_0"
" req-phase_0"
" #f))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2))))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))"
"(if record-shifted-requires-at-name_0"
"(let-values()"
"(namespace-save-shifted-requires!"
" ns_0"
" m_1"
" record-shifted-requires-at-name_0"
"(module-instance-shifted-requires"
" mi_0)))"
"(void))))))))"
"(void))"
"(if(label-phase? instance-phase_0)"
"(void)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((start_0)"
"(module-max-phase-level m_1))"
"((end_0)"
"(sub1(module-min-phase-level m_1)))"
"((inc_0) -1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(> pos_0 end_0)"
"(let-values(((phase-level_0)"
" pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((phase_0)"
"(phase+"
" phase-level_0"
" phase-shift_0)))"
"(if(if(not"
" skip-run?_0)"
"(eqv?"
" phase_0"
" run-phase_0)"
" #f)"
"(let-values()"
"(if(eq?"
" 'started"
"(small-hash-ref"
"(module-instance-phase-level-to-state"
" mi_0)"
" phase-level_0"
" #f))"
"(void)"
"(let-values()"
"(let-values((()"
"(begin"
"(small-hash-set!"
"(module-instance-phase-level-to-state"
" mi_0)"
" phase-level_0"
" 'started)"
"(values))))"
"(let-values((()"
"(begin"
"(void"
"(namespace->definitions"
" m-ns_0"
" phase-level_0))"
"(values))))"
"(let-values(((p-ns_0)"
"(namespace->namespace-at-phase"
" m-ns_0"
" phase_0)))"
"(let-values(((insp_0)"
"(module-inspector"
" m_1)))"
"(let-values(((data-box_0)"
"(module-instance-data-box"
" mi_0)))"
"(let-values(((prep_0)"
"(module-prepare-instance"
" m_1)))"
"(let-values(((go_0)"
"(module-instantiate-phase"
" m_1)))"
"(begin"
"(prep_0"
" data-box_0"
" p-ns_0"
" phase-shift_0"
" mpi_0"
" bulk-binding-registry_0"
" insp_0)"
"(go_0"
" data-box_0"
" p-ns_0"
" phase-shift_0"
" phase-level_0"
" mpi_0"
" bulk-binding-registry_0"
" insp_0))))))))))))"
"(if(if otherwise-available?_0"
"(if(not"
"(negative?"
" run-phase_0))"
"(not"
"(small-hash-ref"
"(module-instance-phase-level-to-state"
" mi_0)"
" phase-level_0"
" #f))"
" #f)"
" #f)"
"(let-values()"
"(begin"
"(if(module-cross-phase-persistent?"
" m_1)"
"(let-values(((bx_0)"
"(namespace-available-cross-phase-module-instances"
" ns_0)))"
"(set-box!"
" bx_0"
"(cons"
" mi_0"
"(unbox"
" bx_0))))"
"(hash-update!"
"(namespace-available-module-instances"
" ns_0)"
" phase_0"
"(lambda(l_0)"
"(cons"
" mi_0"
" l_0))"
" null))"
"(small-hash-set!"
"(module-instance-phase-level-to-state"
" mi_0)"
" phase-level_0"
" 'available)))"
"(void)))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0))))"
"(void))))"
"(if otherwise-available?_0"
"(let-values()"
"(set-module-instance-made-available?! mi_0 #t))"
"(void))"
"(if skip-run?_0"
"(void)"
"(let-values()"
"(small-hash-set!"
"(module-instance-phase-level-to-state mi_0)"
" run-phase-level_0"
" 'started))))))))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))))))))"
"(define-values"
"(namespace-visit-available-modules!)"
"(let-values(((namespace-visit-available-modules!_0)"
"(lambda(ns141_0 run-phase140_0)"
"(begin"
" 'namespace-visit-available-modules!"
"(let-values(((ns_0) ns141_0))"
"(let-values(((run-phase_0)"
"(if(eq? run-phase140_0 unsafe-undefined)(namespace-phase ns_0) run-phase140_0)))"
"(let-values()(namespace-run-available-modules! ns_0(add1 run-phase_0)))))))))"
"(case-lambda"
"((ns_0)(begin(namespace-visit-available-modules!_0 ns_0 unsafe-undefined)))"
"((ns_0 run-phase140_0)(namespace-visit-available-modules!_0 ns_0 run-phase140_0)))))"
"(define-values"
"(namespace-run-available-modules!)"
"(let-values(((namespace-run-available-modules!_0)"
"(lambda(ns143_0 run-phase142_0)"
"(begin"
" 'namespace-run-available-modules!"
"(let-values(((ns_0) ns143_0))"
"(let-values(((run-phase_0)"
"(if(eq? run-phase142_0 unsafe-undefined)(namespace-phase ns_0) run-phase142_0)))"
"(let-values()"
"(registry-call-with-lock"
"(namespace-module-registry$1 ns_0)"
"(lambda()"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((cp-mis_0)"
"(unbox"
"(namespace-available-cross-phase-module-instances"
" ns_0))))"
"(let-values(((mis_0)"
"(hash-ref"
"(namespace-available-module-instances ns_0)"
" run-phase_0"
" null)))"
"(if(if(null? cp-mis_0)(null? mis_0) #f)"
"(void)"
"(let-values()"
"(begin"
"(set-box!"
"(namespace-available-cross-phase-module-instances ns_0)"
" null)"
"(hash-set!"
"(namespace-available-module-instances ns_0)"
" run-phase_0"
" null)"
"(let-values()"
"(let-values(((lst_0)(reverse$1 cp-mis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mi_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((mi250_0)"
" mi_0)"
"((ns251_0)"
" ns_0)"
"((temp252_0)"
" 0)"
"((temp253_0)"
" #f)"
"((temp254_0)"
" #f)"
"((temp255_0)"
" #f))"
"(run-module-instance!.1"
" #f"
" temp254_0"
" temp255_0"
" temp252_0"
" '#hasheq()"
" null"
" temp253_0"
" #f"
" mi250_0"
" ns251_0)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(let-values()"
"(let-values(((lst_0)(reverse$1 mis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mi_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((mi256_0)"
" mi_0)"
"((ns257_0)"
" ns_0)"
"((run-phase258_0)"
" run-phase_0)"
"((temp259_0)"
" #f)"
"((temp260_0)"
" #f)"
"((temp261_0)"
" #f))"
"(run-module-instance!.1"
" #f"
" temp260_0"
" temp261_0"
" run-phase258_0"
" '#hasheq()"
" null"
" temp259_0"
" #f"
" mi256_0"
" ns257_0)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(loop_0))))))))))"
" loop_0)))))))))))"
"(case-lambda"
"((ns_0)(begin(namespace-run-available-modules!_0 ns_0 unsafe-undefined)))"
"((ns_0 run-phase142_0)(namespace-run-available-modules!_0 ns_0 run-phase142_0)))))"
"(define-values"
"(namespace-primitive-module-visit!)"
"(lambda(ns_0 name_0)"
"(begin"
"(let-values(((mi_0)(hash-ref(namespace-module-instances ns_0)(1/make-resolved-module-path name_0))))"
"(let-values(((mi262_0) mi_0)((ns263_0) ns_0)((temp264_0) 1)((temp265_0) #f)((temp266_0) #t))"
"(run-module-instance!.1 #f temp266_0 #t temp264_0 '#hasheq() null temp265_0 #f mi262_0 ns263_0))))))"
"(define-values"
"(namespace-clear-shifted-requires!)"
"(lambda(ns_0 mod-name_0)(begin(hash-remove!(namespace-module-instance-shifted-requires ns_0) mod-name_0))))"
"(define-values"
"(build-module-instance-shifted-requires)"
"(lambda(ns_0 m_0 mpi_0 name_0)"
"(begin"
"(let-values(((requires_0)(module-requires m_0)))"
"(let-values(((recur-requires_0)(module-recur-requires m_0)))"
"(let-values(((flattened-requires_0)(module-flattened-requires m_0)))"
"(let-values(((freshen-cache_0)(make-hasheq)))"
"(if(not flattened-requires_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) requires_0)"
"((lst_1) recur-requires_0)"
"((lst_2)"
"(let-values(((ns267_0) ns_0)((name268_0) name_0)((requires269_0) requires_0))"
"(namespace-find-shifted-requires.1 #f ns267_0 name268_0 requires269_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_3 lst_4 lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_3)(if(pair? lst_4)(pair? lst_5) #f) #f)"
"(let-values(((phase+mpis_0)(unsafe-car lst_3))"
"((rest_0)(unsafe-cdr lst_3))"
"((recurs_0)(unsafe-car lst_4))"
"((rest_1)(unsafe-cdr lst_4))"
"((resolved-paths_0)(unsafe-car lst_5))"
"((rest_2)(unsafe-cdr lst_5)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
"(car phase+mpis_0)"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_6)"
"(cdr"
" phase+mpis_0))"
"((lst_7) recurs_0)"
"((lst_8)"
" resolved-paths_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_6)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_7)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_8)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_9"
" lst_10"
" lst_11)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_9)"
"(if(pair?"
" lst_10)"
"(pair?"
" lst_11)"
" #f)"
" #f)"
"(let-values(((req-mpi_0)"
"(unsafe-car"
" lst_9))"
"((rest_3)"
"(unsafe-cdr"
" lst_9))"
"((recur_0)"
"(unsafe-car"
" lst_10))"
"((rest_4)"
"(unsafe-cdr"
" lst_10))"
"((resolved-path_0)"
"(unsafe-car"
" lst_11))"
"((rest_5)"
"(unsafe-cdr"
" lst_11)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(if recur_0"
"(module-path-index-shift/resolved"
" req-mpi_0"
"(module-self"
" m_0)"
" mpi_0"
" freshen-cache_0"
" resolved-path_0)"
" #f))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_3"
" rest_4"
" rest_5)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_6"
" lst_7"
" lst_8)))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0 rest_1 rest_2)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1"
" lst_2)))))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) flattened-requires_0)"
"((lst_1)"
"(let-values(((ns270_0) ns_0)"
"((name271_0) name_0)"
"((flattened-requires272_0) flattened-requires_0)"
"((temp273_0) #t))"
"(namespace-find-shifted-requires.1"
" temp273_0"
" ns270_0"
" name271_0"
" flattened-requires272_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((mpi+phases_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((resolved-path_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((req-mpi_0)"
"(vector-ref"
" mpi+phases_0"
" 0)))"
"(let-values(((new-req-mpi_0)"
"(module-path-index-shift/resolved"
" req-mpi_0"
"(module-self m_0)"
" mpi_0"
" freshen-cache_0"
" resolved-path_0)))"
"(vector-immutable"
" new-req-mpi_0"
"(vector-ref mpi+phases_0 1)))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0 rest_1) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1)))))))))))))"
"(define-values"
"(namespace-find-shifted-requires.1)"
"(lambda(flattened?144_0 ns146_0 name147_0 requires148_0)"
"(begin"
" 'namespace-find-shifted-requires"
"(let-values(((ns_0) ns146_0))"
"(let-values(((name_0) name147_0))"
"(let-values(((requires_0) requires148_0))"
"(let-values(((flattened?_0) flattened?144_0))"
"(let-values()"
"(let-values(((bx_0)(hash-ref(namespace-module-instance-shifted-requires ns_0) name_0 #f)))"
"(let-values(((or-part_0)(if bx_0(unbox bx_0) #f)))"
"(if or-part_0"
" or-part_0"
"(if(not flattened?_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((phase+mpis_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
"(cdr"
" phase+mpis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((mpi_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
" #f)"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mpi+phases_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values() #f)"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))))))))))"
"(define-values"
"(namespace-shifted-requires-box)"
"(lambda(ns_0 name_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(namespace-module-instance-shifted-requires ns_0) name_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((bx_0)(box #f)))"
"(begin(hash-set!(namespace-module-instance-shifted-requires ns_0) name_0 bx_0) bx_0)))))))"
"(define-values"
"(namespace-save-shifted-requires!)"
"(lambda(ns_0 m_0 name_0 shifted-requires_0)"
"(begin"
"(let-values(((bx_0)(namespace-shifted-requires-box ns_0 name_0)))"
"(if(unbox bx_0)"
"(void)"
"(let-values()"
"(let-values(((resolve_0)"
"(lambda(mpi_0)"
"(begin"
" 'resolve"
"(let-values(((r_0)(if mpi_0(1/module-path-index-resolve mpi_0) #f)))"
"(if r_0"
"(let-values(((name_1)(1/resolved-module-path-name r_0)))"
"(if(let-values(((or-part_0)(path? name_1)))"
"(if or-part_0 or-part_0(if(pair? name_1)(path?(car name_1)) #f)))"
" r_0"
" #f))"
" #f))))))"
"(set-box!"
" bx_0"
"(if(not(module-flattened-requires m_0))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) shifted-requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((phase+mpis_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
"(cdr"
" phase+mpis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((mpi_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(resolve_0"
" mpi_0))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) shifted-requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mpi+phases_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((mpi_0)"
"(vector-ref"
" mpi+phases_0"
" 0)))"
"(resolve_0 mpi_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))))))"
"(define-values"
"(namespace-copy-shifted-requires!)"
"(lambda(dest-namespace_0 src-namespace_0 name_0)"
"(begin"
"(let-values(((bx_0)(namespace-shifted-requires-box src-namespace_0 name_0)))"
"(hash-set!(namespace-module-instance-shifted-requires dest-namespace_0) name_0 bx_0)))))"
"(define-values"
"(namespace-module-use->module+linklet-instances.1)"
"(lambda(phase-shift152_0 resolution-cache153_0 shift-from150_0 shift-to151_0 ns158_0 mu159_0)"
"(begin"
" 'namespace-module-use->module+linklet-instances"
"(let-values(((ns_0) ns158_0))"
"(let-values(((mu_0) mu159_0))"
"(let-values(((shift-from_0) shift-from150_0))"
"(let-values(((shift-to_0) shift-to151_0))"
"(let-values(((phase-shift_0) phase-shift152_0))"
"(let-values(((module-use-resolution-cache_0) resolution-cache153_0))"
"(let-values()"
"(let-values(((mod_0)(module-use-module mu_0)))"
"(let-values(((use-name_0)"
"(let-values(((or-part_0)"
"(if module-use-resolution-cache_0"
"(hash-ref module-use-resolution-cache_0 mod_0 #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((name_0)"
"(1/module-path-index-resolve"
"(if shift-from_0"
"(module-path-index-shift mod_0 shift-from_0 shift-to_0)"
" mod_0))))"
"(begin"
"(if module-use-resolution-cache_0"
"(let-values()(hash-set! module-use-resolution-cache_0 mod_0 name_0))"
"(void))"
" name_0))))))"
"(let-values(((mi_0)"
"(let-values(((ns274_0) ns_0)"
"((use-name275_0) use-name_0)"
"((phase-shift276_0) phase-shift_0)"
"((temp277_0) #t))"
"(namespace->module-instance.1"
" #f"
" temp277_0"
" void"
" ns274_0"
" use-name275_0"
" phase-shift276_0))))"
"(let-values(((m-ns_0)(module-instance-namespace mi_0)))"
"(let-values(((d_0)"
"(small-hash-ref"
"(namespace-phase-level-to-definitions m-ns_0)"
"(module-use-phase mu_0)"
" #f)))"
"(if d_0"
"(values mi_0(definitions-variables d_0))"
"(error"
" 'eval"
"(string-append"
"                                  \"namespace mismatch: phase level not found;\\n\""
"                                  \"  module: ~a\\n\""
"                                  \"  instance phase: ~a\\n\""
"                                  \"  phase level: ~a\\n\""
"                                  \"  found phase levels: ~a\")"
" mod_0"
"(namespace-0-phase m-ns_0)"
"(module-use-phase mu_0)"
"(small-hash-keys(namespace-phase-level-to-definitions m-ns_0)))))))))))))))))))"
"(define-values"
"(module-compute-access!)"
"(lambda(m_0)"
"(begin"
"(let-values(((access_0)"
"(let-values(((access_0)(let-values(((access_0) '#hasheqv())) access_0)))"
"(let-values(((ht_0)(module-provides m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(access_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase+space_0 at-phase+space_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((access_2)"
"(let-values(((access_2)"
"(let-values()"
"(let-values(((phase_0)"
"(phase+space-phase"
" phase+space_0)))"
"(let-values(((phase-access_0)"
"(let-values(((phase-access_0)"
"(let-values(((phase-access_0)"
"(hash-ref"
" access_1"
" phase_0"
" '#hasheq())))"
" phase-access_0)))"
"(let-values(((ht_1)"
" at-phase+space_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(phase-access_1"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((sym_0"
" binding/p_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((phase-access_2)"
"(let-values(((phase-access_2)"
"(let-values()"
"(hash-set"
" phase-access_1"
"(module-binding-sym"
"(provided-as-binding"
" binding/p_0))"
"(if(provided-as-protected?"
" binding/p_0)"
" 'protected"
" 'provided)))))"
"(values"
" phase-access_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" phase-access_2"
"(hash-iterate-next"
" ht_1"
" i_1))"
" phase-access_2)))"
" phase-access_1))))))"
" for-loop_1)"
" phase-access_0"
"(hash-iterate-first"
" ht_1)))))))"
"(hash-set"
" access_1"
" phase_0"
" phase-access_0))))))"
"(values access_2))))"
"(if(not #f)"
"(for-loop_0 access_2(hash-iterate-next ht_0 i_0))"
" access_2)))"
" access_1))))))"
" for-loop_0)"
" access_0"
"(hash-iterate-first ht_0)))))))"
"(begin(set-module-access! m_0 access_0) access_0)))))"
"(define-values"
"(module-instances->indented-module-names)"
"(lambda(mi_0 seen-list_0)"
"(begin"
"(let-values(((mi->name_0)"
"(lambda(mi_1)"
"(begin"
" 'mi->name"
"(format"
"                         \"\\n   ~a\""
"(1/module-path-index-resolve(namespace-mpi(module-instance-namespace mi_1))))))))"
"(cons"
"(mi->name_0 mi_0)"
"((letrec-values(((loop_0)"
"(lambda(seen-list_1)"
"(begin"
" 'loop"
"(if(null? seen-list_1)"
"(let-values() '())"
"(if(eq? mi_0(car seen-list_1))"
"(let-values()(list(mi->name_0 mi_0)))"
"(let-values()"
"(cons(mi->name_0(car seen-list_1))(loop_0(cdr seen-list_1))))))))))"
" loop_0)"
" seen-list_0))))))"
"(define-values"
"(binding->module-instance)"
"(lambda(b_0 ns_0 phase_0 id_0)"
"(begin"
"(let-values(((at-phase_0)(phase- phase_0(module-binding-phase b_0))))"
"(let-values(((mi_0)"
"(let-values(((ns1_0) ns_0)"
"((temp2_0)(1/module-path-index-resolve(module-binding-module b_0)))"
"((at-phase3_0) at-phase_0)"
"((temp4_0)(module-binding-phase b_0))"
"((temp5_0)(lambda(mi_0) 'unavailable)))"
"(namespace->module-instance.1 temp4_0 #f temp5_0 ns1_0 temp2_0 at-phase3_0))))"
"(begin"
"(if(eq? mi_0 'unavailable)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(format"
"(string-append"
"                   \"module mismatch;\\n\""
"                   \" attempted to use a module that is not available\\n\""
"                   \"  possible cause:\\n\""
"                   \"   using (dynamic-require .... #f)\\n\""
"                   \"   but need (dynamic-require .... 0)\\n\""
"                   \"  module: ~s\\n\""
"                   \"  phase: ~s\")"
"(module-binding-module b_0)"
"(phase+ at-phase_0(module-binding-phase b_0)))"
" id_0))"
"(void))"
"(if mi_0"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(format"
"(string-append"
"                   \"namespace mismatch;\\n\""
"                   \" cannot locate module instance\\n\""
"                   \"  module: ~a\\n\""
"                   \"  use phase: ~a\\n\""
"                   \"  definition phase: ~a\")"
"(1/module-path-index-resolve(module-binding-module b_0))"
" phase_0"
"(module-binding-phase b_0))"
" id_0)))"
" mi_0))))))"
"(define-values"
"(check-access)"
"(lambda(b_0 mi_0 id_0 in-s_0 what_0)"
"(begin"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(if(if m_0(not(module-no-protected? m_0)) #f)"
"(let-values()"
"(let-values(((access_0)"
"(let-values(((or-part_0)(module-access m_0)))"
"(if or-part_0 or-part_0(module-compute-access! m_0)))))"
"(let-values(((a_0)"
"(hash-ref"
"(hash-ref access_0(module-binding-phase b_0) '#hasheq())"
"(module-binding-sym b_0)"
" 'unexported)))"
"(if(let-values(((or-part_0)(eq? a_0 'unexported)))(if or-part_0 or-part_0(eq? a_0 'protected)))"
"(let-values()"
"(begin"
"(if(let-values(((or-part_0)"
"(inspector-superior?"
"(let-values(((or-part_0)(syntax-inspector id_0)))"
"(if or-part_0 or-part_0(current-code-inspector)))"
"(namespace-inspector(module-instance-namespace mi_0)))))"
"(if or-part_0"
" or-part_0"
"(if(module-binding-extra-inspector b_0)"
"(inspector-superior?"
"(module-binding-extra-inspector b_0)"
"(namespace-inspector(module-instance-namespace mi_0)))"
" #f)))"
"(void)"
"(let-values()"
"(let-values(((complain-id_0)"
"(let-values(((c-id_0)"
"(let-values(((or-part_0) in-s_0))"
"(if or-part_0 or-part_0(module-binding-sym b_0)))))"
"(if(not"
"(eq?"
"(if(syntax?$1 c-id_0)(syntax-content c-id_0) c-id_0)"
"(syntax-content id_0)))"
" c-id_0"
" #f))))"
"(raise-syntax-error$1"
" #f"
"(format"
"                              \"access disallowed by code inspector to ~a ~a\\n  from module: ~a\""
" a_0"
" what_0"
"(1/module-path-index-resolve(namespace-mpi(module-instance-namespace mi_0))))"
" complain-id_0"
" id_0"
" null))))"
" #t))"
"(let-values() #f)))))"
"(let-values() #f))))))"
"(define-values"
"(resolve+shift/extra-inspector)"
"(lambda(id_0 phase_0 ns_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(id_1 in-s_0)"
"(begin"
" 'loop"
"(let-values(((b_0)"
"(let-values(((id1_0) id_1)((phase2_0) phase_0)((temp3_0) #t))"
"(resolve+shift.1 #f #f null temp3_0 #f id1_0 phase2_0))))"
"(let-values(((c1_0)(binding-free=id b_0)))"
"(if c1_0"
"((lambda(next-id_0)"
"(let-values((()"
"(begin"
"(if(if(module-binding? b_0)"
"(not"
"(top-level-module-path-index?(module-binding-module b_0)))"
" #f)"
"(let-values()"
"(let-values(((mi_0)"
"(binding->module-instance"
" b_0"
" ns_0"
" phase_0"
" id_1)))"
"                                                           (check-access b_0 mi_0 id_1 in-s_0 \"provided binding\")))"
"(void))"
"(values))))"
"(let-values(((next-b_0)"
"(loop_0"
" next-id_0"
"(let-values(((or-part_0) in-s_0))"
"(if or-part_0 or-part_0 id_1)))))"
"(if(not next-b_0)"
"(let-values() b_0)"
"(if(if(module-binding? next-b_0)"
"(if(not(module-binding-extra-inspector next-b_0))"
"(syntax-inspector id_1)"
" #f)"
" #f)"
"(let-values()"
"(let-values(((next-b4_0) next-b_0)((temp5_0)(syntax-inspector id_1)))"
"(module-binding-update.1"
" temp5_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" next-b4_0)))"
"(let-values() next-b_0))))))"
" c1_0)"
"(let-values() b_0))))))))"
" loop_0)"
" id_0"
" #f))))"
"(define-values"
"(1/prop:set!-transformer 1/set!-transformer? set!-transformer-value)"
"(make-struct-type-property"
" 'set!-transformer"
"(lambda(v_0 info_0)"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)"
"(if(procedure? v_0)"
"(let-values(((or-part_0)(procedure-arity-includes? v_0 1)))"
"(if or-part_0 or-part_0(procedure-arity-includes? v_0 2)))"
" #f)))"
"(if or-part_0 or-part_0(exact-nonnegative-integer? v_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'guard-for-prop:set!-transformer"
"(string-append"
"                           \"(or/c (procedure-arity-includes? proc 1)\\n\""
"                           \"      (procedure-arity-includes? proc 2)\\n\""
"                           \"      exact-nonnegative-integer?)\")"
" v_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(exact-nonnegative-integer? v_0)"
"(let-values()"
"(begin"
"(if(<= v_0(list-ref info_0 1))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'guard-for-prop:set!-transformer"
"                                  \"field index >= initialized-field count for structure type\""
"                                  \"field index\""
" v_0"
"                                  \"initialized-field count\""
"(list-ref info_0 1))))"
"(if(member v_0(list-ref info_0 5))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'guard-for-prop:set!-transformer"
"                                  \"field index not declared immutable\""
"                                  \"field index\""
" v_0)))))"
"(void))"
"(values))))"
"(let-values(((ref_0)(list-ref info_0 3)))"
"(if(integer? v_0)"
"(let-values()"
"(lambda(t_0)"
"(let-values(((p_0)(ref_0 t_0 v_0)))"
"(if(if(procedure? p_0)(procedure-arity-includes? p_0 1) #f)"
" p_0"
"                     (lambda (s_0) (error \"bad syntax:\" s_0))))))"
"(let-values()(lambda(t_0) v_0)))))))))"
"(define-values"
"(1/make-set!-transformer)"
"(let-values()"
"(let-values(((struct:set!-transformer_0 set!-transformer1_0 set!-transformer?_0 set!-transformer-proc_0)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'set!-transformer"
" #f"
" 1"
" 0"
" #f"
"(list(cons 1/prop:set!-transformer 0))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'set!-transformer)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'proc)))))"
"(lambda(proc_0)"
"(begin"
" 'make-set!-transformer"
"(begin"
"(if(if(procedure? proc_0)(procedure-arity-includes? proc_0 1) #f)"
"(void)"
"              (let-values () (raise-argument-error 'make-set!-transformer \"(procedure-arity-includes/c 1)\" proc_0)))"
"(set!-transformer1_0 proc_0)))))))"
"(define-values"
"(1/set!-transformer-procedure)"
"(lambda(t_0)"
"(begin"
" 'set!-transformer-procedure"
"(let-values(((v_0)((set!-transformer-value t_0) t_0)))"
"(if(procedure-arity-includes? v_0 1) v_0(lambda(s_0)(v_0 t_0 s_0)))))))"
"(define-values(empty-env) '#hasheq())"
"(define-values(env-extend)(lambda(env_0 key_0 val_0)(begin(hash-set env_0 key_0 val_0))))"
"(define-values(lookup)(lambda(env_0 key_0 default_0)(begin(hash-ref env_0 key_0 default_0))))"
"(define-values(variable)(gensym 'variable))"
"(define-values"
"(variable?)"
"(lambda(t_0)(begin(let-values(((or-part_0)(eq? t_0 variable)))(if or-part_0 or-part_0(local-variable? t_0))))))"
"(define-values"
"(struct:local-variable local-variable1.1 local-variable? local-variable-id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'local-variable"
" #f"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'local-variable)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'id))))"
"(define-values"
"(substitute-variable.1)"
"(lambda(no-stops?2_0 id4_0 t5_0)"
"(begin"
" 'substitute-variable"
"(let-values(((id_0) id4_0))"
"(let-values(((t_0) t5_0))"
"(let-values(((no-stops?_0) no-stops?2_0))"
"(let-values()"
"(if(if no-stops?_0(local-variable? t_0) #f)"
"(let-values(((bind-id_0)(local-variable-id t_0)))"
"(let-values(((pruned-id_0)(datum->syntax$1 bind-id_0(syntax-e$1 bind-id_0) id_0 id_0)))"
"(if(syntax-any-macro-scopes? id_0)"
"(1/syntax-property-remove pruned-id_0 original-property-sym)"
" pruned-id_0)))"
" id_0))))))))"
"(define-values(missing)(gensym 'missing))"
"(define-values"
"(transformer?)"
"(lambda(t_0)"
"(begin"
"(let-values(((or-part_0)(procedure? t_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/set!-transformer? t_0)))"
"(if or-part_1 or-part_1(1/rename-transformer? t_0))))))))"
"(define-values"
"(transformer->procedure)"
"(lambda(t_0)"
"(begin"
"(if(1/set!-transformer? t_0)"
"(let-values()(1/set!-transformer-procedure t_0))"
"(if(1/rename-transformer? t_0)(let-values()(lambda(s_0) s_0))(let-values() t_0))))))"
"(define-values"
"(struct:core-form core-form7.1 core-form? core-form-expander core-form-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'core-form"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
" #f"
" #f"
" '(0 1)"
" #f"
" 'core-form)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'expander)"
"(make-struct-field-accessor -ref_0 1 'name))))"
"(define-values"
"(add-binding!.1)"
"(lambda(in8_0 just-for-nominal?9_0 id12_0 binding13_0 phase14_0)"
"(begin"
" 'add-binding!"
"(let-values(((id_0) id12_0))"
"(let-values(((binding_0) binding13_0))"
"(let-values(((phase_0) phase14_0))"
"(let-values(((in-s_0) in8_0))"
"(let-values(((just-for-nominal?_0) just-for-nominal?9_0))"
"(let-values()"
"(begin"
"(check-id-taint id_0 in-s_0)"
"(let-values(((temp49_0)(syntax-scope-set id_0 phase_0))"
"((temp50_0)(syntax-e$1 id_0))"
"((binding51_0) binding_0)"
"((just-for-nominal?52_0) just-for-nominal?_0))"
"(add-binding-in-scopes!.1 just-for-nominal?52_0 temp49_0 temp50_0 binding51_0))))))))))))"
"(define-values"
"(add-bulk-binding!.1)"
"(lambda(in16_0 shadow-except17_0 s20_0 binding21_0 phase22_0)"
"(begin"
" 'add-bulk-binding!"
"(let-values(((s_0) s20_0))"
"(let-values(((binding_0) binding21_0))"
"(let-values(((phase_0) phase22_0))"
"(let-values(((in-s_0) in16_0))"
"(let-values(((shadow-except_0) shadow-except17_0))"
"(let-values()"
"(begin"
"(if(syntax-tainted?$1 s_0)"
"                      (let-values () (raise-syntax-error$1 #f \"cannot bind from tainted syntax\" in-s_0 s_0))"
"(void))"
"(let-values(((temp53_0)(syntax-scope-set s_0 phase_0))"
"((binding54_0) binding_0)"
"((shadow-except55_0) shadow-except_0))"
"(add-bulk-binding-in-scopes!.1 shadow-except55_0 temp53_0 binding54_0))))))))))))"
"(define-values"
"(add-local-binding!.1)"
"(lambda(frame-id25_0 in26_0 local-sym24_0 id30_0 phase31_0 counter32_0)"
"(begin"
" 'add-local-binding!"
"(let-values(((id_0) id30_0))"
"(let-values(((phase_0) phase31_0))"
"(let-values(((counter_0) counter32_0))"
"(let-values(((local-sym_0) local-sym24_0))"
"(let-values(((frame-id_0) frame-id25_0))"
"(let-values(((in-s_0) in26_0))"
"(let-values()"
"(let-values((()(begin(check-id-taint id_0 in-s_0)(values))))"
"(let-values(((c_0)(add1(unbox counter_0))))"
"(let-values((()(begin(set-box! counter_0 c_0)(values))))"
"(let-values(((sym_0)(syntax-content id_0)))"
"(let-values(((key_0)"
"(string->uninterned-symbol"
"(string-append-immutable"
"(symbol->immutable-string"
"(let-values(((or-part_0) local-sym_0))(if or-part_0 or-part_0 sym_0)))"
"                                            \"_\""
"(number->string c_0)))))"
"(begin"
"(let-values(((temp56_0)(syntax-scope-set id_0 phase_0))"
"((sym57_0) sym_0)"
"((temp58_0)"
"(let-values(((key59_0) key_0)((frame-id60_0) frame-id_0))"
"(make-local-binding.1 frame-id60_0 #f key59_0))))"
"(add-binding-in-scopes!.1 #f temp56_0 sym57_0 temp58_0))"
" key_0))))))))))))))))"
"(define-values"
"(check-id-taint)"
"(lambda(id_0 in-s_0)"
"(begin"
"(if(syntax-tainted?$1 id_0)"
"        (let-values () (raise-syntax-error$1 #f \"cannot bind tainted identifier\" in-s_0 id_0))"
"(void)))))"
"(define-values"
"(binding-lookup.1)"
"(lambda(check-access?36_0 in34_0 out-of-context-as-variable?35_0 b40_0 env41_0 lift-envs42_0 ns43_0 phase44_0 id45_0)"
"(begin"
" 'binding-lookup"
"(let-values(((b_0) b40_0))"
"(let-values(((env_0) env41_0))"
"(let-values(((lift-envs_0) lift-envs42_0))"
"(let-values(((ns_0) ns43_0))"
"(let-values(((phase_0) phase44_0))"
"(let-values(((id_0) id45_0))"
"(let-values(((in-s_0) in34_0))"
"(let-values(((out-of-context-as-variable?_0) out-of-context-as-variable?35_0))"
"(let-values(((check-access?_0) check-access?36_0))"
"(let-values()"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((top-level?_0)(top-level-module-path-index?(module-binding-module b_0))))"
"(let-values(((mi_0)"
"(if(not top-level?_0)"
"(binding->module-instance b_0 ns_0 phase_0 id_0)"
" #f)))"
"(let-values(((m_0)(if mi_0(module-instance-module mi_0) #f)))"
"(let-values(((primitive?_0)(if m_0(module-primitive? m_0) #f)))"
"(let-values(((m-ns_0)"
"(if top-level?_0"
" ns_0"
"(if mi_0(module-instance-namespace mi_0) #f))))"
"(let-values((()(begin(check-taint id_0)(values))))"
"(let-values(((t_0)"
"(namespace-get-transformer"
" m-ns_0"
"(module-binding-phase b_0)"
"(module-binding-sym b_0)"
" variable)))"
"(let-values(((protected?_0)"
"(if check-access?_0"
"(if mi_0"
"(check-access"
" b_0"
" mi_0"
" id_0"
" in-s_0"
"                                                               (if (variable? t_0) \"variable\" \"transformer\"))"
" #f)"
" #f)))"
"(let-values(((insp_0)"
"(if mi_0"
"(if(module-instance-module mi_0)"
"(module-inspector(module-instance-module mi_0))"
" #f)"
" #f)))"
"(values t_0 primitive?_0 insp_0 protected?_0)))))))))))"
"(if(local-binding? b_0)"
"(let-values()"
"(let-values(((t_0)(lookup env_0(local-binding-key b_0) missing)))"
"(if(eq? t_0 missing)"
"(let-values()"
"(values"
"(let-values(((or-part_0)"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0) lift-envs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((lift-env_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(lookup"
"(unbox"
" lift-env_0)"
"(local-binding-key"
" b_0)"
" #f)))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0 result_2)"
" lift-env_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))))"
"(if or-part_0"
" or-part_0"
"(if out-of-context-as-variable?_0"
" variable"
"                                             (raise-syntax-error$1 #f \"identifier used out of context\" id_0))))"
" #f"
" #f"
" #f))"
"(let-values()(begin(check-taint id_0)(values t_0 #f #f #f))))))"
"                              (let-values () (error \"internal error: unknown binding for lookup:\" b_0)))))))))))))))))"
"(define-values"
"(check-taint)"
"(lambda(id_0)"
"(begin"
"(if(syntax-tainted?$1 id_0)"
"        (let-values () (raise-syntax-error$1 #f \"cannot use identifier tainted by macro transformation\" id_0))"
"(void)))))"
"(define-values"
"(existing-binding-key)"
"(lambda(id_0 phase_0)"
"(begin"
"(let-values(((b_0)"
"(let-values(((id61_0) id_0)((phase62_0) phase_0)((temp63_0) #t))"
"(resolve+shift.1 #f #f null temp63_0 #f id61_0 phase62_0))))"
"(begin"
"(if(local-binding? b_0)"
"(void)"
"(let-values()"
"              (raise-syntax-error$1 #f \"expected an existing local binding for an already-expanded identifier\" id_0)))"
"(local-binding-key b_0))))))"
"(define-values(cons-ish)(lambda(a_0 b_0)(begin(if(null? b_0) a_0(cons a_0 b_0)))))"
"(define-values"
"(free-id-set)"
"(lambda(phase_0 ids_0)"
"(begin"
"(let-values(((ht_0)(let-values(((ht_0) '#hasheq())) ht_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_2)"
"(let-values(((ht_2)"
"(let-values()"
"(let-values(((sym_0)"
"(identifier-binding-symbol$1"
" id_0"
" phase_0)))"
"(hash-set"
" ht_1"
" sym_0"
"(cons-ish id_0(hash-ref ht_1 sym_0 null)))))))"
"(values ht_2))))"
"(if(not #f)(for-loop_0 ht_2 rest_0) ht_2)))"
" ht_1))))))"
" for-loop_0)"
" ht_0"
" lst_0)))))))"
"(define-values(empty-free-id-set)(free-id-set 0 null))"
"(define-values(free-id-set-empty?)(lambda(fs_0)(begin(eq? fs_0 empty-free-id-set))))"
"(define-values"
"(free-id-set-member?)"
"(lambda(fs_0 phase_0 given-id_0)"
"(begin"
"(if(free-id-set-empty? fs_0)"
" #f"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0)(hash-ref fs_0(identifier-binding-symbol$1 given-id_0 phase_0) null)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(not(null? lst_1))"
"(let-values(((id_0)(if(pair? lst_1)(car lst_1) lst_1))"
"((rest_0)(if(pair? lst_1)(cdr lst_1) null)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(free-identifier=?$1"
" id_0"
" given-id_0"
" phase_0"
" phase_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) id_0))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0)))))))"
"(define-values"
"(free-id-set-empty-or-just-module*?)"
"(lambda(fs_0)(begin(let-values(((c_0)(hash-count fs_0)))(<= c_0 1)))))"
"(define-values"
"(struct:expand-context/outer"
" expand-context/outer1.1"
" expand-context/outer?"
" expand-context/outer-context"
" expand-context/outer-env"
" expand-context/outer-scopes"
" expand-context/outer-def-ctx-scopes"
" expand-context/outer-binding-layer"
" expand-context/outer-reference-records"
" expand-context/outer-only-immediate?"
" expand-context/outer-need-eventually-defined"
" expand-context/outer-current-introduction-scopes"
" expand-context/outer-current-use-scopes"
" expand-context/outer-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'expand-context"
" struct:root-expand-context/outer"
" 11"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10)"
" #f"
" 'expand-context/outer)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'context)"
"(make-struct-field-accessor -ref_0 1 'env)"
"(make-struct-field-accessor -ref_0 2 'scopes)"
"(make-struct-field-accessor -ref_0 3 'def-ctx-scopes)"
"(make-struct-field-accessor -ref_0 4 'binding-layer)"
"(make-struct-field-accessor -ref_0 5 'reference-records)"
"(make-struct-field-accessor -ref_0 6 'only-immediate?)"
"(make-struct-field-accessor -ref_0 7 'need-eventually-defined)"
"(make-struct-field-accessor -ref_0 8 'current-introduction-scopes)"
"(make-struct-field-accessor -ref_0 9 'current-use-scopes)"
"(make-struct-field-accessor -ref_0 10 'name))))"
"(define-values"
"(struct:expand-context/inner"
" expand-context/inner2.1"
" expand-context/inner?"
" expand-context/inner-to-parsed?"
" expand-context/inner-phase"
" expand-context/inner-namespace"
" expand-context/inner-just-once?"
" expand-context/inner-module-begin-k"
" expand-context/inner-allow-unbound?"
" expand-context/inner-in-local-expand?"
" expand-context/inner-keep-#%expression?"
" expand-context/inner-stops"
" expand-context/inner-declared-submodule-names"
" expand-context/inner-lifts"
" expand-context/inner-lift-envs"
" expand-context/inner-module-lifts"
" expand-context/inner-require-lifts"
" expand-context/inner-to-module-lifts"
" expand-context/inner-requires+provides"
" expand-context/inner-observer"
" expand-context/inner-for-serializable?"
" expand-context/inner-to-correlated-linklet?"
" expand-context/inner-normalize-locals?"
" expand-context/inner-parsing-expanded?"
" expand-context/inner-skip-visit-available?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'expand-context/inner"
" struct:root-expand-context/inner"
" 22"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21)"
" #f"
" 'expand-context/inner)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'to-parsed?)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'namespace)"
"(make-struct-field-accessor -ref_0 3 'just-once?)"
"(make-struct-field-accessor -ref_0 4 'module-begin-k)"
"(make-struct-field-accessor -ref_0 5 'allow-unbound?)"
"(make-struct-field-accessor -ref_0 6 'in-local-expand?)"
"(make-struct-field-accessor -ref_0 7 'keep-#%expression?)"
"(make-struct-field-accessor -ref_0 8 'stops)"
"(make-struct-field-accessor -ref_0 9 'declared-submodule-names)"
"(make-struct-field-accessor -ref_0 10 'lifts)"
"(make-struct-field-accessor -ref_0 11 'lift-envs)"
"(make-struct-field-accessor -ref_0 12 'module-lifts)"
"(make-struct-field-accessor -ref_0 13 'require-lifts)"
"(make-struct-field-accessor -ref_0 14 'to-module-lifts)"
"(make-struct-field-accessor -ref_0 15 'requires+provides)"
"(make-struct-field-accessor -ref_0 16 'observer)"
"(make-struct-field-accessor -ref_0 17 'for-serializable?)"
"(make-struct-field-accessor -ref_0 18 'to-correlated-linklet?)"
"(make-struct-field-accessor -ref_0 19 'normalize-locals?)"
"(make-struct-field-accessor -ref_0 20 'parsing-expanded?)"
"(make-struct-field-accessor -ref_0 21 'skip-visit-available?))))"
"(define-values"
"(expand-context/make)"
"(lambda(self-mpi_0"
" module-scopes_0"
" post-expansion_0"
" top-level-bind-scope_0"
" all-scopes-stx_0"
" use-site-scopes_0"
" defined-syms_0"
" frame-id_0"
" counter_0"
" lift-key_0"
" to-parsed?_0"
" context_0"
" phase_0"
" namespace_0"
" env_0"
" scopes_0"
" def-ctx-scopes_0"
" binding-layer_0"
" reference-records_0"
" only-immediate?_0"
" just-once?_0"
" module-begin-k_0"
" need-eventually-defined_0"
" allow-unbound?_0"
" in-local-expand?_0"
" keep-#%expression?_0"
" stops_0"
" current-introduction-scopes_0"
" current-use-scopes_0"
" declared-submodule-names_0"
" lifts_0"
" lift-envs_0"
" module-lifts_0"
" require-lifts_0"
" to-module-lifts_0"
" requires+provides_0"
" name_0"
" observer_0"
" for-serializable?_0"
" to-correlated-linklet?_0"
" normalize-locals?_0"
" parsing-expanded?_0"
" skip-visit-available?_0)"
"(begin"
"(expand-context/outer1.1"
"(expand-context/inner2.1"
" self-mpi_0"
" module-scopes_0"
" top-level-bind-scope_0"
" all-scopes-stx_0"
" defined-syms_0"
" counter_0"
" lift-key_0"
" to-parsed?_0"
" phase_0"
" namespace_0"
" just-once?_0"
" module-begin-k_0"
" allow-unbound?_0"
" in-local-expand?_0"
" keep-#%expression?_0"
" stops_0"
" declared-submodule-names_0"
" lifts_0"
" lift-envs_0"
" module-lifts_0"
" require-lifts_0"
" to-module-lifts_0"
" requires+provides_0"
" observer_0"
" for-serializable?_0"
" to-correlated-linklet?_0"
" normalize-locals?_0"
" parsing-expanded?_0"
" skip-visit-available?_0)"
" post-expansion_0"
" use-site-scopes_0"
" frame-id_0"
" context_0"
" env_0"
" scopes_0"
" def-ctx-scopes_0"
" binding-layer_0"
" reference-records_0"
" only-immediate?_0"
" need-eventually-defined_0"
" current-introduction-scopes_0"
" current-use-scopes_0"
" name_0))))"
"(define-values(expand-context-context)(lambda(v_0)(begin(expand-context/outer-context v_0))))"
"(define-values(expand-context-env)(lambda(v_0)(begin(expand-context/outer-env v_0))))"
"(define-values(expand-context-scopes)(lambda(v_0)(begin(expand-context/outer-scopes v_0))))"
"(define-values(expand-context-def-ctx-scopes)(lambda(v_0)(begin(expand-context/outer-def-ctx-scopes v_0))))"
"(define-values(expand-context-binding-layer)(lambda(v_0)(begin(expand-context/outer-binding-layer v_0))))"
"(define-values(expand-context-reference-records)(lambda(v_0)(begin(expand-context/outer-reference-records v_0))))"
"(define-values(expand-context-only-immediate?)(lambda(v_0)(begin(expand-context/outer-only-immediate? v_0))))"
"(define-values"
"(expand-context-need-eventually-defined)"
"(lambda(v_0)(begin(expand-context/outer-need-eventually-defined v_0))))"
"(define-values"
"(expand-context-current-introduction-scopes)"
"(lambda(v_0)(begin(expand-context/outer-current-introduction-scopes v_0))))"
"(define-values"
"(expand-context-current-use-scopes)"
"(lambda(v_0)(begin(expand-context/outer-current-use-scopes v_0))))"
"(define-values(expand-context-name)(lambda(v_0)(begin(expand-context/outer-name v_0))))"
"(define-values"
"(expand-context-to-parsed?)"
"(lambda(v_0)(begin(expand-context/inner-to-parsed?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-phase)"
"(lambda(v_0)(begin(expand-context/inner-phase(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-namespace)"
"(lambda(v_0)(begin(expand-context/inner-namespace(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-just-once?)"
"(lambda(v_0)(begin(expand-context/inner-just-once?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-module-begin-k)"
"(lambda(v_0)(begin(expand-context/inner-module-begin-k(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-allow-unbound?)"
"(lambda(v_0)(begin(expand-context/inner-allow-unbound?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-in-local-expand?)"
"(lambda(v_0)(begin(expand-context/inner-in-local-expand?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-keep-#%expression?)"
"(lambda(v_0)(begin(expand-context/inner-keep-#%expression?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-stops)"
"(lambda(v_0)(begin(expand-context/inner-stops(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-declared-submodule-names)"
"(lambda(v_0)(begin(expand-context/inner-declared-submodule-names(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-lifts)"
"(lambda(v_0)(begin(expand-context/inner-lifts(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-lift-envs)"
"(lambda(v_0)(begin(expand-context/inner-lift-envs(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-module-lifts)"
"(lambda(v_0)(begin(expand-context/inner-module-lifts(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-require-lifts)"
"(lambda(v_0)(begin(expand-context/inner-require-lifts(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-to-module-lifts)"
"(lambda(v_0)(begin(expand-context/inner-to-module-lifts(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-requires+provides)"
"(lambda(v_0)(begin(expand-context/inner-requires+provides(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-observer)"
"(lambda(v_0)(begin(expand-context/inner-observer(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-for-serializable?)"
"(lambda(v_0)(begin(expand-context/inner-for-serializable?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-to-correlated-linklet?)"
"(lambda(v_0)(begin(expand-context/inner-to-correlated-linklet?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-normalize-locals?)"
"(lambda(v_0)(begin(expand-context/inner-normalize-locals?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-parsing-expanded?)"
"(lambda(v_0)(begin(expand-context/inner-parsing-expanded?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-skip-visit-available?)"
"(lambda(v_0)(begin(expand-context/inner-skip-visit-available?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(make-expand-context.1)"
"(lambda(for-serializable?4_0 observer6_0 skip-visit-available?7_0 to-correlated-linklet?5_0 to-parsed?3_0 ns13_0)"
"(begin"
" 'make-expand-context"
"(let-values(((ns_0) ns13_0))"
"(let-values(((to-parsed?_0) to-parsed?3_0))"
"(let-values(((for-serializable?_0) for-serializable?4_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?5_0))"
"(let-values(((observer_0) observer6_0))"
"(let-values(((skip-visit-available?_0) skip-visit-available?7_0))"
"(let-values()"
"(let-values(((root-ctx_0)(namespace-get-root-expand-ctx ns_0)))"
"(expand-context/make"
"(root-expand-context-self-mpi root-ctx_0)"
"(root-expand-context-module-scopes root-ctx_0)"
"(root-expand-context-post-expansion root-ctx_0)"
"(root-expand-context-top-level-bind-scope root-ctx_0)"
"(root-expand-context-all-scopes-stx root-ctx_0)"
"(root-expand-context-use-site-scopes root-ctx_0)"
"(root-expand-context-defined-syms root-ctx_0)"
"(root-expand-context-frame-id root-ctx_0)"
"(root-expand-context-counter root-ctx_0)"
"(root-expand-context-lift-key root-ctx_0)"
" to-parsed?_0"
" 'top-level"
"(namespace-phase ns_0)"
" ns_0"
" empty-env"
" null"
" #f"
"(root-expand-context-frame-id root-ctx_0)"
" null"
" #f"
" #f"
" #f"
" #f"
" #t"
" #f"
" #f"
" empty-free-id-set"
" null"
" null"
" '#hasheq()"
" #f"
" '()"
" #f"
" #f"
" #f"
" #f"
" #f"
" observer_0"
" for-serializable?_0"
" to-correlated-linklet?_0"
" to-correlated-linklet?_0"
" #f"
" skip-visit-available?_0))))))))))))"
"(define-values"
"(copy-root-expand-context)"
"(lambda(ctx_0 root-ctx_0)"
"(begin"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((post-expansion25_0)(root-expand-context-post-expansion root-ctx_0))"
"((use-site-scopes26_0)(root-expand-context-use-site-scopes root-ctx_0))"
"((frame-id27_0)(root-expand-context-frame-id root-ctx_0))"
"((binding-layer28_0)(root-expand-context-frame-id root-ctx_0))"
"((inner29_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((self-mpi30_0)(root-expand-context-self-mpi root-ctx_0))"
"((module-scopes31_0)(root-expand-context-module-scopes root-ctx_0))"
"((top-level-bind-scope32_0)"
"(root-expand-context-top-level-bind-scope root-ctx_0))"
"((all-scopes-stx33_0)(root-expand-context-all-scopes-stx root-ctx_0))"
"((defined-syms34_0)(root-expand-context-defined-syms root-ctx_0))"
"((counter35_0)(root-expand-context-counter root-ctx_0))"
"((lift-key36_0)(root-expand-context-lift-key root-ctx_0)))"
"(expand-context/inner2.1"
" self-mpi30_0"
" module-scopes31_0"
" top-level-bind-scope32_0"
" all-scopes-stx33_0"
" defined-syms34_0"
" counter35_0"
" lift-key36_0"
"(expand-context/inner-to-parsed? the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once? the-struct_1)"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-parsing-expanded? the-struct_1)"
"(expand-context/inner-skip-visit-available? the-struct_1)))"
"                              (raise-argument-error 'struct-copy \"expand-context/inner?\" the-struct_1)))))"
"(expand-context/outer1.1"
" inner29_0"
" post-expansion25_0"
" use-site-scopes26_0"
" frame-id27_0"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
" binding-layer28_0"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"            (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))"
"(define-values(default-val.1$1) #f)"
"(define-values"
"(current-expand-context)"
"(lambda()(begin(continuation-mark-set-first #f current-expand-context default-val.1$1 root-tag))))"
"(define-values"
"(get-current-expand-context.1)"
"(lambda(fail-ok?15_0 who17_0)"
"(begin"
" 'get-current-expand-context"
"(let-values(((who_0) who17_0))"
"(let-values(((fail-ok?_0) fail-ok?15_0))"
"(let-values()"
"(let-values(((or-part_0)(force(current-expand-context))))"
"              (if or-part_0 or-part_0 (if fail-ok?_0 #f (raise-arguments-error who_0 \"not currently expanding\"))))))))))"
"(define-values"
"(current-expand-observe)"
"(make-parameter"
" #f"
"(lambda(v_0)"
"(begin"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0 or-part_0(if(procedure? v_0)(procedure-arity-includes? v_0 2) #f)))"
"(void)"
"         (let-values () (raise-argument-error 'current-expand-observe \"(or/c (procedure-arity-includes/c 2) #f)\" v_0)))"
" v_0))"
" 'current-expand-observe))"
"(define-values"
"(as-expression-context)"
"(lambda(ctx_0)"
"(begin"
"(if(if(eq? 'expression(expand-context-context ctx_0))(not(expand-context-name ctx_0)) #f)"
"(let-values() ctx_0)"
"(let-values()"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context37_0) 'expression)"
"((name38_0) #f)"
"((post-expansion39_0) #f)"
"((inner40_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner40_0"
" post-expansion39_0"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
" context37_0"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name38_0))"
"                (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))))"
"(define-values"
"(as-begin-expression-context)"
"(lambda(ctx_0)"
"(begin"
"(if(not(expand-context-name ctx_0))"
"(let-values() ctx_0)"
"(let-values()"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((name41_0) #f)((inner42_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner42_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name41_0))"
"                (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))))"
"(define-values"
"(as-tail-context.1)"
"(lambda(wrt19_0 ctx21_0)"
"(begin"
" 'as-tail-context"
"(let-values(((ctx_0) ctx21_0))"
"(let-values(((wrt-ctx_0) wrt19_0))"
"(let-values()"
"(if(expand-context-name wrt-ctx_0)"
"(let-values()"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((name43_0)(expand-context-name wrt-ctx_0))"
"((inner44_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner44_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name43_0))"
"                      (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))"
"(let-values() ctx_0))))))))"
"(define-values"
"(as-named-context)"
"(lambda(ctx_0 ids_0)"
"(begin"
"(if(if(pair? ids_0)(null?(cdr ids_0)) #f)"
"(let-values()"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((name45_0)(car ids_0))((inner46_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner46_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name45_0))"
"                (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))"
"(let-values() ctx_0)))))"
"(define-values"
"(as-to-parsed-context)"
"(lambda(ctx_0)"
"(begin"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner47_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((to-parsed?48_0) #t)((observer49_0) #f)((parsing-expanded?50_0) #t))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
" to-parsed?48_0"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once? the-struct_1)"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
" observer49_0"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
" parsing-expanded?50_0"
"(expand-context/inner-skip-visit-available? the-struct_1)))"
"                              (raise-argument-error 'struct-copy \"expand-context/inner?\" the-struct_1)))))"
"(expand-context/outer1.1"
" inner47_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"            (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))"
"(call-with-values"
"(lambda()"
"(set-current-previously-unbound!"
"(lambda()"
"(let-values(((ctx_0)(force(current-expand-context))))"
"(let-values(((phase-to-ids_0)(if ctx_0(expand-context-need-eventually-defined ctx_0) #f)))"
"(if phase-to-ids_0(hash-ref phase-to-ids_0(expand-context-phase ctx_0) null) #f))))))"
" print-values)"
"(define-values"
"(to-syntax-list.1)"
"(lambda(s_0)"
"(begin"
" 'to-syntax-list"
"(if(list? s_0)"
"(let-values() s_0)"
"(if(pair? s_0)"
"(let-values()(let-values(((r_0)(to-syntax-list.1(cdr s_0))))(if r_0(cons(car s_0) r_0) #f)))"
"(if(syntax?$1 s_0)(let-values()(to-syntax-list.1(syntax-e$1 s_0)))(let-values() #f)))))))"
"(define-values"
"(syntax-debug-info$1)"
"(lambda(s_0 phase_0 all-bindings?_0)"
"(begin"
" 'syntax-debug-info"
"(let-values(((hts_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(fallback->list(syntax-shifted-multi-scopes s_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((smss_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((init-ht_0)"
"(if(identifier?"
" s_0)"
"(hasheq"
" 'name"
"(syntax-e$1"
" s_0))"
" '#hasheq())))"
"(let-values(((s-scs_0)"
"(scope-set-at-fallback"
" s_0"
" smss_0"
" phase_0)))"
"(let-values(((context_0)"
"(scope-set->context"
" s-scs_0)))"
"(let-values(((context-ht_0)"
"(hash-set"
" init-ht_0"
" 'context"
" context_0)))"
"(let-values(((sym_0)"
"(syntax-e$1"
" s_0)))"
"(let-values(((classify-binding_0)"
"(lambda(b_0)"
"(begin"
" 'classify-binding"
"(if(local-binding?"
" b_0)"
"(let-values()"
" 'local)"
"(if(like-ambiguous-binding?"
" b_0)"
"(let-values()"
" 'ambiguous)"
"(let-values()"
" 'module)))))))"
"(let-values(((extract-binding_0)"
"(lambda(b_0)"
"(begin"
" 'extract-binding"
"(if(local-binding?"
" b_0)"
"(let-values()"
"(local-binding-key"
" b_0))"
"(if(like-ambiguous-binding?"
" b_0)"
"(let-values()"
" #t)"
"(let-values()"
"(vector"
"(module-binding-sym"
" b_0)"
"(module-binding-module"
" b_0)"
"(module-binding-phase"
" b_0)))))))))"
"(let-values(((bindings_0)"
"(append"
"(if(identifier?"
" s_0)"
"(let-values()"
"(let-values(((bindings_0"
" covered-scopess_0)"
"(let-values(((bindings_0)"
"(let-values(((bindings_0)"
" null))"
" bindings_0))"
"((covered-scope-sets_0)"
"(let-values(((covered-scope-sets_0)"
"(set)))"
" covered-scope-sets_0)))"
"(let-values(((ht_0)"
" s-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys"
" ht_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(bindings_1"
" covered-scope-sets_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((bindings_2"
" covered-scope-sets_2)"
"(let-values(((ht_1"
" bulk-bindings_0)"
"(let-values(((table_0)"
"(scope-binding-table"
" sc_0)))"
"(if(hash?"
" table_0)"
"(values"
"(hash-ref"
" table_0"
" sym_0"
" '#hash())"
" null)"
"(values"
"(hash-ref"
"(table-with-bulk-bindings-syms"
" table_0)"
" sym_0"
" '#hash())"
"(table-with-bulk-bindings-bulk-bindings"
" table_0)))))"
"((s_1)"
" s_0)"
"((extra-shifts_0)"
" null))"
"(begin"
" #t"
"((letrec-values(((for-loop_2)"
"(lambda(bindings_2"
" covered-scope-sets_2"
" i_1)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" i_1))"
"(let-values(((scs_0)"
"(if(pair?"
" i_1)"
"(let-values()"
"(bulk-binding-at-scopes"
"(car"
" i_1)))"
"(let-values()"
"(hash-iterate-key"
" ht_1"
" i_1))))"
"((b_0)"
"(if(pair?"
" i_1)"
"(let-values()"
"(let-values(((bulk_0)"
"(bulk-binding-at-bulk"
"(car"
" i_1))))"
"(let-values(((b-info_0)"
"(if(symbol-interned?"
" sym_0)"
"(hash-ref"
"(bulk-binding-symbols"
" bulk_0"
" s_1"
" extra-shifts_0)"
" sym_0"
" #f)"
" #f)))"
"(if b-info_0"
"((bulk-binding-create"
" bulk_0)"
" bulk_0"
" b-info_0"
" sym_0)"
" #f))))"
"(let-values()"
"(hash-iterate-value"
" ht_1"
" i_1)))))"
"(let-values(((bindings_3"
" covered-scope-sets_3)"
"(if(if scs_0"
"(if b_0"
"(not"
"(set-member?"
" covered-scope-sets_2"
" scs_0))"
" #f)"
" #f)"
"(let-values(((bindings_3"
" covered-scope-sets_3)"
"(let-values()"
"(values"
"(cons"
"(hasheq"
" 'name"
"(syntax-e$1"
" s_0)"
" 'context"
"(scope-set->context"
" scs_0)"
" 'match?"
"(subset?"
" scs_0"
" s-scs_0)"
"(classify-binding_0"
" b_0)"
"(extract-binding_0"
" b_0))"
" bindings_2)"
"(set-add"
" covered-scope-sets_2"
" scs_0)))))"
"(values"
" bindings_3"
" covered-scope-sets_3))"
"(values"
" bindings_2"
" covered-scope-sets_2))))"
"(if(not"
" #f)"
"(for-loop_2"
" bindings_3"
" covered-scope-sets_3"
"(if(pair?"
" i_1)"
"(let-values()"
"(cdr"
" i_1))"
"(let-values()"
"(let-values(((or-part_0)"
"(hash-iterate-next"
" ht_1"
" i_1)))"
"(if or-part_0"
" or-part_0"
" bulk-bindings_0)))))"
"(values"
" bindings_3"
" covered-scope-sets_3))))"
"(values"
" bindings_2"
" covered-scope-sets_2))))))"
" for-loop_2)"
" bindings_1"
" covered-scope-sets_1"
"(let-values(((or-part_0)"
"(hash-iterate-first"
" ht_1)))"
"(if or-part_0"
" or-part_0"
" bulk-bindings_0)))))))"
"(if(not"
" #f)"
"(for-loop_1"
" bindings_2"
" covered-scope-sets_2"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
"(values"
" bindings_2"
" covered-scope-sets_2))))"
"(values"
" bindings_1"
" covered-scope-sets_1)))))))"
" for-loop_1)"
" bindings_0"
" covered-scope-sets_0"
"(unsafe-immutable-hash-iterate-first"
" ht_0)))))))"
" bindings_0))"
"(let-values()"
" null))"
"(if all-bindings?_0"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((ht_0)"
" s-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys"
" ht_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((fold-var_4)"
"(let-values(((sym-ht_0)"
"(let-values(((table_0)"
"(scope-binding-table"
" sc_0)))"
"(if(hash?"
" table_0)"
" table_0"
"(table-with-bulk-bindings-syms"
" table_0)))))"
"(begin"
" #t"
"((letrec-values(((for-loop_2)"
"(lambda(fold-var_4"
" state_0)"
"(begin"
" 'for-loop"
"(if(car"
" state_0)"
"(let-values(((o-sym_0)"
"(vector-ref"
"(car"
" state_0)"
" 1))"
"((scs_0)"
"(hash-iterate-key"
"(vector-ref"
"(car"
" state_0)"
" 2)"
"(cdr"
" state_0)))"
"((b_0)"
"(hash-iterate-value"
"(vector-ref"
"(car"
" state_0)"
" 2)"
"(cdr"
" state_0))))"
"(let-values(((fold-var_5)"
"(if(eq?"
" o-sym_0"
" sym_0)"
" fold-var_4"
"(let-values(((fold-var_5)"
"(let-values()"
"(cons"
"(let-values()"
"(hasheq"
" 'name"
" o-sym_0"
" 'context"
"(scope-set->context"
" scs_0)"
" 'match?"
" #f"
"(classify-binding_0"
" b_0)"
"(extract-binding_0"
" b_0)))"
" fold-var_4))))"
"(values"
" fold-var_5)))))"
"(if(not"
" #f)"
"(for-loop_2"
" fold-var_5"
"(let-values(((ht_1)"
"(vector-ref"
"(car"
" state_0)"
" 2)))"
"(let-values(((i_1)"
"(hash-iterate-next"
" ht_1"
"(cdr"
" state_0))))"
"(if i_1"
"(cons"
"(car"
" state_0)"
" i_1)"
"(next-state-in-full-binding-table"
" sym-ht_0"
"(hash-iterate-next"
" sym-ht_0"
"(vector-ref"
"(car"
" state_0)"
" 0)))))))"
" fold-var_5)))"
" fold-var_4)))))"
" for-loop_2)"
" fold-var_3"
"((letrec-values(((loop_0)"
"(lambda(sym-i_0)"
"(begin"
" 'loop"
"(if sym-i_0"
"(next-state-in-full-binding-table"
" sym-ht_0"
" sym-i_0)"
" '(#f"
" ."
" #f))))))"
" loop_0)"
"(hash-iterate-first"
" sym-ht_0)))))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
"(unsafe-immutable-hash-iterate-first"
" ht_0)))))))"
"(let-values()"
" null)))))"
"(if(null?"
" bindings_0)"
" context-ht_0"
"(hash-set"
" context-ht_0"
" 'bindings"
" bindings_0)))))))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((ht_0)(car hts_0)))(if(null?(cdr hts_0)) ht_0(hash-set ht_0 'fallbacks(cdr hts_0))))))))"
"(define-values"
"(scope-set->context)"
"(lambda(scs_0)"
"(begin"
"(let-values(((temp1_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0) scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(interned-scope? sc_0)"
"(let-values()"
"(vector"
"(scope-id sc_0)"
"(scope-kind sc_0)"
"(interned-scope-key sc_0)))"
"(if(representative-scope?"
" sc_0)"
"(let-values()"
"(vector"
"(scope-id sc_0)"
"(scope-kind sc_0)"
"(multi-scope-name"
"(representative-scope-owner"
" sc_0))))"
"(let-values()"
"(vector"
"(scope-id sc_0)"
"(scope-kind sc_0))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"((<2_0) <)"
"((temp3_0)(lambda(v_0)(vector-ref v_0 0))))"
"(sort.1 #f temp3_0 temp1_0 <2_0)))))"
"(define-values"
"(raise-ambiguous-error)"
"(lambda(id_0 ctx_0)"
"(begin"
"(raise-syntax-error$1"
" #f"
"       \"identifier's binding is ambiguous\""
" id_0"
" #f"
" null"
"(syntax-debug-info-string id_0 ctx_0)))))"
"(define-values"
"(syntax-debug-info-string)"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((info_0)(syntax-debug-info$1 s_0(expand-context-phase ctx_0) #f)))"
"(if(not"
"(let-values(((or-part_0)(pair?(hash-ref info_0 'bindings null))))"
"(if or-part_0"
" or-part_0"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0)(hash-ref info_0 'fallbacks null)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((fb-info_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(pair?"
"(hash-ref"
" fb-info_0"
" 'bindings"
" null))))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) fb-info_0))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0)))))))"
"          (let-values () \"\")"
"(let-values()"
"(let-values(((relevant-scope-sets_0)"
"((letrec-values(((loop_0)"
"(lambda(info_1 layer_0)"
"(begin"
" 'loop"
"(apply"
" append"
"(cons"
"(hash-ref info_1 'context)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(hash-ref info_1 'bindings null)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((b_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(hash-ref"
" b_0"
" 'context))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
"(let-values(((fallbacks_0)(hash-ref info_1 'fallbacks null)))"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) fallbacks_0)((start_0)(add1 layer_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((fallback_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1))"
"((layer_1) pos_0))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0"
" fallback_0"
" layer_1))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0"
"(+ pos_0 1))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" start_0)))))))))))"
" loop_0)"
" info_0"
" 0)))"
"(let-values(((common-scopes_0)"
"(if(null? relevant-scope-sets_0)"
"(set)"
"(let-values(((s_1)(let-values(((s_1)(list->set(car relevant-scope-sets_0)))) s_1)))"
"(let-values(((lst_0) relevant-scope-sets_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((l_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_3)"
"(let-values(((s_3)"
"(let-values()"
"(set-intersect"
" s_2"
"(list->set l_0)))))"
"(values s_3))))"
"(if(not #f)(for-loop_0 s_3 rest_0) s_3)))"
" s_2))))))"
" for-loop_0)"
" s_1"
" lst_0)))))))"
"(string-append"
"((letrec-values(((loop_0)"
"(lambda(info_1 layer_0)"
"(begin"
" 'loop"
"(string-append"
"                                        \"\\n  context\""
"(layer->string layer_0)"
"                                        \"...:\""
"(describe-context(hash-ref info_1 'context) common-scopes_0)"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)"
"(let-values(((temp1_0)(hash-ref info_1 'bindings null))"
"((temp2_0)"
"(lambda(a_0 b_0)"
"(if(hash-ref a_0 'match? #f)"
"(not(hash-ref b_0 'match? #f))"
" #f))))"
"(sort.1 #f #f temp1_0 temp2_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((b_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(string-append"
"                                                                                                              \"\\n  \""
"(if(hash-ref"
" b_0"
" 'match?"
" #f)"
"                                                                                                                \"matching\""
"                                                                                                                \"other\")"
"                                                                                                              \" binding\""
"(layer->string"
" layer_0)"
"                                                                                                              \"...:\""
"                                                                                                              \"\\n   \""
"(if(hash-ref"
" b_0"
" 'local"
" #f)"
"                                                                                                                \"local\""
"(format"
"                                                                                                                 \"~a\""
"(hash-ref"
" b_0"
" 'module"
" #f)))"
"(describe-context"
"(hash-ref"
" b_0"
" 'context)"
" common-scopes_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
"(let-values(((fallbacks_0)(hash-ref info_1 'fallbacks null)))"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) fallbacks_0)((start_0)(add1 layer_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((fallback_0)"
"(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((layer_1) pos_0))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0"
" fallback_0"
" layer_1))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0"
"(+ pos_0 1))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" start_0))))))))))))"
" loop_0)"
" info_0"
" 0)"
"(if(set-empty? common-scopes_0)"
"                   \"\""
"(string-append"
"                    \"\\n  common scopes...:\""
"(describe-context"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(hash-ref info_0 'context)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(if(set-member? common-scopes_0 s_1)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values() s_1)"
" fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
"(set)))))))))))))"
"(define-values"
"(describe-context)"
"(lambda(scopes_0 common-scopes_0)"
"(begin"
"(let-values(((strs_0)"
"((letrec-values(((loop_0)"
"(lambda(strs_0 scopes_1)"
"(begin"
" 'loop"
"(if(null? scopes_1)"
"(let-values()(reverse$1 strs_0))"
"(let-values()"
"                                              (let-values (((str_0) (format \" ~a\" (car scopes_1))))"
"(if(if(pair? strs_0)"
"(<(+(string-length str_0)(string-length(car strs_0))) 72)"
" #f)"
"(loop_0"
"(cons(string-append(car strs_0) str_0)(cdr strs_0))"
"(cdr scopes_1))"
"(loop_0(cons str_0 strs_0)(cdr scopes_1))))))))))"
" loop_0)"
" null"
"(if(set-empty? common-scopes_0)"
" scopes_0"
"(append"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(if(not(set-member? common-scopes_0 s_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values() s_0)"
" fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
"                        (list \"[common scopes]\"))))))"
"(if(null? strs_0)"
"          (let-values () \"\\n   [empty]\")"
"(let-values()"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) strs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((str_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"                                                                                 (string-append \"\\n  \" str_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))))"
" (define-values (layer->string) (lambda (layer_0) (begin (if (zero? layer_0) \"\" (format \" at layer ~a\" layer_0)))))"
"(define-values"
"(raise-syntax-implicit-error)"
"(lambda(s_0 sym_0 trigger-id_0 ctx_0)"
"(begin"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((what_0)"
"(let-values(((tmp_0) sym_0))"
"(if(equal? tmp_0 '#%app)"
"                          (let-values () \"function application\")"
"(if(equal? tmp_0 '#%datum)"
"                            (let-values () \"literal data\")"
"(if(equal? tmp_0 '#%top)"
"(let-values()"
"(if(expand-context-allow-unbound? ctx_0)"
"                                  \"reference to a top-level identifier\""
"                                  \"reference to an unbound identifier\"))"
"(let-values()(void))))))))"
"(let-values(((unbound?_0)"
"(if trigger-id_0"
"(not"
"(let-values(((trigger-id1_0) trigger-id_0)((phase2_0) phase_0))"
"(resolve.1 #f #f null #f trigger-id1_0 phase2_0)))"
" #f)))"
"(let-values(((unbound-form_0)"
"(if unbound?_0(if(not(eq?(syntax-e$1 s_0)(syntax-e$1 trigger-id_0))) s_0 #f) #f)))"
"(raise-syntax-error$1"
" #f"
"(format"
"(if unbound?_0"
"                  \"unbound identifier;\\n also, no ~a syntax transformer is bound~a\""
"                  (string-append what_0 \" is not allowed;\\n no ~a syntax transformer is bound~a\"))"
" sym_0"
"(let-values(((tmp_0) phase_0))"
"(if(equal? tmp_0 0)"
"                    (let-values () \"\")"
"(if(equal? tmp_0 1)"
"                      (let-values () \" in the transformer phase\")"
"                      (let-values () (format \" at phase ~a\" phase_0))))))"
"(if unbound?_0(let-values(((or-part_0) unbound-form_0))(if or-part_0 or-part_0 trigger-id_0)) #f)"
"(if unbound?_0(if unbound-form_0 trigger-id_0 #f) s_0)"
" null"
"               (if unbound?_0 (syntax-debug-info-string trigger-id_0 ctx_0) \"\")))))))))"
"(define-values(make-check-no-duplicate-table)(lambda()(begin '#hasheq())))"
"(define-values"
"(check-no-duplicate-ids.1)"
"(lambda(what1_0 ids4_0 phase5_0 s6_0 ht3_0)"
"(begin"
" 'check-no-duplicate-ids"
"(let-values(((ids_0) ids4_0))"
"(let-values(((phase_0) phase5_0))"
"(let-values(((s_0) s6_0))"
"(let-values(((ht_0)(if(eq? ht3_0 unsafe-undefined)(make-check-no-duplicate-table) ht3_0)))"
"              (let-values (((what_0) (if (eq? what1_0 unsafe-undefined) \"binding name\" what1_0)))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(v_0 ht_1)"
"(begin"
" 'loop"
"(if(identifier? v_0)"
"(let-values()"
"(let-values(((l_0)(hash-ref ht_1(syntax-e$1 v_0) null)))"
"(begin"
"(let-values()"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(bound-identifier=?$1"
" id_0"
" v_0"
" phase_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(string-append"
"                                                                                                                        \"duplicate \""
" what_0)"
" s_0"
" v_0))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(hash-set ht_1(syntax-e$1 v_0)(cons v_0 l_0)))))"
"(if(pair? v_0)"
"(let-values()(loop_0(cdr v_0)(loop_0(car v_0) ht_1)))"
"(let-values() ht_1)))))))"
" loop_0)"
" ids_0"
" ht_0))))))))))"
"(define-values"
"(remove-use-site-scopes)"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((use-sites_0)(root-expand-context-use-site-scopes ctx_0)))"
"(if(if use-sites_0(pair?(unbox use-sites_0)) #f)"
"(if(syntax?$1 s_0)"
"(remove-scopes s_0(unbox use-sites_0))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(remove-scopes"
" id_0"
"(unbox use-sites_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
" s_0)))))"
"(define-values"
"(struct:compile-context"
" compile-context1.1"
" compile-context?"
" compile-context-namespace"
" compile-context-phase"
" compile-context-self"
" compile-context-module-self"
" compile-context-full-module-name"
" compile-context-lazy-syntax-literals?"
" compile-context-header)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'compile-context"
" #f"
" 7"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'compile-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'namespace)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'self)"
"(make-struct-field-accessor -ref_0 3 'module-self)"
"(make-struct-field-accessor -ref_0 4 'full-module-name)"
"(make-struct-field-accessor -ref_0 5 'lazy-syntax-literals?)"
"(make-struct-field-accessor -ref_0 6 'header))))"
"(define-values"
"(make-compile-context.1)"
"(lambda(full-module-name6_0 lazy-syntax-literals?7_0 module-self5_0 namespace2_0 phase3_0 self4_0)"
"(begin"
" 'make-compile-context"
"(let-values(((namespace_0)(if(eq? namespace2_0 unsafe-undefined)(1/current-namespace) namespace2_0)))"
"(let-values(((phase_0)(if(eq? phase3_0 unsafe-undefined)(namespace-phase namespace_0) phase3_0)))"
"(let-values(((self_0)(if(eq? self4_0 unsafe-undefined)(namespace-self-mpi namespace_0) self4_0)))"
"(let-values(((module-self_0) module-self5_0))"
"(let-values(((full-module-name_0) full-module-name6_0))"
"(let-values(((lazy-syntax-literals?_0)"
"(if(eq? lazy-syntax-literals?7_0 unsafe-undefined)"
"(if module-self_0 #t #f)"
" lazy-syntax-literals?7_0)))"
"(let-values()"
"(begin"
"(if(if module-self_0(not full-module-name_0) #f)"
"                        (let-values () (error \"internal error: module-self provided without full name\"))"
"(void))"
"(compile-context1.1"
" namespace_0"
" phase_0"
" self_0"
" module-self_0"
" full-module-name_0"
" lazy-syntax-literals?_0"
" #f))))))))))))"
"(define-values(kernel)(primitive-table '#%kernel))"
"(define-values(syntax?$3)(hash-ref kernel 'syntax?))"
"(define-values(syntax-e$4)(hash-ref kernel 'syntax-e))"
"(define-values(datum->syntax$4)(hash-ref kernel 'datum->syntax))"
"(define-values(syntax->datum$4)(hash-ref kernel 'syntax->datum))"
"(define-values(syntax-property$3)(hash-ref kernel 'syntax-property))"
"(define-values(syntax-property-symbol-keys$3)(hash-ref kernel 'syntax-property-symbol-keys))"
"(define-values(syntax-source$3)(hash-ref kernel 'syntax-source))"
"(define-values(syntax-line$3)(hash-ref kernel 'syntax-line))"
"(define-values(syntax-column$3)(hash-ref kernel 'syntax-column))"
"(define-values(syntax-position$3)(hash-ref kernel 'syntax-position))"
"(define-values(syntax-span$3)(hash-ref kernel 'syntax-span))"
"(define-values(correlated?$1)(lambda(e_0)(begin 'correlated?(syntax?$3 e_0))))"
"(define-values"
"(datum->correlated$1)"
"(let-values(((datum->correlated_0)"
"(lambda(d3_0 srcloc1_0 props2_0)"
"(begin"
" 'datum->correlated"
"(let-values(((d_0) d3_0))"
"(let-values(((srcloc_0) srcloc1_0))"
"(let-values(((props_0) props2_0))"
"(let-values()(datum->syntax$4 #f d_0 srcloc_0 props_0)))))))))"
"(case-lambda"
"((d_0)(begin 'datum->correlated(datum->correlated_0 d_0 #f #f)))"
"((d_0 srcloc_0 props2_0)(datum->correlated_0 d_0 srcloc_0 props2_0))"
"((d_0 srcloc1_0)(datum->correlated_0 d_0 srcloc1_0 #f)))))"
"(define-values(correlated-e$1)(lambda(e_0)(begin 'correlated-e(syntax-e$4 e_0))))"
"(define-values"
"(correlated-property$1)"
"(case-lambda"
"((e_0 k_0)(begin 'correlated-property(syntax-property$3 e_0 k_0)))"
"((e_0 k_0 v_0)(syntax-property$3 e_0 k_0 v_0))))"
"(define-values"
"(correlated-property-symbol-keys$1)"
"(lambda(e_0)(begin 'correlated-property-symbol-keys(syntax-property-symbol-keys$3 e_0))))"
"(define-values(correlated-source$1)(lambda(s_0)(begin 'correlated-source(syntax-source$3 s_0))))"
"(define-values(correlated-line$1)(lambda(s_0)(begin 'correlated-line(syntax-line$3 s_0))))"
"(define-values(correlated-column$1)(lambda(s_0)(begin 'correlated-column(syntax-column$3 s_0))))"
"(define-values(correlated-position$1)(lambda(s_0)(begin 'correlated-position(syntax-position$3 s_0))))"
"(define-values(correlated-span$1)(lambda(s_0)(begin 'correlated-span(syntax-span$3 s_0))))"
"(define-values"
"(check-flvector)"
"(lambda(v_0)"
"(begin"
"(if(flvector? v_0)"
"(void)"
"        (let-values () (1/raise-argument-error 'in-flvector* (string-append \"flvector\" \"?\") v_0))))))"
" (define-values (not-an-fX.1$1) (lambda (who_0 v_0) (begin 'not-an-fX (raise-argument-error who_0 \"flonum?\" v_0))))"
"(define-values"
"(truncate-path)"
"(lambda(p_0)"
"(begin"
"(let-values(((base1_0 name1_0 dir?_0)(split-path p_0)))"
"(if(path-for-some-system? base1_0)"
"(let-values()"
"(let-values(((base2_0 name2_0 dir?_1)(split-path base1_0)))"
"(if(not base2_0)"
"(let-values()(path-for-some-system->string p_0))"
"(if(symbol? name2_0)"
"                  (let-values () (string-append \".../\" (path-elem->string name1_0)))"
"(let-values()"
"                    (string-append \".../\" (path-for-some-system->string name2_0) \"/\" (path-elem->string name1_0)))))))"
"(if(eq? base1_0 'relative)"
"(let-values()(path-elem->string name1_0))"
"(let-values()(path-for-some-system->string p_0))))))))"
"(define-values"
"(path-elem->string)"
"(lambda(p_0)"
"(begin"
"(if(eq? p_0 'same)"
"        (let-values () \".\")"
"        (if (eq? p_0 'up) (let-values () \"..\") (let-values () (path-for-some-system->string p_0)))))))"
"(define-values"
"(path-for-some-system->string)"
"(lambda(p_0)"
"(begin"
"(if(path? p_0)"
"(let-values()(path->string p_0))"
"(let-values()(bytes->string/utf-8(path->bytes p_0) '#\\�))))))"
"(define-values"
"(make-path->relative-path-elements.1)"
"(lambda(who1_0 wr-dir3_0)"
"(begin"
" 'make-path->relative-path-elements"
"(let-values(((wr-dir_0)(if(eq? wr-dir3_0 unsafe-undefined)(current-write-relative-directory) wr-dir3_0)))"
"(let-values(((who_0) who1_0))"
"(let-values()"
"(begin"
"(if who_0"
"(let-values()"
"(if(let-values(((or-part_0)(not wr-dir_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(path-string? wr-dir_0)(complete-path? wr-dir_0) #f)))"
"(if or-part_1"
" or-part_1"
"(if(pair? wr-dir_0)"
"(if(path-string?(car wr-dir_0))"
"(if(complete-path?(car wr-dir_0))"
"(if(path-string?(cdr wr-dir_0))(complete-path?(cdr wr-dir_0)) #f)"
" #f)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"(string-append"
"                        \"(or/c (and/c path-string? complete-path?)\\n\""
"                        \"      (cons/c (and/c path-string? complete-path?)\\n\""
"                        \"              (and/c path-string? complete-path?))\\n\""
"                        \"      #f)\")"
" wr-dir_0))))"
"(void))"
"(if(not wr-dir_0)"
"(let-values()(lambda(v_0) #f))"
"(let-values()"
"(let-values(((exploded-base-dir_0) 'not-ready))"
"(let-values(((exploded-wrt-rel-dir_0) 'not-ready))"
"(lambda(v_0)"
"(begin"
"(if(if(eq? exploded-base-dir_0 'not-ready)(path? v_0) #f)"
"(let-values()"
"(let-values(((wrt-dir_0)(if wr-dir_0(if(pair? wr-dir_0)(car wr-dir_0) wr-dir_0) #f)))"
"(let-values(((exploded-wrt-dir_0)(explode-path wrt-dir_0)))"
"(let-values(((base-dir_0)"
"(if wr-dir_0(if(pair? wr-dir_0)(cdr wr-dir_0) wr-dir_0) #f)))"
"(begin"
"(set! exploded-base-dir_0(if base-dir_0(explode-path base-dir_0) #f))"
"(set! exploded-wrt-rel-dir_0"
"(if(eq? base-dir_0 wrt-dir_0)"
"(let-values() '())"
"(let-values()"
"(let-values(((exploded-wrt-dir_1)(explode-path wrt-dir_0)))"
"(let-values(((base-len_0)(length exploded-base-dir_0)))"
"(begin"
"(if who_0"
"(let-values()"
"(if(if(>=(length exploded-wrt-dir_1) base-len_0)"
"(let-values(((result_0)"
"(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0) exploded-wrt-dir_1)"
"((lst_1) exploded-base-dir_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)"
"(pair? lst_3)"
" #f)"
"(let-values(((a_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((b_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(equal?"
" a_0"
" b_0)))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" a_0))"
"(if(not"
"((lambda x_0"
"(not"
" result_2))"
" b_0))"
"(not #f)"
" #f)"
" #f)"
"(for-loop_0"
" result_2"
" rest_0"
" rest_1)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0"
" lst_1))))"
" #f)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                           \"relative-directory pair's first path does not extend second path\""
"                                                           \"first path\""
" wrt-dir_0"
"                                                           \"second path\""
" base-dir_0))))"
"(void))"
"(list-tail exploded-wrt-dir_1 base-len_0))))))))))))"
"(void))"
"(if exploded-base-dir_0"
"(if(path? v_0)"
"(let-values(((exploded_0)(explode-path v_0)))"
"(if(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0) exploded-base-dir_0)((lst_1) exploded_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((base-p_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((p_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(equal?"
" base-p_0"
" p_0)))))"
"(values result_2))))"
"(if(if(not"
"((lambda x_0(not result_2)) base-p_0))"
"(if(not"
"((lambda x_0(not result_2)) p_0))"
"(not #f)"
" #f)"
" #f)"
"(for-loop_0 result_2 rest_0 rest_1)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0"
" lst_1))))"
"(if(>=(length exploded_0)(length exploded-base-dir_0))"
"((letrec-values(((loop_0)"
"(lambda(exploded-wrt-rel-dir_1 rel_0)"
"(begin"
" 'loop"
"(if(null? exploded-wrt-rel-dir_1)"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) rel_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(path?"
" p_0)"
"(path-element->bytes"
" p_0)"
" p_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
"(if(if(pair? rel_0)"
"(equal?(car rel_0)(car exploded-wrt-rel-dir_1))"
" #f)"
"(let-values()"
"(loop_0(cdr exploded-wrt-rel-dir_1)(cdr rel_0)))"
"(let-values()"
"(append"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) exploded-wrt-rel-dir_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" 'up)"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) rel_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(path?"
" p_0)"
"(path-element->bytes"
" p_0)"
" p_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))))))"
" loop_0)"
" exploded-wrt-rel-dir_0"
"(list-tail exploded_0(length exploded-base-dir_0)))"
" #f)"
" #f))"
" #f)"
" #f))))))))))))))"
"(define-values(1/write-byte)(lambda(byte_0 out_0)(begin 'write-byte(write-byte byte_0 out_0))))"
"(define-values"
"(1/write-bytes)"
"(let-values(((write-bytes_0)"
"(lambda(bstr3_0 out4_0 start-pos1_0 end-pos2_0)"
"(begin"
" 'write-bytes"
"(let-values(((bstr_0) bstr3_0))"
"(let-values(((out_0) out4_0))"
"(let-values(((start-pos_0) start-pos1_0))"
"(let-values(((end-pos_0)"
"(if(eq? end-pos2_0 unsafe-undefined)(bytes-length bstr_0) end-pos2_0)))"
"(let-values()(write-bytes bstr_0 out_0 start-pos_0 end-pos_0))))))))))"
"(case-lambda"
"((bstr_0 out_0)(begin 'write-bytes(write-bytes_0 bstr_0 out_0 0 unsafe-undefined)))"
"((bstr_0 out_0 start-pos_0 end-pos2_0)(write-bytes_0 bstr_0 out_0 start-pos_0 end-pos2_0))"
"((bstr_0 out_0 start-pos1_0)(write-bytes_0 bstr_0 out_0 start-pos1_0 unsafe-undefined)))))"
"(define-values(fasl-graph-def-type) 1)"
"(define-values(fasl-graph-ref-type) 2)"
"(define-values(fasl-false-type) 3)"
"(define-values(fasl-true-type) 4)"
"(define-values(fasl-null-type) 5)"
"(define-values(fasl-void-type) 6)"
"(define-values(fasl-eof-type) 7)"
"(define-values(fasl-integer-type) 8)"
"(define-values(fasl-flonum-type) 9)"
"(define-values(fasl-single-flonum-type) 10)"
"(define-values(fasl-rational-type) 11)"
"(define-values(fasl-complex-type) 12)"
"(define-values(fasl-char-type) 13)"
"(define-values(fasl-symbol-type) 14)"
"(define-values(fasl-unreadable-symbol-type) 15)"
"(define-values(fasl-uninterned-symbol-type) 16)"
"(define-values(fasl-keyword-type) 17)"
"(define-values(fasl-string-type) 18)"
"(define-values(fasl-immutable-string-type) 19)"
"(define-values(fasl-bytes-type) 20)"
"(define-values(fasl-immutable-bytes-type) 21)"
"(define-values(fasl-path-type) 22)"
"(define-values(fasl-relative-path-type) 23)"
"(define-values(fasl-pregexp-type) 24)"
"(define-values(fasl-regexp-type) 25)"
"(define-values(fasl-byte-pregexp-type) 26)"
"(define-values(fasl-byte-regexp-type) 27)"
"(define-values(fasl-list-type) 28)"
"(define-values(fasl-list*-type) 29)"
"(define-values(fasl-pair-type) 30)"
"(define-values(fasl-vector-type) 31)"
"(define-values(fasl-immutable-vector-type) 32)"
"(define-values(fasl-box-type) 33)"
"(define-values(fasl-immutable-box-type) 34)"
"(define-values(fasl-prefab-type) 35)"
"(define-values(fasl-hash-type) 36)"
"(define-values(fasl-immutable-hash-type) 37)"
"(define-values(fasl-srcloc-type) 38)"
"(define-values(fasl-extflonum-type) 39)"
"(define-values(fasl-correlated-type) 40)"
"(define-values(fasl-undefined-type) 41)"
"(define-values(fasl-prefab-type-type) 42)"
"(define-values(fasl-fxvector-type) 43)"
"(define-values(fasl-flvector-type) 44)"
"(define-values(fasl-small-integer-start) 100)"
"(define-values(fasl-lowest-small-integer) -10)"
"(define-values(fasl-highest-small-integer)(- 255(- fasl-small-integer-start fasl-lowest-small-integer) 1))"
" (define-values (fasl-prefix) #\"racket/fasl:\")"
"(define-values(fasl-prefix-length)(bytes-length fasl-prefix))"
"(define-values(fasl-hash-eq-variant) 0)"
"(define-values(fasl-hash-equal-variant) 1)"
"(define-values(fasl-hash-eqv-variant) 2)"
"(define-values(fasl-hash-equal-always-variant) 3)"
"(define-values"
"(s-exp->fasl.1)"
"(lambda(external-lift?7_0 handle-fail6_0 keep-mutable?5_0 skip-prefix?8_0 v14_0 orig-o13_0)"
"(begin"
" 's-exp->fasl"
"(let-values(((v_0) v14_0))"
"(let-values(((orig-o_0) orig-o13_0))"
"(let-values(((keep-mutable?_0) keep-mutable?5_0))"
"(let-values(((handle-fail_0) handle-fail6_0))"
"(let-values(((external-lift?_0) external-lift?7_0))"
"(let-values(((skip-prefix?_0) skip-prefix?8_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if orig-o_0"
"(let-values()"
"(if(output-port? orig-o_0)"
"(void)"
"(let-values()"
"                                            (raise-argument-error 's-exp->fasl \"(or/c output-port? #f)\" orig-o_0))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if handle-fail_0"
"(let-values()"
"(if(if(procedure? handle-fail_0)"
"(procedure-arity-includes? handle-fail_0 1)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 's-exp->fasl"
"                                               \"(or/c (procedure-arity-includes/c 1) #f)\""
" handle-fail_0))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if external-lift?_0"
"(let-values()"
"(if(if(procedure? external-lift?_0)"
"(procedure-arity-includes? external-lift?_0 1)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 's-exp->fasl"
"                                                 \"(or/c (procedure-arity-includes/c 1) #f)\""
" external-lift?_0))))"
"(void))"
"(values))))"
"(let-values(((o_0)"
"(let-values(((or-part_0) orig-o_0))"
"(if or-part_0 or-part_0(open-output-bytes)))))"
"(let-values(((shared_0)(make-hasheq)))"
"(let-values(((external-lift_0)(if external-lift?_0(make-hasheq) #f)))"
"(let-values(((shared-counter_0) 0))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(v_1)"
"(begin"
" 'loop"
"(if(if external-lift_0"
"(hash-ref external-lift_0 v_1 #f)"
" #f)"
"(let-values()(void))"
"(if(if external-lift?_0"
"(external-lift?_0 v_1)"
" #f)"
"(let-values()"
"(begin"
"(hash-set! external-lift_0 v_1 #t)"
"(set! shared-counter_0"
"(add1 shared-counter_0))"
"(hash-set!"
" shared_0"
" v_1"
"(- shared-counter_0))))"
"(if(let-values(((or-part_0)"
"(symbol? v_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(keyword? v_1)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(string? v_1)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)"
"(bytes? v_1)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)"
"(fxvector?"
" v_1)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)"
"(flvector?"
" v_1)))"
"(if or-part_5"
" or-part_5"
"(path?"
" v_1)))))))))))))"
"(let-values()"
"(hash-update! shared_0 v_1 add1 0))"
"(if(pair? v_1)"
"(let-values()"
"(begin"
"(loop_0(car v_1))"
"(loop_0(cdr v_1))))"
"(if(vector? v_1)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-vector"
" vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(hash? v_1)"
"(let-values()"
"(hash-for-each"
" v_1"
"(lambda(k_0 v_2)"
"(begin"
"(loop_0 k_0)"
"(loop_0 v_2)))"
" #t))"
"(if(box? v_1)"
"(let-values()"
"(loop_0(unbox v_1)))"
"(let-values(((c2_0)"
"(prefab-struct-key"
" v_1)))"
"(if c2_0"
"((lambda(k_0)"
"(begin"
"(loop_0 k_0)"
"(let-values()"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(unsafe-normalise-inputs"
" unsafe-vector-length"
"(struct->vector"
" v_1)"
" 1"
" #f"
" 1)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                  \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
"(struct->vector"
" v_1)"
" 1"
" #f"
" 1))))"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void)))"
" c2_0)"
"(if(srcloc? v_1)"
"(let-values()"
"(loop_0"
"(srcloc-source v_1)))"
"(if(correlated?$1 v_1)"
"(let-values()"
"(begin"
"(loop_0"
"(correlated-e$1 v_1))"
"(loop_0"
"(correlated-source$1"
" v_1))"
"(let-values()"
"(let-values(((lst_0)"
"(correlated-property-symbol-keys$1"
" v_1)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(loop_0"
" k_0)"
"(loop_0"
"(correlated-property$1"
" v_1"
" k_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))"
"(let-values(((c1_0)"
"(if(struct-type?"
" v_1)"
"(prefab-struct-type-key+field-count"
" v_1)"
" #f)))"
"(if c1_0"
"((lambda(k+c_0)"
"(begin"
"(loop_0"
"(car k+c_0))"
"(loop_0"
"(cdr k+c_0))))"
" c1_0)"
"(let-values()"
"(void)))))))))))))))))))"
" loop_0)"
" v_0)"
"(values))))"
"(let-values(((treat-immutable?_0)"
"(lambda(v_1)"
"(begin"
" 'treat-immutable?"
"(let-values(((or-part_0)(not keep-mutable?_0)))"
"(if or-part_0 or-part_0(immutable? v_1)))))))"
"(let-values(((path->relative-path-elements_0)"
"(let-values()"
"(make-path->relative-path-elements.1 #f unsafe-undefined))))"
"(let-values((()"
"(begin"
"(if skip-prefix?_0"
"(void)"
"(let-values()(1/write-bytes fasl-prefix o_0)))"
"(values))))"
"(let-values(((bstr_0)"
"(let-values(((o_1)(open-output-bytes)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(v_1)"
"(begin"
" 'loop"
"(if(not"
"(eq?"
"(hash-ref shared_0 v_1 1)"
" 1))"
"(let-values()"
"(let-values(((c_0)"
"(hash-ref"
" shared_0"
" v_1)))"
"(if(negative? c_0)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-graph-ref-type"
" o_1)"
"(write-fasl-integer"
"(sub1(- c_0))"
" o_1)))"
"(let-values()"
"(let-values(((pos_0)"
" shared-counter_0))"
"(begin"
"(set! shared-counter_0"
"(add1"
" shared-counter_0))"
"(1/write-byte"
" fasl-graph-def-type"
" o_1)"
"(write-fasl-integer"
" pos_0"
" o_1)"
"(hash-remove!"
" shared_0"
" v_1)"
"(loop_0 v_1)"
"(hash-set!"
" shared_0"
" v_1"
"(-(add1 pos_0)))))))))"
"(if(not v_1)"
"(let-values()"
"(1/write-byte"
" fasl-false-type"
" o_1))"
"(if(eq? v_1 #t)"
"(let-values()"
"(1/write-byte"
" fasl-true-type"
" o_1))"
"(if(null? v_1)"
"(let-values()"
"(1/write-byte"
" fasl-null-type"
" o_1))"
"(if(void? v_1)"
"(let-values()"
"(1/write-byte"
" fasl-void-type"
" o_1))"
"(if(eof-object? v_1)"
"(let-values()"
"(1/write-byte"
" fasl-eof-type"
" o_1))"
"(if(exact-integer? v_1)"
"(let-values()"
"(if(<="
" fasl-lowest-small-integer"
" v_1"
" fasl-highest-small-integer)"
"(let-values()"
"(1/write-byte"
"(+"
" fasl-small-integer-start"
"(-"
" v_1"
" fasl-lowest-small-integer))"
" o_1))"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-integer-type"
" o_1)"
"(write-fasl-integer"
" v_1"
" o_1)))))"
"(if(flonum? v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-flonum-type"
" o_1)"
"(write-fasl-flonum"
" v_1"
" o_1)))"
"(if(single-flonum?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-single-flonum-type"
" o_1)"
"(1/write-bytes"
"(if(eqv?"
" v_1"
"(real->single-flonum"
" +nan.0))"
"                                                                                                           #\"\\0\\0\\300\\177\""
"(real->floating-point-bytes"
" v_1"
" 4"
" #f))"
" o_1)))"
"(if(extflonum? v_1)"
"(let-values()"
"(let-values((()"
"(begin"
"(1/write-byte"
" fasl-extflonum-type"
" o_1)"
"(values))))"
"(let-values(((bstr_0)"
"(string->bytes/utf-8"
"(format"
"                                                                                                                          \"~a\""
" v_1))))"
"(begin"
"(write-fasl-integer"
"(bytes-length"
" bstr_0)"
" o_1)"
"(1/write-bytes"
" bstr_0"
" o_1)))))"
"(if(rational?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-rational-type"
" o_1)"
"(loop_0"
"(numerator"
" v_1))"
"(loop_0"
"(denominator"
" v_1))))"
"(if(complex?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-complex-type"
" o_1)"
"(loop_0"
"(real-part"
" v_1))"
"(loop_0"
"(imag-part"
" v_1))))"
"(if(char?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-char-type"
" o_1)"
"(write-fasl-integer"
"(char->integer"
" v_1)"
" o_1)))"
"(if(symbol?"
" v_1)"
"(let-values()"
"(let-values((()"
"(begin"
"(if(symbol-interned?"
" v_1)"
"(let-values()"
"(1/write-byte"
" fasl-symbol-type"
" o_1))"
"(if(symbol-unreadable?"
" v_1)"
"(let-values()"
"(1/write-byte"
" fasl-unreadable-symbol-type"
" o_1))"
"(let-values()"
"(1/write-byte"
" fasl-uninterned-symbol-type"
" o_1))))"
"(values))))"
"(let-values(((bstr_0)"
"(string->bytes/utf-8"
"(symbol->string"
" v_1))))"
"(begin"
"(write-fasl-integer"
"(bytes-length"
" bstr_0)"
" o_1)"
"(1/write-bytes"
" bstr_0"
" o_1)))))"
"(if(keyword?"
" v_1)"
"(let-values()"
"(let-values((()"
"(begin"
"(1/write-byte"
" fasl-keyword-type"
" o_1)"
"(values))))"
"(let-values(((bstr_0)"
"(string->bytes/utf-8"
"(keyword->string"
" v_1))))"
"(begin"
"(write-fasl-integer"
"(bytes-length"
" bstr_0)"
" o_1)"
"(1/write-bytes"
" bstr_0"
" o_1)))))"
"(if(string?"
" v_1)"
"(let-values()"
"(begin"
"(write-fasl-integer"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-string-type"
" fasl-string-type)"
" o_1)"
"(write-fasl-string"
" v_1"
" o_1)))"
"(if(bytes?"
" v_1)"
"(let-values()"
"(begin"
"(write-fasl-integer"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-bytes-type"
" fasl-bytes-type)"
" o_1)"
"(write-fasl-bytes"
" v_1"
" o_1)))"
"(if(path-for-some-system?"
" v_1)"
"(let-values()"
"(let-values(((rel-elems_0)"
"(path->relative-path-elements_0"
" v_1)))"
"(if rel-elems_0"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-relative-path-type"
" o_1)"
"(loop_0"
" rel-elems_0)))"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-path-type"
" o_1)"
"(write-fasl-bytes"
"(path->bytes"
" v_1)"
" o_1)"
"(loop_0"
"(path-convention-type"
" v_1)))))))"
"(if(if(srcloc?"
" v_1)"
"(let-values(((src_0)"
"(srcloc-source"
" v_1)))"
"(let-values(((or-part_0)"
"(not"
" src_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(path-for-some-system?"
" src_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(string?"
" src_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)"
"(bytes?"
" src_0)))"
"(if or-part_3"
" or-part_3"
"(symbol?"
" src_0))))))))))"
" #f)"
"(let-values()"
"(let-values(((src_0)"
"(srcloc-source"
" v_1)))"
"(let-values(((new-src_0)"
"(if(if(path?"
" src_0)"
"(not"
"(path->relative-path-elements_0"
" src_0))"
" #f)"
"(let-values()"
"(truncate-path"
" src_0))"
"(let-values()"
" src_0))))"
"(begin"
"(write-fasl-integer"
" fasl-srcloc-type"
" o_1)"
"(loop_0"
" new-src_0)"
"(loop_0"
"(srcloc-line"
" v_1))"
"(loop_0"
"(srcloc-column"
" v_1))"
"(loop_0"
"(srcloc-position"
" v_1))"
"(loop_0"
"(srcloc-span"
" v_1))))))"
"(if(pair?"
" v_1)"
"(let-values()"
"(if(pair?"
"(cdr"
" v_1))"
"(let-values()"
"(let-values(((n_0"
" normal-list?_0)"
"((letrec-values(((loop_1)"
"(lambda(v_2"
" len_0)"
"(begin"
" 'loop"
"(if(null?"
" v_2)"
"(let-values()"
"(values"
" len_0"
" #t))"
"(if(pair?"
" v_2)"
"(let-values()"
"(loop_1"
"(cdr"
" v_2)"
"(add1"
" len_0)))"
"(let-values()"
"(values"
" len_0"
" #f))))))))"
" loop_1)"
" v_1"
" 0)))"
"(begin"
"(1/write-byte"
"(if normal-list?_0"
" fasl-list-type"
" fasl-list*-type)"
" o_1)"
"(write-fasl-integer"
" n_0"
" o_1)"
"((letrec-values(((ploop_0)"
"(lambda(v_2)"
"(begin"
" 'ploop"
"(if(pair?"
" v_2)"
"(let-values()"
"(begin"
"(loop_0"
"(car"
" v_2))"
"(ploop_0"
"(cdr"
" v_2))))"
"(let-values()"
"(if normal-list?_0"
"(void)"
"(let-values()"
"(loop_0"
" v_2)))))))))"
" ploop_0)"
" v_1))))"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-pair-type"
" o_1)"
"(loop_0"
"(car"
" v_1))"
"(loop_0"
"(cdr"
" v_1))))))"
"(if(vector?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-vector-type"
" fasl-vector-type)"
" o_1)"
"(write-fasl-integer"
"(vector-length"
" v_1)"
" o_1)"
"(let-values()"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-vector"
" vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(flvector?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-flvector-type"
" o_1)"
"(write-fasl-integer"
"(flvector-length"
" v_1)"
" o_1)"
"(let-values()"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-flvector"
" vec_0)))"
"(values"
" vec_0"
"(unsafe-flvector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-flvector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(write-fasl-flonum"
" e_0"
" o_1))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(fxvector?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-fxvector-type"
" o_1)"
"(write-fasl-integer"
"(fxvector-length"
" v_1)"
" o_1)"
"(let-values()"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-fxvector"
" vec_0)))"
"(values"
" vec_0"
"(unsafe-fxvector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-fxvector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(write-fasl-integer"
" e_0"
" o_1))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(box?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-box-type"
" fasl-box-type)"
" o_1)"
"(loop_0"
"(unbox"
" v_1))))"
"(let-values(((c4_0)"
"(prefab-struct-key"
" v_1)))"
"(if c4_0"
"((lambda(k_0)"
"(let-values((()"
"(begin"
"(1/write-byte"
" fasl-prefab-type"
" o_1)"
"(values))))"
"(let-values((()"
"(begin"
"(loop_0"
" k_0)"
"(values))))"
"(let-values(((vec_0)"
"(struct->vector"
" v_1)))"
"(begin"
"(write-fasl-integer"
"(sub1"
"(vector-length"
" vec_0))"
" o_1)"
"(let-values()"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(unsafe-normalise-inputs"
" unsafe-vector-length"
" vec_0"
" 1"
" #f"
" 1)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                                                                    \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
" vec_0"
" 1"
" #f"
" 1))))"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void))))))"
" c4_0)"
"(if(hash?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-hash-type"
" fasl-hash-type)"
" o_1)"
"(1/write-byte"
"(if(hash-eq?"
" v_1)"
"(let-values()"
" fasl-hash-eq-variant)"
"(if(hash-eqv?"
" v_1)"
"(let-values()"
" fasl-hash-eqv-variant)"
"(if(hash-equal-always?"
" v_1)"
"(let-values()"
" fasl-hash-equal-always-variant)"
"(let-values()"
" fasl-hash-equal-variant))))"
" o_1)"
"(write-fasl-integer"
"(hash-count"
" v_1)"
" o_1)"
"(hash-for-each"
" v_1"
"(lambda(k_0"
" v_2)"
"(begin"
"(loop_0"
" k_0)"
"(loop_0"
" v_2)))"
" #t)))"
"(if(regexp?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(pregexp?"
" v_1)"
" fasl-pregexp-type"
" fasl-regexp-type)"
" o_1)"
"(write-fasl-string"
"(object-name"
" v_1)"
" o_1)))"
"(if(byte-regexp?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(byte-pregexp?"
" v_1)"
" fasl-byte-pregexp-type"
" fasl-byte-regexp-type)"
" o_1)"
"(write-fasl-bytes"
"(object-name"
" v_1)"
" o_1)))"
"(if(correlated?$1"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-correlated-type"
" o_1)"
"(loop_0"
"(correlated-e$1"
" v_1))"
"(loop_0"
"(srcloc"
"(correlated-source$1"
" v_1)"
"(correlated-line$1"
" v_1)"
"(correlated-column$1"
" v_1)"
"(correlated-position$1"
" v_1)"
"(correlated-span$1"
" v_1)))"
"(loop_0"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
"(correlated-property-symbol-keys$1"
" v_1)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" k_0"
"(correlated-property$1"
" v_1"
" k_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(if(eq?"
" v_1"
" unsafe-undefined)"
"(let-values()"
"(1/write-byte"
" fasl-undefined-type"
" o_1))"
"(let-values(((c3_0)"
"(if(struct-type?"
" v_1)"
"(prefab-struct-type-key+field-count"
" v_1)"
" #f)))"
"(if c3_0"
"((lambda(k+c_0)"
"(begin"
"(1/write-byte"
" fasl-prefab-type-type"
" o_1)"
"(loop_0"
"(car"
" k+c_0))"
"(loop_0"
"(cdr"
" k+c_0))))"
" c3_0)"
"(let-values()"
"(if handle-fail_0"
"(loop_0"
"(handle-fail_0"
" v_1))"
"(raise-arguments-error"
" 's-exp->fasl"
"                                                                                                                                                         \"cannot write value\""
"                                                                                                                                                         \"value\""
" v_1))))))))))))))))))))))))))))))))))))))))"
" loop_0)"
" v_0)"
"(get-output-bytes o_1 #t)))))"
"(begin"
"(write-fasl-integer shared-counter_0 o_0)"
"(write-fasl-integer(bytes-length bstr_0) o_0)"
"(1/write-bytes bstr_0 o_0)"
"(if orig-o_0(void)(get-output-bytes o_0)))))))))))))))))))))))))"
"(define-values"
"(fasl->s-exp.1)"
"(lambda(datum-intern?16_0 external-lifts17_0 skip-prefix?18_0 orig-i22_0)"
"(begin"
" 'fasl->s-exp"
"(let-values(((orig-i_0) orig-i22_0))"
"(let-values(((intern?_0) datum-intern?16_0))"
"(let-values(((external-lifts_0)(if(eq? external-lifts17_0 unsafe-undefined) '#() external-lifts17_0)))"
"(let-values(((skip-prefix?_0) skip-prefix?18_0))"
"(let-values()"
"(let-values(((init-i_0)"
"(if(bytes? orig-i_0)"
"(let-values()(mcons orig-i_0 0))"
"(if(input-port? orig-i_0)"
"(let-values() orig-i_0)"
"(let-values()"
"                                    (raise-argument-error 'fasl->s-exp \"(or/c bytes? input-port?)\" orig-i_0))))))"
"(let-values((()"
"(begin"
"(if skip-prefix?_0"
"(void)"
"(let-values()"
"(if(bytes=?(read-bytes/exactly* fasl-prefix-length init-i_0) fasl-prefix)"
"(void)"
"                                        (let-values () (read-error \"unrecognized prefix\")))))"
"(values))))"
"(let-values(((shared-count_0)(read-fasl-integer* init-i_0)))"
"(let-values(((shared_0)(make-vector shared-count_0)))"
"(let-values((()"
"(begin"
"(if(if(vector? external-lifts_0)"
"(<=(vector-length external-lifts_0) shared-count_0)"
" #f)"
"(void)"
"(let-values()"
"                                            (error 'fasl->s-exp \"external-lift vector does not match expected size\")))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values()"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0) external-lifts_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_0)))"
"(values vec_0(unsafe-vector-length vec_0)))))"
"((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0 pos_1)"
"(begin"
" 'for-loop"
"(if(if(unsafe-fx< pos_0 len_0) #t #f)"
"(let-values(((v_0)"
"(unsafe-vector-ref vec_0 pos_0))"
"((pos_2) pos_1))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(vector-set!"
" shared_0"
" pos_2"
"(vector-ref"
" external-lifts_0"
" pos_2)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-fx+ 1 pos_0)"
"(+ pos_1 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0"
" start_0))))"
"(values))))"
"(let-values()"
"(let-values(((len_0)(read-fasl-integer* init-i_0)))"
"(let-values(((i_0)"
"(if(mpair? init-i_0)"
" init-i_0"
"(let-values(((bstr_0)(read-bytes/exactly* len_0 init-i_0)))"
"(mcons bstr_0 0)))))"
"(let-values(((intern_0)"
"(lambda(v_0)"
"(begin 'intern(if intern?_0(datum-intern-literal v_0) v_0)))))"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((type_0)(read-byte/no-eof i_0)))"
"(let-values(((tmp_0) type_0))"
"(let-values(((index_0)"
"(if(fixnum? tmp_0)"
"(if(if(unsafe-fx>= tmp_0 1)"
"(unsafe-fx< tmp_0 45)"
" #f)"
"(let-values(((tbl_0)"
" '#(1"
" 2"
" 3"
" 4"
" 5"
" 6"
" 7"
" 8"
" 9"
" 10"
" 12"
" 13"
" 14"
" 15"
" 16"
" 17"
" 18"
" 19"
" 20"
" 21"
" 22"
" 23"
" 24"
" 25"
" 26"
" 27"
" 28"
" 29"
" 31"
" 30"
" 32"
" 32"
" 35"
" 36"
" 37"
" 38"
" 39"
" 40"
" 11"
" 41"
" 42"
" 43"
" 34"
" 33)))"
"(unsafe-vector*-ref"
" tbl_0"
"(unsafe-fx- tmp_0 1)))"
" 0)"
" 0)))"
"(if(unsafe-fx< index_0 21)"
"(if(unsafe-fx< index_0 10)"
"(if(unsafe-fx< index_0 4)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(if(>= type_0 fasl-small-integer-start)"
"(let-values()"
"(+"
"(- type_0 fasl-small-integer-start)"
" fasl-lowest-small-integer))"
"(let-values()"
"(read-error"
"                                                                               \"unrecognized fasl tag\""
"                                                                               \"tag\""
" type_0))))"
"(if(unsafe-fx< index_0 2)"
"(let-values()"
"(let-values(((pos_0)"
"(read-fasl-integer i_0)))"
"(let-values(((v_0)(loop_0)))"
"(begin"
"(if(< pos_0 shared-count_0)"
"(void)"
"(let-values()"
"                                                                                      (read-error \"bad graph index\")))"
"(vector-set! shared_0 pos_0 v_0)"
" v_0))))"
"(if(unsafe-fx< index_0 3)"
"(let-values()"
"(let-values(((pos_0)"
"(read-fasl-integer i_0)))"
"(begin"
"(if(< pos_0 shared-count_0)"
"(void)"
"(let-values()"
"                                                                                      (read-error \"bad graph index\")))"
"(vector-ref shared_0 pos_0))))"
"(let-values() #f))))"
"(if(unsafe-fx< index_0 6)"
"(if(unsafe-fx< index_0 5)"
"(let-values() #t)"
"(let-values() null))"
"(if(unsafe-fx< index_0 7)"
"(let-values()(void))"
"(if(unsafe-fx< index_0 8)"
"(let-values() eof)"
"(if(unsafe-fx< index_0 9)"
"(let-values()"
"(intern_0(read-fasl-integer i_0)))"
"(let-values()"
"(read-fasl-flonum i_0)))))))"
"(if(unsafe-fx< index_0 15)"
"(if(unsafe-fx< index_0 12)"
"(if(unsafe-fx< index_0 11)"
"(let-values()"
"(real->single-flonum"
"(floating-point-bytes->real"
"(read-bytes/exactly 4 i_0)"
" #f)))"
"(let-values()"
"(let-values(((bstr_0)"
"(read-bytes/exactly"
"(read-fasl-integer i_0)"
" i_0)))"
"(1/string->number"
"(bytes->string/utf-8 bstr_0)"
" 10"
" 'read))))"
"(if(unsafe-fx< index_0 13)"
"(let-values()"
"(intern_0(/(loop_0)(loop_0))))"
"(if(unsafe-fx< index_0 14)"
"(let-values()"
"(intern_0"
"(make-rectangular(loop_0)(loop_0))))"
"(let-values()"
"(intern_0"
"(integer->char"
"(read-fasl-integer i_0)))))))"
"(if(unsafe-fx< index_0 17)"
"(if(unsafe-fx< index_0 16)"
"(let-values()"
"(string->symbol(read-fasl-string i_0)))"
"(let-values()"
"(string->unreadable-symbol"
"(read-fasl-string i_0))))"
"(if(unsafe-fx< index_0 18)"
"(let-values()"
"(string->uninterned-symbol"
"(read-fasl-string i_0)))"
"(if(unsafe-fx< index_0 19)"
"(let-values()"
"(string->keyword(read-fasl-string i_0)))"
"(if(unsafe-fx< index_0 20)"
"(let-values()(read-fasl-string i_0))"
"(let-values()"
"(intern_0"
"(string->immutable-string"
"(read-fasl-string i_0))))))))))"
"(if(unsafe-fx< index_0 32)"
"(if(unsafe-fx< index_0 26)"
"(if(unsafe-fx< index_0 23)"
"(if(unsafe-fx< index_0 22)"
"(let-values()(read-fasl-bytes i_0))"
"(let-values()"
"(intern_0"
"(bytes->immutable-bytes"
"(read-fasl-bytes i_0)))))"
"(if(unsafe-fx< index_0 24)"
"(let-values()"
"(bytes->path"
"(read-fasl-bytes i_0)"
"(loop_0)))"
"(if(unsafe-fx< index_0 25)"
"(let-values()"
"(let-values(((wrt-dir_0)"
"(let-values(((or-part_0)"
"(current-load-relative-directory)))"
"(if or-part_0"
" or-part_0"
"(current-directory)))))"
"(let-values(((rel-elems_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
"(loop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(bytes?"
" p_0)"
"(bytes->path-element"
" p_0)"
" p_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(if wrt-dir_0"
"(let-values()"
"(apply"
" build-path"
" wrt-dir_0"
" rel-elems_0))"
"(if(null? rel-elems_0)"
"(let-values()(build-path 'same))"
"(let-values()"
"(apply"
" build-path"
" rel-elems_0)))))))"
"(let-values()"
"(intern_0"
"(pregexp(read-fasl-string i_0)))))))"
"(if(unsafe-fx< index_0 28)"
"(if(unsafe-fx< index_0 27)"
"(let-values()"
"(intern_0(regexp(read-fasl-string i_0))))"
"(let-values()"
"(intern_0"
"(byte-pregexp(read-fasl-bytes i_0)))))"
"(if(unsafe-fx< index_0 29)"
"(let-values()"
"(intern_0"
"(byte-regexp(read-fasl-bytes i_0))))"
"(if(unsafe-fx< index_0 30)"
"(let-values()"
"(let-values(((len_1)"
"(read-fasl-integer i_0)))"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((start_0) 0)"
"((end_0) len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(<"
" pos_0"
" end_0)"
"(let-values()"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
"(+"
" pos_0"
" inc_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" start_0)))))))"
"(if(unsafe-fx< index_0 31)"
"(let-values()(cons(loop_0)(loop_0)))"
"(let-values()"
"(let-values(((len_1)"
"(read-fasl-integer i_0)))"
"((letrec-values(((ploop_0)"
"(lambda(len_2)"
"(begin"
" 'ploop"
"(if(zero?"
" len_2)"
"(loop_0)"
"(cons"
"(loop_0)"
"(ploop_0"
"(sub1"
" len_2))))))))"
" ploop_0)"
" len_1))))))))"
"(if(unsafe-fx< index_0 37)"
"(if(unsafe-fx< index_0 34)"
"(if(unsafe-fx< index_0 33)"
"(let-values()"
"(let-values(((len_1)"
"(read-fasl-integer i_0)))"
"(let-values(((vec_0)"
"(let-values(((len_2)"
" len_1))"
"(begin"
"(if(exact-nonnegative-integer?"
" len_2)"
"(void)"
"(let-values()"
"(1/raise-argument-error"
" 'for/vector"
"                                                                                                     \"exact-nonnegative-integer?\""
" len_2)))"
"(let-values(((v_0)"
"(make-vector"
" len_2"
" 0)))"
"(begin"
"(if(zero? len_2)"
"(void)"
"(let-values()"
"(let-values(((i_1)"
"(let-values(((i_1)"
" 0))"
" i_1)))"
"(let-values(((start_0)"
" 0)"
"((end_0)"
" len_1)"
"((inc_0)"
" 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_2"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((j_0)"
" pos_0))"
"(let-values(((i_3)"
"(let-values(((i_3)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_2"
"(let-values()"
"(loop_0)))"
"(unsafe-fx+"
" 1"
" i_2)))))"
"(values"
" i_3))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_3"
" len_2))"
" j_0))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" i_3"
"(+"
" pos_0"
" inc_0))"
" i_3)))"
" i_2))))))"
" for-loop_0)"
" i_1"
" start_0))))))"
" v_0))))))"
"(if(eqv?"
" type_0"
" fasl-immutable-vector-type)"
"(vector->immutable-vector vec_0)"
" vec_0))))"
"(let-values()"
"(let-values(((len_1)"
"(read-fasl-integer i_0)))"
"(let-values(((len_2) len_1))"
"(begin"
"(if(exact-nonnegative-integer? len_2)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/flvector"
"                                                                                       \"exact-nonnegative-integer?\""
" len_2)))"
"(let-values(((fill_0) 0.0))"
"(let-values(((v_0)"
"(make-flvector"
" len_2"
" fill_0)))"
"(begin"
"(if(zero? len_2)"
"(void)"
"(let-values()"
"(let-values(((i_1)"
"(let-values(((i_1)"
" 0))"
" i_1)))"
"(let-values(((start_0) 0)"
"((end_0)"
" len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_2"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((j_0)"
" pos_0))"
"(let-values(((i_3)"
"(let-values(((i_3)"
"(let-values()"
"(begin"
"(let-values(((elem_0)"
"(let-values()"
"(read-fasl-flonum"
" i_0))))"
"(if(flonum?"
" elem_0)"
"(unsafe-flvector-set!"
" v_0"
" i_2"
" elem_0)"
"(not-an-fX.1$1"
" 'for*/vector"
" elem_0)))"
"(unsafe-fx+"
" 1"
" i_2)))))"
"(values"
" i_3))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_3"
" len_2))"
" j_0))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" i_3"
"(+"
" pos_0"
" inc_0))"
" i_3)))"
" i_2))))))"
" for-loop_0)"
" i_1"
" start_0))))))"
" v_0))))))))"
"(if(unsafe-fx< index_0 35)"
"(let-values()"
"(let-values(((len_1)"
"(read-fasl-integer i_0)))"
"(let-values(((len_2) len_1))"
"(begin"
"(if(exact-nonnegative-integer? len_2)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/fxvector"
"                                                                                       \"exact-nonnegative-integer?\""
" len_2)))"
"(let-values(((fill_0) 0))"
"(let-values(((v_0)"
"(make-fxvector"
" len_2"
" fill_0)))"
"(begin"
"(if(zero? len_2)"
"(void)"
"(let-values()"
"(let-values(((i_1)"
"(let-values(((i_1)"
" 0))"
" i_1)))"
"(let-values(((start_0) 0)"
"((end_0)"
" len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_2"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((j_0)"
" pos_0))"
"(let-values(((i_3)"
"(let-values(((i_3)"
"(let-values()"
"(begin"
"(let-values(((elem_0)"
"(let-values()"
"(read-fasl-integer"
" i_0))))"
"(if(fixnum?"
" elem_0)"
"(unsafe-fxvector-set!"
" v_0"
" i_2"
" elem_0)"
"(not-an-fX.1"
" 'for*/vector"
" elem_0)))"
"(unsafe-fx+"
" 1"
" i_2)))))"
"(values"
" i_3))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_3"
" len_2))"
" j_0))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" i_3"
"(+"
" pos_0"
" inc_0))"
" i_3)))"
" i_2))))))"
" for-loop_0)"
" i_1"
" start_0))))))"
" v_0)))))))"
"(if(unsafe-fx< index_0 36)"
"(let-values()(box(loop_0)))"
"(let-values()(box-immutable(loop_0))))))"
"(if(unsafe-fx< index_0 40)"
"(if(unsafe-fx< index_0 38)"
"(let-values()"
"(let-values(((key_0)(loop_0)))"
"(let-values(((len_1)"
"(read-fasl-integer i_0)))"
"(apply"
" make-prefab-struct"
" key_0"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((start_0) 0)"
"((end_0) len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(<"
" pos_0"
" end_0)"
"(let-values()"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
"(+"
" pos_0"
" inc_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" start_0)))))))))"
"(if(unsafe-fx< index_0 39)"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((tmp_1)"
"(read-byte/no-eof"
" i_0)))"
"(if(equal? tmp_1 0)"
"(let-values()"
"(make-hasheq))"
"(if(equal? tmp_1 2)"
"(let-values()"
"(make-hasheqv))"
"(if(equal? tmp_1 3)"
"(let-values()"
"(make-hashalw))"
"(let-values()"
"(make-hash))))))))"
"(let-values(((len_1)"
"(read-fasl-integer i_0)))"
"(begin"
"(let-values()"
"(let-values(((start_0) 0)"
"((end_0) len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(<"
" pos_0"
" end_0)"
"(let-values()"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(hash-set!"
" ht_0"
"(loop_0)"
"(loop_0)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0))))"
"(void)"
" ht_0))))"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((tmp_1)"
"(read-byte/no-eof"
" i_0)))"
"(if(equal? tmp_1 0)"
"(let-values()"
" '#hasheq())"
"(if(equal? tmp_1 2)"
"(let-values()"
" '#hasheqv())"
"(if(equal? tmp_1 3)"
"(let-values()"
"(hashalw))"
"(let-values()"
" '#hash())))))))"
"(let-values(((len_1)"
"(read-fasl-integer i_0)))"
"(let-values(((ht_1)"
"(let-values(((ht_1)"
" ht_0))"
" ht_1)))"
"(let-values(((start_0) 0)"
"((end_0) len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_2"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(<"
" pos_0"
" end_0)"
"(let-values()"
"(let-values(((ht_3)"
"(let-values(((ht_3)"
"(let-values()"
"(hash-set"
" ht_2"
"(loop_0)"
"(loop_0)))))"
"(values"
" ht_3))))"
"(if(not"
" #f)"
"(for-loop_0"
" ht_3"
"(+"
" pos_0"
" inc_0))"
" ht_3)))"
" ht_2))))))"
" for-loop_0)"
" ht_1"
" start_0)))))))))"
"(if(unsafe-fx< index_0 41)"
"(let-values()"
"(srcloc"
"(loop_0)"
"(loop_0)"
"(loop_0)"
"(loop_0)"
"(loop_0)))"
"(if(unsafe-fx< index_0 42)"
"(let-values()"
"(let-values(((e_0)(loop_0)))"
"(let-values(((s_0)(loop_0)))"
"(let-values(((c_0)"
"(datum->correlated$1"
" e_0"
"(vector"
"(srcloc-source s_0)"
"(srcloc-line s_0)"
"(srcloc-column s_0)"
"(srcloc-position s_0)"
"(srcloc-span s_0)))))"
"(let-values(((c_1)"
"(let-values(((c_1)"
" c_0))"
" c_1)))"
"(let-values(((lst_0)(loop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(c_2"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((c_3)"
"(let-values(((c_3)"
"(let-values()"
"(correlated-property$1"
" c_2"
"(car"
" p_0)"
"(cdr"
" p_0)))))"
"(values"
" c_3))))"
"(if(not"
" #f)"
"(for-loop_0"
" c_3"
" rest_0)"
" c_3)))"
" c_2))))))"
" for-loop_0)"
" c_1"
" lst_0))))))))"
"(if(unsafe-fx< index_0 43)"
"(let-values() unsafe-undefined)"
"(let-values()"
"(prefab-key->struct-type"
"(loop_0)"
"(loop_0)))))))))))))))))"
" loop_0))))))))))))))))))))"
"(define-values"
"(write-fasl-integer)"
"(lambda(i_0 o_0)"
"(begin"
"(if(<= -124 i_0 127)"
"(let-values()(if(negative? i_0)(1/write-byte(+ i_0 256) o_0)(1/write-byte i_0 o_0)))"
"(if(<= -32768 i_0 32767)"
"(let-values()(begin(1/write-byte 128 o_0)(1/write-bytes(integer->integer-bytes i_0 2 #t #f) o_0)))"
"(if(<= -2147483648 i_0 2147483647)"
"(let-values()(begin(1/write-byte 129 o_0)(1/write-bytes(integer->integer-bytes i_0 4 #t #f) o_0)))"
"(if(<= -9223372036854775808 i_0 9223372036854775807)"
"(let-values()(begin(1/write-byte 130 o_0)(1/write-bytes(integer->integer-bytes i_0 8 #t #f) o_0)))"
"(let-values()"
"(let-values((()(begin(1/write-byte 131 o_0)(values))))"
"                  (let-values (((s_0) (format \"~x\" i_0)))"
"(begin(write-fasl-integer(string-length s_0) o_0)(write-string s_0 o_0))))))))))))"
"(define-values"
"(write-fasl-string)"
"(lambda(v_0 o_0)"
"(begin"
"(let-values(((bstr_0)(string->bytes/utf-8 v_0)))"
"(begin(write-fasl-integer(bytes-length bstr_0) o_0)(1/write-bytes bstr_0 o_0))))))"
"(define-values"
"(write-fasl-bytes)"
"(lambda(v_0 o_0)(begin(begin(write-fasl-integer(bytes-length v_0) o_0)(1/write-bytes v_0 o_0)))))"
"(define-values"
"(write-fasl-flonum)"
"(lambda(v_0 o_0)"
"    (begin (1/write-bytes (if (eqv? v_0 +nan.0) #\"\\0\\0\\0\\0\\0\\0\\370\\177\" (real->floating-point-bytes v_0 8 #f)) o_0))))"
"(define-values"
"(read-error)"
"(lambda(s_0 . args_0)"
"    (begin (apply raise-arguments-error 'fasl-read (string-append \"error parsing fasl stream;\\n\" \" \" s_0) args_0))))"
"(define-values"
"(read-byte/no-eof)"
"(lambda(i_0)"
"(begin"
"(let-values(((pos_0)(mcdr i_0)))"
"(begin"
"          (if (fx< pos_0 (bytes-length (mcar i_0))) (void) (let-values () (read-error \"truncated stream\")))"
"(set-mcdr! i_0(fx+ pos_0 1))"
"(bytes-ref(mcar i_0) pos_0))))))"
"(define-values"
"(read-byte/no-eof*)"
"(lambda(i_0)"
"(begin"
"(if(mpair? i_0)"
"(let-values()(read-byte/no-eof i_0))"
"(let-values()"
"(let-values(((b_0)(read-byte i_0)))"
"            (begin (if (eof-object? b_0) (let-values () (read-error \"truncated stream\")) (void)) b_0)))))))"
"(define-values"
"(read-bytes/exactly)"
"(lambda(n_0 i_0)"
"(begin"
"(let-values(((pos_0)(mcdr i_0)))"
"(begin"
"          (if (<= (+ pos_0 n_0) (bytes-length (mcar i_0))) (void) (let-values () (read-error \"truncated stream\")))"
"(set-mcdr! i_0(fx+ pos_0 n_0))"
"(subbytes(mcar i_0) pos_0(fx+ pos_0 n_0)))))))"
"(define-values"
"(read-bytes/exactly*)"
"(lambda(n_0 i_0)"
"(begin"
"(if(mpair? i_0)"
"(let-values()(read-bytes/exactly n_0 i_0))"
"(let-values()"
"(let-values(((bstr_0)(read-bytes n_0 i_0)))"
"(begin"
"(if(if(bytes? bstr_0)(= n_0(bytes-length bstr_0)) #f)"
"(void)"
"                (let-values () (read-error \"truncated stream\")))"
" bstr_0)))))))"
"(define-values"
"(read-fasl-integer read-fasl-integer*)"
"(let-values()"
"(let-values()"
"(values"
"(lambda(i_0)"
"(let-values(((b_0)(read-byte/no-eof i_0)))"
"(if(fx<= b_0 127)"
"(let-values() b_0)"
"(if(fx>= b_0 132)"
"(let-values()(fx- b_0 256))"
"(if(eqv? b_0 128)"
"(let-values()"
"(let-values(((lo_0)(read-byte/no-eof i_0)))"
"(let-values(((hi_0)(read-byte/no-eof i_0)))"
"(if(fx> hi_0 127)(fxior(fxlshift(fx+ -256 hi_0) 8) lo_0)(fxior(fxlshift hi_0 8) lo_0)))))"
"(if(eqv? b_0 129)"
"(let-values()"
"(let-values(((a_0)(read-byte/no-eof i_0)))"
"(let-values(((b_1)(read-byte/no-eof i_0)))"
"(let-values(((c_0)(read-byte/no-eof i_0)))"
"(let-values(((d_0)(read-byte/no-eof i_0)))"
"(bitwise-ior"
" a_0"
"(arithmetic-shift"
"(if(fx> d_0 127)"
"(fxior(fxlshift(fx+ -256 d_0) 16)(fxlshift c_0 8) b_1)"
"(fxior(fxlshift d_0 16)(fxlshift c_0 8) b_1))"
" 8)))))))"
"(if(eqv? b_0 130)"
"(let-values()(integer-bytes->integer(read-bytes/exactly 8 i_0) #t #f))"
"(if(eqv? b_0 131)"
"(let-values()"
"(let-values(((len_0)(read-fasl-integer i_0)))"
"(let-values(((str_0)(read-fasl-string i_0 len_0)))"
"(begin"
"(if(if(string? str_0)(= len_0(string-length str_0)) #f)"
"(void)"
"                                 (let-values () (read-error \"truncated stream at number\")))"
"(1/string->number str_0 16)))))"
"                       (let-values () (read-error \"internal error on integer mode\"))))))))))"
"(lambda(i_0)"
"(let-values(((b_0)(read-byte/no-eof* i_0)))"
"(if(fx<= b_0 127)"
"(let-values() b_0)"
"(if(fx>= b_0 132)"
"(let-values()(fx- b_0 256))"
"(if(eqv? b_0 128)"
"(let-values()"
"(let-values(((lo_0)(read-byte/no-eof* i_0)))"
"(let-values(((hi_0)(read-byte/no-eof* i_0)))"
"(if(fx> hi_0 127)(fxior(fxlshift(fx+ -256 hi_0) 8) lo_0)(fxior(fxlshift hi_0 8) lo_0)))))"
"(if(eqv? b_0 129)"
"(let-values()"
"(let-values(((a_0)(read-byte/no-eof* i_0)))"
"(let-values(((b_1)(read-byte/no-eof* i_0)))"
"(let-values(((c_0)(read-byte/no-eof* i_0)))"
"(let-values(((d_0)(read-byte/no-eof* i_0)))"
"(bitwise-ior"
" a_0"
"(arithmetic-shift"
"(if(fx> d_0 127)"
"(fxior(fxlshift(fx+ -256 d_0) 16)(fxlshift c_0 8) b_1)"
"(fxior(fxlshift d_0 16)(fxlshift c_0 8) b_1))"
" 8)))))))"
"(if(eqv? b_0 130)"
"(let-values()(integer-bytes->integer(read-bytes/exactly* 8 i_0) #t #f))"
"(if(eqv? b_0 131)"
"(let-values()"
"(let-values(((len_0)(read-fasl-integer i_0)))"
"(let-values(((str_0)(read-fasl-string i_0 len_0)))"
"(begin"
"(if(if(string? str_0)(= len_0(string-length str_0)) #f)"
"(void)"
"                                 (let-values () (read-error \"truncated stream at number\")))"
"(1/string->number str_0 16)))))"
"                       (let-values () (read-error \"internal error on integer mode\"))))))))))))))"
"(define-values"
"(read-fasl-string)"
"(let-values(((read-fasl-string_0)"
"(lambda(i25_0 len24_0)"
"(begin"
" 'read-fasl-string"
"(let-values(((i_0) i25_0))"
"(let-values(((len_0)(if(eq? len24_0 unsafe-undefined)(read-fasl-integer i_0) len24_0)))"
"(let-values()"
"(let-values(((pos_0)(mcdr i_0)))"
"(let-values(((bstr_0)(mcar i_0)))"
"(if(<=(+ pos_0 len_0)(bytes-length bstr_0))"
"(let-values()"
"(let-values((()(begin(set-mcdr! i_0(fx+ pos_0 len_0))(values))))"
"(let-values(((s_0)(make-string len_0)))"
"((letrec-values(((loop_0)"
"(lambda(i_1)"
"(begin"
" 'loop"
"(if(fx= i_1 len_0)"
"(let-values() s_0)"
"(let-values()"
"(let-values(((c_0)(bytes-ref bstr_0(fx+ i_1 pos_0))))"
"(if(fx<= c_0 128)"
"(let-values()"
"(begin"
"(string-set! s_0 i_1(integer->char c_0))"
"(loop_0(fx+ i_1 1))))"
"(let-values()"
"(bytes->string/utf-8"
" bstr_0"
" #f"
" pos_0"
"(fx+ pos_0 len_0)))))))))))"
" loop_0)"
" 0))))"
"(let-values()"
"(let-values(((bstr_1)(read-bytes/exactly len_0 i_0)))"
"(bytes->string/utf-8 bstr_1)))))))))))))"
"(case-lambda"
"((i_0)(begin(read-fasl-string_0 i_0 unsafe-undefined)))"
"((i_0 len24_0)(read-fasl-string_0 i_0 len24_0)))))"
"(define-values"
"(read-fasl-bytes)"
"(lambda(i_0)(begin(let-values(((len_0)(read-fasl-integer i_0)))(read-bytes/exactly len_0 i_0)))))"
"(define-values(read-fasl-flonum)(lambda(i_0)(begin(floating-point-bytes->real(read-bytes/exactly 8 i_0) #f))))"
"(define-values"
"(struct:mpi-intern-table mpi-intern-table1.1 mpi-intern-table? mpi-intern-table-normal mpi-intern-table-fast)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'mpi-intern-table"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'mpi-intern-table)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'normal)"
"(make-struct-field-accessor -ref_0 1 'fast))))"
"(define-values"
"(make-module-path-index-intern-table)"
"(lambda()(begin(mpi-intern-table1.1(make-hash)(make-hasheq)))))"
"(define-values"
"(intern-module-path-index!)"
"(lambda(t_0 mpi_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(mpi-intern-table-fast t_0) mpi_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((name_0 base_0)(1/module-path-index-split mpi_0)))"
"(if(not name_0)"
"(let-values()(begin(hash-set!(mpi-intern-table-fast t_0) mpi_0 mpi_0) mpi_0))"
"(let-values()"
"(let-values(((interned-base_0)(if base_0(intern-module-path-index! t_0 base_0) #f)))"
"(let-values(((at-name_0)"
"(let-values(((or-part_1)(hash-ref(mpi-intern-table-normal t_0) name_0 #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((at-name_0)(make-hasheq)))"
"(begin(hash-set!(mpi-intern-table-normal t_0) name_0 at-name_0) at-name_0))))))"
"(let-values(((i-mpi_0)"
"(let-values(((or-part_1)(hash-ref at-name_0 interned-base_0 #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((mpi_1)"
"(if(eq? base_0 interned-base_0)"
" mpi_0"
"(let-values(((the-struct_0) mpi_0))"
"(if(1/module-path-index? the-struct_0)"
"(let-values(((base3_0) interned-base_0))"
"(module-path-index2.1"
"(module-path-index-path the-struct_0)"
" base3_0"
"(module-path-index-resolved the-struct_0)"
"(module-path-index-shift-cache the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                           \"module-path-index?\""
" the-struct_0))))))"
"(begin(hash-set! at-name_0 interned-base_0 mpi_1) mpi_1))))))"
"(begin(hash-set!(mpi-intern-table-fast t_0) mpi_0 i-mpi_0) i-mpi_0))))))))))))"
"(define-values(built-in-symbols)(make-hasheq))"
"(define-values(register-built-in-symbol!)(lambda(s_0)(begin(hash-set! built-in-symbols s_0 #t))))"
"(define-values(built-in-symbol?)(lambda(s_0)(begin(hash-ref built-in-symbols s_0 #f))))"
"(define-values"
"(make-built-in-symbol!)"
"(lambda(s_0)"
"(begin"
"      (let-values (((built-in-s_0) (string->symbol (format \".~s\" s_0))))"
"(begin(register-built-in-symbol! built-in-s_0) built-in-s_0)))))"
"(void"
"(begin"
"(for-each2"
" register-built-in-symbol!"
" '(lambda case-lambda"
" if"
" begin"
" begin0"
" let-values"
" letrec-values"
" set!"
" quote"
" with-continuation-mark"
" #%variable-reference))"
"(for-each2"
" register-built-in-symbol!"
" '(check-not-undefined"
" instance-variable-box"
" variable-reference"
" variable-reference?"
" variable-reference->instance"
" variable-reference-constant?"
" variable-reference-from-unsafe?))"
"(for-each2"
" register-built-in-symbol!"
" '(or and"
" let"
" letrec*"
" define"
" $value"
" with-continuation-mark*"
" pariah"
" begin-unsafe"
" variable-set!"
" variable-ref"
" variable-ref/no-check"
" variable-set!/check-undefined"
" variable-set!/define"
" make-instance-variable-reference"
" instance-variable-reference"
" unbox/check-undefined"
" set-box!/check-undefined"
" annotation?"
" annotation-expression"
" #%app"
" #%call-with-values"
" #%app/no-return"
" #%app/value"
" apply-string-append"
" apply-string-append-immutable"
" apply-bytes-append"
" call-with-module-prompt"
" make-pthread-parameter"
" engine-block"
" make-record-type-descriptor"
" make-record-type-descriptor*"
" make-record-constructor-descriptor"
" record-constructor"
" record-accessor"
" record-mutator"
" record-predicate"
" make-struct-type-install-properties"
" #%struct-constructor"
" #%struct-predicate"
" #%struct-field-accessor"
" #%struct-field-mutator"
" #%nongenerative-uid"
" #%struct-ref-error"
" #%struct-set!-error"
" unsafe-struct?"
" unsafe-sealed-struct?"
" unsafe-struct"
" raise-binding-result-arity-error"
" raise-definition-result-arity-error"
" structure-type-lookup-prefab-uid"
" struct-type-constructor-add-guards"
" impersonator-val"
" impersonator-ref"
" impersonate-set!"
" ptr-ref/int8"
" ptr-set!/int8"
" ptr-ref/uint8"
" ptr-set!/uint8"
" ptr-ref/int16"
" ptr-set!/int16"
" ptr-ref/uint16"
" ptr-set!/uint16"
" ptr-ref/int32"
" ptr-set!/int32"
" ptr-ref/uint32"
" ptr-set!/uint32"
" ptr-ref/int64"
" ptr-set!/int64"
" ptr-ref/uint64"
" ptr-set!/uint64"
" ptr-ref/double"
" ptr-set!/double"
" ptr-ref/float"
" ptr-set!/float"
" ffi-static-call-and-callback-core))))"
"(define-values(phase-shift-id)(make-built-in-symbol! 'phase))"
"(define-values(dest-phase-id)(make-built-in-symbol! 'dest-phase))"
"(define-values(ns-id)(make-built-in-symbol! 'namespace))"
"(define-values(self-id)(make-built-in-symbol! 'self))"
"(define-values(syntax-literals-id)(make-built-in-symbol! 'syntax-literals))"
"(define-values(get-syntax-literal!-id)(make-built-in-symbol! 'get-syntax-literal!))"
"(define-values(bulk-binding-registry-id)(make-built-in-symbol! 'bulk-binding-registry))"
"(define-values(inspector-id)(make-built-in-symbol! 'inspector))"
"(define-values(deserialize-syntax-id)(make-built-in-symbol! 'deserialize-syntax))"
"(define-values(deserialized-syntax-vector-id)(make-built-in-symbol! 'deserialized-syntax-vector))"
"(define-values(set-transformer!-id)(make-built-in-symbol! 'set-transformer!))"
"(define-values(top-level-bind!-id)(make-built-in-symbol! 'top-level-bind!))"
"(define-values(top-level-require!-id)(make-built-in-symbol! 'top-level-require!))"
"(define-values(mpi-vector-id)(make-built-in-symbol! 'mpi-vector))"
"(define-values"
"(struct:module-path-index-table"
" module-path-index-table1.1"
" module-path-index-table?"
" module-path-index-table-positions"
" module-path-index-table-intern)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-path-index-table"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'module-path-index-table)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'positions)"
"(make-struct-field-accessor -ref_0 1 'intern))))"
"(define-values"
"(make-module-path-index-table)"
"(lambda()(begin(module-path-index-table1.1(make-hasheq)(make-module-path-index-intern-table)))))"
"(define-values"
"(add-module-path-index!)"
"(lambda(mpis_0 mpi_0)"
"(begin"
"(let-values(((pos_0)(add-module-path-index!/pos mpis_0 mpi_0)))"
"(if pos_0(list 'unsafe-vector*-ref mpi-vector-id pos_0) #f)))))"
"(define-values"
"(add-module-path-index!/pos)"
"(lambda(mpis_0 mpi_0)"
"(begin"
"(if(not mpi_0)"
"(let-values() #f)"
"(if mpi_0"
"(let-values()"
"(let-values(((mpi_1)(intern-module-path-index!(module-path-index-table-intern mpis_0) mpi_0))"
"((positions_0)(module-path-index-table-positions mpis_0)))"
"(let-values(((or-part_0)(hash-ref positions_0 mpi_1 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((pos_0)(hash-count positions_0)))"
"(begin(hash-set! positions_0 mpi_1 pos_0) pos_0))))))"
"(void))))))"
"(define-values"
"(module-path-index-table-mpis)"
"(lambda(mpis_0)"
"(begin"
"(let-values(((pos->mpi_0)"
"(let-values(((table_0)(let-values(((table_0) '#hasheqv())) table_0)))"
"(let-values(((ht_0)(module-path-index-table-positions mpis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((mpi_0 pos_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" pos_0"
" mpi_0))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values(((vec_0 i_0)"
"(let-values(((vec_0)(let-values(((vec_0)(make-vector 16))) vec_0))"
"((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((start_0) 0)((end_0)(hash-count pos->mpi_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(vec_1 i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values(((i_2) pos_0))"
"(let-values(((vec_2 i_3)"
"(let-values(((vec_2 i_3)"
"(let-values()"
"(let-values(((new-vec_0)"
"(if(eq?"
" i_1"
"(unsafe-vector*-length"
" vec_1))"
"(grow-vector"
" vec_1)"
" vec_1)))"
"(begin"
"(unsafe-vector*-set!"
" new-vec_0"
" i_1"
"(let-values()"
"(hash-ref pos->mpi_0 i_2)))"
"(values"
" new-vec_0"
"(unsafe-fx+ i_1 1)))))))"
"(values vec_2 i_3))))"
"(if(not #f)"
"(for-loop_0 vec_2 i_3(+ pos_0 inc_0))"
"(values vec_2 i_3))))"
"(values vec_1 i_1)))))))"
" for-loop_0)"
" vec_0"
" i_0"
" start_0))))))"
"(shrink-vector vec_0 i_0))))))"
"(define-values"
"(generate-module-path-index-deserialize.1)"
"(lambda(as-data?2_0 mpis4_0)"
"(begin"
" 'generate-module-path-index-deserialize"
"(let-values(((mpis_0) mpis4_0))"
"(let-values(((as-data?_0) as-data?2_0))"
"(let-values()"
"(let-values(((unique-list_0)"
"(lambda(v_0)"
"(begin"
" 'unique-list"
"(if(pair? v_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values() i_0)"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" v_0)))))"
"(let-values(((positions_0)(module-path-index-table-positions mpis_0)))"
"(let-values(((gen-order_0)(make-hasheqv)))"
"(let-values(((rev-positions_0)"
"(let-values(((table_0)(let-values(((table_0) '#hasheqv())) table_0)))"
"(let-values(((ht_0) positions_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" v_0"
" k_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values((()"
"(begin"
"(let-values()"
"(let-values(((start_0) 0)((end_0)(hash-count rev-positions_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_0) pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((mpi_0)"
"(hash-ref"
" rev-positions_0"
" i_0)))"
"((letrec-values(((loop_0)"
"(lambda(mpi_1)"
"(begin"
" 'loop"
"(if(hash-ref"
" gen-order_0"
" mpi_1"
" #f)"
"(void)"
"(let-values()"
"(let-values(((name_0"
" base_0)"
"(1/module-path-index-split"
" mpi_1)))"
"(begin"
"(if base_0"
"(let-values()"
"(loop_0"
" base_0))"
"(void))"
"(hash-set!"
" gen-order_0"
" mpi_1"
"(hash-count"
" gen-order_0))))))))))"
" loop_0)"
" mpi_0)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(+ pos_0 inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0))))"
"(values))))"
"(let-values()"
"(let-values(((rev-gen-order_0)"
"(let-values(((table_0)(let-values(((table_0) '#hasheqv())) table_0)))"
"(let-values(((ht_0) gen-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" v_0"
" k_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values(((gens_0)"
"(let-values(((len_0)(hash-count gen-order_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(1/raise-argument-error"
" 'for/vector"
"                                                 \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((start_0) 0)"
"((end_0)(hash-count gen-order_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values(((i_2) pos_0))"
"(let-values(((i_3)"
"(let-values(((i_3)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(let-values(((mpi_0)"
"(hash-ref"
" rev-gen-order_0"
" i_2)))"
"(let-values(((path_0"
" base_0)"
"(1/module-path-index-split"
" mpi_0)))"
"(if(top-level-module-path-index?"
" mpi_0)"
"(let-values()"
" 'top)"
"(if(not"
" path_0)"
"(let-values()"
"(box"
"(let-values(((or-part_0)"
"(unique-list_0"
"(1/resolved-module-path-name"
"(module-path-index-resolved"
" mpi_0)))))"
"(if or-part_0"
" or-part_0"
" 'self))))"
"(if(not"
" base_0)"
"(let-values()"
"(vector"
" path_0))"
"(if base_0"
"(let-values()"
"(vector"
" path_0"
"(hash-ref"
" gen-order_0"
" base_0)))"
"(void)))))))))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values i_3))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_3"
" len_0))"
" i_2))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_3"
"(+ pos_0 inc_0))"
" i_3)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" start_0))))))"
" v_0))))))"
"(let-values(((reorder-vec_0)"
"(let-values(((vec_0 i_0)"
"(let-values(((vec_0)"
"(let-values(((vec_0)(make-vector 16))) vec_0))"
"((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((start_0) 0)"
"((end_0)(hash-count rev-positions_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(vec_1 i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values(((i_2) pos_0))"
"(let-values(((vec_2 i_3)"
"(let-values(((vec_2"
" i_3)"
"(let-values()"
"(let-values(((new-vec_0)"
"(if(eq?"
" i_1"
"(unsafe-vector*-length"
" vec_1))"
"(grow-vector"
" vec_1)"
" vec_1)))"
"(begin"
"(unsafe-vector*-set!"
" new-vec_0"
" i_1"
"(let-values()"
"(hash-ref"
" gen-order_0"
"(hash-ref"
" rev-positions_0"
" i_2))))"
"(values"
" new-vec_0"
"(unsafe-fx+"
" i_1"
" 1)))))))"
"(values"
" vec_2"
" i_3))))"
"(if(not #f)"
"(for-loop_0"
" vec_2"
" i_3"
"(+ pos_0 inc_0))"
"(values vec_2 i_3))))"
"(values vec_1 i_1)))))))"
" for-loop_0)"
" vec_0"
" i_0"
" start_0))))))"
"(shrink-vector vec_0 i_0))))"
"(if as-data?_0"
"(let-values()(vector gens_0 reorder-vec_0))"
"(let-values()"
"(list"
" 'deserialize-module-path-indexes"
"(list 'quote gens_0)"
"(list 'quote reorder-vec_0)))))))))))))))))))"
"(define-values"
"(deserialize-module-path-indexes)"
"(lambda(gen-vec_0 order-vec_0)"
"(begin"
"(let-values(((gen_0)(make-vector(vector-length gen-vec_0) #f)))"
"(begin"
"(let-values()"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0) gen-vec_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_0)))"
"(values vec_0(unsafe-vector-length vec_0)))))"
"((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0 pos_1)"
"(begin"
" 'for-loop"
"(if(if(unsafe-fx< pos_0 len_0) #t #f)"
"(let-values(((d_0)(unsafe-vector-ref vec_0 pos_0))((i_0) pos_1))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(vector-set!"
" gen_0"
" i_0"
"(if(eq? d_0 'top)"
"(let-values()"
"(deserialize-module-path-index))"
"(if(box? d_0)"
"(let-values()"
"(deserialize-module-path-index"
"(unbox d_0)))"
"(let-values()"
"(deserialize-module-path-index"
"(vector*-ref d_0 0)"
"(if(>(vector*-length d_0) 1)"
"(vector*-ref"
" gen_0"
"(vector*-ref d_0 1))"
" #f)))))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(unsafe-fx+ 1 pos_0)(+ pos_1 1))(values))))"
"(values))))))"
" for-loop_0)"
" 0"
" start_0))))"
"(void)"
"(let-values(((len_0)(vector-length order-vec_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"                (let-values () (1/raise-argument-error 'for/vector \"exact-nonnegative-integer?\" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) order-vec_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_0)))"
"(values vec_0(unsafe-vector-length vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_1)"
"(let-values(((p_0)(unsafe-vector-ref vec_0 pos_0)))"
"(let-values(((i_2)"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(vector*-ref gen_0 p_0)))"
"(unsafe-fx+ 1 i_1)))))"
"(values i_2))))"
"(if(if(not((lambda x_0(unsafe-fx= i_2 len_0)) p_0))"
"(not #f)"
" #f)"
"(for-loop_0 i_2(unsafe-fx+ 1 pos_0))"
" i_2)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" 0)))))"
" v_0)))))))))"
"(define-values"
"(deserialize-module-path-index-data)"
"(lambda(v_0)"
"(begin"
"(begin"
"(if(if(vector? v_0)(= 2(vector-length v_0)) #f)"
"(void)"
"          (let-values () (error 'syntax-deserialize \"ill-formed serialization\")))"
"(deserialize-module-path-indexes(vector-ref v_0 0)(vector-ref v_0 1))))))"
"(define-values"
"(mpis-as-vector)"
"(lambda(mpis_0)"
"(begin"
"(let-values(((positions_0)(module-path-index-table-positions mpis_0)))"
"(let-values(((vec_0)(make-vector(hash-count positions_0) #f)))"
"(begin"
"(let-values()"
"(let-values(((ht_0) positions_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((mpi_0 pos_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(vector-set! vec_0 pos_0 mpi_0))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)"
" vec_0))))))"
"(define-values"
"(generate-module-data-linklet)"
"(lambda(mpis_0)"
"(begin"
"(list"
" 'linklet"
"(list deserialize-imports)"
"(list mpi-vector-id)"
"(list* 'define-values(list inspector-id) '((current-code-inspector)))"
"(list"
" 'define-values"
"(list mpi-vector-id)"
"(let-values(((mpis27_0) mpis_0))(generate-module-path-index-deserialize.1 #f mpis27_0)))))))"
"(define-values"
"(generate-module-declaration-linklet)"
"(lambda(mpis_0"
" self_0"
" requires_0"
" recur-requires_0"
" flattened-requires_0"
" provides_0"
" phase-to-link-module-uses-expr_0"
" portal-stxes_0)"
"(begin"
"(list"
" 'linklet"
"(list deserialize-imports(list mpi-vector-id))"
" '(self-mpi requires recur-requires flattened-requires provides phase-to-link-modules portal-stxes)"
"(list 'define-values '(self-mpi)(add-module-path-index! mpis_0 self_0))"
"(list"
" 'define-values"
" '(requires)"
"(let-values(((requires28_0) requires_0)((mpis29_0) mpis_0)((temp30_0) #f))"
"(generate-deserialize.1"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" mpis29_0"
" #f"
" '#hasheq()"
" #f"
" temp30_0"
" requires28_0)))"
"(list 'define-values '(recur-requires)(list 'quote recur-requires_0))"
"(list"
" 'define-values"
" '(flattened-requires)"
"(if flattened-requires_0"
"(let-values(((flattened-requires31_0) flattened-requires_0)((mpis32_0) mpis_0)((temp33_0) #f))"
"(generate-deserialize.1"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" mpis32_0"
" #f"
" '#hasheq()"
" #f"
" temp33_0"
" flattened-requires31_0))"
" ''#f))"
"(list"
" 'define-values"
" '(provides)"
"(let-values(((provides34_0) provides_0)((mpis35_0) mpis_0)((temp36_0) #f)((provides37_0) provides_0))"
"(generate-deserialize.1"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" mpis35_0"
" provides37_0"
" '#hasheq()"
" #f"
" temp36_0"
" provides34_0)))"
"(list 'define-values '(phase-to-link-modules) phase-to-link-module-uses-expr_0)"
"(list 'define-values '(portal-stxes)(list 'quote portal-stxes_0))))))"
"(define-values"
"(serialize-module-uses)"
"(lambda(mus_0 mpis_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) mus_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
" 'module-use"
"(add-module-path-index!"
" mpis_0"
"(module-use-module mu_0))"
"(module-use-phase mu_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(define-values"
"(interned-literal?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(null? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? v_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(if(fixnum? v_0)(if(< v_0(sub1(expt 2 30)))(> v_0(-(expt 2 30))) #f) #f)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(symbol? v_0)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(char? v_0)))(if or-part_4 or-part_4(keyword? v_0))))))))))))))"
"(define-values"
"(serialize-phase-to-link-module-uses)"
"(lambda(phase-to-link-module-uses_0 mpis_0)"
"(begin"
"(let-values(((phases-in-order_0)"
"(let-values(((temp38_0)(hash-keys phase-to-link-module-uses_0))((<39_0) <))"
"(sort.1 #f #f temp38_0 <39_0))))"
"(list*"
" 'hasheqv"
"(apply"
" append"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((phase_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
" phase_0"
"(list*"
" 'list"
"(serialize-module-uses"
"(hash-ref"
" phase-to-link-module-uses_0"
" phase_0)"
" mpis_0))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))))"
"(define-values"
"(generate-deserialize.1)"
"(lambda(as-data?7_0"
" keep-provides?10_0"
" map-binding-symbol13_0"
" map-mpi12_0"
" mpis6_0"
" phase+space-hasheqv11_0"
" preserve-prop-keys9_0"
" report-mpi-shifts14_0"
" syntax-support?8_0"
" v24_0)"
"(begin"
" 'generate-deserialize"
"(let-values(((v_0) v24_0))"
"(let-values(((mpis_0) mpis6_0))"
"(let-values(((as-data?_0) as-data?7_0))"
"(let-values(((syntax-support?_0) syntax-support?8_0))"
"(let-values(((preserve-prop-keys_0) preserve-prop-keys9_0))"
"(let-values(((keep-provides?_0) keep-provides?10_0))"
"(let-values(((phase+space-hasheqv_0) phase+space-hasheqv11_0))"
"(let-values(((map-mpi_0)"
"(if(eq? map-mpi12_0 unsafe-undefined)"
"(lambda(mpi_0)(begin 'map-mpi mpi_0))"
" map-mpi12_0)))"
"(let-values(((map-binding-symbol_0)"
"(if(eq? map-binding-symbol13_0 unsafe-undefined)"
"(lambda(mpi_0 sym_0 phase_0)(begin 'map-binding-symbol(values sym_0 phase_0)))"
" map-binding-symbol13_0)))"
"(let-values(((report-mpi-shifts_0) report-mpi-shifts14_0))"
"(let-values()"
"(let-values(((bulk-shifts_0)(if keep-provides?_0(list(make-hasheq)) #f)))"
"(let-values(((reachable-scopes_0 implicitly-reachable-scopes_0)"
"(find-reachable-scopes v_0 bulk-shifts_0 report-mpi-shifts_0)))"
"(let-values(((state_0)"
"(make-serialize-state"
" reachable-scopes_0"
" implicitly-reachable-scopes_0"
" preserve-prop-keys_0"
"(if keep-provides?_0"
"(lambda(b_0)"
"(let-values(((name_0)(hash-ref(car bulk-shifts_0) b_0 #f)))"
"(let-values(((or-part_0)(not name_0)))"
"(if or-part_0 or-part_0(keep-provides?_0 name_0)))))"
" #f)"
"(if report-mpi-shifts_0 #t #f)"
" map-binding-symbol_0)))"
"(let-values(((mutables_0)(make-hasheq)))"
"(let-values(((objs_0)(make-hasheq)))"
"(let-values(((shares_0)(make-hasheq)))"
"(let-values(((binding-interns_0)(make-hash)))"
"(let-values(((obj-step_0) 0))"
"(let-values(((serialize-maybe-intern_0)"
"(lambda(v_1)"
"(begin"
" 'serialize-maybe-intern"
"(if(module-binding? v_1)"
"(let-values()"
"(module-binding-maybe-intern"
" v_1"
" binding-interns_0"
" map-binding-symbol_0"
"(lambda(mpi_0)"
"(add-module-path-index!/pos"
" mpis_0"
"(map-mpi_0 mpi_0)))))"
"(let-values() #f))))))"
"(let-values(((frontier_0) null))"
"(letrec-values(((add-frontier!_0)"
"(case-lambda"
"((v_1)"
"(begin"
" 'add-frontier!"
"(set! frontier_0(cons v_1 frontier_0))))"
"((kind_0 v_1)(add-frontier!_0 v_1)))))"
"(let-values((()"
"(begin"
"((letrec-values(((frontier-loop_0)"
"(lambda(v_1)"
"(begin"
" 'frontier-loop"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(v_2)"
"(begin"
" 'loop"
"(if(let-values(((or-part_0)"
"(interned-literal?"
" v_2)))"
"(if or-part_0"
" or-part_0"
"(1/module-path-index?"
" v_2)))"
"(let-values()"
"(void))"
"(let-values(((c1_0)"
"(serialize-maybe-intern_0"
" v_2)))"
"(if c1_0"
"((lambda(v_3)"
"(loop_0"
" v_3))"
" c1_0)"
"(if(hash-ref"
" objs_0"
" v_2"
" #f)"
"(let-values()"
"(if(hash-ref"
" mutables_0"
" v_2"
" #f)"
"(void)"
"(let-values()"
"(hash-set!"
" shares_0"
" v_2"
" #t))))"
"(let-values()"
"(begin"
"(if(serialize-fill!?"
" v_2)"
"(let-values()"
"(begin"
"(hash-set!"
" mutables_0"
" v_2"
"(hash-count"
" mutables_0))"
"((serialize-fill!-ref"
" v_2)"
" v_2"
" add-frontier!_0"
" state_0)))"
"(if(serialize?"
" v_2)"
"(let-values()"
"((serialize-ref"
" v_2)"
" v_2"
"(case-lambda"
"((sub-v_0)"
"(loop_0"
" sub-v_0))"
"((kind_0"
" sub-v_0)"
"(loop_0"
" sub-v_0)))"
" state_0))"
"(if(pair?"
" v_2)"
"(let-values()"
"(begin"
"(loop_0"
"(car"
" v_2))"
"(loop_0"
"(cdr"
" v_2))))"
"(if(vector?"
" v_2)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(immutable?"
" v_2)))"
"(if or-part_0"
" or-part_0"
"(zero?"
"(vector-length"
" v_2))))"
"(begin"
"(let-values()"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_2))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-vector"
" vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void))"
"(begin"
"(hash-set!"
" mutables_0"
" v_2"
"(hash-count"
" mutables_0))"
"(begin"
"(let-values()"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_2))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-vector"
" vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(add-frontier!_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))))"
"(if(box?"
" v_2)"
"(let-values()"
"(if(immutable?"
" v_2)"
"(loop_0"
"(unbox"
" v_2))"
"(begin"
"(hash-set!"
" mutables_0"
" v_2"
"(hash-count"
" mutables_0))"
"(add-frontier!_0"
"(unbox"
" v_2)))))"
"(if(hash?"
" v_2)"
"(let-values()"
"(if(immutable?"
" v_2)"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(sorted-hash-keys"
" v_2)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(loop_0"
" k_0)"
"(loop_0"
"(hash-ref"
" v_2"
" k_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))"
"(begin"
"(hash-set!"
" mutables_0"
" v_2"
"(hash-count"
" mutables_0))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(sorted-hash-keys"
" v_2)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(add-frontier!_0"
" k_0)"
"(add-frontier!_0"
"(hash-ref"
" v_2"
" k_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))"
"(if(prefab-struct-key"
" v_2)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(unsafe-normalise-inputs"
" unsafe-vector-length"
"(struct->vector"
" v_2)"
" 1"
" #f"
" 1)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                                                                 \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
"(struct->vector"
" v_2)"
" 1"
" #f"
" 1))))"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void)))"
"(if(srcloc?"
" v_2)"
"(let-values()"
"(if(path?"
"(srcloc-source"
" v_2))"
"(void)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(unsafe-normalise-inputs"
" unsafe-vector-length"
"(struct->vector"
" v_2)"
" 1"
" #f"
" 1)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                                                                       \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
"(struct->vector"
" v_2)"
" 1"
" #f"
" 1))))"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void)))))"
"(let-values()"
"(void))))))))))"
"(hash-set!"
" objs_0"
" v_2"
" obj-step_0)"
"(set! obj-step_0"
"(add1"
" obj-step_0))))))))))))"
" loop_0)"
" v_1)"
"(if(null? frontier_0)"
"(void)"
"(let-values()"
"(let-values(((l_0)"
" frontier_0))"
"(begin"
"(set! frontier_0 null)"
"(let-values()"
"(let-values(((lst_0)"
" l_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((v_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(frontier-loop_0"
" v_2))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))))))))))"
" frontier-loop_0)"
" v_0)"
"(values))))"
"(let-values(((num-mutables_0)(hash-count mutables_0)))"
"(let-values(((share-step-positions_0)"
"(let-values(((share-steps_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((ht_0) shares_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((obj_0)"
"(hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(hash-ref"
" objs_0"
" obj_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first"
" ht_0))))))))"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheqv()))"
" table_0)))"
"(let-values(((lst_0)"
"(let-values(((share-steps40_0)"
" share-steps_0)"
"((<41_0) <))"
"(sort.1"
" #f"
" #f"
" share-steps40_0"
" <41_0)))"
"((start_0) num-mutables_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" lst_1"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_1)"
" #t"
" #f)"
"(let-values(((step_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((pos_1)"
" pos_0))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" step_0"
" pos_1))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
" rest_0"
"(+"
" pos_0"
" 1))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0"
" start_0)))))))"
"(let-values(((stream_0) null))"
"(let-values(((stream-size_0) 0))"
"(let-values(((next-push-position_0)"
"(lambda()"
"(begin 'next-push-position stream-size_0))))"
"(let-values(((quoted?_0)"
"(lambda(pos_0)"
"(begin"
" 'quoted?"
"(let-values(((v_1)"
"(list-ref"
" stream_0"
"(-"
" stream-size_0"
"(add1 pos_0)))))"
"(let-values(((or-part_0)"
"(not(keyword? v_1))))"
"(if or-part_0"
" or-part_0"
"(eq? '#:quote v_1))))))))"
"(let-values(((ser-reset!_0)"
"(lambda(pos_0)"
"(begin"
" 'ser-reset!"
"(begin"
"(set! stream_0"
"(list-tail"
" stream_0"
"(- stream-size_0 pos_0)))"
"(set! stream-size_0 pos_0))))))"
"(let-values(((reap-stream!_0)"
"(lambda()"
"(begin"
" 'reap-stream!"
"(begin0"
"(list->vector"
"(reverse$1 stream_0))"
"(set! stream_0 null)"
"(set! stream-size_0 0))))))"
"(letrec-values(((ser-push!_0)"
"(case-lambda"
"((v_1)"
"(begin"
" 'ser-push!"
"(if(hash-ref shares_0 v_1 #f)"
"(let-values()"
"(let-values(((n_0)"
"(hash-ref"
" share-step-positions_0"
"(hash-ref"
" objs_0"
" v_1))))"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:ref)"
"(ser-push!_0"
" 'exact"
" n_0))))"
"(let-values(((c2_0)"
"(hash-ref"
" mutables_0"
" v_1"
" #f)))"
"(if c2_0"
"((lambda(n_0)"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:ref)"
"(ser-push!_0"
" 'exact"
" n_0)))"
" c2_0)"
"(let-values()"
"(ser-push-encoded!_0"
" v_1)))))))"
"((kind_0 v_1)"
"(let-values(((tmp_0) kind_0))"
"(if(equal? tmp_0 'exact)"
"(let-values()"
"(begin"
"(set! stream_0"
"(cons v_1 stream_0))"
"(set! stream-size_0"
"(add1 stream-size_0))))"
"(if(equal? tmp_0 'tag)"
"(let-values()"
"(ser-push!_0 'exact v_1))"
"(if(equal?"
" tmp_0"
" 'reference)"
"(let-values()"
"(if(hash-ref"
" shares_0"
" v_1"
" #f)"
"(let-values()"
"(let-values(((n_0)"
"(hash-ref"
" share-step-positions_0"
"(hash-ref"
" objs_0"
" v_1))))"
"(ser-push!_0"
" 'exact"
" n_0)))"
"(let-values(((c3_0)"
"(hash-ref"
" mutables_0"
" v_1"
" #f)))"
"(if c3_0"
"((lambda(n_0)"
"(ser-push!_0"
" 'exact"
" n_0))"
" c3_0)"
"(let-values()"
"(ser-push!_0"
" v_1))))))"
"(let-values()"
"(ser-push!_0"
" v_1)))))))))"
"((ser-push-encoded!_0)"
"(lambda(v_1)"
"(begin"
" 'ser-push-encoded!"
"(let-values(((c5_0)"
"(serialize-maybe-intern_0"
" v_1)))"
"(if c5_0"
"((lambda(v_2)"
"(ser-push!_0 v_2))"
" c5_0)"
"(if(keyword? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:quote)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(if(1/module-path-index?"
" v_1)"
"(let-values()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:mpi)"
"(ser-push!_0"
" 'exact"
"(add-module-path-index!/pos"
" mpis_0"
"(map-mpi_0"
" v_1)))))"
"(if(serialize? v_1)"
"(let-values()"
"((serialize-ref"
" v_1)"
" v_1"
" ser-push!_0"
" state_0))"
"(if(if(list? v_1)"
"(if(pair? v_1)"
"(pair?"
"(cdr v_1))"
" #f)"
" #f)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:list)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(length"
" v_1))"
"(values))))"
"(let-values(((all-quoted?_0)"
"(let-values(((all-quoted?_0)"
"(let-values(((all-quoted?_0)"
" #t))"
" all-quoted?_0)))"
"(let-values(((lst_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(all-quoted?_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((i_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((all-quoted?_2)"
"(let-values(((all-quoted?_2)"
"(let-values()"
"(let-values(((i-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0"
" i_0)"
"(if all-quoted?_1"
"(quoted?_0"
" i-pos_0)"
" #f))))))"
"(values"
" all-quoted?_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" all-quoted?_2"
" rest_0)"
" all-quoted?_2)))"
" all-quoted?_1))))))"
" for-loop_0)"
" all-quoted?_0"
" lst_0))))))"
"(if all-quoted?_0"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))"
"(if(pair? v_1)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:cons)"
"(values))))"
"(let-values(((a-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
"(car"
" v_1))"
"(values))))"
"(let-values(((d-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0"
"(cdr"
" v_1))"
"(if(if(quoted?_0"
" a-pos_0)"
"(quoted?_0"
" d-pos_0)"
" #f)"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))))"
"(if(box? v_1)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:box)"
"(values))))"
"(let-values(((v-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0"
"(unbox"
" v_1))"
"(if(quoted?_0"
" v-pos_0)"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))"
"(if(vector?"
" v_1)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:vector)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(vector-length"
" v_1))"
"(values))))"
"(let-values(((all-quoted?_0)"
"(let-values(((all-quoted?_0)"
"(let-values(((all-quoted?_0)"
" #t))"
" all-quoted?_0)))"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-vector"
" vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(all-quoted?_1"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((i_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values(((all-quoted?_2)"
"(let-values(((all-quoted?_2)"
"(let-values()"
"(let-values(((i-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0"
" i_0)"
"(if all-quoted?_1"
"(quoted?_0"
" i-pos_0)"
" #f))))))"
"(values"
" all-quoted?_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" all-quoted?_2"
"(unsafe-fx+"
" 1"
" pos_0))"
" all-quoted?_2)))"
" all-quoted?_1))))))"
" for-loop_0)"
" all-quoted?_0"
" 0)))))"
"(if all-quoted?_0"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))"
"(if(hash?"
" v_1)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values(((as-set?_0)"
"(let-values(((result_0)"
"(let-values(((result_0)"
" #t))"
" result_0)))"
"(let-values(((ht_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-values"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((val_0)"
"(hash-iterate-value"
" ht_0"
" i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(eq?"
" val_0"
" #t)))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" val_0))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(hash-iterate-first"
" ht_0)))))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
"(if as-set?_0"
"(if(hash-eq?"
" v_1)"
"(let-values()"
" '#:seteq)"
"(if(hash-eqv?"
" v_1)"
"(let-values()"
" '#:seteqv)"
"(let-values()"
" '#:set)))"
"(if(hash-eq?"
" v_1)"
"(let-values()"
" '#:hasheq)"
"(if(hash-eqv?"
" v_1)"
"(let-values()"
"(if(eq?"
" v_1"
" phase+space-hasheqv_0)"
" '#:hasheqv/phase+space"
" '#:hasheqv))"
"(let-values()"
" '#:hash)))))"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(hash-count"
" v_1))"
"(values))))"
"(let-values(((ks_0)"
"(sorted-hash-keys"
" v_1)))"
"(let-values(((all-quoted?_0)"
"(let-values(((all-quoted?_0)"
"(let-values(((all-quoted?_0)"
" #t))"
" all-quoted?_0)))"
"(let-values(((lst_0)"
" ks_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(all-quoted?_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((all-quoted?_2)"
"(let-values(((all-quoted?_2)"
"(let-values()"
"(let-values(((k-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" k_0)"
"(values))))"
"(let-values(((v-pos_0)"
"(next-push-position_0)))"
"(begin"
"(if as-set?_0"
"(void)"
"(let-values()"
"(ser-push!_0"
"(hash-ref"
" v_1"
" k_0))))"
"(if all-quoted?_1"
"(if(quoted?_0"
" k-pos_0)"
"(let-values(((or-part_0)"
" as-set?_0))"
"(if or-part_0"
" or-part_0"
"(quoted?_0"
" v-pos_0)))"
" #f)"
" #f))))))))"
"(values"
" all-quoted?_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" all-quoted?_2"
" rest_0)"
" all-quoted?_2)))"
" all-quoted?_1))))))"
" for-loop_0)"
" all-quoted?_0"
" lst_0))))))"
"(if all-quoted?_0"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))))"
"(let-values(((c4_0)"
"(prefab-struct-key"
" v_1)))"
"(if c4_0"
"((lambda(k_0)"
"(let-values(((vec_0)"
"(struct->vector"
" v_1)))"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:prefab)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
" k_0)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(sub1"
"(vector-length"
" vec_0)))"
"(values))))"
"(let-values(((all-quoted?_0)"
"(let-values(((all-quoted?_0)"
"(let-values(((all-quoted?_0)"
" #t))"
" all-quoted?_0)))"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(unsafe-normalise-inputs"
" unsafe-vector-length"
" vec_0"
" 1"
" #f"
" 1)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                                                               \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
" vec_0"
" 1"
" #f"
" 1))))"
"((letrec-values(((for-loop_0)"
"(lambda(all-quoted?_1"
" idx_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((i_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values(((all-quoted?_2)"
"(let-values(((all-quoted?_2)"
"(let-values()"
"(let-values(((i-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0"
" i_0)"
"(if all-quoted?_1"
"(quoted?_0"
" i-pos_0)"
" #f))))))"
"(values"
" all-quoted?_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" all-quoted?_2"
"(unsafe-fx+"
" idx_0"
" 1))"
" all-quoted?_2)))"
" all-quoted?_1))))))"
" for-loop_0)"
" all-quoted?_0"
" start*_0)))))"
"(if all-quoted?_0"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))))"
" c4_0)"
"(if(srcloc?"
" v_1)"
"(let-values()"
"(if(path?"
"(srcloc-source"
" v_1))"
"(let-values()"
"(begin"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(let-values()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:srcloc)"
"(ser-push!_0"
"(srcloc-source"
" v_1))"
"(ser-push!_0"
"(srcloc-line"
" v_1))"
"(ser-push!_0"
"(srcloc-column"
" v_1))"
"(ser-push!_0"
"(srcloc-position"
" v_1))"
"(ser-push!_0"
"(srcloc-span"
" v_1))))))"
"(let-values()"
"(begin"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))))))))))))))))))"
"((ser-push-optional-quote!_0)"
"(lambda()"
"(begin"
" 'ser-push-optional-quote!"
"(void)))))"
"(let-values(((ser-shell!_0)"
"(lambda(v_1)"
"(begin"
" 'ser-shell!"
"(if(serialize-fill!? v_1)"
"(let-values()"
"((serialize-ref v_1)"
" v_1"
" ser-push!_0"
" state_0))"
"(if(box? v_1)"
"(let-values()"
"(ser-push!_0 'tag '#:box))"
"(if(vector? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:vector)"
"(ser-push!_0"
" 'exact"
"(vector-length"
" v_1))))"
"(if(hash? v_1)"
"(let-values()"
"(ser-push!_0"
" 'tag"
"(if(hash-eq? v_1)"
"(let-values()"
" '#:hasheq)"
"(if(hash-eqv? v_1)"
"(let-values()"
" '#:hasheqv)"
"(let-values()"
" '#:hash)))))"
"(let-values()"
"(error"
" 'ser-shell"
"                                                                                                   \"unknown mutable: ~e\""
" v_1))))))))))"
"(let-values(((ser-shell-fill!_0)"
"(lambda(v_1)"
"(begin"
" 'ser-shell-fill!"
"(if(serialize-fill!? v_1)"
"(let-values()"
"((serialize-fill!-ref v_1)"
" v_1"
" ser-push!_0"
" state_0))"
"(if(box? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:set-box!)"
"(ser-push!_0"
"(unbox v_1))))"
"(if(vector? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:set-vector!)"
"(ser-push!_0"
" 'exact"
"(vector-length"
" v_1))"
"(let-values()"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-vector"
" vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((v_2)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(ser-push!_0"
" v_2))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(hash? v_1)"
"(let-values()"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:set-hash!)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(hash-count"
" v_1))"
"(values))))"
"(let-values(((ks_0)"
"(sorted-hash-keys"
" v_1)))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" ks_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(ser-push!_0"
" k_0)"
"(ser-push!_0"
"(hash-ref"
" v_1"
" k_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))))))"
"(let-values()"
"(error"
" 'ser-shell-fill"
"                                                                                                     \"unknown mutable: ~e\""
" v_1))))))))))"
"(let-values(((rev-mutables_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheqv()))"
" table_0)))"
"(let-values(((ht_0)"
" mutables_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0"
" v_1)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" v_1"
" k_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first"
" ht_0)))))))"
"(let-values(((mutable-shell-bindings_0)"
"(begin"
"(begin"
"(let-values()"
"(let-values(((start_0)"
" 0)"
"((end_0)"
"(hash-count"
" mutables_0))"
"((inc_0)"
" 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((i_0)"
" pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(ser-shell!_0"
"(hash-ref"
" rev-mutables_0"
" i_0)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0))))"
"(void))"
"(reap-stream!_0))))"
"(let-values(((rev-shares_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheqv()))"
" table_0)))"
"(let-values(((ht_0)"
" shares_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((obj_0)"
"(hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(hash-ref"
" share-step-positions_0"
"(hash-ref"
" objs_0"
" obj_0))"
" obj_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first"
" ht_0)))))))"
"(let-values(((shared-bindings_0)"
"(begin"
"(begin"
"(let-values()"
"(let-values(((start_0)"
" num-mutables_0)"
"((end_0)"
"(+"
" num-mutables_0"
"(hash-count"
" shares_0)))"
"((inc_0)"
" 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((i_0)"
" pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(ser-push-encoded!_0"
"(hash-ref"
" rev-shares_0"
" i_0)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0))))"
"(void))"
"(reap-stream!_0))))"
"(let-values(((mutable-fills_0)"
"(begin"
"(begin"
"(let-values()"
"(let-values(((start_0)"
" 0)"
"((end_0)"
"(hash-count"
" mutables_0))"
"((inc_0)"
" 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((i_0)"
" pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(ser-shell-fill!_0"
"(hash-ref"
" rev-mutables_0"
" i_0)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0))))"
"(void))"
"(reap-stream!_0))))"
"(let-values(((result_0)"
"(begin"
"(ser-push!_0 v_0)"
"(reap-stream!_0))))"
"(if as-data?_0"
"(let-values()"
"(vector"
"(hash-count mutables_0)"
" mutable-shell-bindings_0"
"(hash-count shares_0)"
" shared-bindings_0"
" mutable-fills_0"
" result_0))"
"(let-values()"
"(let-values(((finish_0)"
"(lambda(mutable-shell-bindings-expr_0"
" shared-bindings-expr_0"
" mutable-fills-expr_0"
" result-expr_0)"
"(begin"
" 'finish"
"(list"
" 'deserialize"
" mpi-vector-id"
"(if syntax-support?_0"
" inspector-id"
" #f)"
"(if syntax-support?_0"
" bulk-binding-registry-id"
" #f)"
"(list"
" 'quote"
"(hash-count"
" mutables_0))"
" mutable-shell-bindings-expr_0"
"(list"
" 'quote"
"(hash-count"
" shares_0))"
" shared-bindings-expr_0"
" mutable-fills-expr_0"
" result-expr_0)))))"
"(list"
" 'let-values"
"(list"
"(list"
" '(data)"
"(list"
" 'quote"
"(vector"
" mutable-shell-bindings_0"
" shared-bindings_0"
" mutable-fills_0"
" result_0))))"
"(finish_0"
" '(unsafe-vector*-ref"
" data"
" 0)"
" '(unsafe-vector*-ref"
" data"
" 1)"
" '(unsafe-vector*-ref"
" data"
" 2)"
" '(unsafe-vector*-ref"
" data"
" 3)))))))))))))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(sorted-hash-keys)"
"(lambda(ht_0)"
"(begin"
"(let-values(((ks_0)(hash-keys ht_0)))"
"(if(null? ks_0)"
"(let-values() ks_0)"
"(if(null?(cdr ks_0))"
"(let-values() ks_0)"
"(if(andmap2 symbol? ks_0)"
"(let-values()"
"(let-values(((ks42_0) ks_0)((symbol<?43_0) symbol<?))(sort.1 #f #f ks42_0 symbol<?43_0)))"
"(if(andmap2 scope? ks_0)"
"(let-values()(let-values(((ks44_0) ks_0)((scope<?45_0) scope<?))(sort.1 #f #f ks44_0 scope<?45_0)))"
"(if(andmap2 shifted-multi-scope? ks_0)"
"(let-values()"
"(let-values(((ks46_0) ks_0)((shifted-multi-scope<?47_0) shifted-multi-scope<?))"
"(sort.1 #f #f ks46_0 shifted-multi-scope<?47_0)))"
"(if(andmap2 real? ks_0)"
"(let-values()(let-values(((ks48_0) ks_0)((<49_0) <))(sort.1 #f #f ks48_0 <49_0)))"
"(let-values() ks_0)))))))))))"
"(define-values"
"(deserialize)"
"(lambda(mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" num-mutables_0"
" mutable-vec_0"
" num-shared_0"
" shared-vec_0"
" mutable-fill-vec_0"
" result-vec_0)"
"(begin"
"(let-values(((shared_0)(make-vector(+ num-mutables_0 num-shared_0) 'uninit)))"
"(let-values((()"
"(begin"
"(let-values(((pos_0)(let-values(((pos_0) 0)) pos_0)))"
"(let-values(((start_0) 0)((end_0) num-mutables_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_1 pos_2)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_2 end_0)"
"(let-values(((i_0) pos_2))"
"(let-values(((pos_3)"
"(let-values(((pos_3)"
"(let-values()"
"(let-values(((d_0 next-pos_0)"
"(decode-shell"
" mutable-vec_0"
" pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(begin"
"(vector-set!"
" shared_0"
" i_0"
" d_0)"
" next-pos_0)))))"
"(values pos_3))))"
"(if(not #f)(for-loop_0 pos_3(+ pos_2 inc_0)) pos_3)))"
" pos_1))))))"
" for-loop_0)"
" pos_0"
" start_0))))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((pos_0)(let-values(((pos_0) 0)) pos_0)))"
"(let-values(((start_0) num-mutables_0)"
"((end_0)(+ num-mutables_0 num-shared_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_1 pos_2)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_2 end_0)"
"(let-values(((i_0) pos_2))"
"(let-values(((pos_3)"
"(let-values(((pos_3)"
"(let-values()"
"(let-values(((d_0 next-pos_0)"
"(decode"
" shared-vec_0"
" pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(begin"
"(vector-set!"
" shared_0"
" i_0"
" d_0)"
" next-pos_0)))))"
"(values pos_3))))"
"(if(not #f)(for-loop_0 pos_3(+ pos_2 inc_0)) pos_3)))"
" pos_1))))))"
" for-loop_0)"
" pos_0"
" start_0))))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((pos_0)(let-values(((pos_0) 0)) pos_0)))"
"(let-values(((start_0) 0)"
"((end_0) num-mutables_0)"
"((inc_0) 1)"
"((vec_0 len_0)"
"(let-values(((vec_0) shared_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_0)))"
"(values vec_0(unsafe-vector-length vec_0))))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"(void)"
"((letrec-values(((for-loop_0)"
"(lambda(pos_1 pos_2 pos_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(< pos_2 end_0)(unsafe-fx< pos_3 len_0) #f)"
"(let-values(((v_0)(unsafe-vector-ref vec_0 pos_3)))"
"(let-values(((pos_4)"
"(let-values(((pos_4)"
"(let-values()"
"(decode-fill!"
" v_0"
" mutable-fill-vec_0"
" pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0))))"
"(values pos_4))))"
"(if(not #f)"
"(for-loop_0"
" pos_4"
"(+ pos_2 inc_0)"
"(unsafe-fx+ 1 pos_3))"
" pos_4)))"
" pos_1))))))"
" for-loop_0)"
" pos_0"
" start_0"
" 0))))"
"(values))))"
"(let-values(((result_0 done-pos_0)"
"(decode result-vec_0 0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
" result_0))))))))"
"(define-values"
"(deserialize-data)"
"(lambda(mpis_0 inspector_0 bulk-binding-registry_0 data_0)"
"(begin"
"(begin"
"(if(if(vector? data_0)(= 6(vector-length data_0)) #f)"
"(void)"
"          (let-values () (error 'syntax-deserialize \"ill-formed serialization\")))"
"(deserialize"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
"(vector-ref data_0 0)"
"(vector-ref data_0 1)"
"(vector-ref data_0 2)"
"(vector-ref data_0 3)"
"(vector-ref data_0 4)"
"(vector-ref data_0 5))))))"
"(define-values"
"(decode-shell)"
"(lambda(vec_0 pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)"
"(begin"
"(let-values(((tmp_0)(vector*-ref vec_0 pos_0)))"
"(if(equal? tmp_0 '#:box)"
"(let-values()(values(box #f)(add1 pos_0)))"
"(if(equal? tmp_0 '#:vector)"
"(let-values()(values(make-vector(vector*-ref vec_0(add1 pos_0)))(+ pos_0 2)))"
"(if(equal? tmp_0 '#:hash)"
"(let-values()(values(make-hasheq)(add1 pos_0)))"
"(if(equal? tmp_0 '#:hasheq)"
"(let-values()(values(make-hasheq)(add1 pos_0)))"
"(if(equal? tmp_0 '#:hasheqv)"
"(let-values()(values(make-hasheqv)(add1 pos_0)))"
"(let-values()(decode vec_0 pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))))))))))"
"(define-values"
"(decode)"
"(lambda(vec_0 pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)"
"(begin"
"(let-values()"
"(let-values(((tmp_0)(vector*-ref vec_0 pos_0)))"
"(let-values(((index_0)"
"(if(keyword? tmp_0)"
"(hash-ref"
" '#hasheq((#:box . 10)"
"(#:bulk-binding . 28)"
"(#:bulk-binding+provides . 30)"
"(#:bulk-binding-at . 23)"
"(#:bulk-binding-registry . 3)"
"(#:cons . 11)"
"(#:datum->syntax . 5)"
"(#:hash . 13)"
"(#:hasheq . 13)"
"(#:hasheqv . 13)"
"(#:hasheqv/phase+space . 14)"
"(#:inspector . 2)"
"(#:interned-scope . 19)"
"(#:like-ambiguous-binding . 29)"
"(#:list . 12)"
"(#:local-binding . 27)"
"(#:module-binding . 25)"
"(#:mpi . 9)"
"(#:multi-scope . 20)"
"(#:prefab . 16)"
"(#:provided . 31)"
"(#:quote . 8)"
"(#:ref . 1)"
"(#:representative-scope . 24)"
"(#:scope . 17)"
"(#:scope+kind . 18)"
"(#:set . 15)"
"(#:seteq . 15)"
"(#:seteqv . 15)"
"(#:shifted-multi-scope . 21)"
"(#:simple-module-binding . 26)"
"(#:srcloc . 7)"
"(#:syntax . 4)"
"(#:syntax+props . 6)"
"(#:table-with-bulk-bindings . 22)"
"(#:vector . 12))"
" tmp_0"
"(lambda() 0))"
" 0)))"
"(if(unsafe-fx< index_0 15)"
"(if(unsafe-fx< index_0 7)"
"(if(unsafe-fx< index_0 3)"
"(if(unsafe-fx< index_0 1)"
"(let-values()(values(vector*-ref vec_0 pos_0)(add1 pos_0)))"
"(if(unsafe-fx< index_0 2)"
"(let-values()(values(vector*-ref shared_0(vector*-ref vec_0(add1 pos_0)))(+ pos_0 2)))"
"(let-values()(values inspector_0(add1 pos_0)))))"
"(if(unsafe-fx< index_0 4)"
"(let-values()(values bulk-binding-registry_0(add1 pos_0)))"
"(if(unsafe-fx< index_0 5)"
"(let-values()"
"(let-values(((content_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((context_0 next-pos_1)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_0)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_0))"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(let-values(((srcloc_0 next-pos_2)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_1)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_1))"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(values"
"(deserialize-syntax content_0 context_0 srcloc_0 #f #f inspector_0)"
" next-pos_2)))))"
"(if(unsafe-fx< index_0 6)"
"(let-values()"
"(let-values(((content_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((context_0 next-pos_1)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_0)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_0))"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(let-values(((srcloc_0 next-pos_2)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_1)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_1))"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(values"
"(deserialize-datum->syntax content_0 context_0 srcloc_0 inspector_0)"
" next-pos_2)))))"
"(let-values()"
"(let-values(((content_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((context_0 next-pos_1)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_0)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_0))"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(let-values(((srcloc_0 next-pos_2)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_1)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_1))"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(let-values(((props_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((tamper_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-syntax content_0 context_0 srcloc_0 props_0 tamper_0 inspector_0)"
" next-pos_4)))))))))))"
"(if(unsafe-fx< index_0 10)"
"(if(unsafe-fx< index_0 8)"
"(let-values()"
"(let-values(((source_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((line_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((column_0 next-pos_2)"
"(decode vec_0 next-pos_1 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((position_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((span_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values(srcloc source_0 line_0 column_0 position_0 span_0) next-pos_4)))))))"
"(if(unsafe-fx< index_0 9)"
"(let-values()(values(vector*-ref vec_0(add1 pos_0))(+ pos_0 2)))"
"(let-values()(values(vector*-ref mpis_0(vector*-ref vec_0(add1 pos_0)))(+ pos_0 2)))))"
"(if(unsafe-fx< index_0 12)"
"(if(unsafe-fx< index_0 11)"
"(let-values()"
"(let-values(((v_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(box-immutable v_0) next-pos_0)))"
"(let-values()"
"(let-values(((a_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((d_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(cons a_0 d_0) next-pos_1)))))"
"(if(unsafe-fx< index_0 13)"
"(let-values()"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((r_0)(make-vector len_0)))"
"(let-values(((next-pos_0)"
"(let-values(((pos_1)(let-values(((pos_1)(+ pos_0 2))) pos_1)))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_2 pos_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_3 end_0)"
"(let-values(((i_0) pos_3))"
"(let-values(((pos_4)"
"(let-values(((pos_4)"
"(let-values()"
"(let-values(((v_0"
" next-pos_0)"
"(let-values(((v_0"
" next-pos_0)"
"(decode"
" vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
" v_0"
" next-pos_0))))"
"(begin"
"(vector-set!"
" r_0"
" i_0"
" v_0)"
" next-pos_0)))))"
"(values pos_4))))"
"(if(not #f)"
"(for-loop_0 pos_4(+ pos_3 inc_0))"
" pos_4)))"
" pos_2))))))"
" for-loop_0)"
" pos_1"
" start_0))))))"
"(values"
"(if(eq?(vector*-ref vec_0 pos_0) '#:list)"
"(vector->list r_0)"
"(vector->immutable-vector r_0))"
" next-pos_0)))))"
"(if(unsafe-fx< index_0 14)"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((tmp_1)(vector*-ref vec_0 pos_0)))"
"(if(equal? tmp_1 '#:hash)"
"(let-values()(hash))"
"(if(equal? tmp_1 '#:hasheq)"
"(let-values()(hasheq))"
"(if(equal? tmp_1 '#:hasheqv)"
"(let-values()(hasheqv))"
"(let-values()(void))))))))"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((ht_1)(let-values(((ht_1) ht_0)) ht_1))"
"((pos_1)(let-values(((pos_1)(+ pos_0 2))) pos_1)))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_2 pos_2 pos_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_3 end_0)"
"(let-values()"
"(let-values(((ht_3 pos_4)"
"(let-values(((ht_3 pos_4)"
"(let-values()"
"(let-values(((k_0"
" next-pos_0)"
"(decode"
" vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((v_0"
" next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(hash-set"
" ht_2"
" k_0"
" v_0)"
" next-pos_1))))))"
"(values ht_3 pos_4))))"
"(if(not #f)"
"(for-loop_0 ht_3 pos_4(+ pos_3 inc_0))"
"(values ht_3 pos_4))))"
"(values ht_2 pos_2)))))))"
" for-loop_0)"
" ht_1"
" pos_1"
" start_0)))))))"
"(let-values()"
"(let-values(((ht_0)(hasheqv)))"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((ht_1)(let-values(((ht_1) ht_0)) ht_1))"
"((pos_1)(let-values(((pos_1)(+ pos_0 2))) pos_1)))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_2 pos_2 pos_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_3 end_0)"
"(let-values()"
"(let-values(((ht_3 pos_4)"
"(let-values(((ht_3 pos_4)"
"(let-values()"
"(let-values(((k_0"
" next-pos_0)"
"(decode"
" vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((v_0"
" next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(hash-set"
" ht_2"
"(intern-phase+space"
" k_0)"
" v_0)"
" next-pos_1))))))"
"(values ht_3 pos_4))))"
"(if(not #f)"
"(for-loop_0 ht_3 pos_4(+ pos_3 inc_0))"
"(values ht_3 pos_4))))"
"(values ht_2 pos_2)))))))"
" for-loop_0)"
" ht_1"
" pos_1"
" start_0))))))))))))"
"(if(unsafe-fx< index_0 23)"
"(if(unsafe-fx< index_0 18)"
"(if(unsafe-fx< index_0 16)"
"(let-values()"
"(let-values(((s_0)"
"(let-values(((tmp_1)(vector*-ref vec_0 pos_0)))"
"(if(equal? tmp_1 '#:set)"
"(let-values()(set))"
"(if(equal? tmp_1 '#:seteq)"
"(let-values()(seteq))"
"(if(equal? tmp_1 '#:seteqv)"
"(let-values()(seteqv))"
"(let-values()(void))))))))"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((s_1)(let-values(((s_1) s_0)) s_1))"
"((pos_1)(let-values(((pos_1)(+ pos_0 2))) pos_1)))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_2 pos_2 pos_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_3 end_0)"
"(let-values()"
"(let-values(((s_3 pos_4)"
"(let-values(((s_3 pos_4)"
"(let-values()"
"(let-values(((k_0 next-pos_0)"
"(decode"
" vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(set-add s_2 k_0)"
" next-pos_0)))))"
"(values s_3 pos_4))))"
"(if(not #f)"
"(for-loop_0 s_3 pos_4(+ pos_3 inc_0))"
"(values s_3 pos_4))))"
"(values s_2 pos_2)))))))"
" for-loop_0)"
" s_1"
" pos_1"
" start_0)))))))"
"(if(unsafe-fx< index_0 17)"
"(let-values()"
"(let-values(((key_0 next-pos_0)"
"(let-values(((k_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values k_0 next-pos_0))))"
"(let-values(((len_0)(vector*-ref vec_0 next-pos_0)))"
"(let-values(((r_0 done-pos_0)"
"(let-values(((r_0)(let-values(((r_0) null)) r_0))"
"((pos_1)(let-values(((pos_1)(add1 next-pos_0))) pos_1)))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(r_1 pos_2 pos_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_3 end_0)"
"(let-values()"
"(let-values(((r_2 pos_4)"
"(let-values(((r_2 pos_4)"
"(let-values()"
"(let-values(((v_0"
" next-pos_1)"
"(decode"
" vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(cons"
" v_0"
" r_1)"
" next-pos_1)))))"
"(values r_2 pos_4))))"
"(if(not #f)"
"(for-loop_0 r_2 pos_4(+ pos_3 inc_0))"
"(values r_2 pos_4))))"
"(values r_1 pos_2)))))))"
" for-loop_0)"
" r_0"
" pos_1"
" start_0))))))"
"(values(apply make-prefab-struct key_0(reverse$1 r_0)) done-pos_0)))))"
"(let-values()(values(deserialize-scope)(add1 pos_0)))))"
"(if(unsafe-fx< index_0 20)"
"(if(unsafe-fx< index_0 19)"
"(let-values()"
"(let-values(((kind_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-scope kind_0) next-pos_0)))"
"(let-values()"
"(let-values(((id_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(make-interned-scope id_0) next-pos_0))))"
"(if(unsafe-fx< index_0 21)"
"(let-values()"
"(let-values(((name_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((scopes_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-multi-scope name_0 scopes_0) next-pos_1))))"
"(if(unsafe-fx< index_0 22)"
"(let-values()"
"(let-values(((phase_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((multi-scope_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values(deserialize-shifted-multi-scope phase_0 multi-scope_0) next-pos_1))))"
"(let-values()"
"(let-values(((syms_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((bulk-bindings_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values(deserialize-table-with-bulk-bindings syms_0 bulk-bindings_0) next-pos_1))))))))"
"(if(unsafe-fx< index_0 27)"
"(if(unsafe-fx< index_0 24)"
"(let-values()"
"(let-values(((scopes_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((bulk_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-bulk-binding-at scopes_0 bulk_0) next-pos_1))))"
"(if(unsafe-fx< index_0 25)"
"(let-values()"
"(let-values(((kind_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((phase_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-representative-scope kind_0 phase_0) next-pos_1))))"
"(if(unsafe-fx< index_0 26)"
"(let-values()"
"(let-values(((module_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((sym_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((phase_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-module_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-phase_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-sym_0 next-pos_5)"
"(decode"
" vec_0"
" next-pos_4"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-require-phase_0 next-pos_6)"
"(decode"
" vec_0"
" next-pos_5"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((free=id_0 next-pos_7)"
"(decode"
" vec_0"
" next-pos_6"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((extra-inspector_0 next-pos_8)"
"(decode"
" vec_0"
" next-pos_7"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((extra-nominal-bindings_0 next-pos_9)"
"(decode"
" vec_0"
" next-pos_8"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-full-module-binding"
" module_0"
" sym_0"
" phase_0"
" nominal-module_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase_0"
" free=id_0"
" extra-inspector_0"
" extra-nominal-bindings_0)"
" next-pos_9))))))))))))"
"(let-values()"
"(let-values(((module_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((sym_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((phase_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-module_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-simple-module-binding module_0 sym_0 phase_0 nominal-module_0)"
" next-pos_3)))))))))"
"(if(unsafe-fx< index_0 29)"
"(if(unsafe-fx< index_0 28)"
"(let-values()"
"(let-values(((key_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((free=id_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-full-local-binding key_0 free=id_0) next-pos_1))))"
"(let-values()"
"(let-values(((prefix_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((excepts_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((mpi_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((provide-phase-level_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((phase-shift_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((bulk-binding-registry_1 next-pos_5)"
"(decode"
" vec_0"
" next-pos_4"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-bulk-binding"
" prefix_0"
" excepts_0"
" mpi_0"
" provide-phase-level_0"
" phase-shift_0"
" bulk-binding-registry_1)"
" next-pos_5)))))))))"
"(if(unsafe-fx< index_0 30)"
"(let-values()(values(like-ambiguous-binding1.1)(add1 pos_0)))"
"(if(unsafe-fx< index_0 31)"
"(let-values()"
"(let-values(((provides_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((self_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((prefix_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((excepts_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((mpi_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((provide-phase-level_0 next-pos_5)"
"(decode"
" vec_0"
" next-pos_4"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((phase-shift_0 next-pos_6)"
"(decode"
" vec_0"
" next-pos_5"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((bulk-binding-registry_1 next-pos_7)"
"(decode"
" vec_0"
" next-pos_6"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-bulk-binding+provides"
" provides_0"
" self_0"
" prefix_0"
" excepts_0"
" mpi_0"
" provide-phase-level_0"
" phase-shift_0"
" bulk-binding-registry_1)"
" next-pos_7))))))))))"
"(let-values()"
"(let-values(((binding_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((protected?_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((syntax?_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-provided binding_0 protected?_0 syntax?_0)"
" next-pos_2)))))))))))))))))"
"(define-values"
"(decode-fill!)"
"(lambda(v_0 vec_0 pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)"
"(begin"
"(let-values(((tmp_0)(vector*-ref vec_0 pos_0)))"
"(if(equal? tmp_0 #f)"
"(let-values()(add1 pos_0))"
"(if(equal? tmp_0 '#:set-box!)"
"(let-values()"
"(let-values(((c_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(begin(set-box! v_0 c_0) next-pos_0)))"
"(if(equal? tmp_0 '#:set-vector!)"
"(let-values()"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((pos_1)(let-values(((pos_1)(+ pos_0 2))) pos_1)))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_2 pos_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_3 end_0)"
"(let-values(((i_0) pos_3))"
"(let-values(((pos_4)"
"(let-values(((pos_4)"
"(let-values()"
"(let-values(((c_0 next-pos_0)"
"(decode"
" vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(begin"
"(vector-set! v_0 i_0 c_0)"
" next-pos_0)))))"
"(values pos_4))))"
"(if(not #f)(for-loop_0 pos_4(+ pos_3 inc_0)) pos_4)))"
" pos_2))))))"
" for-loop_0)"
" pos_1"
" start_0))))))"
"(if(equal? tmp_0 '#:set-hash!)"
"(let-values()"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((pos_1)(let-values(((pos_1)(+ pos_0 2))) pos_1)))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_2 pos_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_3 end_0)"
"(let-values()"
"(let-values(((pos_4)"
"(let-values(((pos_4)"
"(let-values()"
"(let-values(((key_0 next-pos_0)"
"(decode"
" vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((val_0 done-pos_0)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(begin"
"(hash-set! v_0 key_0 val_0)"
" done-pos_0))))))"
"(values pos_4))))"
"(if(not #f)(for-loop_0 pos_4(+ pos_3 inc_0)) pos_4)))"
" pos_2))))))"
" for-loop_0)"
" pos_1"
" start_0))))))"
"(if(equal? tmp_0 '#:scope-fill!)"
"(let-values()"
"(let-values(((c_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(begin(deserialize-scope-fill! v_0 c_0) next-pos_0)))"
"(if(equal? tmp_0 '#:representative-scope-fill!)"
"(let-values()"
"(let-values(((a_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((d_0 done-pos_0)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(begin(deserialize-representative-scope-fill! v_0 a_0 d_0) done-pos_0))))"
"                    (let-values () (error 'deserialize \"bad fill encoding: ~v\" (vector*-ref vec_0 pos_0)))))))))))))"
"(define-values"
"(find-reachable-scopes)"
"(lambda(v_0 bulk-shifts_0 report-mpi-shifts_0)"
"(begin"
"(let-values(((seen_0)(make-hasheq)))"
"(let-values(((reachable-scopes_0)(interned-scopes)))"
"(let-values(((implicitly-reachable-scopes_0)(interned-scopes)))"
"(let-values(((get-reachable-scopes_0)(lambda()(begin 'get-reachable-scopes reachable-scopes_0))))"
"(let-values(((scope-triggers_0)(make-hasheq)))"
"(let-values(((report-shifts_0)"
"(if report-mpi-shifts_0"
"(lambda(mpi_0 bulk-shifts_1)"
"(begin"
" 'report-shifts"
"(report-mpi-shifts_0 mpi_0(apply-syntax-shifts mpi_0(cdr bulk-shifts_1)))))"
" #f)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(v_1 bulk-shifts_1)"
"(begin"
" 'loop"
"(if(interned-literal? v_1)"
"(let-values()(void))"
"(if(hash-ref seen_0 v_1 #f)"
"(let-values()(void))"
"(let-values()"
"(begin"
"(hash-set! seen_0 v_1 #t)"
"(if(scope-with-bindings? v_1)"
"(let-values()"
"(begin"
"(set! reachable-scopes_0(set-add reachable-scopes_0 v_1))"
"((reach-scopes-ref v_1) v_1 bulk-shifts_1 loop_0)"
"(let-values()"
"(let-values(((lst_0)(hash-ref scope-triggers_0 v_1 null)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((proc_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(proc_0"
" loop_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(hash-remove! scope-triggers_0 v_1)"
"((scope-with-bindings-ref v_1)"
" v_1"
" get-reachable-scopes_0"
" bulk-shifts_1"
" loop_0"
"(lambda(sc-unreachable_0 b_0)"
"(hash-update!"
" scope-triggers_0"
" sc-unreachable_0"
"(lambda(l_0)(cons b_0 l_0))"
" null))"
"(lambda(sc_0)"
"(if(set-member? reachable-scopes_0 sc_0)"
"(void)"
"(let-values()"
"(set! implicitly-reachable-scopes_0"
"(set-add implicitly-reachable-scopes_0 sc_0)))))"
" report-shifts_0)))"
"(if(reach-scopes? v_1)"
"(let-values()((reach-scopes-ref v_1) v_1 bulk-shifts_1 loop_0))"
"(if(pair? v_1)"
"(let-values()"
"(begin"
"(loop_0(car v_1) bulk-shifts_1)"
"(loop_0(cdr v_1) bulk-shifts_1)))"
"(if(vector? v_1)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0) v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-vector vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0"
" bulk-shifts_1))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-fx+ 1 pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(box? v_1)"
"(let-values()(loop_0(unbox v_1) bulk-shifts_1))"
"(if(hash? v_1)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_0) v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_2)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(loop_0"
" k_0"
" bulk-shifts_1)"
"(loop_0"
" v_2"
" bulk-shifts_1)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next"
" ht_0"
" i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)))"
"(if(prefab-struct-key v_1)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((v*_0 start*_0 stop*_0 step*_0)"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(unsafe-normalise-inputs"
" unsafe-vector-length"
"(struct->vector v_1)"
" 1"
" #f"
" 1)"
"(normalise-inputs"
" 'in-vector"
"                                                                                       \"vector\""
"(lambda(x_0)(vector? x_0))"
"(lambda(x_0)"
"(unsafe-vector-length x_0))"
"(struct->vector v_1)"
" 1"
" #f"
" 1))))"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0"
" bulk-shifts_1))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void)))"
"(if(srcloc? v_1)"
"(let-values()"
"(loop_0(srcloc-source v_1) bulk-shifts_1))"
"(let-values()(void))))))))))))))))))"
" loop_0)"
" v_0"
" bulk-shifts_0)"
"(values reachable-scopes_0 implicitly-reachable-scopes_0)))))))))))"
"(define-values"
"(force-syntax-object)"
"(lambda(syntax-literals_0"
" pos_0"
" mpi_0"
" self-mpi_0"
" phase-shift_0"
" inspector_0"
" deserialized-syntax-vector_0"
" bulk-binding-registry_0"
" deserialize-syntax_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(vector*-ref deserialized-syntax-vector_0 0)"
"(void)"
"(let-values()(deserialize-syntax_0 bulk-binding-registry_0)))"
"(values))))"
"(let-values(((stx_0)"
"(let-values(((temp50_0)"
"(syntax-shift-phase-level$1"
"(vector*-ref deserialized-syntax-vector_0 pos_0)"
" phase-shift_0))"
"((mpi51_0) mpi_0)"
"((self-mpi52_0) self-mpi_0)"
"((inspector53_0) inspector_0))"
"(syntax-module-path-index-shift.1 #f temp50_0 mpi51_0 self-mpi52_0 inspector53_0))))"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values((()(begin(vector-cas! syntax-literals_0 pos_0 #f stx_0)(values))))"
"(let-values(((new-stx_0)(vector*-ref syntax-literals_0 pos_0)))"
"(if new-stx_0 new-stx_0(loop_0))))))))"
" loop_0)))))))"
"(define-values"
"(deserialize-imports)"
" '(deserialize-module-path-indexes"
" syntax-module-path-index-shift"
" syntax-shift-phase-level"
" force-syntax-object"
" module-use"
" deserialize))"
"(define-values"
"(syntax-module-path-index-shift/no-keywords)"
"(let-values(((syntax-module-path-index-shift_0)"
"(let-values(((syntax-module-path-index-shift_0)"
"(lambda(s55_0 from-mpi56_0 to-mpi57_0 inspector54_0)"
"(begin"
" 'syntax-module-path-index-shift"
"(let-values(((s_0) s55_0))"
"(let-values(((from-mpi_0) from-mpi56_0))"
"(let-values(((to-mpi_0) to-mpi57_0))"
"(let-values(((inspector_0) inspector54_0))"
"(let-values()"
"(let-values(((s58_0) s_0)"
"((from-mpi59_0) from-mpi_0)"
"((to-mpi60_0) to-mpi_0)"
"((inspector61_0) inspector_0))"
"(syntax-module-path-index-shift.1"
" #f"
" s58_0"
" from-mpi59_0"
" to-mpi60_0"
" inspector61_0)))))))))))"
"(case-lambda"
"((s_0 from-mpi_0 to-mpi_0)"
"(begin"
" 'syntax-module-path-index-shift"
"(syntax-module-path-index-shift_0 s_0 from-mpi_0 to-mpi_0 #f)))"
"((s_0 from-mpi_0 to-mpi_0 inspector54_0)"
"(syntax-module-path-index-shift_0 s_0 from-mpi_0 to-mpi_0 inspector54_0))))))"
" syntax-module-path-index-shift_0))"
"(define-values"
"(deserialize-instance)"
"(1/make-instance"
" 'deserialize"
" #f"
" 'consistent"
" 'deserialize-module-path-indexes"
" deserialize-module-path-indexes"
" 'syntax-module-path-index-shift"
" syntax-module-path-index-shift/no-keywords"
" 'syntax-shift-phase-level"
" syntax-shift-phase-level$1"
" 'force-syntax-object"
" force-syntax-object"
" 'module-use"
" module-use1.1"
" 'deserialize"
" deserialize))"
"(define-values"
"(struct:parsed parsed1.1 parsed? parsed-s)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'parsed #f 1 0 #f(list(cons prop:authentic #t)) #f #f '(0) #f 'parsed)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 's))))"
"(define-values"
"(struct:parsed-id parsed-id2.1 parsed-id? parsed-id-binding parsed-id-inspector)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-id"
" struct:parsed"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'parsed-id)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'binding)"
"(make-struct-field-accessor -ref_0 1 'inspector))))"
"(define-values"
"(struct:parsed-primitive-id parsed-primitive-id3.1 parsed-primitive-id?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-primitive-id"
" struct:parsed-id"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-primitive-id)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-top-id parsed-top-id4.1 parsed-top-id?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-top-id"
" struct:parsed-id"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-top-id)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-lambda parsed-lambda5.1 parsed-lambda? parsed-lambda-keys parsed-lambda-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-lambda"
" struct:parsed"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'parsed-lambda)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'keys)"
"(make-struct-field-accessor -ref_0 1 'body))))"
"(define-values"
"(struct:parsed-case-lambda parsed-case-lambda6.1 parsed-case-lambda? parsed-case-lambda-clauses)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-case-lambda"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-case-lambda)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'clauses))))"
"(define-values"
"(struct:parsed-app parsed-app7.1 parsed-app? parsed-app-rator parsed-app-rands)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-app"
" struct:parsed"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'parsed-app)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'rator)"
"(make-struct-field-accessor -ref_0 1 'rands))))"
"(define-values"
"(struct:parsed-if parsed-if8.1 parsed-if? parsed-if-tst parsed-if-thn parsed-if-els)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-if"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-if)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'tst)"
"(make-struct-field-accessor -ref_0 1 'thn)"
"(make-struct-field-accessor -ref_0 2 'els))))"
"(define-values"
"(struct:parsed-set! parsed-set!9.1 parsed-set!? parsed-set!-id parsed-set!-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-set!"
" struct:parsed"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'parsed-set!)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'rhs))))"
"(define-values"
"(struct:parsed-with-continuation-mark"
" parsed-with-continuation-mark10.1"
" parsed-with-continuation-mark?"
" parsed-with-continuation-mark-key"
" parsed-with-continuation-mark-val"
" parsed-with-continuation-mark-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-with-continuation-mark"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-with-continuation-mark)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'key)"
"(make-struct-field-accessor -ref_0 1 'val)"
"(make-struct-field-accessor -ref_0 2 'body))))"
"(define-values"
"(struct:parsed-#%variable-reference"
" parsed-#%variable-reference11.1"
" parsed-#%variable-reference?"
" parsed-#%variable-reference-id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-#%variable-reference"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-#%variable-reference)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'id))))"
"(define-values"
"(struct:parsed-begin parsed-begin12.1 parsed-begin? parsed-begin-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-begin"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-begin)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'body))))"
"(define-values"
"(struct:parsed-begin0 parsed-begin013.1 parsed-begin0? parsed-begin0-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-begin0"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-begin0)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'body))))"
"(define-values"
"(struct:parsed-quote parsed-quote14.1 parsed-quote? parsed-quote-datum)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-quote"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-quote)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'datum))))"
"(define-values"
"(struct:parsed-quote-syntax parsed-quote-syntax15.1 parsed-quote-syntax? parsed-quote-syntax-datum)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-quote-syntax"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-quote-syntax)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'datum))))"
"(define-values"
"(struct:parsed-let_-values"
" parsed-let_-values16.1"
" parsed-let_-values?"
" parsed-let_-values-idss"
" parsed-let_-values-clauses"
" parsed-let_-values-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-let_-values"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-let_-values)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'idss)"
"(make-struct-field-accessor -ref_0 1 'clauses)"
"(make-struct-field-accessor -ref_0 2 'body))))"
"(define-values"
"(struct:parsed-let-values parsed-let-values17.1 parsed-let-values?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-let-values"
" struct:parsed-let_-values"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-let-values)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-letrec-values parsed-letrec-values18.1 parsed-letrec-values?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-letrec-values"
" struct:parsed-let_-values"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-letrec-values)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-define-values"
" parsed-define-values19.1"
" parsed-define-values?"
" parsed-define-values-ids"
" parsed-define-values-syms"
" parsed-define-values-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-define-values"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-define-values)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'ids)"
"(make-struct-field-accessor -ref_0 1 'syms)"
"(make-struct-field-accessor -ref_0 2 'rhs))))"
"(define-values"
"(struct:parsed-define-syntaxes"
" parsed-define-syntaxes20.1"
" parsed-define-syntaxes?"
" parsed-define-syntaxes-ids"
" parsed-define-syntaxes-syms"
" parsed-define-syntaxes-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-define-syntaxes"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-define-syntaxes)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'ids)"
"(make-struct-field-accessor -ref_0 1 'syms)"
"(make-struct-field-accessor -ref_0 2 'rhs))))"
"(define-values"
"(struct:parsed-begin-for-syntax parsed-begin-for-syntax21.1 parsed-begin-for-syntax? parsed-begin-for-syntax-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-begin-for-syntax"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-begin-for-syntax)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'body))))"
"(define-values"
"(struct:parsed-#%declare parsed-#%declare22.1 parsed-#%declare?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-#%declare"
" struct:parsed"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-#%declare)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-require parsed-require23.1 parsed-require? parsed-require-portal-syms)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-require"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-require)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'portal-syms))))"
"(define-values"
"(struct:parsed-#%module-begin"
" parsed-#%module-begin24.1"
" parsed-#%module-begin?"
" parsed-#%module-begin-body"
" parsed-#%module-begin-realm"
" parsed-#%module-begin-flatten-requires?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-#%module-begin"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-#%module-begin)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'body)"
"(make-struct-field-accessor -ref_0 1 'realm)"
"(make-struct-field-accessor -ref_0 2 'flatten-requires?))))"
"(define-values"
"(struct:parsed-module"
" parsed-module25.1"
" parsed-module?"
" parsed-module-star?"
" parsed-module-name-id"
" parsed-module-self"
" parsed-module-requires"
" parsed-module-recur-requires"
" parsed-module-flattened-requires"
" parsed-module-provides"
" parsed-module-root-ctx-simple?"
" parsed-module-encoded-root-ctx"
" parsed-module-body"
" parsed-module-realm"
" parsed-module-portal-syntaxes"
" parsed-module-compiled-module"
" parsed-module-compiled-submodules)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-module"
" struct:parsed"
" 14"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12 13)"
" #f"
" 'parsed-module)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'star?)"
"(make-struct-field-accessor -ref_0 1 'name-id)"
"(make-struct-field-accessor -ref_0 2 'self)"
"(make-struct-field-accessor -ref_0 3 'requires)"
"(make-struct-field-accessor -ref_0 4 'recur-requires)"
"(make-struct-field-accessor -ref_0 5 'flattened-requires)"
"(make-struct-field-accessor -ref_0 6 'provides)"
"(make-struct-field-accessor -ref_0 7 'root-ctx-simple?)"
"(make-struct-field-accessor -ref_0 8 'encoded-root-ctx)"
"(make-struct-field-accessor -ref_0 9 'body)"
"(make-struct-field-accessor -ref_0 10 'realm)"
"(make-struct-field-accessor -ref_0 11 'portal-syntaxes)"
"(make-struct-field-accessor -ref_0 12 'compiled-module)"
"(make-struct-field-accessor -ref_0 13 'compiled-submodules))))"
"(define-values"
"(struct:parsed-bundle parsed-bundle26.1 parsed-bundle? parsed-bundle-bundle)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-bundle"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-bundle)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'bundle))))"
"(define-values"
"(add-space-scope)"
"(lambda(stx_0 space_0)(begin(if space_0(add-scope stx_0(make-interned-scope space_0)) stx_0))))"
"(define-values"
"(remove-space-scope)"
"(lambda(stx_0 space_0)(begin(if space_0(remove-scope stx_0(make-interned-scope space_0)) stx_0))))"
"(define-values"
"(module-path->mpi.1)"
"(lambda(declared-submodule-names1_0 mod-path3_0 self4_0)"
"(begin"
" 'module-path->mpi"
"(let-values(((mod-path_0) mod-path3_0))"
"(let-values(((self_0) self4_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names1_0))"
"(let-values()"
"(if(if(list? mod-path_0)"
"(if(= 2(length mod-path_0))"
"(if(eq? 'quote(car mod-path_0))"
"(if(symbol?(cadr mod-path_0))(hash-ref declared-submodule-names_0(cadr mod-path_0) #f) #f)"
" #f)"
" #f)"
" #f)"
"                (let-values () (module-path-index-join* (list 'submod \".\" (cadr mod-path_0)) self_0))"
"(if(if(list? mod-path_0)"
"(if(eq? 'submod(car mod-path_0))"
"(let-values(((mod-path_1)(cadr mod-path_0)))"
"(if(list? mod-path_1)"
"(if(= 2(length mod-path_1))"
"(if(eq? 'quote(car mod-path_1))"
"(if(symbol?(cadr mod-path_1))"
"(hash-ref declared-submodule-names_0(cadr mod-path_1) #f)"
" #f)"
" #f)"
" #f)"
" #f))"
" #f)"
" #f)"
"(let-values()"
"                    (module-path-index-join* (list* 'submod \".\" (cadr (cadr mod-path_0)) (cddr mod-path_0)) self_0))"
"(let-values()(module-path-index-join* mod-path_0 self_0)))))))))))"
"(define-values"
"(module-path->mpi/context)"
"(lambda(mod-path_0 ctx_0)"
"(begin"
"(let-values(((mod-path6_0) mod-path_0)"
"((temp7_0)(namespace-mpi(expand-context-namespace ctx_0)))"
"((temp8_0)(expand-context-declared-submodule-names ctx_0)))"
"(module-path->mpi.1 temp8_0 mod-path6_0 temp7_0)))))"
"(define-values"
"(syntax-mapped-names.1)"
"(lambda(exactly?2_0 only-interned?1_0 s5_0 phase6_0)"
"(begin"
" 'syntax-mapped-names"
"(let-values(((s_0) s5_0))"
"(let-values(((phase_0) phase6_0))"
"(let-values(((only-interned?_0) only-interned?1_0))"
"(let-values(((exactly?_0) exactly?2_0))"
"(let-values()"
"(let-values(((s-scs_0)(syntax-scope-set s_0 phase_0)))"
"(let-values(((syms_0)(let-values(((syms_0)(seteq))) syms_0)))"
"(let-values(((ht_0) s-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(syms_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((syms_2)"
"(let-values(((syms_2)"
"(let-values()"
"(set-union"
" syms_1"
"(let-values(((temp13_0)"
"(scope-binding-table"
" sc_0))"
"((s-scs14_0) s-scs_0)"
"((s15_0) s_0)"
"((null16_0) null)"
"((only-interned?17_0)"
" only-interned?_0)"
"((exactly?18_0)"
" exactly?_0))"
"(binding-table-symbols.1"
" exactly?18_0"
" only-interned?17_0"
" temp13_0"
" s-scs14_0"
" s15_0"
" null16_0))))))"
"(values syms_2))))"
"(if(not #f)"
"(for-loop_0"
" syms_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" syms_2)))"
" syms_1))))))"
" for-loop_0)"
" syms_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))))))))"
"(define-values"
"(syntax-mapped-phases)"
"(lambda(s_0)"
"(begin"
"(let-values(((smss_0)(fallback-first(syntax-shifted-multi-scopes s_0))))"
"(let-values(((phases_0)(let-values(((phases_0)(seteqv))) phases_0)))"
"(let-values(((ht_0) smss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(phases_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sms_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((phases_2)"
"(let-values(((phases_2)"
"(let-values()"
"(shifted-multi-scope-add-binding-phases"
" sms_0"
" phases_1))))"
"(values phases_2))))"
"(if(not #f)"
"(for-loop_0 phases_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" phases_2)))"
" phases_1))))))"
" for-loop_0)"
" phases_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))"
"(define-values"
"(syntax-mapped-interned-scope-symbols.1)"
"(lambda(exactly?8_0 s10_0 phase11_0)"
"(begin"
" 'syntax-mapped-interned-scope-symbols"
"(let-values(((s_0) s10_0))"
"(let-values(((phase_0) phase11_0))"
"(let-values(((exactly?_0) exactly?8_0))"
"(let-values()"
"(let-values(((s-scs_0)(syntax-scope-set s_0 phase_0)))"
"(let-values(((sym_0)(syntax-e$1 s_0)))"
"(let-values(((syms_0)(let-values(((syms_0)(seteq))) syms_0)))"
"(let-values(((ht_0) s-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(syms_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((syms_2)"
"(let-values(((syms_2)"
"(let-values()"
"(set-union"
" syms_1"
"(let-values(((temp19_0)"
"(scope-binding-table"
" sc_0))"
"((s-scs20_0) s-scs_0)"
"((sym21_0) sym_0)"
"((s22_0) s_0)"
"((null23_0) null)"
"((exactly?24_0)"
" exactly?_0)"
"((interned-scope?25_0)"
" interned-scope?)"
"((interned-scope-key26_0)"
" interned-scope-key))"
"(binding-table-interned-scope-keys.1"
" exactly?24_0"
" temp19_0"
" s-scs20_0"
" sym21_0"
" s22_0"
" null23_0"
" interned-scope?25_0"
" interned-scope-key26_0))))))"
"(values syms_2))))"
"(if(not #f)"
"(for-loop_0"
" syms_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" syms_2)))"
" syms_1))))))"
" for-loop_0)"
" syms_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))))))))"
"(define-values"
"(struct:requires+provides"
" requires+provides1.1"
" requires+provides?"
" requires+provides-self"
" requires+provides-require-mpis"
" requires+provides-require-mpis-in-order"
" requires+provides-requires"
" requires+provides-transitive-requires"
" requires+provides-provides"
" requires+provides-phase-to-defined-syms"
" requires+provides-also-required"
" requires+provides-spaces"
" requires+provides-portal-syntaxes"
" requires+provides-can-cross-phase-persistent?"
" requires+provides-all-bindings-simple?"
" requires+provides-definitions-shadow-imports?"
" set-requires+provides-can-cross-phase-persistent?!"
" set-requires+provides-all-bindings-simple?!"
" set-requires+provides-definitions-shadow-imports?!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'requires+provides"
" #f"
" 13"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9)"
" #f"
" 'requires+provides)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'self)"
"(make-struct-field-accessor -ref_0 1 'require-mpis)"
"(make-struct-field-accessor -ref_0 2 'require-mpis-in-order)"
"(make-struct-field-accessor -ref_0 3 'requires)"
"(make-struct-field-accessor -ref_0 4 'transitive-requires)"
"(make-struct-field-accessor -ref_0 5 'provides)"
"(make-struct-field-accessor -ref_0 6 'phase-to-defined-syms)"
"(make-struct-field-accessor -ref_0 7 'also-required)"
"(make-struct-field-accessor -ref_0 8 'spaces)"
"(make-struct-field-accessor -ref_0 9 'portal-syntaxes)"
"(make-struct-field-accessor -ref_0 10 'can-cross-phase-persistent?)"
"(make-struct-field-accessor -ref_0 11 'all-bindings-simple?)"
"(make-struct-field-accessor -ref_0 12 'definitions-shadow-imports?)"
"(make-struct-field-mutator -set!_0 10 'can-cross-phase-persistent?)"
"(make-struct-field-mutator -set!_0 11 'all-bindings-simple?)"
"(make-struct-field-mutator -set!_0 12 'definitions-shadow-imports?))))"
"(define-values"
"(struct:required"
" required2.1"
" required?"
" required-id"
" required-phase+space"
" required-can-be-shadowed?"
" required-as-transformer?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'required"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'required)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'phase+space)"
"(make-struct-field-accessor -ref_0 2 'can-be-shadowed?)"
"(make-struct-field-accessor -ref_0 3 'as-transformer?))))"
"(define-values"
"(struct:bulk-required"
" bulk-required3.1"
" bulk-required?"
" bulk-required-provides"
" bulk-required-prefix-len"
" bulk-required-s"
" bulk-required-provide-phase+space"
" bulk-required-can-be-shadowed?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-required"
" #f"
" 5"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4)"
" #f"
" 'bulk-required)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'provides)"
"(make-struct-field-accessor -ref_0 1 'prefix-len)"
"(make-struct-field-accessor -ref_0 2 's)"
"(make-struct-field-accessor -ref_0 3 'provide-phase+space)"
"(make-struct-field-accessor -ref_0 4 'can-be-shadowed?))))"
"(define-values"
"(make-requires+provides.1)"
"(lambda(copy-requires4_0 portal-syntaxes5_0 self8_0)"
"(begin"
" 'make-requires+provides"
"(let-values(((self_0) self8_0))"
"(let-values(((copy-r+p_0) copy-requires4_0))"
"(let-values(((portal-syntaxes_0)"
"(if(eq? portal-syntaxes5_0 unsafe-undefined)"
"(if copy-r+p_0(hash-copy(requires+provides-portal-syntaxes copy-r+p_0)) #f)"
" portal-syntaxes5_0)))"
"(let-values()"
"(requires+provides1.1"
" self_0"
"(if copy-r+p_0(requires+provides-require-mpis copy-r+p_0)(make-module-path-index-intern-table))"
"(if copy-r+p_0(hash-copy(requires+provides-require-mpis-in-order copy-r+p_0))(make-hasheqv))"
"(make-hasheq)"
"(make-hasheq)"
"(make-hasheqv)"
"(make-hasheqv)"
"(make-hasheq)"
"(make-hasheq)"
" portal-syntaxes_0"
" #t"
" #t"
" #t))))))))"
"(define-values"
"(requires+provides-reset!)"
"(lambda(r+p_0)"
"(begin"
"(begin"
"(hash-clear!(requires+provides-requires r+p_0))"
"(hash-clear!(requires+provides-transitive-requires r+p_0))"
"(hash-clear!(requires+provides-provides r+p_0))"
"(hash-clear!(requires+provides-phase-to-defined-syms r+p_0))"
"(hash-clear!(requires+provides-also-required r+p_0))"
"(hash-clear!(requires+provides-spaces r+p_0))))))"
"(define-values"
"(intern-mpi)"
"(lambda(r+p_0 mpi_0)(begin(intern-module-path-index!(requires+provides-require-mpis r+p_0) mpi_0))))"
"(define-values"
"(add-required-space!)"
"(lambda(r+p_0 space_0)"
"(begin(if space_0(let-values()(hash-set!(requires+provides-spaces r+p_0) space_0 #t))(void)))))"
"(define-values"
"(add-required-module!)"
"(lambda(r+p_0 mod-name_0 phase+space-shift_0 is-cross-phase-persistent?_0)"
"(begin"
"(let-values(((mpi_0)(intern-mpi r+p_0 mod-name_0)))"
"(begin"
"(if(hash-ref(hash-ref(requires+provides-requires r+p_0) mpi_0 '#hasheqv()) phase+space-shift_0 #f)"
"(void)"
"(let-values()"
"(begin"
"(hash-update!"
"(requires+provides-require-mpis-in-order r+p_0)"
"(phase+space-shift-phase-level phase+space-shift_0)"
"(lambda(l_0)(cons mpi_0 l_0))"
" null)"
"(hash-set!"
"(hash-ref!(requires+provides-requires r+p_0) mpi_0 make-hasheqv)"
" phase+space-shift_0"
"(make-hasheq)))))"
"(if is-cross-phase-persistent?_0"
"(void)"
"(let-values()(set-requires+provides-can-cross-phase-persistent?! r+p_0 #f)))"
" mpi_0)))))"
"(define-values"
"(add-defined-or-required-id!.1)"
"(lambda(as-transformer?11_0 can-be-shadowed?10_0 r+p14_0 id15_0 phase+space16_0 binding17_0)"
"(begin"
" 'add-defined-or-required-id!"
"(let-values(((r+p_0) r+p14_0))"
"(let-values(((id_0) id15_0))"
"(let-values(((phase+space_0) phase+space16_0))"
"(let-values(((binding_0) binding17_0))"
"(let-values(((can-be-shadowed?_0) can-be-shadowed?10_0))"
"(let-values(((as-transformer?_0) as-transformer?11_0))"
"(let-values()"
"(begin"
"(if(eqv?"
" phase+space_0"
"(phase+space+"
"(module-binding-nominal-phase+space binding_0)"
"(module-binding-nominal-require-phase+space-shift binding_0)))"
"(void)"
"                        (let-values () (error \"internal error: binding phase+space does not match nominal info\")))"
"(let-values(((r+p109_0) r+p_0)"
"((id110_0) id_0)"
"((phase+space111_0) phase+space_0)"
"((temp112_0)(module-binding-nominal-module binding_0))"
"((temp113_0)(module-binding-nominal-require-phase+space-shift binding_0))"
"((can-be-shadowed?114_0) can-be-shadowed?_0)"
"((as-transformer?115_0) as-transformer?_0))"
"(add-defined-or-required-id-at-nominal!.1"
" as-transformer?115_0"
" can-be-shadowed?114_0"
" temp112_0"
" temp113_0"
" r+p109_0"
" id110_0"
" phase+space111_0)))))))))))))"
"(define-values"
"(add-defined-or-required-id-at-nominal!.1)"
"(lambda(as-transformer?22_0"
" can-be-shadowed?21_0"
" nominal-module19_0"
" nominal-require-phase+space-shift20_0"
" r+p27_0"
" id28_0"
" phase+space29_0)"
"(begin"
" 'add-defined-or-required-id-at-nominal!"
"(let-values(((r+p_0) r+p27_0))"
"(let-values(((id_0) id28_0))"
"(let-values(((phase+space_0) phase+space29_0))"
"(let-values(((nominal-module_0) nominal-module19_0))"
"(let-values(((nominal-require-phase+space-shift_0) nominal-require-phase+space-shift20_0))"
"(let-values(((can-be-shadowed?_0) can-be-shadowed?21_0))"
"(let-values(((as-transformer?_0) as-transformer?22_0))"
"(let-values()"
"(let-values(((at-mod_0)"
"(hash-ref!"
"(requires+provides-requires r+p_0)"
"(intern-mpi r+p_0 nominal-module_0)"
" make-hasheqv)))"
"(let-values(((sym-to-reqds_0)"
"(hash-ref! at-mod_0 nominal-require-phase+space-shift_0 make-hasheq)))"
"(let-values(((sym_0)(syntax-e$1 id_0)))"
"(hash-set!"
" sym-to-reqds_0"
" sym_0"
"(cons-ish"
"(required2.1 id_0 phase+space_0 can-be-shadowed?_0 as-transformer?_0)"
"(hash-ref sym-to-reqds_0 sym_0 null)))))))))))))))))"
"(define-values"
"(add-bulk-required-ids!.1)"
"(lambda(accum-update-nominals37_0"
" can-be-shadowed?35_0"
" check-and-remove?36_0"
" excepts32_0"
" in34_0"
" prefix31_0"
" symbols-accum33_0"
" who38_0"
" r+p47_0"
" s48_0"
" self49_0"
" nominal-module50_0"
" phase-level51_0"
" provides52_0"
" provide-phase+space53_0)"
"(begin"
" 'add-bulk-required-ids!"
"(let-values(((r+p_0) r+p47_0))"
"(let-values(((s_0) s48_0))"
"(let-values(((self_0) self49_0))"
"(let-values(((nominal-module_0) nominal-module50_0))"
"(let-values(((phase-level_0) phase-level51_0))"
"(let-values(((provides_0) provides52_0))"
"(let-values(((provide-phase+space_0) provide-phase+space53_0))"
"(let-values(((bulk-prefix_0) prefix31_0))"
"(let-values(((bulk-excepts_0) excepts32_0))"
"(let-values(((symbols-accum_0) symbols-accum33_0))"
"(let-values(((orig-s_0) in34_0))"
"(let-values(((can-be-shadowed?_0) can-be-shadowed?35_0))"
"(let-values(((check-and-remove?_0) check-and-remove?36_0))"
"(let-values(((accum-update-nominals_0) accum-update-nominals37_0))"
"(let-values(((who_0) who38_0))"
"(let-values()"
"(let-values(((phase+space_0)(phase+space+ provide-phase+space_0 phase-level_0)))"
"(let-values(((phase_0)(phase+space-phase phase+space_0)))"
"(let-values(((space_0)(phase+space-space phase+space_0)))"
"(let-values(((s-at-space_0)(add-space-scope s_0 space_0)))"
"(let-values(((shortcut-table_0)"
"(if check-and-remove?_0"
"(if(>(hash-count provides_0) 64)"
"(let-values(((s-at-space116_0) s-at-space_0)"
"((phase117_0) phase_0))"
"(syntax-mapped-names.1"
" #f"
" #f"
" s-at-space116_0"
" phase117_0))"
" #f)"
" #f)))"
"(let-values(((mpi_0)(intern-mpi r+p_0 nominal-module_0)))"
"(let-values(((at-mod_0)"
"(hash-ref!"
"(requires+provides-requires r+p_0)"
" mpi_0"
" make-hasheqv)))"
"(let-values(((sym-to-reqds_0)"
"(hash-ref! at-mod_0 phase-level_0 make-hasheq)))"
"(let-values(((prefix-len_0)"
"(if bulk-prefix_0"
"(string-length(symbol->string bulk-prefix_0))"
" 0)))"
"(let-values(((br_0)"
"(bulk-required3.1"
" provides_0"
" prefix-len_0"
" s_0"
" provide-phase+space_0"
" can-be-shadowed?_0)))"
"(let-values(((any-already-defined?_0)"
"(let-values(((any-already-defined?_0) #f))"
" any-already-defined?_0)))"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(any-already-defined?_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((out-sym_0"
" binding/p_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((any-already-defined?_2)"
"(if(not"
"(symbol-interned?"
" out-sym_0))"
" any-already-defined?_1"
"(let-values(((any-already-defined?_2)"
"(let-values()"
"(begin"
"(if symbols-accum_0"
"(let-values()"
"(hash-set!"
" symbols-accum_0"
" out-sym_0"
" #t))"
"(void))"
"(if(hash-ref"
" bulk-excepts_0"
" out-sym_0"
" #f)"
"(let-values()"
" #f)"
"(let-values()"
"(let-values(((sym_0)"
"(if(not"
" bulk-prefix_0)"
"(let-values()"
" out-sym_0)"
"(let-values()"
"(string->symbol"
"(string-append"
"(symbol->string"
" bulk-prefix_0)"
"(symbol->string"
" out-sym_0)))))))"
"(let-values(((bound-status_0)"
"(if(if check-and-remove?_0"
"(let-values(((or-part_0)"
"(not"
" shortcut-table_0)))"
"(if or-part_0"
" or-part_0"
"(hash-ref"
" shortcut-table_0"
" sym_0"
" #f)))"
" #f)"
"(let-values()"
"(let-values(((id_0)"
"(datum->syntax$1"
" s-at-space_0"
" sym_0"
" s-at-space_0)))"
"(begin"
"(adjust-shadow-requires!"
" r+p_0"
" id_0"
" phase_0"
" space_0)"
"(let-values(((temp118_0)"
" #t)"
"((temp119_0)"
"(requires+provides-definitions-shadow-imports?"
" r+p_0))"
"((r+p120_0)"
" r+p_0)"
"((id121_0)"
" id_0)"
"((phase122_0)"
" phase_0)"
"((space123_0)"
" space_0)"
"((orig-s124_0)"
" orig-s_0)"
"((temp125_0)"
"(lambda()"
"(let-values(((binding/p129_0)"
" binding/p_0)"
"((sym130_0)"
" sym_0)"
"((self131_0)"
" self_0)"
"((mpi132_0)"
" mpi_0)"
"((provide-phase+space133_0)"
" provide-phase+space_0)"
"((phase-level134_0)"
" phase-level_0))"
"(provide-binding-to-require-binding.1"
" mpi132_0"
" phase-level134_0"
" provide-phase+space133_0"
" self131_0"
" binding/p129_0"
" sym130_0))))"
"((temp126_0)"
" #t)"
"((accum-update-nominals127_0)"
" accum-update-nominals_0)"
"((who128_0)"
" who_0))"
"(check-not-defined.1"
" accum-update-nominals127_0"
" temp119_0"
" temp118_0"
" orig-s124_0"
" temp126_0"
" temp125_0"
" who128_0"
" r+p120_0"
" id121_0"
" phase122_0"
" space123_0)))))"
"(let-values()"
" #f))))"
"(let-values(((already-defined?_0)"
"(eq?"
" bound-status_0"
" 'defined)))"
"(begin"
"(if already-defined?_0"
"(void)"
"(let-values()"
"(hash-set!"
" sym-to-reqds_0"
" sym_0"
"(cons-ish"
" br_0"
"(hash-ref"
" sym-to-reqds_0"
" sym_0"
" null)))))"
"(let-values(((or-part_0)"
" any-already-defined?_1))"
"(if or-part_0"
" or-part_0"
" already-defined?_0))))))))))))"
"(values"
" any-already-defined?_2)))))"
"(if(not #f)"
"(for-loop_0"
" any-already-defined?_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" any-already-defined?_2)))"
" any-already-defined?_1))))))"
" for-loop_0)"
" any-already-defined?_0"
"(hash-iterate-first"
" ht_0))))))))))))))))))))))))))))))))))"
"(define-values"
"(bulk-required->required)"
"(lambda(br_0 nominal-module_0 phase+space-shift_0 sym_0)"
"(begin"
"(let-values(((prefix-len_0)(bulk-required-prefix-len br_0)))"
"(let-values(((out-sym_0)"
"(if(zero? prefix-len_0) sym_0(string->symbol(substring(symbol->string sym_0) prefix-len_0)))))"
"(let-values(((binding/p_0)(hash-ref(bulk-required-provides br_0) out-sym_0)))"
"(let-values(((phase+space_0)(phase+space+(bulk-required-provide-phase+space br_0) phase+space-shift_0)))"
"(required2.1"
"(add-space-scope(datum->syntax$1(bulk-required-s br_0) sym_0)(phase+space-space phase+space_0))"
" phase+space_0"
"(bulk-required-can-be-shadowed? br_0)"
"(provided-as-transformer? binding/p_0)))))))))"
"(define-values"
"(normalize-required)"
"(lambda(r_0 mod-name_0 phase+space-shift_0 sym_0)"
"(begin(if(bulk-required? r_0)(bulk-required->required r_0 mod-name_0 phase+space-shift_0 sym_0) r_0))))"
"(define-values"
"(add-enclosing-module-defined-and-required!.1)"
"(lambda(enclosing-requires+provides55_0 r+p57_0 enclosing-mod58_0 phase-level59_0)"
"(begin"
" 'add-enclosing-module-defined-and-required!"
"(let-values(((r+p_0) r+p57_0))"
"(let-values(((enclosing-r+p_0) enclosing-requires+provides55_0))"
"(let-values(((enclosing-mod_0) enclosing-mod58_0))"
"(let-values(((phase-level_0) phase-level59_0))"
"(let-values()"
"(begin"
"(set-requires+provides-all-bindings-simple?! r+p_0 #f)"
"(let-values()"
"(let-values(((ht_0)(requires+provides-requires enclosing-r+p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((mod-name_0 at-mod_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_1) at-mod_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((phase+space-shift_0"
" at-phase_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values((()"
"(let-values(((ht_2)"
" at-phase_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_2)))"
"((letrec-values(((for-loop_2)"
"(lambda(i_2)"
"(begin"
" 'for-loop"
"(if i_2"
"(let-values(((sym_0"
" reqds_0)"
"(hash-iterate-key+value"
" ht_2"
" i_2)))"
"(let-values((()"
"(let-values(((lst_0)"
" reqds_0))"
"((letrec-values(((for-loop_3)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" lst_1))"
"(let-values(((reqd/maybe-bulk_0)"
"(if(pair?"
" lst_1)"
"(car"
" lst_1)"
" lst_1))"
"((rest_0)"
"(if(pair?"
" lst_1)"
"(cdr"
" lst_1)"
" null)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((reqd_0)"
"(normalize-required"
" reqd/maybe-bulk_0"
" mod-name_0"
" phase+space-shift_0"
" sym_0)))"
"(let-values(((r+p135_0)"
" r+p_0)"
"((temp136_0)"
"(syntax-shift-phase-level$1"
"(let-values(((temp142_0)"
"(required-id"
" reqd_0))"
"((temp143_0)"
"(requires+provides-self"
" enclosing-r+p_0))"
"((enclosing-mod144_0)"
" enclosing-mod_0))"
"(syntax-module-path-index-shift.1"
" #f"
" temp142_0"
" temp143_0"
" enclosing-mod144_0"
" #f))"
" phase-level_0))"
"((temp137_0)"
"(phase+space+"
"(required-phase+space"
" reqd_0)"
" phase-level_0))"
"((enclosing-mod138_0)"
" enclosing-mod_0)"
"((phase-level139_0)"
" phase-level_0)"
"((temp140_0)"
" #t)"
"((temp141_0)"
"(required-as-transformer?"
" reqd_0)))"
"(add-defined-or-required-id-at-nominal!.1"
" temp141_0"
" temp140_0"
" enclosing-mod138_0"
" phase-level139_0"
" r+p135_0"
" temp136_0"
" temp137_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_3"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_3)"
" lst_0))))"
"(if(not"
" #f)"
"(for-loop_2"
"(hash-iterate-next"
" ht_2"
" i_2))"
"(values))))"
"(values))))))"
" for-loop_2)"
"(hash-iterate-first"
" ht_2))))))"
"(if(not"
" #f)"
"(for-loop_1"
"(hash-iterate-next"
" ht_1"
" i_1))"
"(values))))"
"(values))))))"
" for-loop_1)"
"(hash-iterate-first"
" ht_1)))))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void))))))))))"
"(define-values"
"(remove-required-id!)"
"(lambda(r+p_0 id_0 phase_0)"
"(begin"
"(let-values(((remove!_0)"
"(lambda(bind-as-ambiguous?145_0 id147_0)"
"(begin"
" 'remove!"
"(let-values(((id_1) id147_0))"
"(let-values(((bind-as-ambiguous?_0) bind-as-ambiguous?145_0))"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id150_0) id_1)((phase151_0) phase_0)((temp152_0) #t))"
"(resolve+shift.1"
" #f"
" temp152_0"
" null"
" unsafe-undefined"
" #f"
" id150_0"
" phase151_0))))"
"(if(if(module-binding? b_0)"
"(not(eq?(requires+provides-self r+p_0)(module-binding-module b_0)))"
" #f)"
"(let-values()"
"(let-values((()"
"(begin"
"(if bind-as-ambiguous?_0"
"(let-values()"
"(let-values(((id153_0) id_1)"
"((temp154_0)(like-ambiguous-binding1.1))"
"((phase155_0) phase_0))"
"(add-binding!.1 #f #f id153_0 temp154_0 phase155_0)))"
"(void))"
"(values))))"
"(let-values(((mpi_0)(intern-mpi r+p_0(module-binding-nominal-module b_0))))"
"(let-values(((at-mod_0)"
"(hash-ref(requires+provides-requires r+p_0) mpi_0 #f)))"
"(if at-mod_0"
"(let-values()"
"(let-values(((nominal-phase+space-shift_0)"
"(module-binding-nominal-require-phase+space-shift b_0)))"
"(let-values(((sym-to-reqds_0)"
"(hash-ref at-mod_0 nominal-phase+space-shift_0 #f)))"
"(if sym-to-reqds_0"
"(let-values()"
"(let-values(((sym_0)(syntax-e$1 id_1)))"
"(let-values(((l_0)(hash-ref sym-to-reqds_0 sym_0 null)))"
"(if(null? l_0)"
"(void)"
"(let-values()"
"(hash-set!"
" sym-to-reqds_0"
" sym_0"
"(remove-non-matching-requireds"
" l_0"
" id_1"
" phase_0"
" mpi_0"
" nominal-phase+space-shift_0"
" sym_0)))))))"
"(void)))))"
"(void))))))"
"(void))))))))))"
"(let-values()"
"(let-values()"
"(begin"
"(let-values(((id149_0) id_0))(remove!_0 #f id149_0))"
"(let-values()"
"(let-values(((ht_0)(requires+provides-spaces r+p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((space_0)(hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((temp156_0)"
"(add-space-scope"
" id_0"
" space_0))"
"((temp157_0) #t))"
"(remove!_0 temp157_0 temp156_0)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void))))))))"
"(define-values"
"(remove-non-matching-requireds)"
"(lambda(reqds_0 id_0 phase_0 mpi_0 nominal-phase+space-shift_0 sym_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) reqds_0))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(not(null? lst_1))"
"(let-values(((r_0)(if(pair? lst_1)(car lst_1) lst_1))"
"((rest_0)(if(pair? lst_1)(cdr lst_1) null)))"
"(let-values(((fold-var_2)"
"(let-values(((id*_0)"
"(normalize-required"
" r_0"
" mpi_0"
" nominal-phase+space-shift_0"
" sym_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2)"
"(begin"
" 'for-loop"
"(let-values(((r_1) id*_0))"
"(let-values(((fold-var_3)"
"(if(if(eqv?"
" phase_0"
"(phase+space-phase"
"(required-phase+space"
" r_1)))"
"(free-identifier=?$1"
"(required-id r_1)"
" id_0"
" phase_0"
" phase_0)"
" #f)"
" fold-var_2"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
" r_1)"
" fold-var_2))))"
"(values fold-var_3)))))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_1))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(define-values"
"(check-not-defined.1)"
"(lambda(accum-update-nominals66_0"
" allow-defined?62_0"
" check-not-required?61_0"
" in63_0"
" remove-shadowed!?65_0"
" unless-matches64_0"
" who67_0"
" r+p75_0"
" id76_0"
" phase77_0"
" space78_0)"
"(begin"
" 'check-not-defined"
"(let-values(((check-not-required?_0) check-not-required?61_0))"
"(let-values(((allow-defined?_0) allow-defined?62_0))"
"(let-values(((r+p_0) r+p75_0))"
"(let-values(((id_0) id76_0))"
"(let-values(((phase_0) phase77_0))"
"(let-values(((space_0) space78_0))"
"(let-values(((orig-s_0) in63_0))"
"(let-values(((ok-binding/delayed_0) unless-matches64_0))"
"(let-values(((remove-shadowed!?_0) remove-shadowed!?65_0))"
"(let-values(((accum-update-nominals_0) accum-update-nominals66_0))"
"(let-values(((who_0) who67_0))"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id158_0) id_0)((phase159_0) phase_0)((temp160_0) #t))"
"(resolve+shift.1"
" #f"
" temp160_0"
" null"
" unsafe-undefined"
" #f"
" id158_0"
" phase159_0))))"
"(let-values(((check-default-space_0)"
"(lambda()"
"(begin"
" 'check-default-space"
"(if(let-values(((or-part_0)(not space_0)))"
"(if or-part_0 or-part_0(not check-not-required?_0)))"
"(let-values() #f)"
"(let-values()"
"(let-values(((default-b_0)"
"(let-values(((temp161_0)"
"(remove-space-scope id_0 space_0))"
"((phase162_0) phase_0)"
"((temp163_0) #t))"
"(resolve+shift.1"
" #f"
" temp163_0"
" null"
" unsafe-undefined"
" #f"
" temp161_0"
" phase162_0))))"
"(let-values(((defined?_0)"
"(if default-b_0"
"(eq?"
"(requires+provides-self r+p_0)"
"(module-binding-module default-b_0))"
" #f)))"
"(if defined?_0"
"(let-values()"
"(begin"
"(let-values(((id164_0) id_0)"
"((temp165_0)(like-ambiguous-binding1.1))"
"((phase166_0) phase_0))"
"(add-binding!.1 #f #f id164_0 temp165_0 phase166_0))"
" 'defined))"
"(let-values() #f))))))))))"
"(if(not b_0)"
"(let-values()(check-default-space_0))"
"(if(not(module-binding? b_0))"
"(let-values()"
"(if allow-defined?_0"
"(let-values()"
"(begin(set-requires+provides-all-bindings-simple?! r+p_0 #f) 'defined))"
"                                          (let-values () (raise-syntax-error$1 #f \"identifier out of context\" id_0))))"
"(let-values()"
"(let-values(((defined?_0)"
"(if b_0"
"(eq?(requires+provides-self r+p_0)(module-binding-module b_0))"
" #f)))"
"(if(if defined?_0"
"(not"
"(hash-ref"
"(hash-ref"
"(requires+provides-phase-to-defined-syms r+p_0)"
" phase_0"
" '#hasheq())"
"(module-binding-sym b_0)"
" #f))"
" #f)"
"(let-values()(check-default-space_0))"
"(let-values()"
"(let-values(((define-shadowing-require?_0)"
"(if(not defined?_0)"
"(if(requires+provides-definitions-shadow-imports? r+p_0)"
"(not check-not-required?_0)"
" #f)"
" #f)))"
"(let-values(((mpi_0)"
"(intern-mpi r+p_0(module-binding-nominal-module b_0))))"
"(let-values(((at-mod_0)"
"(hash-ref(requires+provides-requires r+p_0) mpi_0 #f)))"
"(let-values(((ok-binding_0)"
"(if(not define-shadowing-require?_0)"
"(if(procedure? ok-binding/delayed_0)"
"(ok-binding/delayed_0)"
" ok-binding/delayed_0)"
" #f)))"
"(let-values(((raise-already-bound_0)"
"(lambda(defined?_1 where_0)"
"(begin"
" 'raise-already-bound"
"(raise-syntax-error$1"
" who_0"
"(string-append"
"                                                                          \"identifier\""
"(if(if(not defined?_1)"
"(not check-not-required?_0)"
" #f)"
"                                                                            (let-values () \" for definition\")"
"(if(if defined?_1 check-not-required?_0 #f)"
"                                                                              (let-values () \" for require\")"
"                                                                              (let-values () \"\")))"
"                                                                          \" already \""
"                                                                          (if defined?_1 \"defined\" \"required\")"
"(if(zero-phase? phase_0)"
"                                                                            (let-values () \"\")"
"(if(label-phase? phase_0)"
"                                                                              (let-values () \" for label\")"
"(if(= 1 phase_0)"
"                                                                                (let-values () \" for syntax\")"
"(let-values()"
"                                                                                  (format \" for phase ~a\" phase_0))))))"
" orig-s_0"
" id_0"
" null"
"(if(bulk-required? where_0)"
"(let-values()"
"(format"
"                                                                              \"\\n  also provided by: ~a\""
"((error-syntax->string-handler)"
"(bulk-required-s where_0)"
"(error-print-width))))"
"                                                                           (let-values () \"\")))))))"
"(if(if(not at-mod_0)(not define-shadowing-require?_0) #f)"
"(let-values()(check-default-space_0))"
"(if(if ok-binding_0(same-binding? b_0 ok-binding_0) #f)"
"(let-values()"
"(begin"
"(if(same-binding-nominals? b_0 ok-binding_0)"
"(void)"
"(let-values()"
"(let-values(((update!_0)"
"(lambda()"
"(begin"
" 'update!"
"(let-values(((temp167_0) #t)"
"((id168_0) id_0)"
"((temp169_0)"
"(let-values(((ok-binding171_0)"
" ok-binding_0)"
"((temp172_0)"
"(cons"
" b_0"
"(module-binding-extra-nominal-bindings"
" b_0))))"
"(module-binding-update.1"
" unsafe-undefined"
" temp172_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" ok-binding171_0)))"
"((phase170_0)"
" phase_0))"
"(add-binding!.1"
" #f"
" temp167_0"
" id168_0"
" temp169_0"
" phase170_0))))))"
"(if accum-update-nominals_0"
"(let-values()"
"(set-box!"
" accum-update-nominals_0"
"(cons"
" update!_0"
"(unbox accum-update-nominals_0))))"
"(let-values()(update!_0))))))"
"(if defined?_0 'defined 'required)))"
"(if(if defined?_0 allow-defined?_0 #f)"
"(let-values()"
"(let-values(((also-required_0)"
"(requires+provides-also-required r+p_0)))"
"(let-values(((prev-b_0)"
"(hash-ref"
" also-required_0"
"(module-binding-sym b_0)"
" #f)))"
"(begin"
"(if(if prev-b_0"
"(not(same-binding? ok-binding_0 prev-b_0))"
" #f)"
"(let-values()(raise-already-bound_0 #f #f))"
"(void))"
"(hash-set!"
" also-required_0"
"(module-binding-sym b_0)"
" ok-binding_0)"
"(set-requires+provides-all-bindings-simple?!"
" r+p_0"
" #f)"
" 'defined))))"
"(let-values()"
"(let-values(((nominal-phase+space-shift_0)"
"(module-binding-nominal-require-phase+space-shift"
" b_0)))"
"(let-values(((sym-to-reqds_0)"
"(hash-ref"
" at-mod_0"
" nominal-phase+space-shift_0"
" '#hasheq())))"
"(let-values(((reqds_0)"
"(hash-ref"
" sym-to-reqds_0"
"(syntax-e$1 id_0)"
" null)))"
"(let-values(((only-can-can-shadow-require?_0)"
"(let-values(((only-can-can-shadow-require?_0)"
"(let-values(((only-can-can-shadow-require?_0)"
" #t))"
" only-can-can-shadow-require?_0)))"
"(let-values(((lst_0) reqds_0))"
"((letrec-values(((for-loop_0)"
"(lambda(only-can-can-shadow-require?_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(not"
"(null?"
" lst_1))"
"(let-values(((r_0)"
"(if(pair?"
" lst_1)"
"(car"
" lst_1)"
" lst_1))"
"((rest_0)"
"(if(pair?"
" lst_1)"
"(cdr"
" lst_1)"
" null)))"
"(let-values(((only-can-can-shadow-require?_2)"
"(let-values(((only-can-can-shadow-require?_2)"
"(let-values()"
"(if(if(bulk-required?"
" r_0)"
"(bulk-required-can-be-shadowed?"
" r_0)"
"(required-can-be-shadowed?"
" r_0))"
"(let-values()"
"(begin"
"(set-requires+provides-all-bindings-simple?!"
" r+p_0"
" #f)"
" only-can-can-shadow-require?_1))"
"(if define-shadowing-require?_0"
"(let-values()"
" #f)"
"(let-values()"
"(let-values(((nr_0)"
"(normalize-required"
" r_0"
" mpi_0"
" nominal-phase+space-shift_0"
"(syntax-e$1"
" id_0))))"
"(if(eqv?"
"(required-phase+space"
" nr_0)"
"(intern-phase+space"
" phase_0"
" space_0))"
"(raise-already-bound_0"
" defined?_0"
" r_0)"
" only-can-can-shadow-require?_1))))))))"
"(values"
" only-can-can-shadow-require?_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" only-can-can-shadow-require?_2"
" rest_0)"
" only-can-can-shadow-require?_2)))"
" only-can-can-shadow-require?_1))))))"
" for-loop_0)"
" only-can-can-shadow-require?_0"
" lst_0)))))"
"(begin"
"(if define-shadowing-require?_0"
"(let-values()"
"(begin"
"(set-requires+provides-all-bindings-simple?!"
" r+p_0"
" #f)"
"(if only-can-can-shadow-require?_0"
"(void)"
"(let-values()"
"(hash-set!"
"(requires+provides-also-required"
" r+p_0)"
"(module-binding-sym b_0)"
" b_0)))))"
"(let-values()"
"(if(if remove-shadowed!?_0"
"(not(null? reqds_0))"
" #f)"
"(let-values()"
"(hash-set!"
" sym-to-reqds_0"
"(syntax-e$1 id_0)"
"(remove-non-matching-requireds"
" reqds_0"
" id_0"
" phase_0"
" mpi_0"
" nominal-phase+space-shift_0"
"(syntax-e$1 id_0))))"
"(void))))"
" #f)))))))))))))))))))))))))))))))))))))"
"(define-values"
"(adjust-shadow-requires!)"
"(lambda(r+p_0 id_0 phase_0 space_0)"
"(begin"
"(if space_0"
"(void)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_0)(requires+provides-spaces r+p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((space_1)(hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((space-id_0)"
"(add-space-scope"
" id_0"
" space_1)))"
"(let-values(((b_0)"
"(let-values(((space-id173_0)"
" space-id_0)"
"((phase174_0)"
" phase_0)"
"((temp175_0)"
" #t))"
"(resolve+shift.1"
" #f"
" temp175_0"
" null"
" unsafe-undefined"
" #f"
" space-id173_0"
" phase174_0))))"
"(if(if(module-binding? b_0)"
"(not"
"(eq?"
"(requires+provides-self r+p_0)"
"(module-binding-module b_0)))"
" #f)"
"(let-values()"
"(let-values(((mpi_0)"
"(intern-mpi"
" r+p_0"
"(module-binding-nominal-module"
" b_0))))"
"(let-values(((at-mod_0)"
"(hash-ref"
"(requires+provides-requires"
" r+p_0)"
" mpi_0"
" #f)))"
"(if at-mod_0"
"(let-values()"
"(let-values(((nominal-phase+space-shift_0)"
"(module-binding-nominal-require-phase+space-shift"
" b_0)))"
"(let-values(((sym-to-reqds_0)"
"(hash-ref"
" at-mod_0"
" nominal-phase+space-shift_0"
" #f)))"
"(if sym-to-reqds_0"
"(let-values()"
"(let-values(((reqds_0)"
"(hash-ref"
" sym-to-reqds_0"
"(syntax-e$1"
" id_0)"
" null)))"
"(if(let-values(((result_0)"
"(let-values(((result_0)"
" #t))"
" result_0)))"
"(let-values(((lst_0)"
" reqds_0))"
"((letrec-values(((for-loop_1)"
"(lambda(result_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(not"
"(null?"
" lst_1))"
"(let-values(((r_0)"
"(if(pair?"
" lst_1)"
"(car"
" lst_1)"
" lst_1))"
"((rest_0)"
"(if(pair?"
" lst_1)"
"(cdr"
" lst_1)"
" null)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(bulk-required?"
" r_0)"
"(bulk-required-can-be-shadowed?"
" r_0)"
"(required-can-be-shadowed?"
" r_0))))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" r_0))"
"(not"
" #f)"
" #f)"
"(for-loop_1"
" result_2"
" rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_1)"
" result_0"
" lst_0)))"
"(let-values()"
"(begin"
"(hash-set!"
" sym-to-reqds_0"
"(syntax-e$1"
" id_0)"
"(remove-non-matching-requireds"
" reqds_0"
" space-id_0"
" phase_0"
" mpi_0"
" nominal-phase+space-shift_0"
"(syntax-e$1"
" id_0)))"
"(let-values(((space-id176_0)"
" space-id_0)"
"((temp177_0)"
"(like-ambiguous-binding1.1))"
"((phase178_0)"
" phase_0))"
"(add-binding!.1"
" #f"
" #f"
" space-id176_0"
" temp177_0"
" phase178_0))))"
"(void))))"
"(void)))))"
"(void)))))"
"(void)))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)))))))"
"(define-values"
"(add-defined-syms!.1)"
"(lambda(as-transformer?80_0 r+p82_0 syms83_0 phase84_0)"
"(begin"
" 'add-defined-syms!"
"(let-values(((r+p_0) r+p82_0))"
"(let-values(((syms_0) syms83_0))"
"(let-values(((phase_0) phase84_0))"
"(let-values(((as-transformer?_0) as-transformer?80_0))"
"(let-values()"
"(let-values(((phase-to-defined-syms_0)(requires+provides-phase-to-defined-syms r+p_0)))"
"(let-values(((defined-syms_0)(hash-ref phase-to-defined-syms_0 phase_0 '#hasheq())))"
"(let-values(((new-defined-syms_0)"
"(let-values(((defined-syms_1)"
"(let-values(((defined-syms_1) defined-syms_0)) defined-syms_1)))"
"(let-values(((lst_0) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(defined-syms_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((defined-syms_3)"
"(let-values(((defined-syms_3)"
"(let-values()"
"(hash-set"
" defined-syms_2"
" sym_0"
"(if as-transformer?_0"
" 'transformer"
" 'variable)))))"
"(values defined-syms_3))))"
"(if(not #f)"
"(for-loop_0 defined-syms_3 rest_0)"
" defined-syms_3)))"
" defined-syms_2))))))"
" for-loop_0)"
" defined-syms_1"
" lst_0))))))"
"(hash-set! phase-to-defined-syms_0 phase_0 new-defined-syms_0))))))))))))"
"(define-values"
"(defined-sym-kind)"
"(lambda(r+p_0 sym_0 phase_0)"
"(begin"
"(let-values(((phase-to-defined-syms_0)(requires+provides-phase-to-defined-syms r+p_0)))"
"(let-values(((defined-syms_0)(hash-ref phase-to-defined-syms_0 phase_0 '#hasheq())))"
"(hash-ref defined-syms_0 sym_0 #f))))))"
"(define-values"
"(extract-module-requires)"
"(lambda(r+p_0 mod-name_0 phase+space-shift_0)"
"(begin"
"(let-values(((mpi_0)(intern-mpi r+p_0 mod-name_0)))"
"(let-values(((at-mod_0)(hash-ref(requires+provides-requires r+p_0) mpi_0 #f)))"
"(if at-mod_0"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0)(hash-ref at-mod_0 phase+space-shift_0 '#hasheq())))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0 reqds_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_2)"
"(let-values(((lst_0) reqds_0))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2 lst_1)"
"(begin"
" 'for-loop"
"(if(not(null? lst_1))"
"(let-values(((reqd_0)"
"(if(pair? lst_1)"
"(car lst_1)"
" lst_1))"
"((rest_0)"
"(if(pair? lst_1)"
"(cdr lst_1)"
" null)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(normalize-required"
" reqd_0"
" mpi_0"
" phase+space-shift_0"
" sym_0))"
" fold-var_2))))"
"(values"
" fold-var_3))))"
"(if(not #f)"
"(for-loop_1"
" fold-var_3"
" rest_0)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" fold-var_1"
" lst_0))))"
"(if(not #f)"
"(for-loop_0 fold-var_2(hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_0))))))"
" #f))))))"
"(define-values"
"(extract-module-definitions)"
"(lambda(r+p_0)"
"(begin"
"(let-values(((or-part_0)(extract-module-requires r+p_0(requires+provides-self r+p_0) 0)))"
"(if or-part_0 or-part_0 null)))))"
"(define-values"
"(extract-all-module-requires)"
"(lambda(r+p_0 mod-name_0 phase+space-shift_0)"
"(begin"
"(let-values(((self_0)(requires+provides-self r+p_0)))"
"(let-values(((requires_0)(requires+provides-requires r+p_0)))"
"(call/ec"
"(lambda(esc_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(if mod-name_0(list(intern-mpi r+p_0 mod-name_0))(hash-keys requires_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mod-name_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(if(eq? mod-name_1 self_0)"
" fold-var_1"
"(let-values(((id*_0)"
"(hash-ref"
" requires_0"
" mod-name_1"
" '#hasheqv())))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2)"
"(begin"
" 'for-loop"
"(let-values(((phase+space-to-requireds_0)"
" id*_0))"
"(let-values(((fold-var_3)"
"(let-values(((lst_2)"
"(if(eq?"
" phase+space-shift_0"
" 'all)"
"(hash-keys"
" phase+space-to-requireds_0)"
"(list"
" phase+space-shift_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_2)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((phase+space-shift_1)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((ht_0)"
"(hash-ref"
" phase+space-to-requireds_0"
" phase+space-shift_1"
"(lambda()"
"(esc_0"
" #f)))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_3)"
"(lambda(fold-var_4"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0"
" reqds_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((fold-var_5)"
"(let-values(((lst_4)"
" reqds_0))"
"((letrec-values(((for-loop_4)"
"(lambda(fold-var_5"
" lst_5)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" lst_5))"
"(let-values(((reqd_0)"
"(if(pair?"
" lst_5)"
"(car"
" lst_5)"
" lst_5))"
"((rest_2)"
"(if(pair?"
" lst_5)"
"(cdr"
" lst_5)"
" null)))"
"(let-values(((fold-var_6)"
"(let-values(((fold-var_6)"
"(let-values()"
"(cons"
"(let-values()"
"(normalize-required"
" reqd_0"
" mod-name_1"
" phase+space-shift_1"
" sym_0))"
" fold-var_5))))"
"(values"
" fold-var_6))))"
"(if(not"
" #f)"
"(for-loop_4"
" fold-var_6"
" rest_2)"
" fold-var_6)))"
" fold-var_5)))))"
" for-loop_4)"
" fold-var_4"
" lst_4))))"
"(if(not"
" #f)"
"(for-loop_3"
" fold-var_5"
"(hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_5)))"
" fold-var_4)))))"
" for-loop_3)"
" fold-var_3"
"(hash-iterate-first"
" ht_0))))))"
"(if(not"
" #f)"
"(for-loop_2"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3)))))"
" for-loop_2)"
" fold-var_2"
" lst_2)))))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_1)))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))))"
"(define-values"
"(disable-definitions-shadow-imports!)"
"(lambda(r+p_0)(begin(set-requires+provides-definitions-shadow-imports?! r+p_0 #f))))"
"(define-values"
"(add-provide!.1)"
"(lambda(as-protected?86_0"
" as-transformer?87_0"
" r+p90_0"
" sym91_0"
" phase+space92_0"
" binding93_0"
" immed-binding94_0"
" id95_0"
" orig-s96_0)"
"(begin"
" 'add-provide!"
"(let-values(((r+p_0) r+p90_0))"
"(let-values(((sym_0) sym91_0))"
"(let-values(((phase+space_0) phase+space92_0))"
"(let-values(((binding_0) binding93_0))"
"(let-values(((immed-binding_0) immed-binding94_0))"
"(let-values(((id_0) id95_0))"
"(let-values(((orig-s_0) orig-s96_0))"
"(let-values(((as-protected?_0) as-protected?86_0))"
"(let-values(((as-transformer?_0) as-transformer?87_0))"
"(let-values()"
"(begin"
"(if(if as-protected?_0"
"(not(eq?(module-binding-module immed-binding_0)(requires+provides-self r+p_0)))"
" #f)"
"(let-values()"
"                                (raise-syntax-error$1 #f \"cannot protect required identifier in re-provide\" sym_0))"
"(void))"
"(hash-update!"
"(requires+provides-provides r+p_0)"
" phase+space_0"
"(lambda(at-phase_0)"
"(let-values(((b/p_0)(hash-ref at-phase_0 sym_0 #f)))"
"(let-values(((b_0)(provided-as-binding b/p_0)))"
"(if(not b_0)"
"(let-values()"
"(let-values(((plain-binding_0)"
"(if(binding-free=id binding_0)"
"(let-values(((binding179_0) binding_0)((temp180_0) #f))"
"(module-binding-update.1"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" temp180_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" binding179_0))"
" binding_0)))"
"(hash-set"
" at-phase_0"
" sym_0"
"(if(let-values(((or-part_0) as-protected?_0))"
"(if or-part_0 or-part_0 as-transformer?_0))"
"(provided1.1 plain-binding_0 as-protected?_0 as-transformer?_0)"
" plain-binding_0))))"
"(if(same-binding? b_0 binding_0)"
"(let-values() at-phase_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                          \"identifier already provided (as a different binding)\""
" orig-s_0"
" id_0)))))))"
" '#hasheq())))))))))))))))"
"(define-values"
"(extract-requires-and-provides.1)"
"(lambda(flatten-requires?98_0 namespace99_0 r+p102_0 old-self103_0 new-self104_0)"
"(begin"
" 'extract-requires-and-provides"
"(let-values(((r+p_0) r+p102_0))"
"(let-values(((old-self_0) old-self103_0))"
"(let-values(((new-self_0) new-self104_0))"
"(let-values(((flatten-requires?_0) flatten-requires?98_0))"
"(let-values(((ns_0) namespace99_0))"
"(let-values()"
"(let-values(((extract-requires_0)"
"(lambda(recurs?181_0)"
"(begin"
" 'extract-requires"
"(let-values(((recurs?_0) recurs?181_0))"
"(let-values()"
"(let-values(((phase-to-mpis-in-order_0)"
"(requires+provides-require-mpis-in-order r+p_0)))"
"(let-values(((phases-in-order_0)"
"(let-values(((temp184_0)(hash-keys phase-to-mpis-in-order_0))"
"((phase<?185_0) phase<?))"
"(sort.1 #f #f temp184_0 phase<?185_0))))"
"(let-values(((transitive-requires_0)"
"(requires+provides-transitive-requires r+p_0)))"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((phase_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((elems_0)"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
"(reverse$1"
"(hash-ref"
" phase-to-mpis-in-order_0"
" phase_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((mpi_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(if(eq?"
" mpi_0"
" old-self_0)"
" fold-var_3"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(if recurs?_0"
"(not"
"(hash-ref"
"(hash-ref"
" transitive-requires_0"
"(module-path-index-resolved"
" mpi_0)"
" '#hasheqv())"
" phase_0"
" #f))"
"(module-path-index-shift"
" mpi_0"
" old-self_0"
" new-self_0)))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2)))))))"
"(if recurs?_0"
" elems_0"
"(cons"
" phase_0"
" elems_0))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))))))"
"(let-values()"
"(let-values()"
"(let-values(((extract-flattened-requires_0)"
"(lambda()"
"(begin"
" 'extract-flattened-requires"
"(let-values(((phase-to-mpis-in-order_0)"
"(requires+provides-require-mpis-in-order r+p_0)))"
"(let-values(((phases-in-order_0)"
"(let-values(((temp186_0)"
"(hash-keys phase-to-mpis-in-order_0))"
"((phase<?187_0) phase<?))"
"(sort.1 #f #f temp186_0 phase<?187_0))))"
"(let-values(((name-to-phases_0 all-mpis_0)"
"(let-values(((name-to-phases_0)"
"(let-values(((name-to-phases_0) '#hasheq()))"
" name-to-phases_0))"
"((all-mpis_0)"
"(let-values(((all-mpis_0) '())) all-mpis_0)))"
"(let-values(((lst_0) phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(name-to-phases_1"
" all-mpis_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((phase_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((name-to-phases_2"
" all-mpis_2)"
"(let-values(((lst_2)"
"(reverse$1"
"(hash-ref"
" phase-to-mpis-in-order_0"
" phase_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(name-to-phases_2"
" all-mpis_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((mpi_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((name-to-phases_3"
" all-mpis_3)"
"(if(eq?"
" mpi_0"
" old-self_0)"
"(values"
" name-to-phases_2"
" all-mpis_2)"
"(let-values(((name-to-phases_3"
" all-mpis_3)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(name-to-phases_3"
" all-mpis_3"
" mpi_1"
" phase_1)"
"(begin"
" 'loop"
"(let-values(((name_0)"
"(1/module-path-index-resolve"
" mpi_1)))"
"(let-values(((at-name_0)"
"(hash-ref"
" name-to-phases_3"
" name_0"
" '#hasheq())))"
"(if(hash-ref"
" at-name_0"
" phase_1"
" #f)"
"(let-values()"
"(values"
" name-to-phases_3"
" all-mpis_3))"
"(let-values()"
"(let-values(((done-name-to-phases_0)"
"(hash-set"
" name-to-phases_3"
" name_0"
"(hash-set"
" at-name_0"
" phase_1"
" #t))))"
"(let-values(((add_0)"
"(lambda(mpi_2"
" all-mpis_4)"
"(begin"
" 'add"
"(if(hash-ref"
" name-to-phases_3"
" name_0"
" #f)"
" all-mpis_4"
"(cons"
"(cons"
" name_0"
" mpi_2)"
" all-mpis_4))))))"
"(let-values(((m_0)"
"(namespace->module"
" ns_0"
" name_0)))"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'module"
"                                                                                                                                                                                                                     \"cannot find module while flattening requires\""
"                                                                                                                                                                                                                     \"module\""
" name_0)))"
"(if(if(module-cross-phase-persistent?"
" m_0)"
"(if(not"
"(eqv?"
" phase_1"
" 0))"
"(not"
"(label-phase?"
" phase_1))"
" #f)"
" #f)"
"(let-values()"
"(loop_0"
" name-to-phases_3"
" all-mpis_3"
" mpi_1"
" 0))"
"(let-values()"
"(let-values(((new-name-to-phases_0"
" new-all-mpis_0)"
"(let-values(((name-to-phases_4)"
"(let-values(((name-to-phases_4)"
" done-name-to-phases_0))"
" name-to-phases_4))"
"((all-mpis_4)"
"(let-values(((all-mpis_4)"
" all-mpis_3))"
" all-mpis_4)))"
"(let-values(((lst_4)"
"(module-requires"
" m_0))"
"((lst_5)"
"(module-recur-requires"
" m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_5)))"
"((letrec-values(((for-loop_2)"
"(lambda(name-to-phases_5"
" all-mpis_5"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((phase+reqs_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((recurs_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((name-to-phases_6"
" all-mpis_6)"
"(let-values()"
"(let-values(((new-phase_0)"
"(phase+"
"(car"
" phase+reqs_0)"
" phase_1)))"
"(let-values(((lst_8)"
"(cdr"
" phase+reqs_0))"
"((lst_9)"
" recurs_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_8)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_9)))"
"((letrec-values(((for-loop_3)"
"(lambda(name-to-phases_6"
" all-mpis_6"
" lst_10"
" lst_11)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_10)"
"(pair?"
" lst_11)"
" #f)"
"(let-values(((req_0)"
"(unsafe-car"
" lst_10))"
"((rest_4)"
"(unsafe-cdr"
" lst_10))"
"((recur_0)"
"(unsafe-car"
" lst_11))"
"((rest_5)"
"(unsafe-cdr"
" lst_11)))"
"(let-values(((name-to-phases_7"
" all-mpis_7)"
"(if recur_0"
"(let-values(((name-to-phases_7"
" all-mpis_7)"
"(let-values()"
"(loop_0"
" name-to-phases_6"
" all-mpis_6"
"(module-path-index-shift"
" req_0"
"(module-self"
" m_0)"
" mpi_1)"
" new-phase_0))))"
"(values"
" name-to-phases_7"
" all-mpis_7))"
"(values"
" name-to-phases_6"
" all-mpis_6))))"
"(if(not"
" #f)"
"(for-loop_3"
" name-to-phases_7"
" all-mpis_7"
" rest_4"
" rest_5)"
"(values"
" name-to-phases_7"
" all-mpis_7))))"
"(values"
" name-to-phases_6"
" all-mpis_6))))))"
" for-loop_3)"
" name-to-phases_5"
" all-mpis_5"
" lst_8"
" lst_9)))))))"
"(if(not"
" #f)"
"(for-loop_2"
" name-to-phases_6"
" all-mpis_6"
" rest_2"
" rest_3)"
"(values"
" name-to-phases_6"
" all-mpis_6))))"
"(values"
" name-to-phases_5"
" all-mpis_5)))))))"
" for-loop_2)"
" name-to-phases_4"
" all-mpis_4"
" lst_4"
" lst_5))))))"
"(values"
" new-name-to-phases_0"
"(add_0"
" mpi_1"
" new-all-mpis_0)))))))))))))))))"
" loop_0)"
" name-to-phases_2"
" all-mpis_2"
"(module-path-index-shift"
" mpi_0"
" old-self_0"
" new-self_0)"
" phase_0))))"
"(values"
" name-to-phases_3"
" all-mpis_3)))))"
"(if(not"
" #f)"
"(for-loop_1"
" name-to-phases_3"
" all-mpis_3"
" rest_1)"
"(values"
" name-to-phases_3"
" all-mpis_3))))"
"(values"
" name-to-phases_2"
" all-mpis_2))))))"
" for-loop_1)"
" name-to-phases_1"
" all-mpis_1"
" lst_2)))))"
"(if(not #f)"
"(for-loop_0"
" name-to-phases_2"
" all-mpis_2"
" rest_0)"
"(values"
" name-to-phases_2"
" all-mpis_2))))"
"(values"
" name-to-phases_1"
" all-mpis_1)))))))"
" for-loop_0)"
" name-to-phases_0"
" all-mpis_0"
" lst_0))))))"
"(let-values(((interned_0)(make-hash)))"
"(let-values(((intern-phases_0)"
"(lambda(phases_0)"
"(begin"
" 'intern-phases"
"(let-values(((or-part_0)"
"(hash-ref interned_0 phases_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((lst_0)(hash-keys phases_0 #t)))"
"(begin"
"(hash-set! interned_0 phases_0 lst_0)"
" lst_0))))))))"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(reverse$1 all-mpis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((name+mpi_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((name_0)"
"(car"
" name+mpi_0)))"
"(let-values(((mpi_0)"
"(cdr"
" name+mpi_0)))"
"(vector-immutable"
" mpi_0"
"(intern-phases_0"
"(hash-ref"
" name-to-phases_0"
" name_0))))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))))))"
"(let-values(((extract-provides_0)"
"(lambda()"
"(begin"
" 'extract-provides"
"(shift-provides-module-path-index"
"(requires+provides-provides r+p_0)"
" old-self_0"
" new-self_0)))))"
"(values"
"(let-values()(extract-requires_0 #f))"
"(let-values(((temp188_0) #t))(extract-requires_0 temp188_0))"
"(if flatten-requires?_0(extract-flattened-requires_0) #f)"
"(extract-provides_0))))))))))))))))"
"(define-values"
"(shift-provides-module-path-index)"
"(lambda(provides_0 from-mpi_0 to-mpi_0)"
"(begin"
"(let-values(((table_0)(let-values(((table_0) '#hasheqv())) table_0)))"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase+space_0 at-phase_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" phase+space_0"
"(let-values(((table_2)"
"(let-values(((table_2)"
" '#hasheq()))"
" table_2)))"
"(let-values(((ht_1)"
" at-phase_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_3"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((sym_0"
" binding_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((table_4)"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
"(if(eq?"
" from-mpi_0"
" to-mpi_0)"
"(let-values()"
" binding_0)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(binding_1)"
"(begin"
" 'loop"
"(if(provided?"
" binding_1)"
"(let-values()"
"(provided1.1"
"(loop_0"
"(provided-binding"
" binding_1))"
"(provided-protected?"
" binding_1)"
"(provided-syntax?"
" binding_1)))"
"(let-values()"
"(binding-module-path-index-shift"
" binding_1"
" from-mpi_0"
" to-mpi_0)))))))"
" loop_0)"
" binding_0)))))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_4"
"(hash-iterate-next"
" ht_1"
" i_1))"
" table_4)))"
" table_3))))))"
" for-loop_1)"
" table_2"
"(hash-iterate-first"
" ht_1)))))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2(hash-iterate-next ht_0 i_0)) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0))))))))"
"(define-values"
"(struct:adjust-only adjust-only1.1 adjust-only? adjust-only-syms)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'adjust-only #f 1 0 #f null(current-inspector) #f '(0) #f 'adjust-only)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'syms))))"
"(define-values"
"(struct:adjust-prefix adjust-prefix2.1 adjust-prefix? adjust-prefix-sym)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'adjust-prefix #f 1 0 #f null(current-inspector) #f '(0) #f 'adjust-prefix)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'sym))))"
"(define-values"
"(struct:adjust-all-except adjust-all-except3.1 adjust-all-except? adjust-all-except-prefix-sym adjust-all-except-syms)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'adjust-all-except"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'adjust-all-except)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'prefix-sym)"
"(make-struct-field-accessor -ref_0 1 'syms))))"
"(define-values"
"(struct:adjust-rename adjust-rename4.1 adjust-rename? adjust-rename-to-id adjust-rename-from-sym)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'adjust-rename #f 2 0 #f null(current-inspector) #f '(0 1) #f 'adjust-rename)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'to-id)"
"(make-struct-field-accessor -ref_0 1 'from-sym))))"
"(define-values(layers$1) '(raw phaseless spaceless justspaceless path))"
"(define-values"
"(parse-and-perform-requires!.1)"
"(lambda(add-defined-portal14_0"
" all-scopes-stx15_0"
" copy-variable-as-constant?11_0"
" copy-variable-phase-level10_0"
" declared-submodule-names9_0"
" initial-require?13_0"
" run-phase6_0"
" run?7_0"
" self5_0"
" skip-variable-phase-level12_0"
" visit?8_0"
" who16_0"
" reqs29_0"
" orig-s30_0"
" m-ns31_0"
" phase-shift32_0"
" requires+provides33_0)"
"(begin"
" 'parse-and-perform-requires!"
"(let-values(((reqs_0) reqs29_0))"
"(let-values(((orig-s_0) orig-s30_0))"
"(let-values(((m-ns_0) m-ns31_0))"
"(let-values(((phase-shift_0) phase-shift32_0))"
"(let-values(((requires+provides_0) requires+provides33_0))"
"(let-values(((self_0) self5_0))"
"(let-values(((run-phase_0)"
"(if(eq? run-phase6_0 unsafe-undefined)(namespace-phase m-ns_0) run-phase6_0)))"
"(let-values(((run?_0) run?7_0))"
"(let-values(((visit?_0) visit?8_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names9_0))"
"(let-values(((copy-variable-phase-level_0) copy-variable-phase-level10_0))"
"(let-values(((copy-variable-as-constant?_0) copy-variable-as-constant?11_0))"
"(let-values(((skip-variable-phase-level_0) skip-variable-phase-level12_0))"
"(let-values(((initial-require?_0) initial-require?13_0))"
"(let-values(((add-defined-portal_0) add-defined-portal14_0))"
"(let-values(((all-scopes-stx_0) all-scopes-stx15_0))"
"(let-values(((who_0) who16_0))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(reqs_1"
" top-req_0"
" phase-shift_1"
" space-level_0"
" just-meta_0"
" just-space_0"
" adjust_0"
" for-meta-ok?_0"
" just-meta-ok?_0"
" layer_0)"
"(begin"
" 'loop"
"(begin"
"(let-values()"
"(let-values(((lst_0) reqs_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((req_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((check-nested_0)"
"(let-values(((check-nested_0)"
"(lambda(want-layer132_0"
" ok?131_0)"
"(begin"
" 'check-nested"
"(let-values(((want-layer_0)"
" want-layer132_0))"
"(let-values(((ok?_0)"
" ok?131_0))"
"(let-values()"
"(if(if ok?_0"
"(member"
" want-layer_0"
"(member"
" layer_0"
" layers$1))"
" #f)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                               \"invalid nesting\""
" orig-s_0"
" req_0))))))))))"
"(case-lambda"
"((want-layer_0)"
"(begin"
" 'check-nested"
"(check-nested_0"
" want-layer_0"
" #t)))"
"((want-layer_0"
" ok?131_0)"
"(check-nested_0"
" want-layer_0"
" ok?131_0))))))"
"(let-values(((fm_0)"
"(if(pair?"
"(syntax-e$1"
" req_0))"
"(if(identifier?"
"(car"
"(syntax-e$1"
" req_0)))"
"(syntax-e$1"
"(car"
"(syntax-e$1"
" req_0)))"
" #f)"
" #f)))"
"(let-values(((tmp_0)"
" fm_0))"
"(let-values(((index_0)"
"(if(symbol?"
" tmp_0)"
"(hash-ref"
" '#hasheq((all-except"
" ."
" 11)"
"(for-label"
" ."
" 4)"
"(for-meta"
" ."
" 1)"
"(for-space"
" ."
" 7)"
"(for-syntax"
" ."
" 2)"
"(for-template"
" ."
" 3)"
"(just-meta"
" ."
" 5)"
"(just-space"
" ."
" 8)"
"(only"
" ."
" 9)"
"(portal"
" ."
" 6)"
"(prefix"
" ."
" 10)"
"(prefix-all-except"
" ."
" 12)"
"(rename ."
" 13))"
" tmp_0"
"(lambda()"
" 0))"
" 0)))"
"(if(unsafe-fx<"
" index_0"
" 6)"
"(if(unsafe-fx<"
" index_0"
" 2)"
"(if(unsafe-fx<"
" index_0"
" 1)"
"(let-values()"
"(let-values(((maybe-mp_0)"
"(syntax->datum$1"
" req_0)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)"
"(1/module-path?"
" maybe-mp_0)))"
"(if or-part_0"
" or-part_0"
"(1/resolved-module-path?"
" maybe-mp_0)))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                           \"bad require spec\""
" orig-s_0"
" req_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(if(requires+provides-all-bindings-simple?"
" requires+provides_0)"
"(let-values(((or-part_0)"
" adjust_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(not"
"(eq?"
" just-meta_0"
" 'all))))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(not"
"(eq?"
" space-level_0"
" '#:none))))"
"(if or-part_2"
" or-part_2"
"(if all-scopes-stx_0"
"(not"
"(same-scopes?"
" req_0"
" all-scopes-stx_0))"
" #f)))))))"
" #f)"
"(let-values()"
"(set-requires+provides-all-bindings-simple?!"
" requires+provides_0"
" #f))"
"(void))"
"(values))))"
"(let-values(((mp_0)"
"(if(1/resolved-module-path?"
" maybe-mp_0)"
"(resolved-module-path->module-path"
" maybe-mp_0)"
" maybe-mp_0)))"
"(let-values(((mpi_0)"
"(let-values(((mp152_0)"
" mp_0)"
"((self153_0)"
" self_0)"
"((declared-submodule-names154_0)"
" declared-submodule-names_0))"
"(module-path->mpi.1"
" declared-submodule-names154_0"
" mp152_0"
" self153_0))))"
"(begin"
"(let-values(((mpi133_0)"
" mpi_0)"
"((req134_0)"
" req_0)"
"((self135_0)"
" self_0)"
"((temp136_0)"
"(let-values(((or-part_0)"
" req_0))"
"(if or-part_0"
" or-part_0"
" top-req_0)))"
"((m-ns137_0)"
" m-ns_0)"
"((phase-shift138_0)"
" phase-shift_1)"
"((space-level139_0)"
" space-level_0)"
"((run-phase140_0)"
" run-phase_0)"
"((just-meta141_0)"
" just-meta_0)"
"((just-space142_0)"
" just-space_0)"
"((adjust143_0)"
" adjust_0)"
"((requires+provides144_0)"
" requires+provides_0)"
"((run?145_0)"
" run?_0)"
"((visit?146_0)"
" visit?_0)"
"((copy-variable-phase-level147_0)"
" copy-variable-phase-level_0)"
"((copy-variable-as-constant?148_0)"
" copy-variable-as-constant?_0)"
"((skip-variable-phase-level149_0)"
" skip-variable-phase-level_0)"
"((initial-require?150_0)"
" initial-require?_0)"
"((who151_0)"
" who_0))"
"(perform-require!.1"
" adjust143_0"
" #t"
" #f"
" copy-variable-as-constant?148_0"
" copy-variable-phase-level147_0"
" initial-require?150_0"
" just-meta141_0"
" just-space142_0"
" phase-shift138_0"
" requires+provides144_0"
" run-phase140_0"
" run?145_0"
" skip-variable-phase-level149_0"
" space-level139_0"
" visit?146_0"
" who151_0"
" mpi133_0"
" req134_0"
" self135_0"
" temp136_0"
" m-ns137_0))"
"(set! initial-require?_0"
" #f))))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" for-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" for-meta155_0"
" phase-level156_0"
" spec157_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-meta155_0"
" phase-level156_0"
" spec157_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-meta158_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((phase-level159_0"
" spec160_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((phase-level161_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec162_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level161_0"
" spec162_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                               \"bad syntax\""
" orig-s_1))))))"
"(values"
" for-meta158_0"
" phase-level159_0"
" spec160_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                           \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-meta155_0"
" phase-level156_0"
" spec157_0))))))"
"(let-values(((p_0)"
"(syntax-e$1"
" phase-level156_0)))"
"(begin"
"(if(phase?"
" p_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                 \"bad phase\""
" orig-s_0"
" req_0)))"
"(loop_0"
" spec157_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
"(phase+"
" phase-shift_1"
" p_0)"
" space-level_0"
" just-meta_0"
" just-space_0"
" adjust_0"
" #f"
" just-meta-ok?_0"
" 'raw)))))))"
"(if(unsafe-fx<"
" index_0"
" 3)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" for-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" for-syntax163_0"
" spec164_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-syntax163_0"
" spec164_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-syntax165_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec166_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-syntax165_0"
" spec166_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                           \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-syntax163_0"
" spec164_0))))))"
"(loop_0"
" spec164_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
"(phase+"
" phase-shift_1"
" 1)"
" space-level_0"
" just-meta_0"
" just-space_0"
" adjust_0"
" #f"
" just-meta-ok?_0"
" 'raw))))"
"(if(unsafe-fx<"
" index_0"
" 4)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" for-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" for-template167_0"
" spec168_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-template167_0"
" spec168_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-template169_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec170_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-template169_0"
" spec170_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                             \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-template167_0"
" spec168_0))))))"
"(loop_0"
" spec168_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
"(phase+"
" phase-shift_1"
" -1)"
" space-level_0"
" just-meta_0"
" just-space_0"
" adjust_0"
" #f"
" just-meta-ok?_0"
" 'raw))))"
"(if(unsafe-fx<"
" index_0"
" 5)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" for-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" for-label171_0"
" spec172_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-label171_0"
" spec172_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-label173_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec174_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-label173_0"
" spec174_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                               \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-label171_0"
" spec172_0))))))"
"(loop_0"
" spec172_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
"(phase+"
" phase-shift_1"
" #f)"
" space-level_0"
" just-meta_0"
" just-space_0"
" adjust_0"
" #f"
" just-meta-ok?_0"
" 'raw))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" just-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" just-meta175_0"
" phase-level176_0"
" spec177_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((just-meta175_0"
" phase-level176_0"
" spec177_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((just-meta178_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((phase-level179_0"
" spec180_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((phase-level181_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec182_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level181_0"
" spec182_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1))))))"
"(values"
" just-meta178_0"
" phase-level179_0"
" spec180_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                               \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" just-meta175_0"
" phase-level176_0"
" spec177_0))))))"
"(let-values(((p_0)"
"(syntax-e$1"
" phase-level176_0)))"
"(begin"
"(if(phase?"
" p_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                     \"bad phase\""
" orig-s_0"
" req_0)))"
"(loop_0"
" spec177_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" space-level_0"
" p_0"
" just-space_0"
" adjust_0"
" for-meta-ok?_0"
" #f"
" 'raw))))))))))"
"(if(unsafe-fx<"
" index_0"
" 9)"
"(if(unsafe-fx<"
" index_0"
" 7)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
"(eq?"
" just-meta_0"
" 'all))"
"(values))))"
"(let-values(((ok?_0"
" portal183_0"
" id:name184_0"
" stx185_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((portal183_0"
" id:name184_0"
" stx185_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((portal186_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:name187_0"
" stx188_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:name189_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_1"
" s_4))))"
"((stx190_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((stx191_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" stx191_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:name189_0"
" stx190_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                               \"bad syntax\""
" orig-s_1))))))"
"(values"
" portal186_0"
" id:name187_0"
" stx188_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                           \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" portal183_0"
" id:name184_0"
" stx185_0))))))"
"(let-values(((temp192_0)"
" id:name184_0)"
"((temp193_0)"
" stx185_0)"
"((phase-shift194_0)"
" phase-shift_1)"
"((orig-s195_0)"
" orig-s_0)"
"((self196_0)"
" self_0)"
"((requires+provides197_0)"
" requires+provides_0)"
"((add-defined-portal198_0)"
" add-defined-portal_0))"
"(perform-portal-syntax-bind!.1"
" add-defined-portal198_0"
" orig-s195_0"
" phase-shift194_0"
" requires+provides197_0"
" self196_0"
" temp192_0"
" temp193_0)))))"
"(if(unsafe-fx<"
" index_0"
" 8)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" for-space199_0"
" space200_0"
" spec201_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-space199_0"
" space200_0"
" spec201_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-space202_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((space203_0"
" spec204_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((space205_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec206_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" space205_0"
" spec206_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" for-space202_0"
" space203_0"
" spec204_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                             \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-space199_0"
" space200_0"
" spec201_0))))))"
"(let-values(((space_0)"
"(syntax-e$1"
" space200_0)))"
"(begin"
"(if(space?"
" space_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                   \"bad space\""
" orig-s_0"
" req_0)))"
"(loop_0"
" spec201_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" space_0"
" just-meta_0"
" just-space_0"
" adjust_0"
" #f"
" #f"
" 'spaceless))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values(((ok?_0"
" just-space207_0"
" space208_0"
" spec209_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((just-space207_0"
" space208_0"
" spec209_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((just-space210_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((space211_0"
" spec212_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((space213_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec214_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" space213_0"
" spec214_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" just-space210_0"
" space211_0"
" spec212_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                             \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" just-space207_0"
" space208_0"
" spec209_0))))))"
"(let-values(((space_0)"
"(syntax-e$1"
" space208_0)))"
"(begin"
"(if(space?"
" space_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                   \"bad space\""
" orig-s_0"
" req_0)))"
"(loop_0"
" spec209_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" space-level_0"
" just-meta_0"
" space_0"
" adjust_0"
" #f"
" #f"
" 'justspaceless))))))))"
"(if(unsafe-fx<"
" index_0"
" 11)"
"(if(unsafe-fx<"
" index_0"
" 10)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'justspaceless)"
"(values))))"
"(let-values(((ok?_0"
" only215_0"
" spec216_0"
" id217_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((only215_0"
" spec216_0"
" id217_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((only218_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec219_0"
" id220_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((spec221_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((id222_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id223_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                         \"not an identifier\""
" orig-s_1"
" s_6)))))"
"(cons"
" id223_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_2"
" rest_1)"
" id_2)))"
" id_1))))))"
" for-loop_1)"
" id_0"
" lst_2))))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" spec221_0"
" id222_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" only218_0"
" spec219_0"
" id220_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                             \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" only215_0"
" spec216_0"
" id217_0))))))"
"(loop_0"
"(list"
" spec216_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" space-level_0"
" just-meta_0"
" just-space_0"
"(adjust-only1.1"
"(ids->sym-set"
" id217_0))"
" #f"
" #f"
" 'path))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'justspaceless)"
"(values))))"
"(let-values(((ok?_0"
" prefix224_0"
" id:prefix225_0"
" spec226_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((prefix224_0"
" id:prefix225_0"
" spec226_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((prefix227_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:prefix228_0"
" spec229_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:prefix230_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                   \"not an identifier\""
" orig-s_1"
" s_4))))"
"((spec231_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((spec232_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))))))"
"(values"
" spec232_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:prefix230_0"
" spec231_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" prefix227_0"
" id:prefix228_0"
" spec229_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                             \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" prefix224_0"
" id:prefix225_0"
" spec226_0))))))"
"(loop_0"
"(list"
" spec226_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" space-level_0"
" just-meta_0"
" just-space_0"
"(adjust-prefix2.1"
"(syntax-e$1"
" id:prefix225_0))"
" #f"
" #f"
" 'path)))))"
"(if(unsafe-fx<"
" index_0"
" 12)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'justspaceless)"
"(values))))"
"(let-values(((ok?_0"
" all-except233_0"
" spec234_0"
" id235_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((all-except233_0"
" spec234_0"
" id235_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-except236_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec237_0"
" id238_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((spec239_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((id240_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id241_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                         \"not an identifier\""
" orig-s_1"
" s_6)))))"
"(cons"
" id241_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_2"
" rest_1)"
" id_2)))"
" id_1))))))"
" for-loop_1)"
" id_0"
" lst_2))))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" spec239_0"
" id240_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" all-except236_0"
" spec237_0"
" id238_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                             \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" all-except233_0"
" spec234_0"
" id235_0))))))"
"(loop_0"
"(list"
" spec234_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" space-level_0"
" just-meta_0"
" just-space_0"
"(adjust-all-except3.1"
" '||"
"(ids->sym-set"
" id235_0))"
" #f"
" #f"
" 'path))))"
"(if(unsafe-fx<"
" index_0"
" 13)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'justspaceless)"
"(values))))"
"(let-values(((ok?_0"
" prefix-all-except242_0"
" id:prefix243_0"
" spec244_0"
" id245_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((prefix-all-except242_0"
" id:prefix243_0"
" spec244_0"
" id245_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((prefix-all-except246_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:prefix247_0"
" spec248_0"
" id249_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:prefix250_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                     \"not an identifier\""
" orig-s_1"
" s_4))))"
"((spec251_0"
" id252_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((spec253_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((id254_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_7)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_8)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id255_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_8)"
"(symbol?"
"(syntax-e$1"
" s_8))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_8)))"
" s_8"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_1"
" s_8)))))"
"(cons"
" id255_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_2"
" rest_1)"
" id_2)))"
" id_1))))))"
" for-loop_1)"
" id_0"
" lst_2))))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" spec253_0"
" id254_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:prefix250_0"
" spec251_0"
" id252_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1))))))"
"(values"
" prefix-all-except246_0"
" id:prefix247_0"
" spec248_0"
" id249_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                               \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" prefix-all-except242_0"
" id:prefix243_0"
" spec244_0"
" id245_0))))))"
"(loop_0"
"(list"
" spec244_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" space-level_0"
" just-meta_0"
" just-space_0"
"(adjust-all-except3.1"
"(syntax-e$1"
" id:prefix243_0)"
"(ids->sym-set"
" id245_0))"
" #f"
" #f"
" 'path))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'justspaceless)"
"(values))))"
"(let-values(((ok?_0"
" rename256_0"
" spec257_0"
" id:to258_0"
" id:from259_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((rename256_0"
" spec257_0"
" id:to258_0"
" id:from259_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((rename260_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec261_0"
" id:to262_0"
" id:from263_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((spec264_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((id:to265_0"
" id:from266_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((id:to267_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                         \"not an identifier\""
" orig-s_1"
" s_6))))"
"((id:from268_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(let-values(((id:from269_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_8)"
"(symbol?"
"(syntax-e$1"
" s_8))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_8)))"
" s_8"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                             \"not an identifier\""
" orig-s_1"
" s_8))))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(syntax?$1"
" s_8)"
"(syntax-e$1"
" s_8)"
" s_8)))"
"(if(null?"
" s_9)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:from269_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:to267_0"
" id:from268_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" spec264_0"
" id:to265_0"
" id:from266_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1))))))"
"(values"
" rename260_0"
" spec261_0"
" id:to262_0"
" id:from263_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                               \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" rename256_0"
" spec257_0"
" id:to258_0"
" id:from259_0))))))"
"(loop_0"
"(list"
" spec257_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" space-level_0"
" just-meta_0"
" just-space_0"
"(adjust-rename4.1"
" id:to258_0"
"(syntax-e$1"
" id:from259_0))"
" #f"
" #f"
" 'path))))))))))))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))))))"
" loop_0)"
" reqs_0"
" #f"
" phase-shift_0"
" '#:none"
" 'all"
" #t"
" #f"
" #t"
" #t"
" 'raw))))))))))))))))))))))"
"(define-values"
"(ids->sym-set)"
"(lambda(ids_0)"
"(begin"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()(syntax-e$1 id_0))"
" #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2 rest_0) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0)))))))"
"(define-values(same-scopes?)(lambda(a_0 b_0)(begin(equal?(syntax-scope-set a_0 0)(syntax-scope-set b_0 0)))))"
"(define-values"
"(build-initial-require-mpi)"
"(lambda(mod-path_0 self_0)"
"(begin"
"(let-values(((mod-path270_0) mod-path_0)((self271_0) self_0))"
"(module-path->mpi.1 '#hasheq() mod-path270_0 self271_0)))))"
"(define-values"
"(perform-initial-require!.1)"
"(lambda(bind?35_0 who36_0 mpi39_0 self40_0 in-stx41_0 m-ns42_0 requires+provides43_0)"
"(begin"
" 'perform-initial-require!"
"(let-values(((mpi_0) mpi39_0))"
"(let-values(((self_0) self40_0))"
"(let-values(((in-stx_0) in-stx41_0))"
"(let-values(((m-ns_0) m-ns42_0))"
"(let-values(((requires+provides_0) requires+provides43_0))"
"(let-values(((bind?_0) bind?35_0))"
"(let-values(((who_0) who36_0))"
"(let-values()"
"(let-values(((mpi272_0) mpi_0)"
"((temp273_0) #f)"
"((self274_0) self_0)"
"((in-stx275_0) in-stx_0)"
"((m-ns276_0) m-ns_0)"
"((temp277_0) 0)"
"((temp278_0) 0)"
"((requires+provides279_0) requires+provides_0)"
"((temp280_0) #t)"
"((temp281_0) #t)"
"((bind?282_0) bind?_0)"
"((who283_0) who_0))"
"(perform-require!.1"
" #f"
" bind?282_0"
" temp280_0"
" #f"
" #f"
" temp281_0"
" 'all"
" #t"
" temp277_0"
" requires+provides279_0"
" temp278_0"
" #f"
" #f"
" unsafe-undefined"
" #t"
" who283_0"
" mpi272_0"
" temp273_0"
" self274_0"
" in-stx275_0"
" m-ns276_0)))))))))))))"
"(define-values"
"(perform-require!.1)"
"(lambda(adjust50_0"
" bind?59_0"
" can-be-shadowed?54_0"
" copy-variable-as-constant?57_0"
" copy-variable-phase-level56_0"
" initial-require?55_0"
" just-meta48_0"
" just-space49_0"
" phase-shift45_0"
" requires+provides51_0"
" run-phase47_0"
" run?53_0"
" skip-variable-phase-level58_0"
" space-level46_0"
" visit?52_0"
" who60_0"
" mpi77_0"
" orig-s78_0"
" self79_0"
" in-stx80_0"
" m-ns81_0)"
"(begin"
" 'perform-require!"
"(let-values(((mpi_0) mpi77_0))"
"(let-values(((orig-s_0) orig-s78_0))"
"(let-values()"
"(let-values(((in-stx_0) in-stx80_0))"
"(let-values(((m-ns_0) m-ns81_0))"
"(let-values(((phase-shift_0) phase-shift45_0))"
"(let-values(((space-level_0)(if(eq? space-level46_0 unsafe-undefined) '#:none space-level46_0)))"
"(let-values(((run-phase_0) run-phase47_0))"
"(let-values(((just-meta_0) just-meta48_0))"
"(let-values(((just-space_0) just-space49_0))"
"(let-values(((adjust_0) adjust50_0))"
"(let-values(((requires+provides_0) requires+provides51_0))"
"(let-values(((visit?_0) visit?52_0))"
"(let-values(((run?_0) run?53_0))"
"(let-values(((can-be-shadowed?_0) can-be-shadowed?54_0))"
"(let-values(((initial-require?_0) initial-require?55_0))"
"(let-values(((copy-variable-phase-level_0) copy-variable-phase-level56_0))"
"(let-values(((copy-variable-as-constant?_0) copy-variable-as-constant?57_0))"
"(let-values(((skip-variable-phase-level_0) skip-variable-phase-level58_0))"
"(let-values(((bind?_0) bind?59_0))"
"(let-values(((who_0) who60_0))"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'expand 'require))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((module-name_0)"
"(1/module-path-index-resolve mpi_0 #t orig-s_0)))"
"(let-values(((bind-in-stx_0)"
"(if(adjust-rename? adjust_0)"
"(adjust-rename-to-id adjust_0)"
" in-stx_0)))"
"(let-values(((done-syms_0)(if adjust_0(make-hasheq) #f)))"
"(let-values(((m_0)"
"(namespace->module m-ns_0 module-name_0)))"
"(let-values((()"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-unknown-module-error"
" 'require"
" module-name_0)))"
"(values))))"
"(let-values(((interned-mpi_0)"
"(if requires+provides_0"
"(add-required-module!"
" requires+provides_0"
" mpi_0"
"(intern-phase+space-shift"
" phase-shift_0"
" space-level_0)"
"(module-cross-phase-persistent? m_0))"
" mpi_0)))"
"(let-values(((transitive-requires_0)"
"(if requires+provides_0"
"(requires+provides-transitive-requires"
" requires+provides_0)"
" #f)))"
"(let-values((()"
"(begin"
"(if visit?_0"
"(let-values()"
"(let-values(((m-ns303_0)"
" m-ns_0)"
"((interned-mpi304_0)"
" interned-mpi_0)"
"((phase-shift305_0)"
" phase-shift_0)"
"((run-phase306_0)"
" run-phase_0)"
"((transitive-requires307_0)"
" transitive-requires_0))"
"(namespace-module-visit!.1"
" transitive-requires307_0"
" run-phase306_0"
" m-ns303_0"
" interned-mpi304_0"
" phase-shift305_0)))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if run?_0"
"(let-values()"
"(let-values(((m-ns308_0)"
" m-ns_0)"
"((interned-mpi309_0)"
" interned-mpi_0)"
"((phase-shift310_0)"
" phase-shift_0)"
"((run-phase311_0)"
" run-phase_0)"
"((transitive-requires312_0)"
" transitive-requires_0))"
"(namespace-module-instantiate!.1"
" #f"
" #t"
" #t"
" run-phase311_0"
" '#hasheq()"
" null"
" #f"
" transitive-requires312_0"
" m-ns308_0"
" interned-mpi309_0"
" phase-shift310_0)))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(not"
"(let-values(((or-part_0)"
" visit?_0))"
"(if or-part_0"
" or-part_0"
" run?_0)))"
"(let-values()"
"(let-values(((m-ns313_0)"
" m-ns_0)"
"((interned-mpi314_0)"
" interned-mpi_0)"
"((phase-shift315_0)"
" phase-shift_0)"
"((run-phase316_0)"
" run-phase_0)"
"((transitive-requires317_0)"
" transitive-requires_0))"
"(namespace-module-make-available!.1"
" transitive-requires317_0"
" run-phase316_0"
" m-ns313_0"
" interned-mpi314_0"
" phase-shift315_0)))"
"(void))"
"(values))))"
"(let-values(((can-bulk-bind?_0)"
"(if(eq?"
" space-level_0"
" '#:none)"
"(if(let-values(((or-part_0)"
"(not"
" adjust_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(adjust-prefix?"
" adjust_0)))"
"(if or-part_1"
" or-part_1"
"(adjust-all-except?"
" adjust_0)))))"
"(not"
" skip-variable-phase-level_0)"
" #f)"
" #f)))"
"(let-values(((bulk-prefix_0)"
"(if(adjust-prefix?"
" adjust_0)"
"(let-values()"
"(adjust-prefix-sym"
" adjust_0))"
"(if(adjust-all-except?"
" adjust_0)"
"(let-values()"
"(adjust-all-except-prefix-sym"
" adjust_0))"
"(let-values() #f)))))"
"(let-values(((bulk-excepts_0)"
"(if(adjust-all-except?"
" adjust_0)"
"(let-values()"
"(adjust-all-except-syms"
" adjust_0))"
"(let-values()"
" '#hasheq()))))"
"(let-values(((update-nominals-box_0)"
"(if can-bulk-bind?_0"
"(box null)"
" #f)))"
"(let-values((()"
"(begin"
"(let-values(((m284_0)"
" m_0)"
"((bind-in-stx285_0)"
" bind-in-stx_0)"
"((phase-shift286_0)"
" phase-shift_0)"
"((space-level287_0)"
" space-level_0)"
"((m-ns288_0)"
" m-ns_0)"
"((interned-mpi289_0)"
" interned-mpi_0)"
"((module-name290_0)"
" module-name_0)"
"((requires+provides291_0)"
" requires+provides_0)"
"((orig-s292_0)"
" orig-s_0)"
"((temp293_0)"
"(if requires+provides_0"
"(requires+provides-self"
" requires+provides_0)"
" #f))"
"((temp294_0)"
"(if(adjust-only?"
" adjust_0)"
"(let-values()"
"(set->list"
"(adjust-only-syms"
" adjust_0)))"
"(if(adjust-rename?"
" adjust_0)"
"(let-values()"
"(list"
"(adjust-rename-from-sym"
" adjust_0)))"
"(let-values()"
" #f))))"
"((just-meta295_0)"
" just-meta_0)"
"((just-space296_0)"
" just-space_0)"
"((bind?297_0)"
" bind?_0)"
"((can-bulk-bind?298_0)"
" can-bulk-bind?_0)"
"((bulk-prefix299_0)"
" bulk-prefix_0)"
"((bulk-excepts300_0)"
" bulk-excepts_0)"
"((temp301_0)"
"(if requires+provides_0"
"(if can-bulk-bind?_0"
"(lambda(provides_0"
" provide-phase+space_0)"
"(begin"
" 'temp301"
"(let-values(((requires+provides318_0)"
" requires+provides_0)"
"((bind-in-stx319_0)"
" bind-in-stx_0)"
"((temp320_0)"
"(module-self"
" m_0))"
"((mpi321_0)"
" mpi_0)"
"((phase-shift322_0)"
" phase-shift_0)"
"((provides323_0)"
" provides_0)"
"((provide-phase+space324_0)"
" provide-phase+space_0)"
"((bulk-prefix325_0)"
" bulk-prefix_0)"
"((bulk-excepts326_0)"
" bulk-excepts_0)"
"((temp327_0)"
"(if(positive?"
"(hash-count"
" bulk-excepts_0))"
" done-syms_0"
" #f))"
"((can-be-shadowed?328_0)"
" can-be-shadowed?_0)"
"((temp329_0)"
"(not"
" initial-require?_0))"
"((orig-s330_0)"
" orig-s_0)"
"((update-nominals-box331_0)"
" update-nominals-box_0)"
"((who332_0)"
" who_0))"
"(add-bulk-required-ids!.1"
" update-nominals-box331_0"
" can-be-shadowed?328_0"
" temp329_0"
" bulk-excepts326_0"
" orig-s330_0"
" bulk-prefix325_0"
" temp327_0"
" who332_0"
" requires+provides318_0"
" bind-in-stx319_0"
" temp320_0"
" mpi321_0"
" phase-shift322_0"
" provides323_0"
" provide-phase+space324_0))))"
" #f)"
" #f))"
"((temp302_0)"
"(if(let-values(((or-part_0)"
"(not"
" can-bulk-bind?_0)))"
"(if or-part_0"
" or-part_0"
" copy-variable-phase-level_0))"
"(lambda(binding_0"
" as-transformer?_0)"
"(begin"
" 'temp302"
"(let-values(((sym_0)"
"(module-binding-nominal-sym"
" binding_0)))"
"(let-values(((provide-phase+space_0)"
"(module-binding-nominal-phase+space"
" binding_0)))"
"(let-values(((provide-phase_0)"
"(phase+space-phase"
" provide-phase+space_0)))"
"(let-values(((provide-space_0)"
"(phase+space-space"
" provide-phase+space_0)))"
"(let-values(((adjusted-sym_0)"
"(if(not"
"(symbol-interned?"
" sym_0))"
"(let-values()"
" #f)"
"(if(if skip-variable-phase-level_0"
"(if(not"
" as-transformer?_0)"
"(equal?"
" provide-phase_0"
" skip-variable-phase-level_0)"
" #f)"
" #f)"
"(let-values()"
" #f)"
"(if(not"
" adjust_0)"
"(let-values()"
" sym_0)"
"(if(adjust-only?"
" adjust_0)"
"(let-values()"
"(if(set-member?"
"(adjust-only-syms"
" adjust_0)"
" sym_0)"
"(if(hash-set!"
" done-syms_0"
" sym_0"
" #t)"
" sym_0"
" #f)"
" #f))"
"(if(adjust-prefix?"
" adjust_0)"
"(let-values()"
"(string->symbol"
"(string-append"
"(symbol->string"
"(adjust-prefix-sym"
" adjust_0))"
"(symbol->string"
" sym_0))))"
"(if(adjust-all-except?"
" adjust_0)"
"(let-values()"
"(if(not"
"(if(set-member?"
"(adjust-all-except-syms"
" adjust_0)"
" sym_0)"
"(hash-set!"
" done-syms_0"
" sym_0"
" #t)"
" #f))"
"(string->symbol"
"(string-append"
"(symbol->string"
"(adjust-all-except-prefix-sym"
" adjust_0))"
"(symbol->string"
" sym_0)))"
" #f))"
"(if(adjust-rename?"
" adjust_0)"
"(let-values()"
"(if(eq?"
" sym_0"
"(adjust-rename-from-sym"
" adjust_0))"
"(if(hash-set!"
" done-syms_0"
" sym_0"
" #t)"
"(adjust-rename-to-id"
" adjust_0)"
" #f)"
" #f))"
"(void))))))))))"
"(let-values(((skip-bind?_0)"
"(if(if adjusted-sym_0"
" requires+provides_0"
" #f)"
"(let-values()"
"(let-values(((bind-phase_0)"
"(phase+"
" phase-shift_0"
" provide-phase_0)))"
"(let-values(((bind-space_0)"
"(space+"
" provide-space_0"
" space-level_0)))"
"(let-values(((s_0)"
"(add-space-scope"
"(datum->syntax$1"
" bind-in-stx_0"
" adjusted-sym_0)"
" bind-space_0)))"
"(let-values(((bound-status_0)"
"(if initial-require?_0"
"(let-values()"
" #f)"
"(let-values()"
"(begin"
"(adjust-shadow-requires!"
" requires+provides_0"
" s_0"
" bind-phase_0"
" bind-space_0)"
"(let-values(((temp333_0)"
" #t)"
"((temp334_0)"
"(requires+provides-definitions-shadow-imports?"
" requires+provides_0))"
"((requires+provides335_0)"
" requires+provides_0)"
"((s336_0)"
" s_0)"
"((bind-phase337_0)"
" bind-phase_0)"
"((bind-space338_0)"
" bind-space_0)"
"((binding339_0)"
" binding_0)"
"((orig-s340_0)"
" orig-s_0)"
"((temp341_0)"
" #t)"
"((who342_0)"
" who_0))"
"(check-not-defined.1"
" #f"
" temp334_0"
" temp333_0"
" orig-s340_0"
" temp341_0"
" binding339_0"
" who342_0"
" requires+provides335_0"
" s336_0"
" bind-phase337_0"
" bind-space338_0)))))))"
"(begin"
"(if(eq?"
" bound-status_0"
" 'defined)"
"(void)"
"(let-values()"
"(let-values(((requires+provides343_0)"
" requires+provides_0)"
"((s344_0)"
" s_0)"
"((temp345_0)"
"(intern-phase+space"
" bind-phase_0"
" bind-space_0))"
"((binding346_0)"
" binding_0)"
"((can-be-shadowed?347_0)"
" can-be-shadowed?_0)"
"((as-transformer?348_0)"
" as-transformer?_0))"
"(add-defined-or-required-id!.1"
" as-transformer?348_0"
" can-be-shadowed?347_0"
" requires+provides343_0"
" s344_0"
" temp345_0"
" binding346_0))))"
" bound-status_0))))))"
"(let-values()"
" #f))))"
"(begin"
"(if(if copy-variable-phase-level_0"
"(if(not"
" as-transformer?_0)"
"(equal?"
" provide-phase_0"
" copy-variable-phase-level_0)"
" #f)"
" #f)"
"(let-values()"
"(copy-namespace-value"
" m-ns_0"
" sym_0"
" binding_0"
" copy-variable-phase-level_0"
" phase-shift_0"
" copy-variable-as-constant?_0))"
"(void))"
"(if(not"
" skip-bind?_0)"
" adjusted-sym_0"
" #f))))))))))"
" #f)))"
"(bind-all-provides!.1"
" bind?297_0"
" temp301_0"
" bulk-excepts300_0"
" bulk-prefix299_0"
" can-bulk-bind?298_0"
" temp293_0"
" temp302_0"
" orig-s292_0"
" just-meta295_0"
" just-space296_0"
" temp294_0"
" m284_0"
" bind-in-stx285_0"
" phase-shift286_0"
" space-level287_0"
" m-ns288_0"
" interned-mpi289_0"
" module-name290_0"
" requires+provides291_0))"
"(values))))"
"(let-values((()"
"(begin"
"(if update-nominals-box_0"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(unbox"
" update-nominals-box_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((update!_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(update!_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))"
"(void))"
"(values))))"
"(let-values(((need-syms_0)"
"(if(adjust-only?"
" adjust_0)"
"(let-values()"
"(adjust-only-syms"
" adjust_0))"
"(if(adjust-all-except?"
" adjust_0)"
"(let-values()"
"(adjust-all-except-syms"
" adjust_0))"
"(if(adjust-rename?"
" adjust_0)"
"(let-values()"
"(set"
"(adjust-rename-from-sym"
" adjust_0)))"
"(let-values()"
" #f))))))"
"(if(if need-syms_0"
"(not"
"(="
"(set-count"
" need-syms_0)"
"(hash-count"
" done-syms_0)))"
" #f)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_0)"
" need-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(hash-ref"
" done-syms_0"
" sym_0"
" #f)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" who_0"
"                                                                                                                                                                       \"not in nested spec\""
" orig-s_0"
" sym_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first"
" ht_0)))))"
"(void)))"
"(void))))))))))))))))))))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void)))))))))))))))))))))))))))))"
"(define-values"
"(bind-all-provides!.1)"
"(lambda(bind?88_0"
" bulk-callback93_0"
" bulk-excepts91_0"
" bulk-prefix90_0"
" can-bulk?89_0"
" defines-mpi84_0"
" filter92_0"
" in83_0"
" just-meta86_0"
" just-space87_0"
" only85_0"
" m105_0"
" in-stx106_0"
" phase-shift107_0"
" space-level108_0"
" ns109_0"
" mpi110_0"
" module-name111_0"
" requires+provides112_0)"
"(begin"
" 'bind-all-provides!"
"(let-values(((m_0) m105_0))"
"(let-values(((in-stx_0) in-stx106_0))"
"(let-values(((phase-shift_0) phase-shift107_0))"
"(let-values(((space-level_0) space-level108_0))"
"(let-values(((ns_0) ns109_0))"
"(let-values(((mpi_0) mpi110_0))"
"(let-values(((module-name_0) module-name111_0))"
"(let-values(((requires+provides_0) requires+provides112_0))"
"(let-values(((orig-s_0) in83_0))"
"(let-values(((defines-mpi_0) defines-mpi84_0))"
"(let-values(((only-syms_0) only85_0))"
"(let-values(((just-meta_0) just-meta86_0))"
"(let-values(((just-space_0) just-space87_0))"
"(let-values(((bind?_0) bind?88_0))"
"(let-values(((can-bulk?_0) can-bulk?89_0))"
"(let-values(((bulk-prefix_0) bulk-prefix90_0))"
"(let-values(((bulk-excepts_0) bulk-excepts91_0))"
"(let-values(((filter_0) filter92_0))"
"(let-values(((bulk-callback_0) bulk-callback93_0))"
"(let-values()"
"(let-values(((self_0)(module-self m_0)))"
"(let-values(((phase+space-shift_0)"
"(intern-phase+space-shift phase-shift_0 space-level_0)))"
"(begin"
"(let-values()"
"(let-values(((ht_0)(module-provides m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((provide-phase+space_0"
" provides_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(if(if(let-values(((or-part_0)"
"(eq?"
" just-meta_0"
" 'all)))"
"(if or-part_0"
" or-part_0"
"(eqv?"
" just-meta_0"
"(phase+space-phase"
" provide-phase+space_0))))"
"(let-values(((or-part_0)"
"(eq?"
" just-space_0"
" #t)))"
"(if or-part_0"
" or-part_0"
"(eqv?"
" just-space_0"
"(phase+space-space"
" provide-phase+space_0))))"
" #f)"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((phase+space_0)"
"(phase+space+"
" provide-phase+space_0"
" phase+space-shift_0)))"
"(let-values(((phase_0)"
"(phase+space-phase"
" phase+space_0)))"
"(let-values(((space_0)"
"(phase+space-space"
" phase+space_0)))"
"(let-values((()"
"(begin"
"(if requires+provides_0"
"(let-values()"
"(add-required-space!"
" requires+provides_0"
" space_0))"
"(void))"
"(values))))"
"(let-values(((need-except?_0)"
"(if bulk-callback_0"
"(bulk-callback_0"
" provides_0"
" provide-phase+space_0)"
" #f)))"
"(if bind?_0"
"(let-values()"
"(begin"
"(if filter_0"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(let-values(((or-part_0)"
" only-syms_0))"
"(if or-part_0"
" or-part_0"
"(hash-keys"
" provides_0)))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((binding/p_0)"
"(hash-ref"
" provides_0"
" sym_0"
" #f)))"
"(if binding/p_0"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((binding/p349_0)"
" binding/p_0)"
"((sym350_0)"
" sym_0)"
"((self351_0)"
" self_0)"
"((mpi352_0)"
" mpi_0)"
"((provide-phase+space353_0)"
" provide-phase+space_0)"
"((phase+space-shift354_0)"
" phase+space-shift_0))"
"(provide-binding-to-require-binding.1"
" mpi352_0"
" phase+space-shift354_0"
" provide-phase+space353_0"
" self351_0"
" binding/p349_0"
" sym350_0))))"
"(let-values(((sym_1)"
"(filter_0"
" b_0"
"(provided-as-transformer?"
" binding/p_0))))"
"(if(if sym_1"
"(not"
" can-bulk?_0)"
" #f)"
"(let-values()"
"(let-values(((temp355_0)"
"(add-space-scope"
"(datum->syntax$1"
" in-stx_0"
" sym_1)"
" space_0))"
"((b356_0)"
" b_0)"
"((phase357_0)"
" phase_0))"
"(add-binding!.1"
" #f"
" #f"
" temp355_0"
" b356_0"
" phase357_0)))"
"(void)))))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_0))))"
"(void)))"
"(void))"
"(if can-bulk?_0"
"(let-values()"
"(let-values(((bulk-binding-registry_0)"
"(namespace-bulk-binding-registry"
" ns_0)))"
"(let-values(((temp358_0)"
"(add-space-scope"
" in-stx_0"
" space_0))"
"((temp359_0)"
"(bulk-binding12.1"
"(let-values(((or-part_0)"
"(if(not"
" bulk-prefix_0)"
"(if(zero?"
"(hash-count"
" bulk-excepts_0))"
" provides_0"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(not"
"(registered-bulk-provide?"
" bulk-binding-registry_0"
" module-name_0))"
"(bulk-provides-add-prefix-remove-exceptions"
" provides_0"
" bulk-prefix_0"
" bulk-excepts_0)"
" #f)))"
" bulk-prefix_0"
" bulk-excepts_0"
" self_0"
" mpi_0"
" provide-phase+space_0"
" phase-shift_0"
" bulk-binding-registry_0))"
"((phase360_0)"
" phase_0)"
"((orig-s361_0)"
" orig-s_0)"
"((temp362_0)"
"(if need-except?_0"
" defines-mpi_0"
" #f)))"
"(add-bulk-binding!.1"
" orig-s361_0"
" temp362_0"
" temp358_0"
" temp359_0"
" phase360_0))))"
"(void))))"
"(void))))))))"
"(values)))))"
"(values))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)))))))))))))))))))))))))))"
"(define-values"
"(require-spec-shift-for-syntax)"
"(lambda(req_0)"
"(begin"
"(let-values(((rebuild-req_0)"
"(lambda(req_1 new-req_0)(begin 'rebuild-req(datum->syntax$1 req_1 new-req_0 req_1 req_1)))))"
"(letrec-values(((loop_0)"
"(lambda(shifted?_0)"
"(begin"
" 'loop"
"(lambda(req_1)"
"(let-values(((fm_0)"
"(if(pair?(syntax-e$1 req_1))"
"(if(identifier?(car(syntax-e$1 req_1)))"
"(syntax-e$1(car(syntax-e$1 req_1)))"
" #f)"
" #f)))"
"(let-values(((tmp_0) fm_0))"
"(if(equal? tmp_0 'for-meta)"
"(let-values()"
"(let-values(((ok?_0 for-meta363_0 phase-level364_0 spec365_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((for-meta363_0 phase-level364_0 spec365_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((for-meta366_0)"
"(let-values(((s_2)(car s_1)))"
" s_2))"
"((phase-level367_0 spec368_0)"
"(let-values(((s_2)(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(let-values(((phase-level369_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec370_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                        \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level369_0"
" spec370_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                \"bad syntax\""
" orig-s_0))))))"
"(values"
" for-meta366_0"
" phase-level367_0"
" spec368_0))"
"(raise-syntax-error$1"
" #f"
"                                                                            \"bad syntax\""
" orig-s_0)))))"
"(values #t for-meta363_0 phase-level364_0 spec365_0))))))"
"(let-values(((p_0)(syntax-e$1 phase-level364_0)))"
"(begin"
"(if(phase? p_0)"
"(void)"
"                                               (let-values () (raise-syntax-error$1 #f \"bad phase\" req_1)))"
"(rebuild-req_0"
" req_1"
"(list* for-meta363_0(phase+ p_0 1)(map2(loop_0 #t) spec365_0)))))))"
"(if(equal? tmp_0 'for-syntax)"
"(let-values()"
"(let-values(((ok?_0 for-syntax371_0 spec372_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((for-syntax371_0 spec372_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((for-syntax373_0)"
"(let-values(((s_2)"
"(car s_1)))"
" s_2))"
"((spec374_0)"
"(let-values(((s_2)"
"(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                      \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values for-syntax373_0 spec374_0))"
"(raise-syntax-error$1"
" #f"
"                                                                              \"bad syntax\""
" orig-s_0)))))"
"(values #t for-syntax371_0 spec372_0))))))"
"(rebuild-req_0 req_1(list* 'for-meta 2(map2(loop_0 #t) spec372_0)))))"
"(if(equal? tmp_0 'for-template)"
"(let-values()"
"(let-values(((ok?_0 for-template375_0 spec376_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((for-template375_0 spec376_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((for-template377_0)"
"(let-values(((s_2)"
"(car s_1)))"
" s_2))"
"((spec378_0)"
"(let-values(((s_2)"
"(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                        \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values for-template377_0 spec378_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                \"bad syntax\""
" orig-s_0)))))"
"(values #t for-template375_0 spec376_0))))))"
"(rebuild-req_0 req_1(list* 'for-meta 0(map2(loop_0 #t) spec376_0)))))"
"(if(equal? tmp_0 'for-label)"
"(let-values()"
"(let-values(((ok?_0 for-label379_0 spec380_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((for-label379_0 spec380_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((for-label381_0)"
"(let-values(((s_2)"
"(car s_1)))"
" s_2))"
"((spec382_0)"
"(let-values(((s_2)"
"(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                          \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values for-label381_0 spec382_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                  \"bad syntax\""
" orig-s_0)))))"
"(values #t for-label379_0 spec380_0))))))"
"(rebuild-req_0"
" req_1"
"(list* for-label379_0(map2(loop_0 #t) spec380_0)))))"
"(if(equal? tmp_0 'just-meta)"
"(let-values()"
"(let-values(((ok?_0 just-meta383_0 phase-level384_0 spec385_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((just-meta383_0"
" phase-level384_0"
" spec385_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((just-meta386_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((phase-level387_0"
" spec388_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(let-values(((phase-level389_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec390_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level389_0"
" spec390_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                        \"bad syntax\""
" orig-s_0))))))"
"(values"
" just-meta386_0"
" phase-level387_0"
" spec388_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                    \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" just-meta383_0"
" phase-level384_0"
" spec385_0))))))"
"(rebuild-req_0"
" req_1"
"(list*"
" just-meta383_0"
" phase-level384_0"
"(map2(loop_0 #f) spec385_0)))))"
"(let-values()"
"(if shifted?_0"
" req_1"
"(datum->syntax$1 #f(list 'for-syntax req_1))))))))))))))))"
"((loop_0 #f) req_0))))))"
"(define-values"
"(copy-namespace-value)"
"(lambda(m-ns_0 adjusted-sym_0 binding_0 phase-level_0 phase-shift_0 as-constant?_0)"
"(begin"
"(let-values(((i-ns_0)"
"(let-values(((m-ns391_0) m-ns_0)"
"((temp392_0)(1/module-path-index-resolve(module-binding-module binding_0)))"
"((temp393_0)"
"(phase+"
"(phase-(module-binding-phase binding_0) phase-level_0)"
"(namespace-phase m-ns_0)))"
"((temp394_0) #t))"
"(namespace->module-namespace.1 #f temp394_0 void m-ns391_0 temp392_0 temp393_0))))"
"(let-values(((val_0)"
"(namespace-get-variable"
" i-ns_0"
"(module-binding-phase binding_0)"
"(module-binding-sym binding_0)"
"(lambda()"
"(error"
" 'namespace-require/copy"
"(format"
"(string-append"
"                            \"namespace mismatch;\\n\""
"                            \" variable not found\\n\""
"                            \"  module: ~a\\n\""
"                            \"  variable name: ~s\\n\""
"                            \"  phase level: ~s\")"
"(module-binding-module binding_0)"
"(module-binding-sym binding_0)"
"(module-binding-phase binding_0)))))))"
"(namespace-set-variable! m-ns_0(phase+ phase-shift_0 phase-level_0) adjusted-sym_0 val_0 as-constant?_0))))))"
"(define-values"
"(perform-portal-syntax-bind!.1)"
"(lambda(add-defined-portal118_0"
" orig-s114_0"
" phase-shift115_0"
" requires+provides117_0"
" self116_0"
" id124_0"
" portal-stx125_0)"
"(begin"
" 'perform-portal-syntax-bind!"
"(let-values(((id_0) id124_0))"
"(let-values(((portal-stx_0) portal-stx125_0))"
"(let-values(((orig-s_0) orig-s114_0))"
"(let-values(((phase-shift_0) phase-shift115_0))"
"(let-values(((self_0) self116_0))"
"(let-values()"
"(let-values(((add-defined-portal_0) add-defined-portal118_0))"
"(let-values()"
"(let-values(((sym_0)"
"(if add-defined-portal_0"
"(add-defined-portal_0 id_0 phase-shift_0 portal-stx_0 orig-s_0)"
"(syntax-e$1 id_0))))"
"(let-values(((binding_0)"
"(let-values(((temp398_0)"
"(let-values(((or-part_0) self_0))"
"(if or-part_0 or-part_0 top-level-module-path-index)))"
"((phase-shift399_0) phase-shift_0)"
"((sym400_0) sym_0))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" temp398_0"
" phase-shift399_0"
" sym400_0))))"
"(let-values(((id395_0) id_0)((binding396_0) binding_0)((phase-shift397_0) phase-shift_0))"
"(add-binding!.1 #f #f id395_0 binding396_0 phase-shift397_0)))))))))))))))"
"(define-values"
"(top-level-instance)"
"(1/make-instance"
" 'top-level"
" #f"
" 'constant"
" top-level-bind!-id"
"(lambda(id_0 mpi_0 orig-phase_0 phase-shift_0 ns_0 sym_0 trans?_0 trans-val_0)"
"(let-values(((phase_0)(phase+ orig-phase_0 phase-shift_0)))"
"(let-values(((b_0)"
"(let-values(((mpi4_0) mpi_0)"
"((phase5_0) phase_0)"
"((sym6_0) sym_0)"
"((temp7_0)(root-expand-context-frame-id(namespace-get-root-expand-ctx ns_0))))"
"(make-module-binding.1"
" #f"
" null"
" temp7_0"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" mpi4_0"
" phase5_0"
" sym6_0))))"
"(begin"
"(let-values(((id1_0) id_0)((b2_0) b_0)((phase3_0) phase_0))(add-binding!.1 #f #f id1_0 b2_0 phase3_0))"
"(if trans?_0"
"(let-values()(if trans-val_0(let-values()(maybe-install-free=id! trans-val_0 id_0 phase_0))(void)))"
"(let-values()(namespace-unset-transformer! ns_0 phase_0 sym_0)))))))"
" top-level-require!-id"
"(lambda(stx_0 ns_0 syms_0)"
"(let-values(((reqs_0)(cdr(syntax->list$1 stx_0))))"
"(let-values(((temp8_0) #t)"
"((temp9_0) #f)"
"((reqs10_0) reqs_0)"
"((temp11_0) #f)"
"((ns12_0) ns_0)"
"((temp13_0)(namespace-self-mpi/no-top-level ns_0))"
"((temp14_0)(namespace-phase ns_0))"
"((temp15_0)(let-values(((temp19_0) #f))(make-requires+provides.1 #f unsafe-undefined temp19_0)))"
"((temp16_0) 'require)"
"((temp17_0) #t)"
"((temp18_0)"
"(lambda(id_0 phase_0 portal-stx_0 orig-s_0)"
"(let-values(((sym_0)"
"(if(pair? syms_0)"
"(begin0(car syms_0)(set! syms_0(cdr syms_0)))"
"(syntax-e$1 id_0))))"
"(begin"
"(if phase_0"
"(let-values()"
"(let-values(((t_0)(portal-syntax1.1 portal-stx_0 #f)))"
"(namespace-set-transformer! ns_0 phase_0 sym_0 t_0)))"
"(void))"
" sym_0)))))"
"(parse-and-perform-requires!.1"
" temp18_0"
" #f"
" #f"
" #f"
" '#hasheq()"
" temp17_0"
" unsafe-undefined"
" temp8_0"
" temp13_0"
" #f"
" temp9_0"
" temp16_0"
" reqs10_0"
" temp11_0"
" ns12_0"
" temp14_0"
" temp15_0))))))"
"(define-values"
"(struct:compiled-in-memory"
" compiled-in-memory1.1"
" compiled-in-memory?"
" compiled-in-memory-linklet-directory"
" compiled-in-memory-original-self"
" compiled-in-memory-requires"
" compiled-in-memory-recur-requires"
" compiled-in-memory-flattened-requires"
" compiled-in-memory-provides"
" compiled-in-memory-phase-to-link-module-uses"
" compiled-in-memory-compile-time-inspector"
" compiled-in-memory-phase-to-link-extra-inspectorsss"
" compiled-in-memory-portal-stxes"
" compiled-in-memory-mpis"
" compiled-in-memory-syntax-literals"
" compiled-in-memory-pre-compiled-in-memorys"
" compiled-in-memory-post-compiled-in-memorys"
" compiled-in-memory-namespace-scopes"
" compiled-in-memory-purely-functional?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'compiled-in-memory"
" #f"
" 16"
" 0"
" #f"
"(list"
"(cons"
" prop:custom-write"
"(lambda(cim_0 port_0 mode_0)(write(compiled-in-memory-linklet-directory cim_0) port_0))))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)"
" #f"
" 'compiled-in-memory)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'linklet-directory)"
"(make-struct-field-accessor -ref_0 1 'original-self)"
"(make-struct-field-accessor -ref_0 2 'requires)"
"(make-struct-field-accessor -ref_0 3 'recur-requires)"
"(make-struct-field-accessor -ref_0 4 'flattened-requires)"
"(make-struct-field-accessor -ref_0 5 'provides)"
"(make-struct-field-accessor -ref_0 6 'phase-to-link-module-uses)"
"(make-struct-field-accessor -ref_0 7 'compile-time-inspector)"
"(make-struct-field-accessor -ref_0 8 'phase-to-link-extra-inspectorsss)"
"(make-struct-field-accessor -ref_0 9 'portal-stxes)"
"(make-struct-field-accessor -ref_0 10 'mpis)"
"(make-struct-field-accessor -ref_0 11 'syntax-literals)"
"(make-struct-field-accessor -ref_0 12 'pre-compiled-in-memorys)"
"(make-struct-field-accessor -ref_0 13 'post-compiled-in-memorys)"
"(make-struct-field-accessor -ref_0 14 'namespace-scopes)"
"(make-struct-field-accessor -ref_0 15 'purely-functional?))))"
"(define-values(version-bytes$1)(string->bytes/utf-8(version)))"
"(define-values(vm-bytes$1)(1/linklet-virtual-machine-bytes))"
"(define-values(datum->syntax$3) datum->syntax)"
"(define-values(syntax-property$2) syntax-property)"
"(define-values(syntax-span$2) syntax-span)"
"(define-values(syntax-position$2) syntax-position)"
"(define-values(syntax-column$2) syntax-column)"
"(define-values(syntax-line$2) syntax-line)"
"(define-values(syntax-source$2) syntax-source)"
"(define-values(syntax-e$2) syntax-e)"
"(define-values(1/syntax?) syntax?)"
"(define-values(correlated?)(lambda(e_0)(begin(1/syntax? e_0))))"
"(define-values"
"(datum->correlated)"
"(let-values(((datum->correlated_0)"
"(lambda(d2_0 srcloc1_0)"
"(begin"
" 'datum->correlated"
"(let-values(((d_0) d2_0))"
"(let-values(((srcloc_0) srcloc1_0))(let-values()(datum->syntax$3 #f d_0 srcloc_0))))))))"
"(case-lambda((d_0)(begin(datum->correlated_0 d_0 #f)))((d_0 srcloc1_0)(datum->correlated_0 d_0 srcloc1_0)))))"
"(define-values(correlated-e)(lambda(e_0)(begin(if(1/syntax? e_0)(syntax-e$2 e_0) e_0))))"
"(define-values(correlated-cadr)(lambda(e_0)(begin(car(correlated-e(cdr(correlated-e e_0)))))))"
"(define-values"
"(correlated-length)"
"(lambda(e_0)(begin(let-values(((l_0)(correlated-e e_0)))(if(list? l_0)(length l_0) #f)))))"
"(define-values"
"(correlated->list)"
"(lambda(e_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(e_1)"
"(begin"
" 'loop"
"(if(list? e_1)"
"(let-values() e_1)"
"(if(pair? e_1)"
"(let-values()(cons(car e_1)(loop_0(cdr e_1))))"
"(if(null? e_1)"
"(let-values() null)"
"(if(1/syntax? e_1)"
"(let-values()(loop_0(syntax-e$2 e_1)))"
"                                    (let-values () (error 'correlated->list \"not a list\"))))))))))"
" loop_0)"
" e_0))))"
"(define-values"
"(correlated-property)"
"(case-lambda((e_0 k_0)(begin(syntax-property$2 e_0 k_0)))((e_0 k_0 v_0)(syntax-property$2 e_0 k_0 v_0))))"
"(define-values"
"(to-syntax-list.1$1)"
"(lambda(s_0)"
"(begin"
" 'to-syntax-list"
"(if(list? s_0)"
"(let-values() s_0)"
"(if(pair? s_0)"
"(let-values()(let-values(((r_0)(to-syntax-list.1$1(cdr s_0))))(if r_0(cons(car s_0) r_0) #f)))"
"(if(1/syntax? s_0)(let-values()(to-syntax-list.1$1(syntax-e$2 s_0)))(let-values() #f)))))))"
"(define-values(correlated-source)(lambda(s_0)(begin(syntax-source$2 s_0))))"
"(define-values(correlated-line)(lambda(s_0)(begin(syntax-line$2 s_0))))"
"(define-values(correlated-column)(lambda(s_0)(begin(syntax-column$2 s_0))))"
"(define-values(correlated-position)(lambda(s_0)(begin(syntax-position$2 s_0))))"
"(define-values(correlated-span)(lambda(s_0)(begin(syntax-span$2 s_0))))"
"(define-values"
"(struct:correlated-linklet"
" correlated-linklet1.1"
" correlated-linklet?"
" correlated-linklet-expr"
" correlated-linklet-name"
" correlated-linklet-compiled"
" set-correlated-linklet-compiled!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'correlated-linklet"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'correlated-linklet)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'expr)"
"(make-struct-field-accessor -ref_0 1 'name)"
"(make-struct-field-accessor -ref_0 2 'compiled)"
"(make-struct-field-mutator -set!_0 2 'compiled))))"
"(define-values(make-correlated-linklet)(lambda(expr_0 name_0)(begin(correlated-linklet1.1 expr_0 name_0 #f))))"
"(define-values"
"(force-compile-linklet)"
"(lambda(l_0)"
"(begin"
"(if(correlated-linklet? l_0)"
"(let-values()"
"(let-values(((or-part_0)(correlated-linklet-compiled l_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((c_0)(1/compile-linklet(correlated-linklet-expr l_0)(correlated-linklet-name l_0))))"
"(begin(set-correlated-linklet-compiled! l_0 c_0) c_0)))))"
"(let-values() l_0)))))"
"(define-values"
"(eval-correlated-linklet)"
"(lambda(l_0)"
"(begin"
"(if(correlated-linklet? l_0)"
"(let-values()"
"(eval-linklet$1(1/compile-linklet(correlated-linklet-expr l_0)(correlated-linklet-name l_0) #f #f '())))"
"        (let-values () (error 'eval-correlated-linklet \"cannot evaluate unknown linklet: ~s\" l_0))))))"
" (define-values (correlated-linklet-vm-bytes) #\"linklet\")"
"(define-values"
"(struct:faslable-correlated"
" faslable-correlated2.1"
" faslable-correlated?"
" faslable-correlated-e"
" faslable-correlated-source"
" faslable-correlated-position"
" faslable-correlated-line"
" faslable-correlated-column"
" faslable-correlated-span"
" faslable-correlated-props)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'faslable-correlated"
" #f"
" 7"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'faslable-correlated)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'e)"
"(make-struct-field-accessor -ref_0 1 'source)"
"(make-struct-field-accessor -ref_0 2 'position)"
"(make-struct-field-accessor -ref_0 3 'line)"
"(make-struct-field-accessor -ref_0 4 'column)"
"(make-struct-field-accessor -ref_0 5 'span)"
"(make-struct-field-accessor -ref_0 6 'props))))"
"(define-values"
"(struct:faslable-correlated-linklet"
" faslable-correlated-linklet3.1"
" faslable-correlated-linklet?"
" faslable-correlated-linklet-expr"
" faslable-correlated-linklet-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'faslable-correlated-linklet"
" #f"
" 2"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0 1)"
" #f"
" 'faslable-correlated-linklet)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'expr)"
"(make-struct-field-accessor -ref_0 1 'name))))"
"(define-values"
"(write-correlated-linklet-bundle-hash)"
"(lambda(ht_0 o_0)"
"(begin(let-values(((temp7_0)(->faslable ht_0))((o8_0) o_0))(s-exp->fasl.1 #f #f #f #f temp7_0 o8_0)))))"
"(define-values"
"(->faslable)"
"(lambda(v_0)"
"(begin"
"(if(pair? v_0)"
"(let-values()"
"(let-values(((a_0)(->faslable(car v_0))))"
"(let-values(((d_0)(->faslable(cdr v_0))))"
"(if(if(eq? a_0(car v_0))(eq? d_0(cdr v_0)) #f) v_0(cons a_0 d_0)))))"
"(if(correlated? v_0)"
"(let-values()"
"(faslable-correlated2.1"
"(->faslable(correlated-e v_0))"
"(correlated-source v_0)"
"(correlated-position v_0)"
"(correlated-line v_0)"
"(correlated-column v_0)"
"(correlated-span v_0)"
"(let-values(((ht_0)(let-values(((ht_0) #f)) ht_0)))"
"(let-values(((lst_0)"
" '(inferred-name"
" undefined-error-name"
" method-arity-error"
" compiler-hint:cross-module-inline"
" body-as-unsafe)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((k_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_2)"
"(let-values(((ht_2)"
"(let-values()"
"(let-values(((p_0)"
"(correlated-property"
" v_0"
" k_0)))"
"(if p_0"
"(hash-set"
"(let-values(((or-part_0) ht_1))"
"(if or-part_0 or-part_0 '#hasheq()))"
" k_0"
" p_0)"
" ht_1)))))"
"(values ht_2))))"
"(if(not #f)(for-loop_0 ht_2 rest_0) ht_2)))"
" ht_1))))))"
" for-loop_0)"
" ht_0"
" lst_0))))))"
"(if(hash? v_0)"
"(let-values()"
"(let-values(((v9_0) v_0)"
"((temp10_0)(lambda(key_0 value_0)(values(->faslable key_0)(->faslable value_0))))"
"((temp11_0) 'immutable))"
"(hash-map/copy.1 temp11_0 v9_0 temp10_0)))"
"(if(correlated-linklet? v_0)"
"(let-values()"
"(faslable-correlated-linklet3.1"
"(->faslable(correlated-linklet-expr v_0))"
"(->faslable(correlated-linklet-name v_0))))"
"(let-values() v_0))))))))"
"(define-values"
"(read-correlated-linklet-bundle-hash)"
"(lambda(in_0)"
"(begin"
"(faslable->(let-values(((in12_0) in_0)((temp13_0) #t))(fasl->s-exp.1 temp13_0 unsafe-undefined #f in12_0))))))"
"(define-values"
"(faslable->)"
"(lambda(v_0)"
"(begin"
"(if(pair? v_0)"
"(let-values()"
"(let-values(((a_0)(faslable->(car v_0))))"
"(let-values(((d_0)(faslable->(cdr v_0))))"
"(if(if(eq? a_0(car v_0))(eq? d_0(cdr v_0)) #f) v_0(cons a_0 d_0)))))"
"(if(faslable-correlated? v_0)"
"(let-values()"
"(let-values(((props_0)(faslable-correlated-props v_0)))"
"(let-values(((c_0)"
"(datum->correlated"
"(faslable->(faslable-correlated-e v_0))"
"(vector"
"(faslable-correlated-source v_0)"
"(faslable-correlated-line v_0)"
"(faslable-correlated-column v_0)"
"(faslable-correlated-position v_0)"
"(faslable-correlated-span v_0)))))"
"(if props_0"
"(let-values(((c_1)(let-values(((c_1) c_0)) c_1)))"
"(let-values(((ht_0) props_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(c_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 p_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((c_3)"
"(let-values(((c_3)"
"(let-values()"
"(correlated-property c_2 k_0 p_0))))"
"(values c_3))))"
"(if(not #f)(for-loop_0 c_3(hash-iterate-next ht_0 i_0)) c_3)))"
" c_2))))))"
" for-loop_0)"
" c_1"
"(hash-iterate-first ht_0)))))"
" c_0))))"
"(if(hash? v_0)"
"(let-values()"
"(let-values(((v14_0) v_0)"
"((temp15_0)(lambda(key_0 value_0)(values(faslable-> key_0)(faslable-> value_0))))"
"((temp16_0) 'immutable))"
"(hash-map/copy.1 temp16_0 v14_0 temp15_0)))"
"(if(faslable-correlated-linklet? v_0)"
"(let-values()"
"(make-correlated-linklet"
"(faslable->(faslable-correlated-linklet-expr v_0))"
"(faslable->(faslable-correlated-linklet-name v_0))))"
"(let-values() v_0))))))))"
"(define-values"
"(machine-type-vm-bytes)"
"(lambda(machine-type_0)"
"(begin"
"(if(eq? machine-type_0(system-type 'target-machine))"
" vm-bytes$1"
"(string->bytes/utf-8(symbol->string machine-type_0))))))"
"(define-values"
"(write-linklet-bundle)"
"(lambda(b_0 as-correlated-linklet?_0 linklet-bundle->hash_0 machine-type_0 port_0)"
"(begin"
"(begin"
"        (write-bytes #\"#~\" port_0)"
"(write-bytes(bytes(bytes-length version-bytes$1)) port_0)"
"(write-bytes version-bytes$1 port_0)"
"(let-values(((vm-bytes_0)"
"(if as-correlated-linklet?_0 correlated-linklet-vm-bytes(machine-type-vm-bytes machine-type_0))))"
"(begin(write-bytes(bytes(bytes-length vm-bytes_0)) port_0)(write-bytes vm-bytes_0 port_0)))"
"        (write-bytes #\"B\" port_0)"
"(write-bytes(make-bytes 20 0) port_0)"
"(if as-correlated-linklet?_0"
"(write-correlated-linklet-bundle-hash(linklet-bundle->hash_0 b_0) port_0)"
"(1/write-linklet-bundle-hash(linklet-bundle->hash_0 b_0) port_0))))))"
"(define-values"
"(linklet-bundle->bytes)"
"(lambda(b_0 as-correlated-linklet?_0 linklet-bundle->hash_0 machine-type_0)"
"(begin"
"(let-values(((o_0)(open-output-bytes)))"
"(begin"
"(write-linklet-bundle b_0 as-correlated-linklet?_0 linklet-bundle->hash_0 machine-type_0 o_0)"
"(get-output-bytes o_0))))))"
"(define-values"
"(write-linklet-directory)"
"(lambda(ld_0 as-correlated-linklet?_0 linklet-directory->hash_0 linklet-bundle->hash_0 machine-type_0 port_0)"
"(begin"
"(let-values(((vm-bytes_0)"
"(if as-correlated-linklet?_0 correlated-linklet-vm-bytes(machine-type-vm-bytes machine-type_0))))"
"        (let-values ((() (begin (write-bytes #\"#~\" port_0) (values))))"
"(let-values((()(begin(write-byte(bytes-length version-bytes$1) port_0)(values))))"
"(let-values((()(begin(write-bytes version-bytes$1 port_0)(values))))"
"(let-values((()(begin(write-byte(bytes-length vm-bytes_0) port_0)(values))))"
"(let-values((()(begin(write-bytes vm-bytes_0 port_0)(values))))"
"                  (let-values ((() (begin (write-bytes #\"D\" port_0) (values))))"
"(letrec-values(((flatten-linklet-directory_0)"
"(lambda(ld_1 rev-name-prefix_0 accum_0)"
"(begin"
" 'flatten-linklet-directory"
"(let-values(((new-accum_0 saw-bundle?_0)"
"(let-values(((accum_1)"
"(let-values(((accum_1) accum_0)) accum_1))"
"((saw-bundle?_0)"
"(let-values(((saw-bundle?_0) #f)) saw-bundle?_0)))"
"(let-values(((ht_0)(linklet-directory->hash_0 ld_1)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(accum_2 saw-bundle?_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((key_0 value_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((accum_3"
" saw-bundle?_2)"
"(let-values(((accum_3"
" saw-bundle?_2)"
"(let-values()"
"(if(eq?"
" key_0"
" #f)"
"(let-values()"
"(values"
"(cons"
"(cons"
"(encode-name"
" rev-name-prefix_0)"
"(linklet-bundle->bytes"
" value_0"
" as-correlated-linklet?_0"
" linklet-bundle->hash_0"
" machine-type_0))"
" accum_2)"
" #t))"
"(let-values()"
"(values"
"(flatten-linklet-directory_0"
" value_0"
"(cons"
" key_0"
" rev-name-prefix_0)"
" accum_2)"
" saw-bundle?_1))))))"
"(values"
" accum_3"
" saw-bundle?_2))))"
"(if(not #f)"
"(for-loop_0"
" accum_3"
" saw-bundle?_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
"(values"
" accum_3"
" saw-bundle?_2))))"
"(values"
" accum_2"
" saw-bundle?_1)))))))"
" for-loop_0)"
" accum_1"
" saw-bundle?_0"
"(hash-iterate-first ht_0)))))))"
"(if saw-bundle?_0"
"(let-values() new-accum_0)"
"(let-values()"
"                                               (cons (cons (encode-name rev-name-prefix_0) #\"#f\") new-accum_0))))))))"
"(let-values(((bundles_0)"
"(list->vector"
"(let-values(((temp1_0)(flatten-linklet-directory_0 ld_0 '() '()))"
"((temp2_0)(lambda(a_0 b_0)(bytes<?(car a_0)(car b_0)))))"
"(sort.1 #f #f temp1_0 temp2_0)))))"
"(let-values(((len_0)(vector-length bundles_0)))"
"(let-values(((initial-offset_0)"
"(+ 2 1(bytes-length version-bytes$1) 1(bytes-length vm-bytes_0) 1 4)))"
"(let-values((()(begin(write-int len_0 port_0)(values))))"
"(let-values(((btree-size_0)(compute-btree-size bundles_0 len_0)))"
"(let-values(((node-offsets_0)"
"(compute-btree-node-offsets bundles_0 len_0 initial-offset_0)))"
"(let-values(((bundle-offsets_0)"
"(compute-bundle-offsets"
" bundles_0"
" len_0"
"(+ initial-offset_0 btree-size_0))))"
"(begin"
"(write-directory-btree bundles_0 node-offsets_0 bundle-offsets_0 len_0 port_0)"
"(let-values()"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_0) pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(write-bytes"
"(cdr"
"(vector-ref"
" bundles_0"
" i_0))"
" port_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(+ pos_0 inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0))))"
"(void))))))))))))))))))))"
"(define-values"
"(encode-name)"
"(lambda(rev-name_0)"
"(begin"
"(let-values(((encode-symbol_0)"
"(lambda(s_0)"
"(begin"
" 'encode-symbol"
"(let-values(((bstr_0)(string->bytes/utf-8(symbol->string s_0))))"
"(let-values(((len_0)(bytes-length bstr_0)))"
"(if(< len_0 255)"
"(list(bytes len_0) bstr_0)"
"(list(bytes 255)(integer->integer-bytes len_0 4 #f #f) bstr_0))))))))"
"((letrec-values(((loop_0)"
"(lambda(rev-name_1 accum_0)"
"(begin"
" 'loop"
"(if(null? rev-name_1)"
"(let-values()(apply bytes-append accum_0))"
"(let-values()"
"(loop_0(cdr rev-name_1)(append(encode-symbol_0(car rev-name_1)) accum_0))))))))"
" loop_0)"
" rev-name_0"
" '())))))"
"(define-values"
"(compute-btree-size)"
"(lambda(bundles_0 len_0)"
"(begin"
"(let-values(((result_0)(let-values(((result_0) 0)) result_0)))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values(((i_0) pos_0))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(+"
" result_1"
"(let-values()"
"(let-values(((nlen_0)"
"(bytes-length"
"(car"
"(vector-ref bundles_0 i_0)))))"
"(+ nlen_0(* 5 4))))))))"
"(values result_2))))"
"(if(not #f)(for-loop_0 result_2(+ pos_0 inc_0)) result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" start_0)))))))"
"(define-values"
"(compute-btree-node-offsets)"
"(lambda(bundles_0 len_0 initial-offset_0)"
"(begin"
"(let-values(((node-offsets_0)(make-vector len_0)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(lo_0 hi_0 offset_0)"
"(begin"
" 'loop"
"(if(= lo_0 hi_0)"
"(let-values() offset_0)"
"(let-values()"
"(let-values(((mid_0)(quotient(+ lo_0 hi_0) 2)))"
"(let-values((()(begin(vector-set! node-offsets_0 mid_0 offset_0)(values))))"
"(let-values(((nlen_0)(bytes-length(car(vector-ref bundles_0 mid_0)))))"
"(let-values(((offset_1)(+ offset_0 4 nlen_0 4 4 4 4)))"
"(let-values(((offset_2)(loop_0 lo_0 mid_0 offset_1)))"
"(loop_0(add1 mid_0) hi_0 offset_2))))))))))))"
" loop_0)"
" 0"
" len_0"
" initial-offset_0)"
" node-offsets_0)))))"
"(define-values"
"(compute-bundle-offsets)"
"(lambda(bundles_0 len_0 offset_0)"
"(begin"
"(let-values(((bundle-offsets_0)(make-vector len_0)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0 offset_1)"
"(begin"
" 'loop"
"(if(= i_0 len_0)"
"(void)"
"(let-values()"
"(begin"
"(vector-set! bundle-offsets_0 i_0 offset_1)"
"(loop_0"
"(add1 i_0)"
"(+ offset_1(bytes-length(cdr(vector-ref bundles_0 i_0))))))))))))"
" loop_0)"
" 0"
" offset_0)"
" bundle-offsets_0)))))"
"(define-values"
"(write-directory-btree)"
"(lambda(bundles_0 node-offsets_0 bundle-offsets_0 len_0 port_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(lo_0 hi_0)"
"(begin"
" 'loop"
"(if(= lo_0 hi_0)"
"(let-values()(void))"
"(let-values()"
"(let-values(((mid_0)(quotient(+ lo_0 hi_0) 2)))"
"(let-values(((p_0)(vector-ref bundles_0 mid_0)))"
"(let-values(((nlen_0)(bytes-length(car p_0))))"
"(begin"
"(write-int nlen_0 port_0)"
"(write-bytes(car p_0) port_0)"
"(write-int(vector-ref bundle-offsets_0 mid_0) port_0)"
"(write-int(bytes-length(cdr p_0)) port_0)"
"(if(> mid_0 lo_0)"
"(let-values()"
"(let-values(((left_0)(quotient(+ lo_0 mid_0) 2)))"
"(write-int(vector-ref node-offsets_0 left_0) port_0)))"
"(let-values()(write-int 0 port_0)))"
"(if(<(add1 mid_0) hi_0)"
"(let-values()"
"(let-values(((right_0)(quotient(+(add1 mid_0) hi_0) 2)))"
"(write-int(vector-ref node-offsets_0 right_0) port_0)))"
"(let-values()(write-int 0 port_0)))"
"(loop_0 lo_0 mid_0)"
"(loop_0(add1 mid_0) hi_0)))))))))))"
" loop_0)"
" 0"
" len_0))))"
"(define-values(write-int)(lambda(n_0 port_0)(begin(write-bytes(integer->integer-bytes n_0 4 #f #f) port_0))))"
"(define-values"
"(struct:linklet-directory linklet-directory1.1 linklet-directory?$1 linklet-directory-ht)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'linklet-directory"
" #f"
" 1"
" 0"
" #f"
"(list"
"(cons"
" prop:custom-write"
"(lambda(ld_0 port_0 mode_0)"
"(let-values(((machine-type_0)(linklet-directory-machine-type ld_0)))"
"(write-linklet-directory"
" ld_0"
"(not machine-type_0)"
" linklet-directory->hash$1"
" 1/linklet-bundle->hash"
" machine-type_0"
" port_0)))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'linklet-directory)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'ht))))"
"(define-values"
"(struct:linklet-bundle linklet-bundle2.1 1/linklet-bundle? linklet-bundle-ht)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'linklet-bundle"
" #f"
" 1"
" 0"
" #f"
"(list"
"(cons"
" prop:custom-write"
"(lambda(b_0 port_0 mode_0)"
"(let-values(((machine-type_0)(linklet-bundle-machine-type b_0)))"
"(write-linklet-bundle"
" b_0"
"(not machine-type_0)"
" 1/linklet-bundle->hash"
" machine-type_0"
" port_0)))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'linklet-bundle)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'ht))))"
"(define-values"
"(1/hash->linklet-directory)"
"(lambda(ht_0)"
"(begin"
" 'hash->linklet-directory"
"(let-values()"
"(let-values()"
"(begin"
"(if((lambda(ht_1)"
"(if(not(impersonator? ht_1))(if(hash? ht_1)(if(immutable? ht_1)(hash-eq? ht_1) #f) #f) #f))"
" ht_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'hash->linklet-directory"
"                 \"(and/c hash? hash-eq? immutable? (not/c impersonator?))\""
" ht_0)))"
"(let-values()"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_1 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(not k_0)"
"(let-values()"
"(if(1/linklet-bundle? v_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'hash->linklet-directory"
"                                                                                       \"value for #f key is not a linklet bundle\""
"                                                                                       \"value\""
" v_0))))"
"(if(symbol? k_0)"
"(let-values()"
"(if(linklet-directory?$1 v_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'hash->linklet-directory"
"                                                                                         \"value for symbol key is not a linklet directory\""
"                                                                                         \"value\""
" v_0))))"
"(let-values()"
"(raise-arguments-error"
" 'hash->linklet-directory"
"                                                                                     \"key in given hash is not #f or a symbol\""
"                                                                                     \"key\""
" k_0)))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_1 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_1)))))"
"(void)"
"(linklet-directory1.1 ht_0)))))))"
"(define-values"
"(1/hash->linklet-bundle)"
"(lambda(ht_0)"
"(begin"
" 'hash->linklet-bundle"
"(let-values()"
"(let-values()"
"(begin"
"(if((lambda(ht_1)"
"(if(not(impersonator? ht_1))(if(hash? ht_1)(if(immutable? ht_1)(hash-eq? ht_1) #f) #f) #f))"
" ht_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'hash->linklet-bundle"
"                 \"(and/c hash? hash-eq? immutable? (not/c impersonator?))\""
" ht_0)))"
"(let-values()"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)(hash-iterate-key ht_1 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(let-values(((or-part_0)"
"(symbol? k_0)))"
"(if or-part_0"
" or-part_0"
"(fixnum? k_0)))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'hash->linklet-bundle"
"                                                                                   \"key in given hash is not a symbol or fixnum\""
"                                                                                   \"key\""
" k_0))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_1 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_1)))))"
"(void)"
"(linklet-bundle2.1 ht_0)))))))"
"(define-values"
"(linklet-directory->hash$1)"
"(lambda(ld_0)"
"(begin"
" 'linklet-directory->hash"
"(let-values()"
"(let-values()"
"(begin"
"(if(linklet-directory?$1 ld_0)"
"(void)"
"              (let-values () (raise-argument-error 'linklet-directory->hash \"linklet-directory?\" ld_0)))"
"(linklet-directory-ht ld_0)))))))"
"(define-values"
"(1/linklet-bundle->hash)"
"(lambda(ld_0)"
"(begin"
" 'linklet-bundle->hash"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/linklet-bundle? ld_0)"
"(void)"
"              (let-values () (raise-argument-error 'linklet-bundle->hash \"linklet-bundle?\" ld_0)))"
"(linklet-bundle-ht ld_0)))))))"
"(define-values"
"(linklet-directory-machine-type)"
"(lambda(ld_0)"
"(begin"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((ht_0)(linklet-directory->hash$1 ld_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(not k_0)"
"(let-values()"
"(linklet-bundle-machine-type v_0))"
"(if(symbol? k_0)"
"(let-values()"
"(linklet-directory-machine-type v_0))"
"(let-values() #f)))))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) k_0 v_0))(not #f) #f)"
"(for-loop_0 result_2(hash-iterate-next ht_0 i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(hash-iterate-first ht_0))))))))"
"(define-values"
"(linklet-bundle-machine-type)"
"(lambda(b_0)"
"(begin"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((ht_0)(1/linklet-bundle->hash b_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(linklet?$1 v_0)"
"(let-values(((or-part_0)"
"(1/linklet-cross-machine-type"
" v_0)))"
"(if or-part_0"
" or-part_0"
"(system-type 'target-machine)))"
" #f)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) k_0 v_0))(not #f) #f)"
"(for-loop_0 result_2(hash-iterate-next ht_0 i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(hash-iterate-first ht_0))))))))"
"(define-values"
"(struct:namespace-scopes namespace-scopes1.1 namespace-scopes? namespace-scopes-post namespace-scopes-other)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'namespace-scopes #f 2 0 #f null 'prefab #f '(0 1) #f 'namespace-scopes)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'post)"
"(make-struct-field-accessor -ref_0 1 'other))))"
"(define-values"
"(swap-top-level-scopes)"
"(lambda(s_0 original-scopes-s_0 new-ns_0)"
"(begin"
"(let-values(((old-scs-post_0 old-scs-other_0)"
"(if(namespace-scopes? original-scopes-s_0)"
"(values(namespace-scopes-post original-scopes-s_0)(namespace-scopes-other original-scopes-s_0))"
"(decode-namespace-scopes original-scopes-s_0))))"
"(let-values(((new-scs-post_0 new-scs-other_0)(extract-namespace-scopes/values new-ns_0)))"
"(syntax-swap-scopes"
"(syntax-swap-scopes s_0 old-scs-post_0 new-scs-post_0)"
" old-scs-other_0"
" new-scs-other_0))))))"
"(define-values"
"(extract-namespace-scopes/values)"
"(lambda(ns_0)"
"(begin"
"(let-values(((root-ctx_0)(namespace-get-root-expand-ctx ns_0)))"
"(let-values(((post-expansion-sc_0)(post-expansion-scope(root-expand-context-post-expansion root-ctx_0))))"
"(values"
"(seteq post-expansion-sc_0)"
"(set-remove(list->seteq(root-expand-context-module-scopes root-ctx_0)) post-expansion-sc_0)))))))"
"(define-values"
"(extract-namespace-scopes)"
"(lambda(ns_0)"
"(begin"
"(let-values(((scs-post_0 scs-other_0)(extract-namespace-scopes/values ns_0)))"
"(namespace-scopes1.1 scs-post_0 scs-other_0)))))"
"(define-values"
"(encode-namespace-scopes)"
"(lambda(ns_0)"
"(begin"
"(let-values(((post-expansion-scs_0 other-scs_0)(extract-namespace-scopes/values ns_0)))"
"(let-values(((post-expansion-s_0)(add-scopes(datum->syntax$1 #f 'post)(set->list post-expansion-scs_0))))"
"(let-values(((other-s_0)(add-scopes(datum->syntax$1 #f 'other)(set->list other-scs_0))))"
"(datum->syntax$1 #f(vector post-expansion-s_0 other-s_0))))))))"
"(define-values"
"(decode-namespace-scopes)"
"(lambda(stx_0)"
"(begin"
"(let-values(((vec_0)(syntax-e$1 stx_0)))"
"(values(syntax-scope-set(vector-ref vec_0 0) 0)(syntax-scope-set(vector-ref vec_0 1) 0))))))"
"(define-values"
"(namespace-scopes=?)"
"(lambda(nss1_0 nss2_0)"
"(begin"
"(if(set=?(namespace-scopes-post nss1_0)(namespace-scopes-post nss2_0))"
"(set=?(namespace-scopes-other nss1_0)(namespace-scopes-other nss2_0))"
" #f))))"
"(define-values"
"(struct:syntax-literals"
" syntax-literals1.1"
" syntax-literals?"
" syntax-literals-stxes"
" syntax-literals-count"
" set-syntax-literals-stxes!"
" set-syntax-literals-count!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'syntax-literals"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'syntax-literals)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'stxes)"
"(make-struct-field-accessor -ref_0 1 'count)"
"(make-struct-field-mutator -set!_0 0 'stxes)"
"(make-struct-field-mutator -set!_0 1 'count))))"
"(define-values"
"(struct:header"
" header2.1"
" header?"
" header-module-path-indexes"
" header-binding-sym-to-define-sym"
" header-binding-syms-in-order"
" header-require-var-to-import-sym"
" header-import-sym-to-extra-inspectors"
" header-require-vars-in-order"
" header-define-and-import-syms"
" header-syntax-literals"
" set-header-binding-syms-in-order!"
" set-header-require-vars-in-order!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'header #f 8 0 #f null(current-inspector) #f '(0 1 3 4 6 7) #f 'header)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module-path-indexes)"
"(make-struct-field-accessor -ref_0 1 'binding-sym-to-define-sym)"
"(make-struct-field-accessor -ref_0 2 'binding-syms-in-order)"
"(make-struct-field-accessor -ref_0 3 'require-var-to-import-sym)"
"(make-struct-field-accessor -ref_0 4 'import-sym-to-extra-inspectors)"
"(make-struct-field-accessor -ref_0 5 'require-vars-in-order)"
"(make-struct-field-accessor -ref_0 6 'define-and-import-syms)"
"(make-struct-field-accessor -ref_0 7 'syntax-literals)"
"(make-struct-field-mutator -set!_0 2 'binding-syms-in-order)"
"(make-struct-field-mutator -set!_0 5 'require-vars-in-order))))"
"(define-values"
"(struct:variable-use variable-use3.1 variable-use? variable-use-module-use variable-use-sym)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'variable-use #f 2 0 #f null #f #f '(0 1) #f 'variable-use)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module-use)"
"(make-struct-field-accessor -ref_0 1 'sym))))"
"(define-values(make-syntax-literals)(lambda()(begin(syntax-literals1.1 null 0))))"
"(define-values"
"(make-header)"
"(lambda(mpis_0 syntax-literals_0)"
"(begin"
"(header2.1 mpis_0(make-hasheq) null(make-variable-uses)(make-hasheq) null(make-hasheq) syntax-literals_0))))"
"(define-values(make-variable-uses)(lambda()(begin(make-hash))))"
"(define-values"
"(add-syntax-literal!)"
"(lambda(header-or-literals_0 q_0)"
"(begin"
"(let-values(((sl_0)"
"(if(header? header-or-literals_0)"
"(header-syntax-literals header-or-literals_0)"
" header-or-literals_0)))"
"(let-values(((pos_0)(syntax-literals-count sl_0)))"
"(begin"
"(set-syntax-literals-count! sl_0(add1 pos_0))"
"(set-syntax-literals-stxes! sl_0(cons q_0(syntax-literals-stxes sl_0)))"
" pos_0))))))"
"(define-values"
"(add-syntax-literals!)"
"(lambda(sl_0 vec_0)"
"(begin"
"(let-values(((pos_0)(syntax-literals-count sl_0)))"
"(begin"
"(let-values()"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1) vec_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_1)))"
"(values vec_1(unsafe-vector-length vec_1))))))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_1)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_1 len_0)"
"(let-values(((e_0)(unsafe-vector-ref vec_1 pos_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()(add-syntax-literal! sl_0 e_0))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(unsafe-fx+ 1 pos_1))(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)"
"(cons pos_0(vector-length vec_0)))))))"
"(define-values(syntax-literals-empty?)(lambda(sl_0)(begin(null?(syntax-literals-stxes sl_0)))))"
"(define-values"
"(generate-lazy-syntax-literals!.1)"
"(lambda(skip-deserialize?4_0 sl6_0 mpis7_0 self8_0)"
"(begin"
" 'generate-lazy-syntax-literals!"
"(let-values(((sl_0) sl6_0))"
"(let-values(((mpis_0) mpis7_0))"
"(let-values(((self_0) self8_0))"
"(let-values(((skip-deserialize?_0) skip-deserialize?4_0))"
"(let-values()"
"(list"
"(list 'define-values(list syntax-literals-id)(list* 'make-vector(syntax-literals-count sl_0) '(#f)))"
"(list"
" 'define-values"
"(list get-syntax-literal!-id)"
"(list"
" 'lambda"
" '(pos)"
"(list"
" 'let-values"
"(list(list '(ready-stx)(list* 'unsafe-vector*-ref syntax-literals-id '(pos))))"
"(list"
" 'if"
" 'ready-stx"
" 'ready-stx"
"(list"
" 'force-syntax-object"
" syntax-literals-id"
" 'pos"
"(add-module-path-index! mpis_0 self_0)"
" self-id"
" phase-shift-id"
" inspector-id"
" deserialized-syntax-vector-id"
" bulk-binding-registry-id"
"(if skip-deserialize?_0 #f deserialize-syntax-id)))))))))))))))"
"(define-values"
"(generate-lazy-syntax-literals-data!)"
"(lambda(sl_0 mpis_0)"
"(begin"
"(if(syntax-literals-empty? sl_0)"
"(let-values()(list(list* 'define-values(list deserialize-syntax-id) '(#f))))"
"(let-values()"
"(list"
"(list"
" 'define-values"
"(list deserialize-syntax-id)"
"(list"
" 'lambda"
"(list bulk-binding-registry-id)"
"(list"
" 'begin"
"(list"
" 'vector-copy!"
" deserialized-syntax-vector-id"
" ''0"
"(list"
" 'let-values"
"(list(list*(list inspector-id) '(#f)))"
"(let-values(((temp21_0)"
"(vector->immutable-vector(list->vector(reverse$1(syntax-literals-stxes sl_0)))))"
"((mpis22_0) mpis_0))"
"(generate-deserialize.1"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" mpis22_0"
" #f"
" '#hasheq()"
" #f"
" #t"
" temp21_0))))"
"(list* 'set! deserialize-syntax-id '(#f)))))))))))"
"(define-values(generate-lazy-syntax-literal-lookup)(lambda(pos_0)(begin(list get-syntax-literal!-id pos_0))))"
"(define-values"
"(generate-eager-syntax-literals!)"
"(lambda(sl_0 mpis_0 base-phase_0 self_0 ns_0)"
"(begin"
"(if(syntax-literals-empty? sl_0)"
"(let-values() #f)"
"(let-values()"
"(list"
" 'let-values"
"(list"
"(list"
" '(ns+stxss)"
"(let-values(((temp23_0)(cons(encode-namespace-scopes ns_0)(reverse$1(syntax-literals-stxes sl_0))))"
"((mpis24_0) mpis_0))"
"(generate-deserialize.1 #f #f unsafe-undefined unsafe-undefined mpis24_0 #f '#hasheq() #f #t temp23_0))))"
"(list"
" 'let-values"
" '(((ns-scope-s)(car ns+stxss)))"
"(list"
" 'list->vector"
"(list*"
" 'map"
"(list"
" 'lambda"
" '(stx)"
"(list"
" 'swap-top-level-scopes"
"(list"
" 'syntax-module-path-index-shift"
"(list 'syntax-shift-phase-level 'stx(list '- base-phase_0 dest-phase-id))"
"(add-module-path-index! mpis_0 self_0)"
" self-id)"
" 'ns-scope-s"
" ns-id))"
" '((cdr ns+stxss)))))))))))"
"(define-values"
"(generate-eager-syntax-literal-lookup)"
"(lambda(pos_0)(begin(list 'unsafe-vector*-ref syntax-literals-id pos_0))))"
"(define-values"
"(syntax-literals-as-vector)"
"(lambda(sl_0)(begin(list->vector(reverse$1(syntax-literals-stxes sl_0))))))"
"(define-values"
"(select-fresh)"
"(lambda(sym_0 header_0)"
"(begin"
"(if(symbol-conflicts? sym_0 header_0)"
"((letrec-values(((loop_0)"
"(lambda(pos_0)"
"(begin"
" 'loop"
"(let-values(((new-sym_0)"
"(string->symbol"
"                                             (string-append (number->string pos_0) \"/\" (symbol->string sym_0)))))"
"(if(symbol-conflicts? new-sym_0 header_0)(loop_0(add1 pos_0)) new-sym_0))))))"
" loop_0)"
" 1)"
" sym_0))))"
"(define-values"
"(symbol-conflicts?)"
"(lambda(sym_0 header_0)"
"(begin"
"(let-values(((or-part_0)(built-in-symbol? sym_0)))"
"(if or-part_0 or-part_0(hash-ref(header-define-and-import-syms header_0) sym_0 #f))))))"
"(define-values"
"(register-required-variable-use!.1)"
"(lambda(defined?10_0 header12_0 mpi13_0 phase14_0 sym15_0 extra-inspector16_0)"
"(begin"
" 'register-required-variable-use!"
"(let-values(((header_0) header12_0))"
"(let-values(((mpi_0) mpi13_0))"
"(let-values(((phase_0) phase14_0))"
"(let-values(((sym_0) sym15_0))"
"(let-values(((extra-inspector_0) extra-inspector16_0))"
"(let-values(((defined?_0) defined?10_0))"
"(let-values()"
"(let-values(((key_0)(variable-use3.1(module-use1.1 mpi_0 phase_0) sym_0)))"
"(let-values(((variable-uses_0)(header-require-var-to-import-sym header_0)))"
"(let-values(((prev-var-sym_0)(hash-ref variable-uses_0 key_0 #f)))"
"(let-values(((var-sym_0)"
"(let-values(((or-part_0) prev-var-sym_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((sym_1)(select-fresh(variable-use-sym key_0) header_0)))"
"(begin"
"(hash-set! variable-uses_0 key_0 sym_1)"
"(set-header-require-vars-in-order!"
" header_0"
"(cons key_0(header-require-vars-in-order header_0)))"
"(hash-set!"
"(header-define-and-import-syms header_0)"
" sym_1"
"(if defined?_0 'defined 'required))"
" sym_1))))))"
"(begin"
"(if(if extra-inspector_0(not prev-var-sym_0) #f)"
"(let-values()"
"(let-values(((extra-inspectors_0)(header-import-sym-to-extra-inspectors header_0)))"
"(hash-update!"
" extra-inspectors_0"
" var-sym_0"
"(lambda(s_0)(set-add s_0 extra-inspector_0))"
" '#hasheq())))"
"(void))"
" var-sym_0)))))))))))))))"
"(define-values"
"(register-as-defined!)"
"(lambda(header_0 def-sym_0)(begin(hash-set!(header-define-and-import-syms header_0) def-sym_0 'defined))))"
"(define-values"
"(registered-as-required?)"
"(lambda(header_0 var-sym_0)"
"(begin(eq? 'required(hash-ref(header-define-and-import-syms header_0) var-sym_0 #f)))))"
"(define-values"
"(generate-links+imports)"
"(lambda(header_0 phase_0 cctx_0 cross-linklet-inlining?_0)"
"(begin"
"(let-values(((mod-use-ht_0 link-mod-uses_0)"
"(let-values(((ht_0)(let-values(((ht_0) '#hash())) ht_0))"
"((link-mod-uses_0)(let-values(((link-mod-uses_0) null)) link-mod-uses_0)))"
"(let-values(((lst_0)(header-require-vars-in-order header_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_1 link-mod-uses_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((vu_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_2 link-mod-uses_2)"
"(let-values(((ht_2 link-mod-uses_2)"
"(let-values()"
"(let-values(((mu_0)"
"(variable-use-module-use"
" vu_0)))"
"(if(let-values(((or-part_0)"
"(hash-ref"
" ht_1"
" mu_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(eq?"
"(module-use-module"
" mu_0)"
"(compile-context-self"
" cctx_0))))"
"(if or-part_1"
" or-part_1"
"(top-level-module-path-index?"
"(module-use-module"
" mu_0))))))"
"(values ht_1 link-mod-uses_1)"
"(values"
"(hash-set ht_1 mu_0 #t)"
"(cons"
" mu_0"
" link-mod-uses_1)))))))"
"(values ht_2 link-mod-uses_2))))"
"(if(not #f)"
"(for-loop_0 ht_2 link-mod-uses_2 rest_0)"
"(values ht_2 link-mod-uses_2))))"
"(values ht_1 link-mod-uses_1)))))))"
" for-loop_0)"
" ht_0"
" link-mod-uses_0"
" lst_0))))))"
"(values"
" link-mod-uses_0"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) link-mod-uses_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
"(header-require-vars-in-order"
" header_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((vu_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(if(equal?"
" mu_0"
"(variable-use-module-use"
" vu_0))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((var-sym_0)"
"(hash-ref"
"(header-require-var-to-import-sym"
" header_0)"
" vu_0)))"
"(let-values(((ex-sym_0)"
"(variable-use-sym"
" vu_0)))"
"(if(eq?"
" var-sym_0"
" ex-sym_0)"
" var-sym_0"
"(list"
" ex-sym_0"
" var-sym_0)))))"
" fold-var_3))))"
"(values"
" fold-var_4))"
" fold-var_3)))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) link-mod-uses_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((extra-inspectorss_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hash()))"
" table_0)))"
"(let-values(((lst_2)"
"(header-require-vars-in-order"
" header_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((vu_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((table_2)"
"(if(equal?"
" mu_0"
"(variable-use-module-use"
" vu_0))"
"(let-values(((id*_0)"
"(hash-ref"
"(header-require-var-to-import-sym"
" header_0)"
" vu_0)))"
"((letrec-values(((for-loop_2)"
"(lambda(table_2)"
"(begin"
" 'for-loop"
"(let-values(((var-sym_0)"
" id*_0))"
"(let-values(((table_3)"
"(let-values(((id*_1)"
"(hash-ref"
"(header-import-sym-to-extra-inspectors"
" header_0)"
" var-sym_0"
" #f)))"
"((letrec-values(((for-loop_3)"
"(lambda(table_3)"
"(begin"
" 'for-loop"
"(let-values(((extra-inspectors_0)"
" id*_1))"
"(let-values(((table_4)"
"(if(let-values(((or-part_0)"
" extra-inspectors_0))"
"(if or-part_0"
" or-part_0"
" cross-linklet-inlining?_0))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" var-sym_0"
" extra-inspectors_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))"
" table_3)))"
" table_4))))))"
" for-loop_3)"
" table_2))))"
" table_3))))))"
" for-loop_2)"
" table_1))"
" table_1)))"
"(if(not"
" #f)"
"(for-loop_1"
" table_2"
" rest_1)"
" table_2)))"
" table_1))))))"
" for-loop_1)"
" table_0"
" lst_2))))))"
"(if(hash-count extra-inspectorss_0)"
" extra-inspectorss_0"
" #f)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(header-require-vars-in-order header_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((vu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(if(let-values(((mod_0)"
"(module-use-module"
"(variable-use-module-use vu_0))))"
"(let-values(((or-part_0)"
"(eq?"
" mod_0"
"(compile-context-self cctx_0))))"
"(if or-part_0"
" or-part_0"
"(top-level-module-path-index? mod_0))))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((var-sym_0)"
"(hash-ref"
"(header-require-var-to-import-sym"
" header_0)"
" vu_0)))"
"(let-values(((ex-sym_0)"
"(variable-use-sym vu_0)))"
"(if(eq? var-sym_0 ex-sym_0)"
" var-sym_0"
"(list var-sym_0 ex-sym_0)))))"
" fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))"
"(define-values"
"(instance-imports)"
"(list ns-id phase-shift-id self-id inspector-id bulk-binding-registry-id set-transformer!-id))"
"(define-values"
"(make-instance-instance.1)"
"(lambda(bulk-binding-registry5_0 inspector4_0 namespace1_0 phase-shift2_0 self3_0 set-transformer!6_0)"
"(begin"
" 'make-instance-instance"
"(let-values(((ns_0) namespace1_0))"
"(let-values(((phase-shift_0) phase-shift2_0))"
"(let-values(((self_0) self3_0))"
"(let-values(((inspector_0) inspector4_0))"
"(let-values(((bulk-binding-registry_0) bulk-binding-registry5_0))"
"(let-values(((set-transformer!_0) set-transformer!6_0))"
"(let-values()"
"(1/make-instance"
" 'instance"
" #f"
" 'constant"
" ns-id"
" ns_0"
" phase-shift-id"
" phase-shift_0"
" self-id"
" self_0"
" inspector-id"
" inspector_0"
" bulk-binding-registry-id"
" bulk-binding-registry_0"
" set-transformer!-id"
" set-transformer!_0)))))))))))"
"(define-values"
"(make-module-body-instance-instance.1)"
"(lambda(set-transformer!14_0)"
"(begin"
" 'make-module-body-instance-instance"
"(let-values(((set-transformer!_0) set-transformer!14_0))"
"(let-values()(1/make-instance 'body-instance #f 'constant set-transformer!-id set-transformer!_0))))))"
"(define-values"
"(empty-syntax-literals-instance)"
"(1/make-instance 'empty-stx #f 'constant get-syntax-literal!-id(lambda(pos_0) #f) 'get-encoded-root-expand-ctx #f))"
"(void(1/instance-describe-variable! empty-syntax-literals-instance get-syntax-literal!-id '(procedure/pure 2)))"
"(define-values"
"(empty-module-body-instance)"
"(let-values(((temp17_0)(lambda(name_0 val_0)(void))))(make-module-body-instance-instance.1 temp17_0)))"
"(void(1/instance-describe-variable! empty-module-body-instance set-transformer!-id '(procedure/succeeds 4)))"
"(define-values"
"(empty-top-syntax-literal-instance)"
"(1/make-instance 'top-syntax-literal #f 'constant mpi-vector-id #f syntax-literals-id #f))"
"(define-values"
"(empty-syntax-literals-data-instance)"
"(1/make-instance 'empty-stx-data #f 'constant deserialized-syntax-vector-id(vector) deserialize-syntax-id void))"
"(define-values"
"(empty-instance-instance)"
"(let-values(((temp18_0) #f)((temp19_0) #f)((temp20_0) #f)((temp21_0) #f)((temp22_0) #f)((temp23_0) #f))"
"(make-instance-instance.1 temp22_0 temp21_0 temp18_0 temp19_0 temp20_0 temp23_0)))"
"(define-values"
"(eager-instance-imports)"
"(list* ns-id dest-phase-id self-id bulk-binding-registry-id inspector-id '(swap-top-level-scopes)))"
"(define-values"
"(make-eager-instance-instance.1)"
"(lambda(bulk-binding-registry4_0 dest-phase2_0 inspector5_0 namespace1_0 self3_0)"
"(begin"
" 'make-eager-instance-instance"
"(let-values(((ns_0) namespace1_0))"
"(let-values(((dest-phase_0) dest-phase2_0))"
"(let-values(((self_0) self3_0))"
"(let-values(((bulk-binding-registry_0) bulk-binding-registry4_0))"
"(let-values(((inspector_0) inspector5_0))"
"(let-values()"
"(1/make-instance"
" 'instance"
" #f"
" 'constant"
" ns-id"
" ns_0"
" dest-phase-id"
" dest-phase_0"
" self-id"
" self_0"
" bulk-binding-registry-id"
" bulk-binding-registry_0"
" inspector-id"
" inspector_0"
" 'swap-top-level-scopes"
" swap-top-level-scopes))))))))))"
"(define-values"
"(empty-eager-instance-instance)"
"(let-values(((temp12_0) #f)((temp13_0) #f)((temp14_0) #f)((temp15_0) #f)((temp16_0) #f))"
"(make-eager-instance-instance.1 temp15_0 temp13_0 temp16_0 temp12_0 temp14_0)))"
"(define-values"
"(self-quoting-in-linklet?)"
"(lambda(datum_0)"
"(begin"
"(let-values(((or-part_0)(number? datum_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? datum_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(string? datum_0)))(if or-part_2 or-part_2(bytes? datum_0))))))))))"
"(define-values"
"(extra-inspectors-allow?)"
"(lambda(extra-inspectors_0 guard-insp_0)"
"(begin"
"(if(not extra-inspectors_0)"
"(let-values() #f)"
"(if(set? extra-inspectors_0)"
"(let-values()"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((ht_0) extra-inspectors_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((extra-insp_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(inspector-superior?"
" extra-insp_0"
" guard-insp_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) extra-insp_0))(not #f) #f)"
"(for-loop_0 result_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(if(procedure? extra-inspectors_0)"
"(let-values()(extra-inspectors_0 guard-insp_0))"
"(let-values()"
"(error"
" 'extra-inspectors-allow?"
"               \"unknown representation of extra inspectors: ~e\""
" extra-inspectors_0))))))))"
"(define-values"
"(extra-inspectors-merge)"
"(lambda(extra-inspectors-1_0 extra-inspectors-2_0)"
"(begin"
"(if(let-values(((or-part_0)(not extra-inspectors-1_0)))(if or-part_0 or-part_0(not extra-inspectors-2_0)))"
"(let-values() #f)"
"(if(if(set? extra-inspectors-1_0)(set? extra-inspectors-2_0) #f)"
"(let-values()(set-union extra-inspectors-1_0 extra-inspectors-2_0))"
"(let-values()"
"(lambda(guard-insp_0)"
"(if(extra-inspectors-allow? extra-inspectors-1_0 guard-insp_0)"
"(extra-inspectors-allow? extra-inspectors-2_0 guard-insp_0)"
" #f))))))))"
"(define-values"
"(struct:module-use*"
" module-use*1.1"
" module-use*?"
" module-use*-extra-inspectorss"
" module-use*-self-inspector"
" set-module-use*-extra-inspectorss!"
" set-module-use*-self-inspector!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-use*"
" struct:module-use"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'module-use*)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'extra-inspectorss)"
"(make-struct-field-accessor -ref_0 1 'self-inspector)"
"(make-struct-field-mutator -set!_0 0 'extra-inspectorss)"
"(make-struct-field-mutator -set!_0 1 'self-inspector))))"
"(define-values"
"(module-uses-add-extra-inspectorsss)"
"(lambda(mus_0 extra-inspectorsss_0)"
"(begin"
"(if extra-inspectorsss_0"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) mus_0)((lst_1) extra-inspectorsss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((mu_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((extra-inspectorss_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-use*1.1"
"(module-use-module mu_0)"
"(module-use-phase mu_0)"
" extra-inspectorss_0"
" #f))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0 rest_1) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1))))))"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) mus_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-use*1.1"
"(module-use-module mu_0)"
"(module-use-phase mu_0)"
" #f"
" #f))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))"
"(define-values"
"(module-uses-strip-extra-inspectorsss)"
"(lambda(mu*s_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) mu*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mu*_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-use1.1"
"(module-use-module mu*_0)"
"(module-use-phase mu*_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(define-values"
"(module-uses-extract-extra-inspectorsss)"
"(lambda(mu*s_0 linklet_0 check-inlined-reference?_0 skip-n_0)"
"(begin"
"(if(not check-inlined-reference?_0)"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) mu*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((mu*_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-use*-extra-inspectorss mu*_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) mu*s_0)((lst_1)(list-tail(linklet-import-variables$1 linklet_0) skip-n_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((mu*_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((imports_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((extra-inspectorss_0)"
"(module-use*-extra-inspectorss"
" mu*_0)))"
"(let-values(((extra-inspectorss_1)"
"(let-values(((extra-inspectorss_1)"
" extra-inspectorss_0))"
" extra-inspectorss_1)))"
"(let-values(((lst_4) imports_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_4)))"
"((letrec-values(((for-loop_1)"
"(lambda(extra-inspectorss_2"
" lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_5)"
"(let-values(((import_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((extra-inspectorss_3)"
"(let-values(((extra-inspectorss_3)"
"(let-values()"
"(if(eq?"
"(hash-ref"
" extra-inspectorss_2"
" import_0"
" '#:not-recorded)"
" '#:not-recorded)"
"(let-values()"
"(hash-set"
" extra-inspectorss_2"
" import_0"
"(set"
"(module-use*-self-inspector"
" mu*_0))))"
"(let-values()"
" extra-inspectorss_2)))))"
"(values"
" extra-inspectorss_3))))"
"(if(not"
" #f)"
"(for-loop_1"
" extra-inspectorss_3"
" rest_2)"
" extra-inspectorss_3)))"
" extra-inspectorss_2))))))"
" for-loop_1)"
" extra-inspectorss_1"
" lst_4))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0 rest_1) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1))))))))))"
"(define-values"
"(module-use*-declaration-inspector!)"
"(lambda(mu*_0 insp_0)(begin(set-module-use*-self-inspector! mu*_0 insp_0))))"
"(define-values"
"(module-use+extra-inspectors)"
"(lambda(mpi_0 phase_0 imports_0 inspector_0 extra-inspector_0 extra-inspectorss_0)"
"(begin"
"(let-values(((now-inspector_0)(current-code-inspector)))"
"(let-values(((add-insp?_0)(if inspector_0(inspector-superior? inspector_0 now-inspector_0) #f)))"
"(let-values(((add-extra-insp?_0)"
"(if extra-inspector_0(inspector-superior? extra-inspector_0 now-inspector_0) #f)))"
"(let-values(((new-extra-inspectorss_0)"
"(if(let-values(((or-part_0) add-insp?_0))(if or-part_0 or-part_0 add-extra-insp?_0))"
"(let-values()"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((lst_0) imports_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((import_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" import_0"
"(let-values(((extra-inspectors_0)"
"(if extra-inspectorss_0"
"(hash-ref"
" extra-inspectorss_0"
" import_0"
" #f)"
" #f)))"
"(lambda(guard-insp_0)"
"(let-values(((or-part_0)"
"(if add-insp?_0"
"(inspector-superior?"
" inspector_0"
" guard-insp_0)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if add-extra-insp?_0"
"(inspector-superior?"
" extra-inspector_0"
" guard-insp_0)"
" #f)))"
"(if or-part_1"
" or-part_1"
"(extra-inspectors-allow?"
" extra-inspectors_0"
" guard-insp_0)))))))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2 rest_0) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0)))))"
"(let-values()"
"(let-values(((extra-inspectorss_1)"
"(let-values(((extra-inspectorss_1)"
"(let-values(((or-part_0) extra-inspectorss_0))"
"(if or-part_0 or-part_0(seteq)))))"
" extra-inspectorss_1)))"
"(let-values(((lst_0) imports_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(extra-inspectorss_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((import_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((extra-inspectorss_3)"
"(let-values(((extra-inspectorss_3)"
"(let-values()"
"(if(hash-ref"
" extra-inspectorss_2"
" import_0"
" #f)"
" extra-inspectorss_2"
"(hash-set"
" extra-inspectorss_2"
" import_0"
" #f)))))"
"(values extra-inspectorss_3))))"
"(if(not #f)"
"(for-loop_0 extra-inspectorss_3 rest_0)"
" extra-inspectorss_3)))"
" extra-inspectorss_2))))))"
" for-loop_0)"
" extra-inspectorss_1"
" lst_0))))))))"
"(module-use*1.1 mpi_0 phase_0 new-extra-inspectorss_0 #f))))))))"
"(define-values"
"(module-use-merge-extra-inspectorss!)"
"(lambda(existing-mu*_0 mu*_0)"
"(begin"
"(let-values(((existing-extra-inspectorss_0)(module-use*-extra-inspectorss existing-mu*_0)))"
"(let-values(((extra-inspectorss_0)(module-use*-extra-inspectorss mu*_0)))"
"(let-values(((new-extra-inspectorss_0)"
"(if(not existing-extra-inspectorss_0)"
"(let-values() extra-inspectorss_0)"
"(if(not extra-inspectorss_0)"
"(let-values() existing-extra-inspectorss_0)"
"(let-values()"
"(let-values(((new-extra-inspectorss_0)"
"(let-values(((new-extra-inspectorss_0) existing-extra-inspectorss_0))"
" new-extra-inspectorss_0)))"
"(let-values(((ht_0) extra-inspectorss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(new-extra-inspectorss_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0 extra-inspectors_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((new-extra-inspectorss_2)"
"(let-values(((new-extra-inspectorss_2)"
"(let-values()"
"(hash-set"
" new-extra-inspectorss_1"
" sym_0"
"(extra-inspectors-merge"
" extra-inspectors_0"
"(hash-ref"
" new-extra-inspectorss_1"
" sym_0"
"(seteq)))))))"
"(values new-extra-inspectorss_2))))"
"(if(not #f)"
"(for-loop_0"
" new-extra-inspectorss_2"
"(hash-iterate-next ht_0 i_0))"
" new-extra-inspectorss_2)))"
" new-extra-inspectorss_1))))))"
" for-loop_0)"
" new-extra-inspectorss_0"
"(hash-iterate-first ht_0))))))))))"
"(set-module-use*-extra-inspectorss! existing-mu*_0 new-extra-inspectorss_0)))))))"
"(define-values(initial-code-inspector)(current-code-inspector))"
"(define-values"
"(check-require-access.1)"
"(lambda(skip-imports1_0"
" linklet3_0"
" import-module-uses4_0"
" import-module-instances5_0"
" insp6_0"
" extra-inspector7_0"
" extra-inspectorsss8_0)"
"(begin"
" 'check-require-access"
"(let-values(((linklet_0) linklet3_0))"
"(let-values(((skip-num-imports_0) skip-imports1_0))"
"(let-values(((import-module-uses_0) import-module-uses4_0))"
"(let-values(((import-module-instances_0) import-module-instances5_0))"
"(let-values(((insp_0) insp6_0))"
"(let-values(((extra-inspector_0) extra-inspector7_0))"
"(let-values(((extra-inspectorsss_0) extra-inspectorsss8_0))"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)(list-tail(linklet-import-variables$1 linklet_0) skip-num-imports_0))"
"((lst_1) import-module-uses_0)"
"((lst_2) import-module-instances_0)"
"((lst_3)"
"(let-values(((or-part_0) extra-inspectorsss_0))"
"(if or-part_0 or-part_0 import-module-uses_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_3)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_4 lst_5 lst_6 lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_4)"
"(if(pair? lst_5)(if(pair? lst_6)(pair? lst_7) #f) #f)"
" #f)"
"(let-values(((import-syms_0)(unsafe-car lst_4))"
"((rest_0)(unsafe-cdr lst_4))"
"((mu_0)(unsafe-car lst_5))"
"((rest_1)(unsafe-cdr lst_5))"
"((mi_0)(unsafe-car lst_6))"
"((rest_2)(unsafe-cdr lst_6))"
"((extra-inspectorss_0)(unsafe-car lst_7))"
"((rest_3)(unsafe-cdr lst_7)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((m_0)"
"(module-instance-module"
" mi_0)))"
"(if(module-no-protected?"
" m_0)"
"(void)"
"(let-values()"
"(let-values(((access_0)"
"(let-values(((or-part_0)"
"(module-access"
" m_0)))"
"(if or-part_0"
" or-part_0"
"(module-compute-access!"
" m_0)))))"
"(begin"
"(let-values()"
"(let-values(((lst_8)"
" import-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_8)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_9)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_9)"
"(let-values(((import-sym_0)"
"(unsafe-car"
" lst_9))"
"((rest_4)"
"(unsafe-cdr"
" lst_9)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((a_0)"
"(hash-ref"
"(hash-ref"
" access_0"
"(module-use-phase"
" mu_0)"
" '#hasheq())"
" import-sym_0"
" 'unexported)))"
"(if(let-values(((or-part_0)"
"(eq?"
" a_0"
" 'unexported)))"
"(if or-part_0"
" or-part_0"
"(eq?"
" a_0"
" 'protected)))"
"(let-values()"
"(let-values(((guard-insp_0)"
"(namespace-inspector"
"(module-instance-namespace"
" mi_0))))"
"(if(let-values(((or-part_0)"
"(inspector-superior?"
" insp_0"
" guard-insp_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if extra-inspector_0"
"(inspector-superior?"
" extra-inspector_0"
" guard-insp_0)"
" #f)))"
"(if or-part_1"
" or-part_1"
"(if extra-inspectorsss_0"
"(if extra-inspectorss_0"
"(extra-inspectors-allow?"
"(hash-ref"
" extra-inspectorss_0"
" import-sym_0"
" #f)"
" guard-insp_0)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(error"
" 'link"
"(string-append"
"                                                                                                                                                                                    \"access disallowed by code inspector to ~a variable\\n\""
"                                                                                                                                                                                    \"  variable: ~s\\n\""
"                                                                                                                                                                                    \"  from module: ~a\")"
" a_0"
" import-sym_0"
"(1/module-path-index-resolve"
"(namespace-mpi"
"(module-instance-namespace"
" mi_0))))))))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_4)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_8))))"
"(void)))))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0 rest_0 rest_1 rest_2 rest_3)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" lst_1"
" lst_2"
" lst_3))))"
"(void)))))))))))))"
"(define-values"
"(check-single-require-access)"
"(lambda(mi_0 phase_0 sym_0 insp_0)"
"(begin"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(if(module-no-protected? m_0)"
"(let-values() #t)"
"(let-values()"
"(let-values(((access_0)"
"(let-values(((or-part_0)(module-access m_0)))"
"(if or-part_0 or-part_0(module-compute-access! m_0)))))"
"(let-values(((a_0)(hash-ref(hash-ref access_0 phase_0 '#hasheq()) sym_0 'unexported)))"
"(if(let-values(((or-part_0)(eq? a_0 'unexported)))(if or-part_0 or-part_0(eq? a_0 'protected)))"
"(let-values()"
"(let-values(((guard-insp_0)(namespace-inspector(module-instance-namespace mi_0))))"
"(let-values(((or-part_0)(if insp_0(inspector-superior? insp_0 guard-insp_0) #f)))"
"(if or-part_0 or-part_0(inspector-superior?(current-code-inspector) guard-insp_0)))))"
"(let-values() #t))))))))))"
"(define-values"
"(srcloc->vector)"
"(lambda(s_0)"
"(begin"
"(if s_0"
"(vector(srcloc-source s_0)(srcloc-line s_0)(srcloc-column s_0)(srcloc-position s_0)(srcloc-span s_0))"
" #f))))"
"(define-values(keep-source-locations?) #f)"
"(define-values"
"(correlate*)"
"(lambda(stx_0 s-exp_0)"
"(begin(if(syntax-srcloc$1 stx_0)(datum->correlated s-exp_0(srcloc->vector(syntax-srcloc$1 stx_0))) s-exp_0))))"
"(define-values(correlate~)(lambda(stx_0 s-exp_0)(begin s-exp_0)))"
"(define-values"
"(correlate/app)"
"(lambda(stx_0 s-exp_0)(begin(if keep-source-locations?(correlate* stx_0 s-exp_0)(correlate~ stx_0 s-exp_0)))))"
"(define-values(->correlated)(lambda(s_0)(begin(datum->correlated s_0 #f))))"
"(define-values"
"(correlate-source-name)"
"(lambda(sym_0 e-sym_0)"
"(begin(if(eq? sym_0 e-sym_0) sym_0(correlated-property(datum->correlated sym_0 #f) 'source-name e-sym_0)))))"
"(define-values(compile-keep-source-locations!)(lambda(on?_0)(begin(set! keep-source-locations? on?_0))))"
"(define-values"
"(compile$2)"
"(let-values(((compile_0)"
"(lambda(p3_0 cctx4_0 name1_0 result-used?2_0)"
"(begin"
" 'compile"
"(let-values(((p_0) p3_0))"
"(let-values(((cctx_0) cctx4_0))"
"(let-values(((name_0) name1_0))"
"(let-values(((result-used?_0) result-used?2_0))"
"(let-values()"
"(let-values(((compile_0)"
"(lambda(p_1 name_1 result-used?_1)"
"(begin 'compile(compile$2 p_1 cctx_0 name_1 result-used?_1)))))"
"(let-values(((s_0)(parsed-s p_0)))"
"(if(parsed-id? p_0)"
"(let-values()"
"(let-values(((p19_0) p_0)((cctx20_0) cctx_0))"
"(compile-identifier.1 #f #f p19_0 cctx20_0)))"
"(if(parsed-lambda? p_0)"
"(let-values()"
"(if result-used?_0"
"(let-values()"
"(add-lambda-properties"
"(correlate*"
" s_0"
"(list*"
" 'lambda"
"(compile-lambda"
"(parsed-lambda-keys p_0)"
"(parsed-lambda-body p_0)"
" cctx_0)))"
" name_0"
" s_0))"
"(let-values()(correlate~ s_0 ''unused-lambda))))"
"(if(parsed-case-lambda? p_0)"
"(let-values()"
"(if result-used?_0"
"(let-values()"
"(add-lambda-properties"
"(correlate*"
" s_0"
"(list*"
" 'case-lambda"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(parsed-case-lambda-clauses p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((clause_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(compile-lambda"
"(car"
" clause_0)"
"(cadr"
" clause_0)"
" cctx_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
" name_0"
" s_0))"
"(let-values()(correlate~ s_0 ''unused-case-lambda))))"
"(if(parsed-app? p_0)"
"(let-values()"
"(let-values(((rands_0)(parsed-app-rands p_0)))"
"(correlate/app"
" s_0"
"(cons"
"(compile_0(parsed-app-rator p_0) #f #t)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) rands_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((r_0)(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(compile_0"
" r_0"
" #f"
" #t))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))"
"(if(parsed-if? p_0)"
"(let-values()"
"(let-values(((tst-e_0)(compile_0(parsed-if-tst p_0) #f #f)))"
"(if(eq?(correlated-e tst-e_0) #t)"
"(let-values()(compile_0(parsed-if-thn p_0) name_0 result-used?_0))"
"(if(eq?(correlated-e tst-e_0) #f)"
"(let-values()"
"(compile_0(parsed-if-els p_0) name_0 result-used?_0))"
"(let-values()"
"(correlate~"
" s_0"
"(list"
" 'if"
" tst-e_0"
"(compile_0(parsed-if-thn p_0) name_0 result-used?_0)"
"(compile_0(parsed-if-els p_0) name_0 result-used?_0))))))))"
"(if(parsed-with-continuation-mark? p_0)"
"(let-values()"
"(correlate~"
" s_0"
"(list"
" 'with-continuation-mark"
"(compile_0(parsed-with-continuation-mark-key p_0) #f #t)"
"(compile_0(parsed-with-continuation-mark-val p_0) #f #t)"
"(compile_0"
"(parsed-with-continuation-mark-body p_0)"
" name_0"
" result-used?_0))))"
"(if(parsed-begin0? p_0)"
"(let-values()"
"(correlate~"
" s_0"
"(list*"
" 'begin0"
"(compile_0(car(parsed-begin0-body p_0)) name_0 result-used?_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(cdr(parsed-begin0-body p_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(compile_0"
" e_0"
" #f"
" #f))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(if(parsed-begin? p_0)"
"(let-values()"
"(correlate~"
" s_0"
"(compile-begin"
"(parsed-begin-body p_0)"
" cctx_0"
" name_0"
" result-used?_0)))"
"(if(parsed-set!? p_0)"
"(let-values()"
"(correlate~"
" s_0"
"(let-values(((temp21_0)(parsed-set!-id p_0))"
"((cctx22_0) cctx_0)"
"((temp23_0) #t)"
"((temp24_0)"
"(compile_0"
"(parsed-set!-rhs p_0)"
"(parsed-s(parsed-set!-id p_0))"
" #t)))"
"(compile-identifier.1 temp24_0 temp23_0 temp21_0 cctx22_0))))"
"(if(parsed-let-values? p_0)"
"(let-values()"
"(let-values(((p25_0) p_0)"
"((cctx26_0) cctx_0)"
"((name27_0) name_0)"
"((temp28_0) #f)"
"((result-used?29_0) result-used?_0))"
"(compile-let.1"
" temp28_0"
" p25_0"
" cctx26_0"
" name27_0"
" result-used?29_0)))"
"(if(parsed-letrec-values? p_0)"
"(let-values()"
"(let-values(((p30_0) p_0)"
"((cctx31_0) cctx_0)"
"((name32_0) name_0)"
"((temp33_0) #t)"
"((result-used?34_0) result-used?_0))"
"(compile-let.1"
" temp33_0"
" p30_0"
" cctx31_0"
" name32_0"
" result-used?34_0)))"
"(if(parsed-quote? p_0)"
"(let-values()"
"(let-values(((datum_0)(parsed-quote-datum p_0)))"
"(if(self-quoting-in-linklet? datum_0)"
"(let-values()(correlate~ s_0 datum_0))"
"(let-values()"
"(correlate~ s_0(list 'quote datum_0))))))"
"(if(parsed-quote-syntax? p_0)"
"(let-values()"
"(if result-used?_0"
"(compile-quote-syntax"
"(parsed-quote-syntax-datum p_0)"
" cctx_0)"
"(correlate~ s_0 ''syntax)))"
"(if(parsed-#%variable-reference? p_0)"
"(let-values()"
"(let-values(((id_0)"
"(parsed-#%variable-reference-id p_0)))"
"(correlate~"
" s_0"
"(if id_0"
"(list"
" '#%variable-reference"
"(let-values(((id35_0) id_0)((cctx36_0) cctx_0))"
"(compile-identifier.1 #f #f id35_0 cctx36_0)))"
" '(#%variable-reference)))))"
"(let-values()"
"(error"
"                                                                 \"unrecognized parsed form:\""
" p_0)))))))))))))))))))))))))))"
"(case-lambda"
"((p_0 cctx_0)(begin 'compile(compile_0 p_0 cctx_0 #f #t)))"
"((p_0 cctx_0 name_0 result-used?2_0)(compile_0 p_0 cctx_0 name_0 result-used?2_0))"
"((p_0 cctx_0 name1_0)(compile_0 p_0 cctx_0 name1_0 #t)))))"
"(define-values"
"(compile-lambda)"
"(lambda(formals_0 bodys_0 cctx_0)(begin(list formals_0(compile-sequence bodys_0 cctx_0 #f #t)))))"
"(define-values"
"(compile-sequence)"
"(lambda(bodys_0 cctx_0 name_0 result-used?_0)"
"(begin"
"(if(null?(cdr bodys_0))"
"(compile$2(car bodys_0) cctx_0 name_0 result-used?_0)"
"(compile-begin bodys_0 cctx_0 name_0 result-used?_0)))))"
"(define-values"
"(compile-begin)"
"(lambda(es_0 cctx_0 name_0 result-used?_0)"
"(begin"
"(let-values(((used-pos_0)(sub1(length es_0))))"
"(list*"
" 'begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) es_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((e_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((used?_0)"
"(= i_0 used-pos_0)))"
"(compile$2"
" e_0"
" cctx_0"
"(if used?_0 name_0 #f)"
"(if used?_0 result-used?_0 #f))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0(+ pos_0 1)) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" start_0))))))))))"
"(define-values"
"(add-lambda-properties)"
"(lambda(s_0 inferred-name_0 orig-s_0)"
"(begin"
"(letrec-values(((simplify-name_0)"
"(lambda(v_0)"
"(begin"
" 'simplify-name"
"(if(pair? v_0)"
"(let-values()"
"(let-values(((n1_0)(simplify-name_0(car v_0))))"
"(let-values(((n2_0)(simplify-name_0(cdr v_0))))(if(eq? n1_0 n2_0) n1_0 v_0))))"
"(let-values() v_0))))))"
"(let-values(((name_0)"
"(let-values(((or-part_0)"
"(let-values(((v_0)(simplify-name_0(syntax-property$1 orig-s_0 'inferred-name))))"
"(if(let-values(((or-part_0)(symbol? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(syntax?$1 v_0)(symbol?(syntax-e$1 v_0)) #f)))"
"(if or-part_1 or-part_1(void? v_0)))))"
" v_0"
" #f))))"
"(if or-part_0 or-part_0 inferred-name_0))))"
"(let-values(((named-s_0)"
"(if name_0"
"(correlated-property"
"(->correlated s_0)"
" 'inferred-name"
"(if(syntax?$1 name_0)(syntax-e$1 name_0) name_0))"
" s_0)))"
"(let-values(((as-method_0)(syntax-property$1 orig-s_0 'method-arity-error)))"
"(let-values(((method-s_0)"
"(if as-method_0"
"(correlated-property(->correlated named-s_0) 'method-arity-error as-method_0)"
" named-s_0)))"
"(let-values(((as-unsafe_0)(syntax-property$1 orig-s_0 'body-as-unsafe)))"
"(if as-unsafe_0"
"(let-values()"
"(begin"
"(if(eq?(current-code-inspector) initial-code-inspector)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                             \"unsafe procedure compilation disallowed by code inspector\""
" orig-s_0)))"
"(correlated-property(->correlated method-s_0) 'body-as-unsafe #t)))"
"(let-values() method-s_0)))))))))))"
"(define-values"
"(compile-let.1)"
"(lambda(rec?5_0 p7_0 cctx8_0 name9_0 result-used?10_0)"
"(begin"
" 'compile-let"
"(let-values(((p_0) p7_0))"
"(let-values(((cctx_0) cctx8_0))"
"(let-values(((name_0) name9_0))"
"(let-values(((rec?_0) rec?5_0))"
"(let-values(((result-used?_0) result-used?10_0))"
"(let-values()"
"(let-values(((body_0)(parsed-let_-values-body p_0)))"
"(correlate~"
"(parsed-s p_0)"
"(list"
"(if rec?_0 'letrec-values 'let-values)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(parsed-let_-values-clauses p_0))"
"((lst_1)(parsed-let_-values-idss p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((clause_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((ids_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
"(if rec?_0"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_4)"
"(car"
" clause_0))"
"((lst_5)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_5)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((id_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(add-undefined-error-name-property"
" sym_0"
" id_0))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_2"
" rest_3)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_4"
" lst_5)))))"
"(car clause_0))"
"(compile$2"
"(cadr clause_0)"
" cctx_0"
"(if(= 1(length ids_0))"
"(car ids_0)"
" #f))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0 rest_1)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1)))))"
"(compile-sequence body_0 cctx_0 name_0 result-used?_0)))))))))))))"
"(define-values"
"(add-undefined-error-name-property)"
"(lambda(sym_0 orig-id_0)"
"(begin"
"(let-values(((id_0)(correlate~ orig-id_0 sym_0)))"
"(correlated-property"
"(->correlated id_0)"
" 'undefined-error-name"
"(let-values(((or-part_0)(syntax-property$1 orig-id_0 'undefined-error-name)))"
"(if or-part_0 or-part_0(syntax-e$1 orig-id_0))))))))"
"(define-values"
"(compile-identifier.1)"
"(lambda(set-to13_0 set-to?12_0 p16_0 cctx17_0)"
"(begin"
" 'compile-identifier"
"(let-values(((p_0) p16_0))"
"(let-values(((cctx_0) cctx17_0))"
"(let-values(((set-to?_0) set-to?12_0))"
"(let-values(((rhs_0) set-to13_0))"
"(let-values()"
"(let-values(((normal-b_0)(parsed-id-binding p_0)))"
"(let-values(((b_0)"
"(let-values(((or-part_0) normal-b_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((temp37_0)(compile-context-self cctx_0))"
"((temp38_0)(compile-context-phase cctx_0))"
"((temp39_0)(syntax-e$1(parsed-s p_0))))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" temp37_0"
" temp38_0"
" temp39_0))))))"
"(let-values(((sym_0)"
"(if(local-binding? b_0)"
"(let-values()(local-binding-key b_0))"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((mpi_0)"
"(if(parsed-top-id? p_0)"
"(compile-context-self cctx_0)"
"(module-binding-module b_0))))"
"(if(parsed-primitive-id? p_0)"
"(let-values()"
"(begin"
"(if(zero?(module-binding-phase b_0))"
"(void)"
"(let-values()"
"                                                    (error \"internal error: non-zero phase for a primitive\")))"
"(if set-to?_0"
"(let-values()"
"(error"
"                                                     \"internal error: cannot assign to a primitive:\""
"(module-binding-sym b_0)))"
"(void))"
"(module-binding-sym b_0)))"
"(let-values(((c1_0)"
"(if(eq? mpi_0(compile-context-module-self cctx_0))"
"(hash-ref"
"(header-binding-sym-to-define-sym"
"(compile-context-header cctx_0))"
"(module-binding-sym b_0)"
" #f)"
" #f)))"
"(if c1_0"
"((lambda(sym_0) sym_0) c1_0)"
"(let-values()"
"(let-values(((temp40_0)(compile-context-header cctx_0))"
"((temp41_0)"
"(if(inside-module-context?"
" mpi_0"
"(compile-context-self cctx_0))"
"(compile-context-self cctx_0)"
" mpi_0))"
"((temp42_0)(module-binding-phase b_0))"
"((temp43_0)(module-binding-sym b_0))"
"((temp44_0)"
"(let-values(((or-part_0)"
"(module-binding-extra-inspector b_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(parsed-id-inspector p_0)))"
"(if or-part_1"
" or-part_1"
"(if(parsed-s p_0)"
"(syntax-inspector(parsed-s p_0))"
" #f)))))))"
"(register-required-variable-use!.1"
" #f"
" temp40_0"
" temp41_0"
" temp42_0"
" temp43_0"
" temp44_0))))))))"
"(let-values()"
"                                        (error \"not a reference to a module or local binding:\" b_0 (parsed-s p_0)))))))"
"(correlate~(parsed-s p_0)(if set-to?_0(list 'set! sym_0 rhs_0) sym_0)))))))))))))"
"(define-values"
"(compile-quote-syntax)"
"(lambda(q_0 cctx_0)"
"(begin"
"(let-values(((pos_0)(add-syntax-literal!(compile-context-header cctx_0) q_0)))"
"(if(compile-context-lazy-syntax-literals? cctx_0)"
"(let-values()(generate-lazy-syntax-literal-lookup pos_0))"
"(let-values()(generate-eager-syntax-literal-lookup pos_0)))))))"
"(define-values"
"(struct:link-info"
" link-info1.1"
" link-info?"
" link-info-link-module-uses"
" link-info-imports"
" link-info-extra-inspectorsss"
" link-info-def-decls)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'link-info #f 4 0 #f null(current-inspector) #f '(0 1 2 3) #f 'link-info)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'link-module-uses)"
"(make-struct-field-accessor -ref_0 1 'imports)"
"(make-struct-field-accessor -ref_0 2 'extra-inspectorsss)"
"(make-struct-field-accessor -ref_0 3 'def-decls))))"
"(define-values"
"(compile-forms.1)"
"(lambda(body-import-instances3_0"
" body-imports2_0"
" body-suffix-forms4_0"
" compiled-expression-callback8_0"
" definition-callback9_0"
" encoded-root-expand-ctx-box6_0"
" force-phases5_0"
" get-module-linklet-info11_0"
" module-prompt?13_0"
" optimize-linklet?16_0"
" other-form-callback10_0"
" realm18_0"
" root-ctx-only-if-syntax?7_0"
" serializable?12_0"
" to-correlated-linklet?15_0"
" unlimited-compile?-box14_0"
" unsafe?-box17_0"
" bodys36_0"
" cctx37_0"
" mpis38_0)"
"(begin"
" 'compile-forms"
"(let-values(((bodys_0) bodys36_0))"
"(let-values(((cctx_0) cctx37_0))"
"(let-values(((mpis_0) mpis38_0))"
"(let-values(((body-imports_0) body-imports2_0))"
"(let-values(((body-import-instances_0) body-import-instances3_0))"
"(let-values(((body-suffix-forms_0) body-suffix-forms4_0))"
"(let-values(((force-phases_0) force-phases5_0))"
"(let-values(((encoded-root-expand-ctx-box_0) encoded-root-expand-ctx-box6_0))"
"(let-values(((root-ctx-only-if-syntax?_0) root-ctx-only-if-syntax?7_0))"
"(let-values(((compiled-expression-callback_0) compiled-expression-callback8_0))"
"(let-values(((definition-callback_0) definition-callback9_0))"
"(let-values(((other-form-callback_0) other-form-callback10_0))"
"(let-values(((get-module-linklet-info_0)"
"(if(eq? get-module-linklet-info11_0 unsafe-undefined)"
"(lambda(mod-name_0 p_0)(begin 'get-module-linklet-info #f))"
" get-module-linklet-info11_0)))"
"(let-values(((serializable?_0) serializable?12_0))"
"(let-values(((module-prompt?_0) module-prompt?13_0))"
"(let-values(((unlimited-compile?-box_0) unlimited-compile?-box14_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?15_0))"
"(let-values(((optimize-linklet?_0) optimize-linklet?16_0))"
"(let-values(((unsafe?-box_0) unsafe?-box17_0))"
"(let-values(((realm_0)"
"(if(eq? realm18_0 unsafe-undefined)"
"(current-compile-realm)"
" realm18_0)))"
"(let-values()"
"(let-values(((phase_0)(compile-context-phase cctx_0)))"
"(let-values(((self_0)(compile-context-self cctx_0)))"
"(let-values(((syntax-literals_0)(make-syntax-literals)))"
"(let-values(((phase-to-body_0)(make-hasheqv)))"
"(let-values(((add-body!_0)"
"(lambda(phase_1 body_0)"
"(begin"
" 'add-body!"
"(hash-update!"
" phase-to-body_0"
" phase_1"
"(lambda(l_0)(cons body_0 l_0))"
" null)))))"
"(let-values(((phase-to-header_0)(make-hasheqv)))"
"(let-values(((find-or-create-header!_0)"
"(lambda(phase_1)"
"(begin"
" 'find-or-create-header!"
"(let-values(((or-part_0)"
"(hash-ref"
" phase-to-header_0"
" phase_1"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((header_0)"
"(make-header"
" mpis_0"
" syntax-literals_0)))"
"(begin"
"(hash-set!"
" phase-to-header_0"
" phase_1"
" header_0)"
" header_0))))))))"
"(let-values((()"
"(begin"
"(let-values()"
"(let-values(((lst_0) force-phases_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((phase_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(find-or-create-header!_0"
" phase_1)"
"(add-body!_0"
" phase_1"
" '(void))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(values))))"
"(let-values()"
"(let-values(((saw-define-syntaxes?_0) #f))"
"(let-values((()"
"(begin"
"(if(compile-context-module-self"
" cctx_0)"
"(let-values()"
"((letrec-values(((loop!_0)"
"(lambda(bodys_1"
" phase_1"
" header_0)"
"(begin"
" 'loop!"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" bodys_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(parsed-define-values?"
" body_0)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_2)"
"(parsed-define-values-syms"
" body_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((def-sym_0)"
"(select-fresh"
" sym_0"
" header_0)))"
"(begin"
"(hash-set!"
"(header-binding-sym-to-define-sym"
" header_0)"
" sym_0"
" def-sym_0)"
"(set-header-binding-syms-in-order!"
" header_0"
"(cons"
" sym_0"
"(header-binding-syms-in-order"
" header_0)))"
"(register-as-defined!"
" header_0"
" def-sym_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2))))"
"(void)))"
"(if(parsed-begin-for-syntax?"
" body_0)"
"(let-values()"
"(loop!_0"
"(parsed-begin-for-syntax-body"
" body_0)"
"(add1"
" phase_1)"
"(find-or-create-header!_0"
"(add1"
" phase_1))))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))))))"
" loop!_0)"
" bodys_0"
" phase_0"
"(find-or-create-header!_0"
" phase_0)))"
"(void))"
"(values))))"
"(let-values(((as-required?_0)"
"(lambda(header_0)"
"(begin"
" 'as-required?"
"(lambda(sym_0)"
"(registered-as-required?"
" header_0"
" sym_0))))))"
"(let-values(((last-i_0)"
"(sub1(length bodys_0))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop!_0)"
"(lambda(bodys_1"
" phase_1"
" header_0)"
"(begin"
" 'loop!"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" bodys_1)"
"((start_0)"
" 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-naturals"
" start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1"
" pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_1)"
" #t"
" #f)"
"(let-values(((body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(parsed-define-values?"
" body_0)"
"(let-values()"
"(let-values(((ids_0)"
"(parsed-define-values-ids"
" body_0)))"
"(let-values(((binding-syms_0)"
"(parsed-define-values-syms"
" body_0)))"
"(let-values(((def-syms_0)"
"(if(compile-context-module-self"
" cctx_0)"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_2)"
" binding-syms_0)"
"((lst_3)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_3)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(correlate-source-name"
"(hash-ref"
"(header-binding-sym-to-define-sym"
" header_0)"
" binding-sym_0)"
"(syntax-e$1"
" id_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_2"
" rest_1"
" rest_2)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_1)"
" fold-var_0"
" lst_2"
" lst_3))))))"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_2)"
" binding-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((header71_0)"
" header_0)"
"((temp72_0)"
"(compile-context-self"
" cctx_0))"
"((phase73_0)"
" phase_1)"
"((binding-sym74_0)"
" binding-sym_0)"
"((temp75_0)"
" #f)"
"((temp76_0)"
" #t))"
"(register-required-variable-use!.1"
" temp76_0"
" header71_0"
" temp72_0"
" phase73_0"
" binding-sym74_0"
" temp75_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_2"
" rest_1)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_1)"
" fold-var_0"
" lst_2)))))))))"
"(let-values(((rhs_0)"
"(compile$2"
"(parsed-define-values-rhs"
" body_0)"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase77_0)"
" phase_1)"
"((header78_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase77_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header78_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                  \"compile-context?\""
" the-struct_0)))"
"(if(="
"(length"
" ids_0)"
" 1)"
"(car"
" ids_0)"
" #f))))"
"(begin"
"(definition-callback_0)"
"(compiled-expression-callback_0"
" rhs_0"
"(length"
" def-syms_0)"
" phase_1"
"(as-required?_0"
" header_0))"
"(add-body!_0"
" phase_1"
"(propagate-inline-property"
"(correlate*"
"(parsed-s"
" body_0)"
"(list"
" 'define-values"
" def-syms_0"
" rhs_0))"
"(parsed-s"
" body_0)))"
"(if(let-values(((or-part_0)"
"(compile-context-module-self"
" cctx_0)))"
"(if or-part_0"
" or-part_0"
"(null?"
" ids_0)))"
"(void)"
"(let-values()"
"(begin"
"(add-body!_0"
" phase_1"
"(list*"
" 'if"
" #f"
"(list*"
" 'begin"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_2)"
" def-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((def-sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list*"
" 'set!"
" def-sym_0"
" '(#f)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_2"
" rest_1)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_1)"
" fold-var_0"
" lst_2))))))"
" '((void))))"
"(add-body!_0"
" phase_1"
"(compile-top-level-bind"
" ids_0"
" binding-syms_0"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase79_0)"
" phase_1)"
"((header80_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase79_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header80_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                               \"compile-context?\""
" the-struct_0)))"
" #f)))))))))))"
"(if(parsed-define-syntaxes?"
" body_0)"
"(let-values()"
"(let-values(((ids_0)"
"(parsed-define-syntaxes-ids"
" body_0)))"
"(let-values(((binding-syms_0)"
"(parsed-define-syntaxes-syms"
" body_0)))"
"(let-values(((next-header_0)"
"(find-or-create-header!_0"
"(add1"
" phase_1))))"
"(let-values(((gen-syms_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_2)"
" binding-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((gen-sym_0)"
"(select-fresh"
" binding-sym_0"
" next-header_0)))"
"(begin"
"(register-as-defined!"
" next-header_0"
" gen-sym_0)"
" gen-sym_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_2"
" rest_1)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_1)"
" fold-var_0"
" lst_2)))))))"
"(let-values(((rhs_0)"
"(compile$2"
"(parsed-define-syntaxes-rhs"
" body_0)"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase81_0)"
"(add1"
" phase_1))"
"((header82_0)"
" next-header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase81_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header82_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                      \"compile-context?\""
" the-struct_0))))))"
"(let-values((()"
"(begin"
"(definition-callback_0)"
"(values))))"
"(let-values((()"
"(begin"
"(compiled-expression-callback_0"
" rhs_0"
"(length"
" gen-syms_0)"
"(add1"
" phase_1)"
"(as-required?_0"
" header_0))"
"(values))))"
"(let-values(((transformer-set!s_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_2)"
" binding-syms_0)"
"((lst_3)"
" gen-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_3)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((gen-sym_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
" set-transformer!-id"
"(list"
" 'quote"
" binding-sym_0)"
" gen-sym_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_2"
" rest_1"
" rest_2)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_1)"
" fold-var_0"
" lst_2"
" lst_3)))))))"
"(begin"
"(if(compile-context-module-self"
" cctx_0)"
"(let-values()"
"(add-body!_0"
"(add1"
" phase_1)"
"(list"
" 'let-values"
"(list"
"(list"
" gen-syms_0"
" rhs_0))"
"(list*"
" 'begin"
"(qq-append"
" transformer-set!s_0"
" '((void)))))))"
"(let-values()"
"(add-body!_0"
"(add1"
" phase_1)"
"(generate-top-level-define-syntaxes"
" gen-syms_0"
" rhs_0"
" transformer-set!s_0"
"(compile-top-level-bind"
" ids_0"
" binding-syms_0"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase83_0)"
" phase_1)"
"((header84_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase83_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header84_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                        \"compile-context?\""
" the-struct_0)))"
" gen-syms_0)))))"
"(set! saw-define-syntaxes?_0"
" #t)))))))))))"
"(if(parsed-begin-for-syntax?"
" body_0)"
"(let-values()"
"(loop!_0"
"(parsed-begin-for-syntax-body"
" body_0)"
"(add1"
" phase_1)"
"(find-or-create-header!_0"
"(add1"
" phase_1))))"
"(if(let-values(((or-part_0)"
"(parsed-#%declare?"
" body_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(parsed-module?"
" body_0)))"
"(if or-part_1"
" or-part_1"
"(parsed-require?"
" body_0)))))"
"(let-values()"
"(let-values(((e_0)"
"(other-form-callback_0"
" body_0"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase85_0)"
" phase_1)"
"((header86_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase85_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header86_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                  \"compile-context?\""
" the-struct_0))))))"
"(if e_0"
"(let-values()"
"(begin"
"(compiled-expression-callback_0"
" e_0"
" #f"
" phase_1"
"(as-required?_0"
" header_0))"
"(add-body!_0"
" phase_1"
" e_0)))"
"(void))))"
"(let-values()"
"(let-values(((e_0)"
"(compile$2"
" body_0"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase87_0)"
" phase_1)"
"((header88_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase87_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header88_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                  \"compile-context?\""
" the-struct_0)))"
" #f"
"(="
" i_0"
" last-i_0))))"
"(begin"
"(compiled-expression-callback_0"
" e_0"
" #f"
" phase_1"
"(as-required?_0"
" header_0))"
"(add-body!_0"
" phase_1"
" e_0)))))))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0"
"(+"
" pos_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0))))"
"(void))))))"
" loop!_0)"
" bodys_0"
" phase_0"
"(find-or-create-header!_0"
" phase_0))"
"(values))))"
"(let-values(((encoded-root-expand-pos_0)"
"(if encoded-root-expand-ctx-box_0"
"(if(unbox"
" encoded-root-expand-ctx-box_0)"
"(if(not"
"(if root-ctx-only-if-syntax?_0"
"(if(not"
" saw-define-syntaxes?_0)"
"(syntax-literals-empty?"
" syntax-literals_0)"
" #f)"
" #f))"
"(add-syntax-literal!"
" syntax-literals_0"
"(unbox"
" encoded-root-expand-ctx-box_0))"
" #f)"
" #f)"
" #f)))"
"(let-values(((phases-in-order_0)"
"(let-values(((temp89_0)"
"(hash-keys"
" phase-to-body_0))"
"((<90_0) <))"
"(sort.1"
" #f"
" #f"
" temp89_0"
" <90_0))))"
"(let-values(((min-phase_0)"
"(if(pair?"
" phases-in-order_0)"
"(car phases-in-order_0)"
" phase_0)))"
"(let-values(((max-phase_0)"
"(if(pair?"
" phases-in-order_0)"
"(car"
"(reverse$1"
" phases-in-order_0))"
" phase_0)))"
"(let-values(((phase-to-link-info_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hash()))"
" table_0)))"
"(let-values(((lst_0)"
" phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((phase_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((header_0)"
"(hash-ref"
" phase-to-header_0"
" phase_1"
" #f)))"
"(let-values(((link-module-uses_0"
" imports_0"
" extra-inspectorsss_0"
" def-decls_0)"
"(generate-links+imports"
" header_0"
" phase_1"
" cctx_0"
" optimize-linklet?_0)))"
"(values"
" phase_1"
"(link-info1.1"
" link-module-uses_0"
" imports_0"
" extra-inspectorsss_0"
" def-decls_0)))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
" rest_0)"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0))))))"
"(let-values(((body-linklets+module-use*s_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheq()))"
" table_0)))"
"(let-values(((lst_0)"
" phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((phase_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((bodys_1)"
"(hash-ref"
" phase-to-body_0"
" phase_1)))"
"(let-values(((li_0)"
"(hash-ref"
" phase-to-link-info_0"
" phase_1)))"
"(let-values(((binding-sym-to-define-sym_0)"
"(header-binding-sym-to-define-sym"
"(hash-ref"
" phase-to-header_0"
" phase_1))))"
"(let-values(((module-use*s_0)"
"(module-uses-add-extra-inspectorsss"
"(link-info-link-module-uses"
" li_0)"
"(link-info-extra-inspectorsss"
" li_0))))"
"(let-values(((body-linklet_0)"
"(list*"
" 'linklet"
"(qq-append"
" body-imports_0"
"(link-info-imports"
" li_0))"
"(qq-append"
"(link-info-def-decls"
" li_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_2)"
"(header-binding-syms-in-order"
"(hash-ref"
" phase-to-header_0"
" phase_1))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((def-sym_0)"
"(hash-ref"
" binding-sym-to-define-sym_0"
" binding-sym_0)))"
"(if(eq?"
" def-sym_0"
" binding-sym_0)"
" def-sym_0"
"(list"
" def-sym_0"
" binding-sym_0))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_2"
" rest_1)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_1)"
" fold-var_0"
" lst_2))))))"
"(qq-append"
"(reverse$1"
" bodys_1)"
" body-suffix-forms_0))))"
"(let-values(((linklet_0"
" new-module-use*s_0)"
"(if to-correlated-linklet?_0"
"(let-values()"
"(values"
"(make-correlated-linklet"
" body-linklet_0"
" 'module)"
" module-use*s_0))"
"(let-values()"
"(let-values(((body-linklet91_0)"
" body-linklet_0)"
"((temp92_0)"
"(hasheq"
" 'module"
"(compile-context-full-module-name"
" cctx_0)"
" 'phase"
" phase_1))"
"((body-imports93_0)"
" body-imports_0)"
"((body-import-instances94_0)"
" body-import-instances_0)"
"((get-module-linklet-info95_0)"
" get-module-linklet-info_0)"
"((serializable?96_0)"
" serializable?_0)"
"((module-prompt?97_0)"
" module-prompt?_0)"
"((temp98_0)"
"(if unlimited-compile?-box_0"
"(unbox"
" unlimited-compile?-box_0)"
" #f))"
"((module-use*s99_0)"
" module-use*s_0)"
"((optimize-linklet?100_0)"
" optimize-linklet?_0)"
"((temp101_0)"
"(if unsafe?-box_0"
"(unbox"
" unsafe?-box_0)"
" #f))"
"((temp102_0)"
" #f)"
"((temp103_0)"
"(compile-context-namespace"
" cctx_0))"
"((realm104_0)"
" realm_0))"
"(compile-module-linklet.1"
" body-import-instances94_0"
" body-imports93_0"
" temp92_0"
" unsafe-undefined"
" get-module-linklet-info95_0"
" temp102_0"
" module-prompt?97_0"
" module-use*s99_0"
" temp103_0"
" optimize-linklet?100_0"
" realm104_0"
" serializable?96_0"
" temp98_0"
" temp101_0"
" body-linklet91_0))))))"
"(values"
" phase_1"
"(cons"
" linklet_0"
" new-module-use*s_0)))))))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
" rest_0)"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0))))))"
"(let-values(((body-linklets_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheq()))"
" table_0)))"
"(let-values(((ht_0)"
" body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_1"
" l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_1"
"(car"
" l+mu*s_0)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first"
" ht_0)))))))"
"(let-values(((phase-to-link-module-uses_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheq()))"
" table_0)))"
"(let-values(((ht_0)"
" body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_1"
" l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_1"
"(module-uses-strip-extra-inspectorsss"
"(cdr"
" l+mu*s_0))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first"
" ht_0)))))))"
"(let-values(((phase-to-link-module-uses-expr_0)"
"(serialize-phase-to-link-module-uses"
" phase-to-link-module-uses_0"
" mpis_0)))"
"(let-values(((phase-to-link-extra-inspectorsss_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hash()))"
" table_0)))"
"(let-values(((ht_0)"
" body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_1"
" l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((id*_0)"
"(module-uses-extract-extra-inspectorsss"
"(cdr"
" l+mu*s_0)"
"(car"
" l+mu*s_0)"
"(if optimize-linklet?_0"
"(not"
" to-correlated-linklet?_0)"
" #f)"
"(length"
" body-imports_0))))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2)"
"(begin"
" 'for-loop"
"(let-values(((extra-inspectorsss_0)"
" id*_0))"
"(let-values(((table_3)"
"(if extra-inspectorsss_0"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_1"
" extra-inspectorsss_0))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values"
" table_3))"
" table_2)))"
" table_3))))))"
" for-loop_1)"
" table_1))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first"
" ht_0)))))))"
"(values"
" body-linklets_0"
" min-phase_0"
" max-phase_0"
" phase-to-link-module-uses_0"
" phase-to-link-module-uses-expr_0"
" phase-to-link-extra-inspectorsss_0"
" syntax-literals_0"
" encoded-root-expand-pos_0)))))))))))))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(compile-top-level-bind)"
"(lambda(ids_0 binding-syms_0 cctx_0 trans-exprs_0)"
"(begin"
"(let-values(((phase_0)(compile-context-phase cctx_0)))"
"(let-values(((self_0)(compile-context-self cctx_0)))"
"(let-values(((header_0)(compile-context-header cctx_0)))"
"(let-values(((mpis_0)(header-module-path-indexes header_0)))"
"(let-values(((top-level-bind-scope_0)"
"(root-expand-context-top-level-bind-scope"
"(namespace-get-root-expand-ctx(compile-context-namespace cctx_0)))))"
"(let-values(((self-expr_0)(add-module-path-index! mpis_0 self_0)))"
"(list*"
" 'begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) ids_0)"
"((lst_1) binding-syms_0)"
"((lst_2)"
"(let-values(((or-part_0) trans-exprs_0))"
"(if or-part_0"
" or-part_0"
"(reverse$1"
"(let-values(((fold-var_1)(let-values(((fold-var_1) null)) fold-var_1)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
" ''#f)"
" fold-var_2))))"
"(values fold-var_3))))"
"(if(not #f)"
"(for-loop_0 fold-var_3 rest_0)"
" fold-var_3)))"
" fold-var_2))))))"
" for-loop_0)"
" fold-var_1"
" lst_0)))))))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_3 lst_4 lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_3)(if(pair? lst_4)(pair? lst_5) #f) #f)"
"(let-values(((id_0)(unsafe-car lst_3))"
"((rest_0)(unsafe-cdr lst_3))"
"((binding-sym_0)(unsafe-car lst_4))"
"((rest_1)(unsafe-cdr lst_4))"
"((trans-expr_0)(unsafe-car lst_5))"
"((rest_2)(unsafe-cdr lst_5)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id-stx_0)"
"(compile-quote-syntax"
"(remove-scope"
" id_0"
" top-level-bind-scope_0)"
" cctx_0)))"
"(list"
" top-level-bind!-id"
" id-stx_0"
" self-expr_0"
" phase_0"
" phase-shift-id"
" ns-id"
"(list 'quote binding-sym_0)"
"(if trans-exprs_0 #t #f)"
" trans-expr_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0 rest_1 rest_2)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1"
" lst_2)))))))))))))))"
"(define-values"
"(generate-top-level-define-syntaxes)"
"(lambda(gen-syms_0 rhs_0 transformer-set!s_0 finish_0)"
"(begin"
"(list"
" 'call-with-values"
"(list 'lambda '() rhs_0)"
"(list*"
" 'case-lambda"
"(qq-append"
"(if(null? gen-syms_0)"
" '()"
"(list(list gen-syms_0(list* 'begin(qq-append transformer-set!s_0(qq-append(cdr finish_0) '((void))))))))"
"(list"
"(list"
" '()"
"(list"
" 'let-values"
"(list"
"(list"
" gen-syms_0"
"(list*"
" 'values"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) gen-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values() ''#f)"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(list* 'begin(qq-append(cdr finish_0) '((void))))))"
"(list 'args(list* 'let-values(list(list* gen-syms_0 '((apply values args)))) '((void)))))))))))"
"(define-values"
"(propagate-inline-property)"
"(lambda(e_0 orig-s_0)"
"(begin"
"(let-values(((v_0)(syntax-property$1 orig-s_0 'compiler-hint:cross-module-inline)))"
"(if v_0(correlated-property e_0 'compiler-hint:cross-module-inline v_0) e_0)))))"
"(define-values"
"(compile-module-linklet.1)"
"(lambda(body-import-instances43_0"
" body-imports42_0"
" body-info41_0"
" compile-linklet40_0"
" get-module-linklet-info44_0"
" load-modules?51_0"
" module-prompt?46_0"
" module-use*s48_0"
" namespace52_0"
" optimize-linklet?49_0"
" realm53_0"
" serializable?45_0"
" unlimited-compile?47_0"
" unsafe?50_0"
" body-linklet68_0)"
"(begin"
" 'compile-module-linklet"
"(let-values(((body-linklet_0) body-linklet68_0))"
"(let-values(((compile-linklet_0)"
"(if(eq? compile-linklet40_0 unsafe-undefined) 1/compile-linklet compile-linklet40_0)))"
"(let-values(((body-info_0) body-info41_0))"
"(let-values(((body-imports_0) body-imports42_0))"
"(let-values(((body-import-instances_0) body-import-instances43_0))"
"(let-values(((get-module-linklet-info_0) get-module-linklet-info44_0))"
"(let-values(((serializable?_0) serializable?45_0))"
"(let-values(((module-prompt?_0) module-prompt?46_0))"
"(let-values(((unlimited-compile?_0) unlimited-compile?47_0))"
"(let-values(((module-use*s_0) module-use*s48_0))"
"(let-values(((optimize-linklet?_0) optimize-linklet?49_0))"
"(let-values(((unsafe?_0) unsafe?50_0))"
"(let-values(((load-modules?_0) load-modules?51_0))"
"(let-values(((namespace_0) namespace52_0))"
"(let-values(((realm_0) realm53_0))"
"(let-values()"
"(let-values(((linklet_0 new-module-use*s_0)"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'compile '_ 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"((lambda(l_0 info_0 keys_0 getter_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-compile-realm"
" realm_0)"
"(let-values()"
"(compile-linklet_0"
" l_0"
" info_0"
" keys_0"
" getter_0"
"(let-values(((flags_0)"
"(if serializable?_0"
"(if module-prompt?_0"
" '(serializable use-prompt)"
" '(serializable))"
"(if module-prompt?_0"
" '(use-prompt)"
"(if optimize-linklet?_0"
" '()"
" '(quick))))))"
"(let-values(((flags_1)"
"(if unsafe?_0"
"(cons 'unsafe flags_0)"
" flags_0)))"
"(let-values(((flags_2)"
"(if unlimited-compile?_0"
"(cons 'unlimited-compile flags_1)"
" flags_1)))"
" flags_2)))))))"
" body-linklet_0"
"(hash-set body-info_0 'name 'module)"
"(list->vector"
"(append body-import-instances_0 module-use*s_0))"
"(make-module-use-to-linklet"
" optimize-linklet?_0"
" load-modules?_0"
" namespace_0"
" get-module-linklet-info_0"
" module-use*s_0)))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(values"
" linklet_0"
"(list-tail"
"(vector->list new-module-use*s_0)"
"(length body-imports_0)))))))))))))))))))))))"
"(define-values"
"(make-module-use-to-linklet)"
"(lambda(optimize-linklet?_0 load-modules?_0 ns_0 get-module-linklet-info_0 init-mu*s_0)"
"(begin"
"(let-values(((mu*-intern-table_0)(make-hash)))"
"(let-values(((intern-module-use*_0)"
"(lambda(mu*_0)"
"(begin"
" 'intern-module-use*"
"(let-values(((mod-name_0)"
"(1/module-path-index-resolve(module-use-module mu*_0) load-modules?_0)))"
"(let-values(((existing-mu*_0)"
"(hash-ref mu*-intern-table_0(cons mod-name_0(module-use-phase mu*_0)) #f)))"
"(if existing-mu*_0"
"(let-values()"
"(begin(module-use-merge-extra-inspectorss! existing-mu*_0 mu*_0) existing-mu*_0))"
"(let-values()"
"(begin"
"(hash-set! mu*-intern-table_0(cons mod-name_0(module-use-phase mu*_0)) mu*_0)"
" mu*_0)))))))))"
"(begin"
"(let-values()"
"(let-values(((lst_0) init-mu*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mu*_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()(intern-module-use*_0 mu*_0))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(lambda(mu*-or-instance_0)"
"(if(1/instance? mu*-or-instance_0)"
"(let-values()(values mu*-or-instance_0 #f))"
"(if(not optimize-linklet?_0)"
"(let-values()(values #f #f))"
"(if mu*-or-instance_0"
"(let-values()"
"(let-values(((mu*_0) mu*-or-instance_0))"
"(let-values(((mod-name_0)"
"(1/module-path-index-resolve(module-use-module mu*_0) load-modules?_0)))"
"(let-values(((mli_0)"
"(let-values(((or-part_0)"
"(get-module-linklet-info_0 mod-name_0(module-use-phase mu*_0))))"
"(if or-part_0"
" or-part_0"
"(namespace->module-linklet-info"
" ns_0"
" mod-name_0"
"(module-use-phase mu*_0))))))"
"(begin"
"(if mli_0"
"(let-values()"
"(module-use*-declaration-inspector! mu*_0(module-linklet-info-inspector mli_0)))"
"(void))"
"(if mli_0"
"(values"
"(module-linklet-info-linklet-or-instance mli_0)"
"(if(module-linklet-info-module-uses mli_0)"
"(list->vector"
"(append"
" '(#f #f)"
"(let-values(((mus_0)(module-linklet-info-module-uses mli_0))"
"((extra-inspectorsss_0)"
"(module-linklet-info-extra-inspectorsss mli_0)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) mus_0)"
"((lst_1)"
"(linklet-import-variables$1"
"(module-linklet-info-linklet-or-instance mli_0)))"
"((lst_2)"
"(let-values(((or-part_0) extra-inspectorsss_0))"
"(if or-part_0 or-part_0 mus_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_3 lst_4 lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_3)"
"(if(pair? lst_4)(pair? lst_5) #f)"
" #f)"
"(let-values(((sub-mu_0)(unsafe-car lst_3))"
"((rest_0)(unsafe-cdr lst_3))"
"((imports_0)(unsafe-car lst_4))"
"((rest_1)(unsafe-cdr lst_4))"
"((extra-inspectorss_0)"
"(unsafe-car lst_5))"
"((rest_2)(unsafe-cdr lst_5)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(intern-module-use*_0"
"(module-use+extra-inspectors"
"(module-path-index-shift"
"(module-use-module"
" sub-mu_0)"
"(module-linklet-info-self"
" mli_0)"
"(module-use-module"
" mu*_0))"
"(module-use-phase"
" sub-mu_0)"
" imports_0"
"(module-linklet-info-inspector"
" mli_0)"
"(module-linklet-info-extra-inspector"
" mli_0)"
"(if extra-inspectorsss_0"
" extra-inspectorss_0"
" #f))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0"
" rest_1"
" rest_2)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1"
" lst_2))))))))"
" #f))"
"(values #f #f)))))))"
"(let-values()(values #f #f))))))))))))"
"(define-values"
"(build-shared-data-linklet.1)"
"(lambda(to-correlated-linklet?1_0 cims3_0 ns4_0)"
"(begin"
" 'build-shared-data-linklet"
"(let-values(((cims_0) cims3_0))"
"(let-values(((ns_0) ns4_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?1_0))"
"(let-values()"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values(((mpi-trees_0)"
"(map-cim-tree"
" cims_0"
"(lambda(cim_0)"
"(let-values(((vec_0 i_0)"
"(let-values(((vec_0)(let-values(((vec_0)(make-vector 16))) vec_0))"
"((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1)(compiled-in-memory-mpis cim_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_1)))"
"(values vec_1(unsafe-vector-length vec_1))))))"
"((letrec-values(((for-loop_0)"
"(lambda(vec_2 i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((mpi_0)"
"(unsafe-vector-ref"
" vec_1"
" pos_0)))"
"(let-values(((vec_3 i_2)"
"(let-values(((vec_3 i_2)"
"(let-values()"
"(let-values(((new-vec_0)"
"(if(eq?"
" i_1"
"(unsafe-vector*-length"
" vec_2))"
"(grow-vector"
" vec_2)"
" vec_2)))"
"(begin"
"(unsafe-vector*-set!"
" new-vec_0"
" i_1"
"(let-values()"
"(add-module-path-index!/pos"
" mpis_0"
" mpi_0)))"
"(values"
" new-vec_0"
"(unsafe-fx+"
" i_1"
" 1)))))))"
"(values vec_3 i_2))))"
"(if(not #f)"
"(for-loop_0"
" vec_3"
" i_2"
"(unsafe-fx+ 1 pos_0))"
"(values vec_3 i_2))))"
"(values vec_2 i_1)))))))"
" for-loop_0)"
" vec_0"
" i_0"
" 0)))))"
"(shrink-vector vec_0 i_0))))))"
"(let-values(((syntax-literals_0)(make-syntax-literals)))"
"(let-values(((syntax-literals-trees_0)"
"(map-cim-tree"
" cims_0"
"(lambda(cim_0)"
"(add-syntax-literals!"
" syntax-literals_0"
"(compiled-in-memory-syntax-literals cim_0))))))"
"(let-values(((module-uses-tables_0) null))"
"(let-values(((module-uses-tables-count_0) 0))"
"(let-values(((phase-to-link-module-uses-trees_0)"
"(map-cim-tree"
" cims_0"
"(lambda(cim_0)"
"(let-values(((pos_0) module-uses-tables-count_0))"
"(begin"
"(set! module-uses-tables_0"
"(cons"
"(compiled-in-memory-phase-to-link-module-uses cim_0)"
" module-uses-tables_0))"
"(set! module-uses-tables-count_0(add1 pos_0))"
" pos_0))))))"
"(let-values(((syntax-literals-expr_0)"
"(generate-eager-syntax-literals! syntax-literals_0 mpis_0 0 #f ns_0)))"
"(let-values(((phase-to-link-module-uses-expr_0)"
"(list*"
" 'vector"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(reverse$1 module-uses-tables_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((phase-to-link-module-uses_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(serialize-phase-to-link-module-uses"
" phase-to-link-module-uses_0"
" mpis_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(let-values(((linklet-s_0)"
"(list"
" 'linklet"
"(list deserialize-imports eager-instance-imports)"
"(list*"
" mpi-vector-id"
" '(mpi-vector-trees"
" phase-to-link-modules-vector"
" phase-to-link-modules-trees"
" syntax-literals"
" syntax-literals-trees))"
"(list"
" 'define-values"
"(list mpi-vector-id)"
"(let-values(((mpis6_0) mpis_0))"
"(generate-module-path-index-deserialize.1 #f mpis6_0)))"
"(list 'define-values '(mpi-vector-trees)(list 'quote mpi-trees_0))"
"(list"
" 'define-values"
" '(phase-to-link-modules-vector)"
" phase-to-link-module-uses-expr_0)"
"(list"
" 'define-values"
" '(phase-to-link-modules-trees)"
"(list 'quote phase-to-link-module-uses-trees_0))"
"(list 'define-values '(syntax-literals) syntax-literals-expr_0)"
"(list"
" 'define-values"
" '(syntax-literals-trees)"
"(list 'quote syntax-literals-trees_0)))))"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet linklet-s_0 #f)"
"(1/compile-linklet linklet-s_0)))))))))))))))))))"
"(define-values"
"(map-cim-tree)"
"(lambda(cims_0 proc_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(cims_1)"
"(begin"
" 'loop"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) cims_1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((cim_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(vector"
"(proc_0 cim_0)"
"(loop_0"
"(compiled-in-memory-pre-compiled-in-memorys"
" cim_0))"
"(loop_0"
"(compiled-in-memory-post-compiled-in-memorys"
" cim_0))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))"
" loop_0)"
" cims_0))))"
"(define-values"
"(compiled-tops->compiled-top.1)"
"(lambda(merge-serialization?2_0 namespace3_0 to-correlated-linklet?1_0 all-cims7_0)"
"(begin"
" 'compiled-tops->compiled-top"
"(let-values(((all-cims_0) all-cims7_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?1_0))"
"(let-values(((merge-serialization?_0) merge-serialization?2_0))"
"(let-values(((ns_0) namespace3_0))"
"(let-values()"
"(let-values(((cims_0)(remove-nontail-purely-functional all-cims_0)))"
"(if(= 1(length cims_0))"
"(let-values()(car cims_0))"
"(let-values()"
"(let-values(((sequence-ht_0)"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((lst_0) cims_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((cim_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(string->symbol"
"(number->string"
" i_0))"
"(compiled-in-memory-linklet-directory"
" cim_0)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2 rest_0(+ pos_0 1))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0"
" start_0))))))"
"(let-values(((ht_0)"
"(if merge-serialization?_0"
"(hash-set"
" sequence-ht_0"
" 'data"
"(1/hash->linklet-directory"
"(hasheq"
" #f"
"(1/hash->linklet-bundle"
"(hasheq"
" 0"
"(let-values(((cims9_0) cims_0)"
"((ns10_0) ns_0)"
"((to-correlated-linklet?11_0) to-correlated-linklet?_0))"
"(build-shared-data-linklet.1"
" to-correlated-linklet?11_0"
" cims9_0"
" ns10_0)))))))"
" sequence-ht_0)))"
"(compiled-in-memory1.1"
"(1/hash->linklet-directory ht_0)"
" #f"
" #f"
" #f"
" #f"
" #f"
" '#hasheqv()"
" #f"
" '#hasheqv()"
" '#hasheqv()"
" '#()"
" '#()"
" cims_0"
" null"
" #f"
" #f))))))))))))))"
"(define-values"
"(compiled-top->compiled-tops)"
"(lambda(ld_0)"
"(begin"
"(let-values(((ht_0)(linklet-directory->hash$1 ld_0)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((start_0) 0)((end_0)(hash-count ht_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values(((i_0) pos_0))"
"(let-values(((fold-var_2)"
"(let-values(((id*_0)"
"(hash-ref"
" ht_0"
"(string->symbol(number->string i_0))"
" #f)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2)"
"(begin"
" 'for-loop"
"(let-values(((top_0) id*_0))"
"(let-values(((fold-var_3)"
"(if top_0"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
" top_0)"
" fold-var_2))))"
"(values"
" fold-var_3))"
" fold-var_2)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_1))))"
"(if(not #f)(for-loop_0 fold-var_2(+ pos_0 inc_0)) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" start_0)))))))))"
"(define-values"
"(remove-nontail-purely-functional)"
"(lambda(cims_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(cims_1)"
"(begin"
" 'loop"
"(if(null? cims_1)"
"(let-values() null)"
"(if(null?(cdr cims_1))"
"(let-values() cims_1)"
"(if(if(compiled-in-memory?(car cims_1))"
"(compiled-in-memory-purely-functional?(car cims_1))"
" #f)"
"(let-values()(loop_0(cdr cims_1)))"
"(let-values()(cons(car cims_1)(cdr cims_1))))))))))"
" loop_0)"
" cims_0))))"
"(define-values"
"(struct:known-defined/delay known-defined/delay2.1 known-defined/delay? known-defined/delay-thunk)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-defined/delay #f 1 0 #f null 'prefab #f '(0) #f 'known-defined/delay)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'thunk))))"
"(define-values"
"(struct:known-property known-property3.1 known-property?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'known-property #f 0 0 #f null 'prefab #f '() #f 'known-property)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:known-property-of-function"
" known-property-of-function4.1"
" known-property-of-function?"
" known-property-of-function-arity)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'known-property-of-function"
" #f"
" 1"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0)"
" #f"
" 'known-property-of-function)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'arity))))"
"(define-values"
"(struct:known-function known-function5.1 known-function? known-function-arity known-function-pure?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-function #f 2 0 #f null 'prefab #f '(0 1) #f 'known-function)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'arity)"
"(make-struct-field-accessor -ref_0 1 'pure?))))"
"(define-values"
"(struct:known-function-of-satisfying"
" known-function-of-satisfying6.1"
" known-function-of-satisfying?"
" known-function-of-satisfying-arg-predicate-keys"
" known-function-of-satisfying-result-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'known-function-of-satisfying"
" #f"
" 2"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0 1)"
" #f"
" 'known-function-of-satisfying)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'arg-predicate-keys)"
"(make-struct-field-accessor -ref_0 1 'result-key))))"
"(define-values"
"(struct:known-predicate known-predicate7.1 known-predicate? known-predicate-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-predicate #f 1 0 #f null 'prefab #f '(0) #f 'known-predicate)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'key))))"
"(define-values"
"(struct:known-satisfies known-satisfies8.1 known-satisfies? known-satisfies-predicate-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-satisfies #f 1 0 #f null 'prefab #f '(0) #f 'known-satisfies)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'predicate-key))))"
"(define-values"
"(struct:known-struct-op known-struct-op9.1 known-struct-op? known-struct-op-type known-struct-op-field-count)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-struct-op #f 2 0 #f null 'prefab #f '(0 1) #f 'known-struct-op)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'type)"
"(make-struct-field-accessor -ref_0 1 'field-count))))"
"(define-values"
"(lookup-defn)"
"(lambda(defns_0 sym_0)"
"(begin"
"(let-values(((d_0)(hash-ref defns_0 sym_0 #f)))"
"(if(known-defined/delay? d_0)"
"(let-values()(begin((known-defined/delay-thunk d_0))(lookup-defn defns_0 sym_0)))"
"(let-values() d_0))))))"
"(define-values"
"(any-side-effects?.1)"
"(lambda(known-defns2_0 known-locals1_0 ready-variable?3_0 e7_0 expected-results8_0)"
"(begin"
" 'any-side-effects?"
"(let-values(((e_0) e7_0))"
"(let-values(((expected-results_0) expected-results8_0))"
"(let-values(((locals_0) known-locals1_0))"
"(let-values(((defns_0) known-defns2_0))"
"(let-values(((ready-variable?_0)"
"(if(eq? ready-variable?3_0 unsafe-undefined)"
"(lambda(id_0)(begin 'ready-variable? #f))"
" ready-variable?3_0)))"
"(let-values()"
"(let-values(((effects?_0)"
"(lambda(e_1 expected-results_1 locals_1)"
"(begin"
" 'effects?"
"(let-values(((e10_0) e_1)"
"((expected-results11_0) expected-results_1)"
"((locals12_0) locals_1)"
"((defns13_0) defns_0)"
"((ready-variable?14_0) ready-variable?_0))"
"(any-side-effects?.1"
" defns13_0"
" locals12_0"
" ready-variable?14_0"
" e10_0"
" expected-results11_0))))))"
"(let-values(((actual-results_0)"
"((letrec-values(((loop_0)"
"(lambda(e_1 locals_1)"
"(begin"
" 'loop"
"(let-values(((tmp_0)"
"(if(pair?(correlated-e e_1))"
"(correlated-e(car(correlated-e e_1)))"
" #f)))"
"(let-values(((index_0)"
"(if(symbol? tmp_0)"
"(hash-ref"
" '#hasheq((#%variable-reference . 1)"
"(begin . 5)"
"(begin0 . 6)"
"(case-lambda . 1)"
"(gensym . 12)"
"(if . 13)"
"(lambda . 1)"
"(let-values . 2)"
"(letrec-values . 2)"
"(make-parameter . 7)"
"(make-struct-field-accessor . 9)"
"(make-struct-field-mutator . 10)"
"(make-struct-type . 8)"
"(make-struct-type-property . 11)"
"(quote . 1)"
"(values . 3)"
"(void . 4))"
" tmp_0"
"(lambda() 0))"
" 0)))"
"(if(unsafe-fx< index_0 6)"
"(if(unsafe-fx< index_0 2)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(let-values(((v_0)(correlated-e e_1)))"
"(if(let-values(((or-part_0)(string? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(number? v_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(boolean? v_0)))"
"(if or-part_2"
" or-part_2"
"(char? v_0)))))))"
"(let-values() 1)"
"(let-values(((c1_0)"
"(if(pair? v_0)"
"(let-values(((rator_0)"
"(correlated-e"
"(car v_0))))"
"(let-values(((or-part_0)"
"(hash-ref"
" locals_1"
" rator_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(lookup-defn"
" defns_0"
" rator_0))))"
" #f)))"
"(if c1_0"
"((lambda(d_0)"
"(let-values(((ok?_0 _15_0 e16_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((_15_0"
" e16_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((_17_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e18_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                            \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _17_0"
" e18_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                    \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _15_0"
" e16_0))))))"
"(let-values(((n-args_0)"
"(length e16_0)))"
"(if(let-values(((or-part_0)"
"(if(let-values(((or-part_0)"
"(if(known-struct-op?"
" d_0)"
"(if(eq?"
" 'constructor"
"(known-struct-op-type"
" d_0))"
"(let-values(((or-part_0)"
"(eq?"
" #t"
"(known-struct-op-field-count"
" d_0))))"
"(if or-part_0"
" or-part_0"
"(="
"(known-struct-op-field-count"
" d_0)"
" n-args_0)))"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(known-function?"
" d_0)"
"(if(known-function-pure?"
" d_0)"
"(arity-includes?"
"(known-function-arity"
" d_0)"
" n-args_0)"
" #f)"
" #f)))"
"(let-values(((result_0)"
"(let-values(((result_0)"
" #t))"
" result_0)))"
"(let-values(((lst_0)"
" e16_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(not"
"(effects?_0"
" e_2"
" 1"
" locals_1))))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" e_2))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_2"
" rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(known-function-of-satisfying?"
" d_0)"
"(if(="
" n-args_0"
"(length"
"(known-function-of-satisfying-arg-predicate-keys"
" d_0)))"
"(let-values(((result_0)"
"(let-values(((result_0)"
" #t))"
" result_0)))"
"(let-values(((lst_0)"
" e16_0)"
"((lst_1)"
"(known-function-of-satisfying-arg-predicate-keys"
" d_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((key_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(not"
"(effects?_0"
" e_2"
" 1"
" locals_1))"
"(satisfies?"
" e_2"
" key_0"
" defns_0"
" locals_1)"
" #f)))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" e_2))"
"(if(not"
"((lambda x_0"
"(not"
" result_2))"
" key_0))"
"(not"
" #f)"
" #f)"
" #f)"
"(for-loop_0"
" result_2"
" rest_0"
" rest_1)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0"
" lst_1))))"
" #f)"
" #f)))"
" 1"
" #f))))"
" c1_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(self-quoting-in-linklet?"
" v_0)))"
"(if or-part_0"
" or-part_0"
"(if(symbol? v_0)"
"(let-values(((or-part_1)"
"(hash-ref"
" locals_1"
" v_0"
" #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(lookup-defn"
" defns_0"
" v_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)"
"(built-in-symbol?"
" v_0)))"
"(if or-part_3"
" or-part_3"
"(ready-variable?_0"
" v_0)))))))"
" #f)))"
" 1"
" #f)))))))"
"(let-values() 1))"
"(if(unsafe-fx< index_0 3)"
"(let-values()"
"(let-values(((ok?_0 _19_0 ids20_0 rhs21_0 body22_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_19_0"
" ids20_0"
" rhs21_0"
" body22_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((_23_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((ids24_0"
" rhs25_0"
" body26_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((ids27_0"
" rhs28_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((ids_0"
" rhs_0)"
"(let-values(((ids_0)"
"(let-values(((ids_0)"
" null))"
" ids_0))"
"((rhs_0)"
"(let-values(((rhs_0)"
" null))"
" rhs_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ids_1"
" rhs_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((ids_2"
" rhs_2)"
"(let-values(((ids_2"
" rhs_2)"
"(let-values()"
"(let-values(((ids34_0"
" rhs35_0)"
"(let-values()"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(let-values(((ids30_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"((rhs31_0)"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(if(pair?"
" s_9)"
"(let-values(((rhs32_0)"
"(let-values(((s_10)"
"(car"
" s_9)))"
" s_10))"
"(()"
"(let-values(((s_10)"
"(cdr"
" s_9)))"
"(let-values(((s_11)"
"(if(1/syntax?"
" s_10)"
"(syntax-e$2"
" s_10)"
" s_10)))"
"(if(null?"
" s_11)"
"(values)"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs32_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values"
" ids30_0"
" rhs31_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" ids34_0"
" ids_1)"
"(cons"
" rhs35_0"
" rhs_1))))))"
"(values"
" ids_2"
" rhs_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" ids_2"
" rhs_2"
" rest_0)"
"(values"
" ids_2"
" rhs_2))))"
"(values"
" ids_1"
" rhs_1)))))))"
" for-loop_0)"
" ids_0"
" rhs_0"
" lst_0))))))"
"(values"
"(reverse$1"
" ids_0)"
"(reverse$1"
" rhs_0)))))))))"
"((body29_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((body33_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" body33_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" ids27_0"
" rhs28_0"
" body29_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" _23_0"
" ids24_0"
" rhs25_0"
" body26_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _19_0"
" ids20_0"
" rhs21_0"
" body22_0))))))"
"(if(not"
"(let-values(((result_0)"
"(let-values(((result_0) #f))"
" result_0)))"
"(let-values(((lst_0) ids20_0)"
"((lst_1) rhs21_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((rhs_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(effects?_0"
" rhs_0"
"(correlated-length"
" ids_0)"
" locals_1)))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
" result_2)"
" ids_0))"
"(if(not"
"((lambda x_0"
" result_2)"
" rhs_0))"
"(not"
" #f)"
" #f)"
" #f)"
"(for-loop_0"
" result_2"
" rest_0"
" rest_1)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0"
" lst_1)))))"
"(loop_0"
" body22_0"
"(add-binding-info locals_1 ids20_0 rhs21_0))"
" #f)))"
"(if(unsafe-fx< index_0 4)"
"(let-values()"
"(let-values(((ok?_0 _36_0 e37_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_36_0 e37_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((_38_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e39_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _38_0"
" e39_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                           \"bad syntax\""
" orig-s_0)))))"
"(values #t _36_0 e37_0))))))"
"(if(let-values(((result_0)"
"(let-values(((result_0) #t))"
" result_0)))"
"(let-values(((lst_0) e37_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(not"
"(effects?_0"
" e_2"
" 1"
" locals_1))))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" e_2))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_2"
" rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
"(length e37_0)"
" #f)))"
"(if(unsafe-fx< index_0 5)"
"(let-values()"
"(let-values(((ok?_0 _40_0 e41_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_40_0 e41_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((_42_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e43_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _42_0"
" e43_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                             \"bad syntax\""
" orig-s_0)))))"
"(values #t _40_0 e41_0))))))"
"(if(let-values(((result_0)"
"(let-values(((result_0)"
" #t))"
" result_0)))"
"(let-values(((lst_0) e41_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(not"
"(effects?_0"
" e_2"
" 1"
" locals_1))))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" e_2))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_2"
" rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" 1"
" #f)))"
"(let-values()"
"(let-values(((ok?_0 _44_0 e45_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_44_0 e45_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((_46_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e47_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _46_0"
" e47_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                             \"bad syntax\""
" orig-s_0)))))"
"(values #t _44_0 e45_0))))))"
"((letrec-values(((bloop_0)"
"(lambda(es_0)"
"(begin"
" 'bloop"
"(if(null? es_0)"
"(let-values() #f)"
"(if(null?(cdr es_0))"
"(let-values()"
"(loop_0"
"(car es_0)"
" locals_1))"
"(let-values()"
"(if(not"
"(effects?_0"
"(car es_0)"
" #f"
" locals_1))"
"(bloop_0"
"(cdr es_0))"
" #f))))))))"
" bloop_0)"
" e45_0)))))))"
"(if(unsafe-fx< index_0 9)"
"(if(unsafe-fx< index_0 7)"
"(let-values()"
"(let-values(((ok?_0 _48_0 e049_0 e50_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_48_0 e049_0 e50_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((_51_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e052_0"
" e53_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((e054_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((e55_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" e054_0"
" e55_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" _51_0"
" e052_0"
" e53_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _48_0"
" e049_0"
" e50_0))))))"
"(if(let-values(((result_0)"
"(let-values(((result_0) #t))"
" result_0)))"
"(let-values(((lst_0) e50_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(not"
"(effects?_0"
" e_2"
" #f"
" locals_1))))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" e_2))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_2"
" rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
"(loop_0 e049_0 locals_1)"
" #f)))"
"(if(unsafe-fx< index_0 8)"
"(let-values()"
"(let-values(((ok?_0"
" mp56_0"
" v57_0"
" g58_0"
" quot59_0"
" nm60_0)"
"(let-values(((s_0) e_1))"
"(if(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
" #t)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
" #t)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(if(pair?"
" s_9)"
"(if(let-values(((s_10)"
"(car"
" s_9)))"
" #t)"
"(let-values(((s_10)"
"(cdr"
" s_9)))"
"(let-values(((s_11)"
"(if(1/syntax?"
" s_10)"
"(syntax-e$2"
" s_10)"
" s_10)))"
"(if(pair?"
" s_11)"
"(if(let-values(((s_12)"
"(car"
" s_11)))"
" #t)"
"(let-values(((s_12)"
"(cdr"
" s_11)))"
"(let-values(((s_13)"
"(if(1/syntax?"
" s_12)"
"(syntax-e$2"
" s_12)"
" s_12)))"
"(null?"
" s_13)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((mp56_0"
" v57_0"
" g58_0"
" quot59_0"
" nm60_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(let-values(((mp61_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((v62_0"
" g63_0"
" quot64_0"
" nm65_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((v66_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((g67_0"
" quot68_0"
" nm69_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((g70_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((quot71_0"
" nm72_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((quot73_0"
" nm74_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(let-values(((quot75_0)"
"(let-values(((s_10)"
"(car"
" s_9)))"
" s_10))"
"((nm76_0)"
"(let-values(((s_10)"
"(cdr"
" s_9)))"
"(let-values(((s_11)"
"(if(1/syntax?"
" s_10)"
"(syntax-e$2"
" s_10)"
" s_10)))"
"(let-values(((nm77_0)"
"(let-values(((s_12)"
"(car"
" s_11)))"
" s_12))"
"(()"
"(let-values(((s_12)"
"(cdr"
" s_11)))"
"(let-values(((s_13)"
"(if(1/syntax?"
" s_12)"
"(syntax-e$2"
" s_12)"
" s_12)))"
"(values)))))"
"(values"
" nm77_0))))))"
"(values"
" quot75_0"
" nm76_0)))))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" quot73_0"
" nm74_0))))))"
"(values"
" g70_0"
" quot71_0"
" nm72_0))))))"
"(values"
" v66_0"
" g67_0"
" quot68_0"
" nm69_0))))))"
"(values"
" mp61_0"
" v62_0"
" g63_0"
" quot64_0"
" nm65_0)))))"
"(values"
" #t"
" mp56_0"
" v57_0"
" g58_0"
" quot59_0"
" nm60_0)))"
"(values #f #f #f #f #f #f)))))"
"(if ok?_0"
"(if(not"
"(let-values(((temp78_0) v57_0)"
"((temp79_0) 1))"
"(any-side-effects?.1"
" '#hasheq()"
" '#hasheq()"
" unsafe-undefined"
" temp78_0"
" temp79_0)))"
"(if(eq? 'quote quot59_0)"
"(if(symbol? nm60_0)"
"(if(equal? #f g58_0) 1 #f)"
" #f)"
" #f)"
" #f)"
" #f)))"
"(let-values()"
"(if(ok-make-struct-type?"
" e_1"
" ready-variable?_0"
" defns_0)"
" 5"
" #f))))"
"(if(unsafe-fx< index_0 11)"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(if(ok-make-struct-field-accessor/mutator?"
" e_1"
" locals_1"
" 'general-accessor"
" defns_0)"
" 1"
" #f))"
"(let-values()"
"(if(ok-make-struct-field-accessor/mutator?"
" e_1"
" locals_1"
" 'general-mutator"
" defns_0)"
" 1"
" #f)))"
"(if(unsafe-fx< index_0 12)"
"(let-values()"
"(if(ok-make-struct-type-property? e_1 defns_0)"
" 3"
" #f))"
"(if(unsafe-fx< index_0 13)"
"(let-values()"
"(let-values(((ok?_0 gs80_0 quot81_0 datum82_0)"
"(let-values(((s_0) e_1))"
"(if(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
" #t)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
" #t)"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(null?"
" s_5)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((gs80_0"
" quot81_0"
" datum82_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(let-values(((gs83_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((quot84_0"
" datum85_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((quot86_0"
" datum87_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((quot88_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((datum89_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((datum90_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" datum90_0))))))"
"(values"
" quot88_0"
" datum89_0)))))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(values)))))"
"(values"
" quot86_0"
" datum87_0))))))"
"(values"
" gs83_0"
" quot84_0"
" datum85_0)))))"
"(values"
" #t"
" gs80_0"
" quot81_0"
" datum82_0)))"
"(values #f #f #f #f)))))"
"(if(let-values(((or-part_0)"
"(if ok?_0"
"(if(eq? 'quote quot81_0)"
"(let-values(((or-part_0)"
"(symbol?"
" datum82_0)))"
"(if or-part_0"
" or-part_0"
"(string?"
" datum82_0)))"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(null?(cdr(correlated-e e_1)))))"
" 1"
" #f)))"
"(let-values()"
"(let-values(((ok?_0"
" _91_0"
" id:rator92_0"
" id:arg93_0"
" thn94_0"
" els95_0)"
"(let-values(((s_0) e_1))"
"(if(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((or-part_0)"
"(if(1/syntax?"
" s_6)"
"(symbol?"
"(syntax-e$2"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6))))"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
"(let-values(((or-part_0)"
"(if(1/syntax?"
" s_8)"
"(symbol?"
"(syntax-e$2"
" s_8))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_8))))"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
" #t)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
" #t)"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((_91_0"
" id:rator92_0"
" id:arg93_0"
" thn94_0"
" els95_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(let-values(((_96_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:rator97_0"
" id:arg98_0"
" thn99_0"
" els100_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((id:rator101_0"
" id:arg102_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((id:rator105_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((id:arg106_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((id:arg107_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" id:arg107_0))))))"
"(values"
" id:rator105_0"
" id:arg106_0)))))"
"((thn103_0"
" els104_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((thn108_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((els109_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((els110_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" els110_0))))))"
"(values"
" thn108_0"
" els109_0))))))"
"(values"
" id:rator101_0"
" id:arg102_0"
" thn103_0"
" els104_0))))))"
"(values"
" _96_0"
" id:rator97_0"
" id:arg98_0"
" thn99_0"
" els100_0)))))"
"(values"
" #t"
" _91_0"
" id:rator92_0"
" id:arg93_0"
" thn94_0"
" els95_0)))"
"(values #f #f #f #f #f #f)))))"
"(if ok?_0"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((or-part_0)"
"(hash-ref"
" locals_1"
" id:rator92_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(lookup-defn"
" defns_0"
" id:rator92_0)))))"
"(if c2_0"
"((lambda(d_0)"
"(if(known-predicate? d_0)"
"(if(not"
"(effects?_0"
" thn94_0"
" expected-results_0"
"(hash-set"
" locals_1"
" id:arg93_0"
"(known-satisfies8.1"
"(known-predicate-key"
" d_0)))))"
"(loop_0 els95_0 locals_1)"
" #f)"
" #f))"
" c2_0)"
"(let-values() #f))))"
"(let-values()"
"(let-values(((ok?_1"
" _111_0"
" tst112_0"
" thn113_0"
" els114_0)"
"(let-values(((s_0) e_1))"
"(if(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
" #t)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
" #t)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
" #t)"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((_111_0"
" tst112_0"
" thn113_0"
" els114_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(let-values(((_115_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((tst116_0"
" thn117_0"
" els118_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((tst119_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((thn120_0"
" els121_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((thn122_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((els123_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((els124_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" els124_0))))))"
"(values"
" thn122_0"
" els123_0))))))"
"(values"
" tst119_0"
" thn120_0"
" els121_0))))))"
"(values"
" _115_0"
" tst116_0"
" thn117_0"
" els118_0)))))"
"(values"
" #t"
" _111_0"
" tst112_0"
" thn113_0"
" els114_0)))"
"(values"
" #f"
" #f"
" #f"
" #f"
" #f)))))"
"(if ok?_1"
"(if(not"
"(effects?_0 tst112_0 1 locals_1))"
"(if(not"
"(effects?_0"
" thn113_0"
" expected-results_0"
" locals_1))"
"(loop_0 els114_0 locals_1)"
" #f)"
" #f)"
" #f)))))))))))))))))"
" loop_0)"
" e_0"
" locals_0)))"
"(not"
"(if actual-results_0"
"(let-values(((or-part_0)(not expected-results_0)))"
"(if or-part_0 or-part_0(= actual-results_0 expected-results_0)))"
" #f)))))))))))))"
"(define-values"
"(satisfies?)"
"(lambda(e_0 key_0 defns_0 locals_0)"
"(begin"
"(let-values(((d_0)"
"(let-values(((or-part_0)(hash-ref locals_0 e_0 #f)))"
"(if or-part_0 or-part_0(lookup-defn defns_0 e_0)))))"
"(let-values(((known-key_0)"
"(let-values(((or-part_0)"
"(if d_0(if(known-satisfies? d_0)(known-satisfies-predicate-key d_0) #f) #f)))"
"(if or-part_0"
" or-part_0"
"(if(not e_0)"
"(let-values() 'false)"
"(if(exact-integer? e_0)"
"(let-values() 'exact-integer)"
"(if(pair? e_0)"
"(let-values()"
"(let-values(((head_0)(car e_0)))"
"(if(eq? head_0 'quote)"
"(let-values()"
"(let-values(((v_0)(cadr e_0)))"
"(if(symbol? v_0)(let-values() 'symbol)(let-values() #f))))"
"(let-values()"
"(let-values(((p_0)(lookup-defn defns_0 head_0)))"
"(if(known-function-of-satisfying? p_0)"
"(let-values()(known-function-of-satisfying-result-key p_0))"
"(let-values() #f)))))))"
"(let-values() #f))))))))"
"(if known-key_0"
"(let-values(((or-part_0)(eq? key_0 known-key_0)))"
"(if or-part_0"
" or-part_0"
"(if(pair? key_0)"
"(if(eq? 'or(car key_0))"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0)(cdr key_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((key_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(eq? key_1 known-key_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) key_1))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f)"
" #f)))"
" #f))))))"
"(define-values"
"(add-binding-info)"
"(lambda(locals_0 idss_0 rhss_0)"
"(begin"
"(let-values(((locals_1)(let-values(((locals_1) locals_0)) locals_1)))"
"(let-values(((lst_0) idss_0)((lst_1) rhss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(locals_2 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((ids_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((rhs_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((locals_3)"
"(let-values(((locals_3)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(rhs_1)"
"(begin"
" 'loop"
"(let-values(((tmp_0)"
"(if(pair?"
"(correlated-e"
" rhs_1))"
"(correlated-e"
"(car"
"(correlated-e"
" rhs_1)))"
" #f)))"
"(if(equal?"
" tmp_0"
" 'make-struct-type)"
"(let-values()"
"(let-values(((field-count_0)"
"(extract-struct-field-count-lower-bound"
" rhs_1)))"
"(let-values(((locals_3)"
"(let-values(((locals_3)"
" locals_2))"
" locals_3)))"
"(let-values(((lst_4)"
"(correlated->list"
" ids_0))"
"((lst_5)"
" '(struct-type"
" constructor"
" predicate"
" general-accessor"
" general-mutator)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_5)))"
"((letrec-values(((for-loop_1)"
"(lambda(locals_4"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((type_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((locals_5)"
"(let-values(((locals_5)"
"(let-values()"
"(hash-set"
" locals_4"
"(correlated-e"
" id_0)"
"(known-struct-op9.1"
" type_0"
" field-count_0)))))"
"(values"
" locals_5))))"
"(if(not"
" #f)"
"(for-loop_1"
" locals_5"
" rest_2"
" rest_3)"
" locals_5)))"
" locals_4))))))"
" for-loop_1)"
" locals_3"
" lst_4"
" lst_5))))))"
"(if(equal?"
" tmp_0"
" 'let-values)"
"(let-values()"
"(if(null?"
"(correlated-e"
"(correlated-cadr"
" rhs_1)))"
"(loop_0"
"(caddr"
"(correlated->list"
" rhs_1)))"
"(loop_0 #f)))"
"(let-values()"
"(let-values(((ids*_0)"
"(correlated->list"
" ids_0)))"
"(if(if(pair?"
" ids*_0)"
"(null?"
"(cdr"
" ids*_0))"
" #f)"
"(let-values()"
"(hash-set"
" locals_2"
"(correlated-e"
"(car"
" ids*_0))"
"(infer-known"
" rhs_1)))"
"(let-values()"
"(let-values(((locals_3)"
"(let-values(((locals_3)"
" locals_2))"
" locals_3)))"
"(let-values(((lst_4)"
" ids*_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"((letrec-values(((for-loop_1)"
"(lambda(locals_4"
" lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_5)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((locals_5)"
"(let-values(((locals_5)"
"(let-values()"
"(hash-set"
" locals_4"
"(correlated-e"
" id_0)"
" #t))))"
"(values"
" locals_5))))"
"(if(not"
" #f)"
"(for-loop_1"
" locals_5"
" rest_2)"
" locals_5)))"
" locals_4))))))"
" for-loop_1)"
" locals_3"
" lst_4)))))))))))))))"
" loop_0)"
" rhs_0))))"
"(values locals_3))))"
"(if(not #f)(for-loop_0 locals_3 rest_0 rest_1) locals_3)))"
" locals_2))))))"
" for-loop_0)"
" locals_1"
" lst_0"
" lst_1)))))))"
"(define-values"
"(infer-known)"
"(lambda(e_0)"
"(begin"
"(let-values(((tmp_0)(if(pair?(correlated-e e_0))(correlated-e(car(correlated-e e_0))) #f)))"
"(if(if(equal? tmp_0 'lambda) #t(equal? tmp_0 'case-lambda))"
"(let-values()(known-satisfies8.1 'procedure))"
"(let-values() #t))))))"
"(define-values"
"(ok-make-struct-type-property?)"
"(lambda(e_0 defns_0)"
"(begin"
"(let-values(((l_0)(correlated->list e_0)))"
"(if(<= 2(length l_0) 8)"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0)(cdr l_0))"
"((lst_1)"
"(list"
"(lambda(v_0)(quoted? symbol? v_0))"
"(lambda(v_0)(is-lambda? v_0 2 defns_0))"
"(lambda(v_0)(ok-make-struct-type-property-super? v_0 defns_0))"
"(lambda(v_0)"
"(not"
"(let-values(((v125_0) v_0)((temp126_0) 1)((defns127_0) defns_0))"
"(any-side-effects?.1 defns127_0 '#hasheq() unsafe-undefined v125_0 temp126_0))))"
"(lambda(v_0)(quoted? symbol? v_0))"
"(lambda(v_0)"
"(quoted?"
"(lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? x_0)))(if or-part_1 or-part_1(string? x_0))))))"
" v_0))"
"(lambda(v_0)(quoted? symbol? v_0)))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((arg_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((pred_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()(let-values()(pred_0 arg_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) arg_0))"
"(if(not((lambda x_0(not result_2)) pred_0))(not #f) #f)"
" #f)"
"(for-loop_0 result_2 rest_0 rest_1)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0"
" lst_1))))"
" #f)))))"
"(define-values"
"(ok-make-struct-type-property-super?)"
"(lambda(v_0 defns_0)"
"(begin"
"(let-values(((or-part_0)(quoted? null? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? 'null(correlated-e v_0))))"
"(if or-part_1"
" or-part_1"
"(if(pair?(correlated-e v_0))"
"(if(eq?(correlated-e(car(correlated-e v_0))) 'list)"
"(if(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0)(cdr(correlated->list v_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((prop+val_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(="
"(correlated-length"
" prop+val_0)"
" 3)"
"(let-values(((prop+val_1)"
"(correlated->list"
" prop+val_0)))"
"(if(eq?"
" 'cons"
"(correlated-e"
"(car prop+val_1)))"
"(if(let-values(((or-part_2)"
"(memq"
"(correlated-e"
"(list-ref"
" prop+val_1"
" 1))"
" '(prop:procedure"
" prop:equal+hash))))"
"(if or-part_2"
" or-part_2"
"(let-values(((o_0)"
"(lookup-defn"
" defns_0"
"(correlated-e"
"(list-ref"
" prop+val_1"
" 1)))))"
"(let-values(((or-part_3)"
"(known-property?"
" o_0)))"
"(if or-part_3"
" or-part_3"
"(known-property-of-function?"
" o_0))))))"
"(not"
"(let-values(((temp128_0)"
"(list-ref"
" prop+val_1"
" 2))"
"((temp129_0)"
" 1)"
"((defns130_0)"
" defns_0))"
"(any-side-effects?.1"
" defns130_0"
" '#hasheq()"
" unsafe-undefined"
" temp128_0"
" temp129_0)))"
" #f)"
" #f))"
" #f)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) prop+val_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
"(="
"(sub1(correlated-length v_0))"
"(set-count"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((lst_0)(cdr(correlated->list v_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((prop+val_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
"(correlated-e"
"(list-ref"
"(correlated->list"
" prop+val_0)"
" 1)))"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2 rest_0) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0))))))"
" #f)"
" #f)"
" #f))))))))"
"(define-values"
"(ok-make-struct-type?)"
"(lambda(e_0 ready-variable?_0 defns_0)"
"(begin"
"(let-values(((l_0)(correlated->list e_0)))"
"(let-values(((init-field-count-expr_0)(if(>(length l_0) 3)(list-ref l_0 3) #f)))"
"(let-values(((auto-field-count-expr_0)(if(>(length l_0) 4)(list-ref l_0 4) #f)))"
"(let-values(((num-fields_0)"
"(maybe+"
"(field-count-expr-to-field-count init-field-count-expr_0)"
"(field-count-expr-to-field-count auto-field-count-expr_0))))"
"(let-values(((immutables-expr_0)"
"(let-values(((or-part_0)(if(>(length l_0) 9)(list-ref l_0 9) #f)))"
"(if or-part_0 or-part_0 'null))))"
"(let-values(((super-expr_0)(if(>(length l_0) 2)(list-ref l_0 2) #f)))"
"(if(>=(length l_0) 5)"
"(if(<=(length l_0) 12)"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0)(cdr l_0))"
"((lst_1)"
"(list"
"(lambda(v_0)(quoted? symbol? v_0))"
"(lambda(v_0)(super-ok? v_0 defns_0))"
"(lambda(v_0)(field-count-expr-to-field-count v_0))"
"(lambda(v_0)(field-count-expr-to-field-count v_0))"
"(lambda(v_0)"
"(not"
"(let-values(((v131_0) v_0)"
"((temp132_0) 1)"
"((ready-variable?133_0) ready-variable?_0)"
"((defns134_0) defns_0))"
"(any-side-effects?.1"
" defns134_0"
" '#hasheq()"
" ready-variable?133_0"
" v131_0"
" temp132_0))))"
"(lambda(v_0)"
"(known-good-struct-properties? v_0 immutables-expr_0 super-expr_0 defns_0))"
"(lambda(v_0)(inspector-or-false? v_0))"
"(lambda(v_0)(procedure-spec? v_0 num-fields_0))"
"(lambda(v_0)(immutables-ok? v_0 init-field-count-expr_0)))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((arg_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((pred_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()(pred_0 arg_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) arg_0))"
"(if(not((lambda x_0(not result_2)) pred_0))"
"(not #f)"
" #f)"
" #f)"
"(for-loop_0 result_2 rest_0 rest_1)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0"
" lst_1))))"
" #f)"
" #f))))))))))"
"(define-values"
"(super-ok?)"
"(lambda(e_0 defns_0)"
"(begin"
"(let-values(((or-part_0)(quoted? false? e_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((o_0)(lookup-defn defns_0(correlated-e e_0))))"
"(if o_0(if(known-struct-op? o_0)(eq? 'struct-type(known-struct-op-type o_0)) #f) #f)))))))"
"(define-values"
"(extract-struct-field-count-lower-bound)"
"(lambda(e_0)"
"(begin"
"(let-values(((l_0)(correlated->list e_0)))"
"(+(field-count-expr-to-field-count(list-ref l_0 3))(field-count-expr-to-field-count(list-ref l_0 4)))))))"
"(define-values"
"(quoted?)"
"(lambda(val?_0 v_0)"
"(begin"
"(let-values(((or-part_0)"
"(if(pair?(correlated-e v_0))"
"(if(eq?(correlated-e(car(correlated-e v_0))) 'quote)"
"(val?_0(correlated-e(correlated-cadr v_0)))"
" #f)"
" #f)))"
"(if or-part_0 or-part_0(val?_0(correlated-e v_0)))))))"
"(define-values"
"(quoted-value)"
"(lambda(v_0)(begin(if(pair?(correlated-e v_0))(correlated-e(correlated-cadr v_0))(correlated-e v_0)))))"
"(define-values(false?)(lambda(v_0)(begin(eq?(correlated-e v_0) #f))))"
"(define-values"
"(field-count-expr-to-field-count)"
"(lambda(v_0)(begin(if(quoted? exact-nonnegative-integer? v_0)(quoted-value v_0) #f))))"
"(define-values"
"(inspector-or-false?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(quoted? false? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(quoted? symbol? v_0)(eq? 'prefab(quoted-value v_0)) #f)))"
"(if or-part_1"
" or-part_1"
"(if(= 1(correlated-length v_0))"
"(eq? 'current-inspector(correlated-e(car(correlated-e v_0))))"
" #f))))))))"
"(define-values"
"(known-good-struct-properties?)"
"(lambda(v_0 immutables-expr_0 super-expr_0 defns_0)"
"(begin"
"(let-values(((or-part_0)(quoted? null? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? 'null(correlated-e v_0))))"
"(if or-part_1"
" or-part_1"
"(if(pair?(correlated-e v_0))"
"(if(eq?(correlated-e(car(correlated-e v_0))) 'list)"
"(if(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0)(cdr(correlated->list v_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((prop+val_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(="
"(correlated-length"
" prop+val_0)"
" 3)"
"(let-values(((prop+val_1)"
"(correlated->list"
" prop+val_0)))"
"(if(eq?"
" 'cons"
"(correlated-e"
"(car prop+val_1)))"
"(known-good-struct-property+value?"
"(list-ref prop+val_1 1)"
"(list-ref prop+val_1 2)"
" immutables-expr_0"
" super-expr_0"
" defns_0)"
" #f))"
" #f)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) prop+val_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
"(="
"(sub1(correlated-length v_0))"
"(set-count"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((lst_0)(cdr(correlated->list v_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((prop+val_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
"(correlated-e"
"(list-ref"
"(correlated->list"
" prop+val_0)"
" 1)))"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2 rest_0) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0))))))"
" #f)"
" #f)"
" #f))))))))"
"(define-values"
"(known-good-struct-property+value?)"
"(lambda(prop-expr_0 val-expr_0 immutables-expr_0 super-expr_0 defns_0)"
"(begin"
"(let-values(((prop-name_0)(correlated-e prop-expr_0)))"
"(let-values(((tmp_0) prop-name_0))"
"(if(equal? tmp_0 'prop:evt)"
"(let-values()"
"(let-values(((or-part_0)(is-lambda? val-expr_0 1 defns_0)))"
"(if or-part_0 or-part_0(immutable-field? val-expr_0 immutables-expr_0))))"
"(if(equal? tmp_0 'prop:procedure)"
"(let-values()"
"(let-values(((or-part_0)(is-lambda? val-expr_0 1 defns_0)))"
"(if or-part_0 or-part_0(immutable-field? val-expr_0 immutables-expr_0))))"
"(if(equal? tmp_0 'prop:equal+hash)"
"(let-values()"
"(let-values(((l_0)(correlated->list val-expr_0)))"
"(if(eq? 'list(car l_0))"
"(if(is-lambda?(list-ref l_0 1) 3 defns_0)"
"(if(is-lambda?(list-ref l_0 2) 2 defns_0)(is-lambda?(list-ref l_0 3) 2 defns_0) #f)"
" #f)"
" #f)))"
"(if(equal? tmp_0 'prop:checked-procedure)"
"(let-values()(if(quoted? false? super-expr_0)(immutable-field? 1 immutables-expr_0) #f))"
"(if(equal? tmp_0 'prop:object-name)"
"(let-values()(immutable-field? val-expr_0 immutables-expr_0))"
"(let-values()"
"(let-values(((o_0)(lookup-defn defns_0 prop-name_0)))"
"(if(known-property? o_0)"
"(let-values()"
"(not"
"(let-values(((val-expr135_0) val-expr_0)((temp136_0) 1)((defns137_0) defns_0))"
"(any-side-effects?.1 defns137_0 '#hasheq() unsafe-undefined val-expr135_0 temp136_0))))"
"(if(known-property-of-function? o_0)"
"(let-values()(is-lambda? val-expr_0(known-property-of-function-arity o_0) defns_0))"
"(let-values() #f)))))))))))))))"
"(define-values"
"(is-lambda?)"
"(lambda(expr_0 arity_0 defns_0)"
"(begin"
"(let-values(((lookup_0)(lookup-defn defns_0 expr_0)))"
"(let-values(((or-part_0)"
"(if lookup_0"
"(if(known-function? lookup_0)"
"(let-values(((or-part_0)(not arity_0)))"
"(if or-part_0 or-part_0(arity-includes?(known-function-arity lookup_0) arity_0)))"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(pair?(correlated-e expr_0))"
"(if(eq? 'case-lambda(car(correlated-e expr_0)))(not arity_0) #f)"
" #f)))"
"(if or-part_1"
" or-part_1"
"(if(pair?(correlated-e expr_0))"
"(if(eq? 'lambda(car(correlated-e expr_0)))"
"(let-values(((or-part_2)(not arity_0)))"
"(if or-part_2"
" or-part_2"
"((letrec-values(((loop_0)"
"(lambda(args_0 arity_1)"
"(begin"
" 'loop"
"(if(correlated? args_0)"
"(let-values()(loop_0(correlated-e args_0) arity_1))"
"(if(null? args_0)"
"(let-values()(zero? arity_1))"
"(if(pair? args_0)"
"(let-values()(loop_0(cdr args_0)(sub1 arity_1)))"
"(let-values()(not(negative? arity_1))))))))))"
" loop_0)"
"(cadr(correlated->list expr_0))"
" arity_0)))"
" #f)"
" #f)))))))))"
"(define-values"
"(arity-includes?)"
"(lambda(a_0 n_0)"
"(begin"
"(let-values(((or-part_0)(equal? a_0 n_0)))"
"(if or-part_0"
" or-part_0"
"(if(list? a_0)"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0) a_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((a_1)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()(equal? a_1 n_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) a_1))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f))))))"
"(define-values"
"(immutable-field?)"
"(lambda(val-expr_0 immutables-expr_0)"
"(begin"
"(if(quoted? exact-nonnegative-integer? val-expr_0)"
"(memv(quoted-value val-expr_0)(immutables-expr-to-immutables immutables-expr_0 null))"
" #f))))"
"(define-values"
"(immutables-expr-to-immutables)"
"(lambda(e_0 fail-v_0)"
"(begin"
"(let-values(((tmp_0)(if(pair?(correlated-e e_0))(correlated-e(car(correlated-e e_0))) #f)))"
"(if(equal? tmp_0 'quote)"
"(let-values()"
"(let-values(((v_0)(correlated-cadr e_0)))"
"(let-values(((or-part_0)"
"(if(correlated-length v_0)"
"(let-values(((l_0)(map2 correlated-e(correlated->list v_0))))"
"(if(andmap2 exact-nonnegative-integer? l_0)"
"(if(=(length l_0)(set-count(list->set l_0))) l_0 #f)"
" #f))"
" #f)))"
"(if or-part_0 or-part_0 fail-v_0))))"
"(let-values() fail-v_0))))))"
"(define-values"
"(procedure-spec?)"
"(lambda(e_0 field-count_0)"
"(begin"
"(let-values(((or-part_0)(quoted? false? e_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(quoted? exact-nonnegative-integer? e_0)"
"(if field-count_0(<(quoted-value e_0) field-count_0) #f)"
" #f)))"
"(if or-part_1 or-part_1(is-lambda? e_0 #f '#hasheq()))))))))"
"(define-values"
"(immutables-ok?)"
"(lambda(e_0 init-field-count-expr_0)"
"(begin"
"(let-values(((l_0)(immutables-expr-to-immutables e_0 #f)))"
"(let-values(((c_0)(field-count-expr-to-field-count init-field-count-expr_0)))"
"(if l_0"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((n_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()(let-values()(< n_0 c_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) n_0))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f))))))"
"(define-values"
"(ok-make-struct-field-accessor/mutator?)"
"(lambda(e_0 locals_0 type_0 defns_0)"
"(begin"
"(let-values(((l_0)(correlated->list e_0)))"
"(let-values(((len_0)(length l_0)))"
"(let-values(((a_0)"
"(if(<= 3 len_0 6)"
"(let-values(((or-part_0)(hash-ref locals_0(correlated-e(list-ref l_0 1)) #f)))"
"(if or-part_0 or-part_0(lookup-defn defns_0(correlated-e(list-ref l_0 1)))))"
" #f)))"
"(if(known-struct-op? a_0)"
"(if(eq?(known-struct-op-type a_0) type_0)"
"(if(let-values(((c_0)(field-count-expr-to-field-count(list-ref l_0 2))))"
"(if c_0(< c_0(known-struct-op-field-count a_0)) #f))"
"(if(let-values(((or-part_0)(< len_0 4)))"
"(if or-part_0 or-part_0(quoted? symbol?(list-ref l_0 3))))"
"(if(let-values(((or-part_0)(< len_0 5)))"
"(if or-part_0"
" or-part_0"
"(quoted?"
"(lambda(x_0)"
"(let-values(((or-part_1)(not x_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(string? x_0)))(if or-part_2 or-part_2(symbol? x_0))))))"
"(list-ref l_0 4))))"
"(let-values(((or-part_0)(< len_0 6)))"
"(if or-part_0 or-part_0(quoted? symbol?(list-ref l_0 5))))"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)))))))"
"(define-values(maybe+)(lambda(x_0 y_0)(begin(if x_0(if y_0(+ x_0 y_0) #f) #f))))"
"(define-values"
"(compile-single)"
"(lambda(p_0 cctx_0)"
"(begin"
"(let-values(((p10_0) p_0)((cctx11_0) cctx_0)((temp12_0) #f)((temp13_0) #t))"
"(compile-top.1 temp12_0 temp13_0 #f p10_0 cctx11_0)))))"
"(define-values"
"(compile-top.1)"
"(lambda(serializable?1_0 single-expression?2_0 to-correlated-linklet?3_0 p7_0 cctx8_0)"
"(begin"
" 'compile-top"
"(let-values(((p_0) p7_0))"
"(let-values(((cctx_0) cctx8_0))"
"(let-values(((serializable?_0) serializable?1_0))"
"(let-values(((single-expression?_0) single-expression?2_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?3_0))"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'compile(if single-expression?_0 'transformer 'top)))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((phase_0)(compile-context-phase cctx_0)))"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values(((purely-functional?_0) #t))"
"(let-values(((body-linklets_0"
" min-phase_0"
" max-phase_0"
" phase-to-link-module-uses_0"
" phase-to-link-module-uses-expr_0"
" phase-to-link-extra-inspectorss_0"
" syntax-literals_0"
" no-root-context-pos_0)"
"(let-values(((temp14_0)(flatten-begin p_0))"
"((cctx15_0) cctx_0)"
"((mpis16_0) mpis_0)"
"((temp17_0)"
"(if single-expression?_0"
"(list* '()(list syntax-literals-id) '(()))"
"(list"
"(list top-level-bind!-id top-level-require!-id)"
"(list mpi-vector-id syntax-literals-id)"
" instance-imports)))"
"((temp18_0)"
"(list"
" top-level-instance"
" empty-top-syntax-literal-instance"
" empty-instance-instance))"
"((serializable?19_0) serializable?_0)"
"((to-correlated-linklet?20_0) to-correlated-linklet?_0)"
"((temp21_0)(lambda()(set! purely-functional?_0 #f)))"
"((temp22_0)"
"(lambda(e_0 expected-results_0 phase_1 required-reference?_0)"
"(if(if purely-functional?_0"
"(let-values(((e25_0) e_0)"
"((expected-results26_0)"
" expected-results_0)"
"((required-reference?27_0)"
" required-reference?_0))"
"(any-side-effects?.1"
" '#hasheq()"
" '#hasheq()"
" required-reference?27_0"
" e25_0"
" expected-results26_0))"
" #f)"
"(let-values()(set! purely-functional?_0 #f))"
"(void))))"
"((temp23_0)"
"(lambda(s_0 cctx_1)"
"(begin"
"(set! purely-functional?_0 #f)"
"(compile-top-level-require s_0 cctx_1))))"
"((temp24_0)(not single-expression?_0)))"
"(compile-forms.1"
" temp18_0"
" temp17_0"
" null"
" temp22_0"
" temp21_0"
" #f"
" null"
" unsafe-undefined"
" #f"
" temp24_0"
" temp23_0"
" unsafe-undefined"
" #f"
" serializable?19_0"
" to-correlated-linklet?20_0"
" #f"
" #f"
" temp14_0"
" cctx15_0"
" mpis16_0))))"
"(let-values(((add-metadata_0)"
"(lambda(ht_0)"
"(begin"
" 'add-metadata"
"(let-values(((ht_1)(hash-set ht_0 'original-phase phase_0)))"
"(let-values(((ht_2)(hash-set ht_1 'max-phase max-phase_0)))"
" ht_2))))))"
"(let-values(((bundle_0)"
"(1/hash->linklet-bundle"
"(add-metadata_0"
"(if serializable?_0"
"(let-values()"
"(let-values(((syntax-literals-expr_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'top"
" 'serialize))"
"(void))"
"(begin0"
"(let-values()"
"(generate-eager-syntax-literals!"
" syntax-literals_0"
" mpis_0"
" phase_0"
"(compile-context-self cctx_0)"
"(compile-context-namespace cctx_0)))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(let-values(((link-linklet_0)"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet s_0 #f)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'top"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((linklet_0 new-keys_0)"
"(1/compile-linklet"
" s_0"
" #f"
"(vector"
" deserialize-instance"
" empty-eager-instance-instance)"
"(lambda(inst_0)"
"(values inst_0 #f)))))"
" linklet_0))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(list"
" 'linklet"
"(list"
" deserialize-imports"
" eager-instance-imports)"
"(list"
" mpi-vector-id"
" deserialized-syntax-vector-id"
" 'phase-to-link-modules"
" syntax-literals-id)"
"(list"
" 'define-values"
"(list mpi-vector-id)"
"(let-values(((mpis28_0) mpis_0))"
"(generate-module-path-index-deserialize.1"
" #f"
" mpis28_0)))"
"(list"
" 'define-values"
"(list deserialized-syntax-vector-id)"
"(list* 'make-vector(add1 phase_0) '(#f)))"
"(list"
" 'define-values"
" '(phase-to-link-modules)"
" phase-to-link-module-uses-expr_0)"
"(list"
" 'define-values"
"(list syntax-literals-id)"
" syntax-literals-expr_0)))))"
"(hash-set body-linklets_0 'link link-linklet_0))))"
"(let-values() body-linklets_0))))))"
"(compiled-in-memory1.1"
"(1/hash->linklet-directory(hasheq #f bundle_0))"
" #f"
" #f"
" #f"
" #f"
" #f"
" phase-to-link-module-uses_0"
"(current-code-inspector)"
" phase-to-link-extra-inspectorss_0"
" '#hasheqv()"
"(mpis-as-vector mpis_0)"
"(syntax-literals-as-vector syntax-literals_0)"
" null"
" null"
"(extract-namespace-scopes(compile-context-namespace cctx_0))"
" purely-functional?_0))))))))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))))))))"
"(define-values"
"(compile-top-level-require)"
"(lambda(p_0 cctx_0)"
"(begin"
"(let-values(((phase_0)(compile-context-phase cctx_0)))"
"(if(parsed-require? p_0)"
"(let-values()"
"(let-values(((form-stx_0)(compile-quote-syntax(parsed-s p_0) cctx_0)))"
"(list top-level-require!-id form-stx_0 ns-id(list 'quote(parsed-require-portal-syms p_0)))))"
"(let-values() #f))))))"
"(define-values"
"(flatten-begin)"
"(lambda(p_0)"
"(begin"
"(if(parsed-begin? p_0)"
"(let-values()(apply append(map2 flatten-begin(parsed-begin-body p_0))))"
"(let-values()(list p_0))))))"
"(define-values(core-scope)(new-multi-scope))"
"(define-values(core-stx)(add-scope empty-syntax core-scope))"
"(define-values(core-module-name)(1/make-resolved-module-path '#%core))"
"(define-values(core-mpi)(module-path-index-join* ''#%core #f))"
"(define-values(cell.1$4)(unsafe-make-place-local(make-hasheq)))"
"(define-values(cell.2$1)(unsafe-make-place-local(make-hasheq)))"
"(define-values"
"(core-place-init!)"
"(lambda()"
"(begin(begin(unsafe-place-local-set! cell.1$4(make-hasheq))(unsafe-place-local-set! cell.2$1(make-hasheq))))))"
"(define-values"
"(core-id)"
"(lambda(sym_0 phase_0)"
"(begin"
"(if(eqv? phase_0 0)"
"(let-values()"
"(let-values(((or-part_0)(hash-ref(unsafe-place-local-ref cell.1$4) sym_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((s_0)(datum->syntax$1 core-stx sym_0)))"
"(begin(hash-set!(unsafe-place-local-ref cell.1$4) sym_0 s_0) s_0)))))"
"(if(eq? phase_0 1)"
"(let-values()"
"(let-values(((or-part_0)(hash-ref(unsafe-place-local-ref cell.2$1) sym_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((s_0)(datum->syntax$1(syntax-shift-phase-level$1 core-stx 1) sym_0)))"
"(begin(hash-set!(unsafe-place-local-ref cell.2$1) sym_0 s_0) s_0)))))"
"(let-values()(datum->syntax$1(syntax-shift-phase-level$1 core-stx phase_0) sym_0)))))))"
"(define-values(core-forms) '#hasheq())"
"(define-values(core-primitives) '#hasheq())"
"(define-values"
"(struct:protected-core protected-core1.1 protected-core? protected-core-val)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'protected-core"
" #f"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'protected-core)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'val))))"
"(define-values"
"(add-core-form!*)"
"(lambda(sym_0 proc_0)"
"(begin(begin(add-core-binding! sym_0)(set! core-forms(hash-set core-forms sym_0 proc_0))))))"
"(define-values"
"(add-core-primitive!.1)"
"(lambda(protected?2_0 sym4_0 val5_0)"
"(begin"
" 'add-core-primitive!"
"(let-values(((sym_0) sym4_0))"
"(let-values(((val_0) val5_0))"
"(let-values(((protected?_0) protected?2_0))"
"(let-values()"
"(begin"
"(add-core-binding! sym_0)"
"(set! core-primitives"
"(hash-set core-primitives sym_0(if protected?_0(protected-core1.1 val_0) val_0)))))))))))"
"(define-values"
"(add-core-binding!)"
"(lambda(sym_0)"
"(begin"
"(let-values(((temp8_0)(datum->syntax$1 core-stx sym_0))"
"((temp9_0)"
"(let-values(((core-mpi11_0) core-mpi)((temp12_0) 0)((sym13_0) sym_0))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" core-mpi11_0"
" temp12_0"
" sym13_0)))"
"((temp10_0) 0))"
"(add-binding!.1 #f #f temp8_0 temp9_0 temp10_0)))))"
"(define-values"
"(declare-core-module!)"
"(lambda(ns_0)"
"(begin"
"(let-values(((ns14_0) ns_0)"
"((temp15_0)"
"(let-values(((temp17_0) #t)"
"((temp18_0) #t)"
"((core-mpi19_0) core-mpi)"
"((temp20_0)"
"(hasheqv"
" 0"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((lst_0)(list core-primitives core-forms))((lst_1) '(#f #t)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((syms_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((syntax?_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((table_2)"
"(let-values(((ht_0) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0"
" val_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_3)"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_1)"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((core-mpi23_0)"
" core-mpi)"
"((temp24_0)"
" 0)"
"((sym25_0)"
" sym_0))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" core-mpi23_0"
" temp24_0"
" sym25_0))))"
"(values"
" sym_0"
"(if syntax?_0"
"(let-values()"
"(provided1.1"
" b_0"
" #f"
" #t))"
"(if(protected-core?"
" val_0)"
"(let-values()"
"(provided1.1"
" b_0"
" #t"
" #f))"
"(let-values()"
" b_0))))))))"
"(hash-set"
" table_2"
" key_0"
" val_1)))))"
"(values"
" table_3))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_3"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_3)))"
" table_2)))))"
" for-loop_1)"
" table_1"
"(hash-iterate-first ht_0))))))"
"(if(not #f)"
"(for-loop_0 table_2 rest_0 rest_1)"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0"
" lst_1))))))"
"((temp21_0)"
"(lambda(phase-level_0 ns_1 insp_0)"
"(if(zero? phase-level_0)"
"(let-values(((ns_2)"
"(let-values(((ns26_0) ns_1)"
"((core-module-name27_0) core-module-name)"
"((temp28_0) 0))"
"(namespace->module-namespace.1"
" #f"
" #f"
" void"
" ns26_0"
" core-module-name27_0"
" temp28_0))))"
"(if ns_2"
"(module-linklet-info2.1(namespace->instance ns_2 0) #f core-mpi insp_0 #f #f)"
" #f))"
" #f)))"
"((temp22_0)"
"(lambda(data-box_0 ns_1 phase_0 phase-level_0 self_0 bulk-binding-registry_0 insp_0)"
"(let-values(((tmp_0) phase-level_0))"
"(if(equal? tmp_0 0)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_0) core-primitives))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 val_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-set-consistent!"
" ns_1"
" 0"
" sym_0"
"(if(protected-core?"
" val_0)"
"(protected-core-val"
" val_0)"
" val_0)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)"
"(let-values()"
"(let-values(((ht_0) core-forms))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 proc_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-set-transformer!"
" ns_1"
" 0"
" sym_0"
"(if(procedure-arity-includes?"
" proc_0"
" 2)"
"(core-form7.1"
" proc_0"
" sym_0)"
" proc_0)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)))"
"(let-values()(void)))))))"
"(make-module.1"
" temp17_0"
" #f"
" void"
" unsafe-undefined"
" unsafe-undefined"
" temp22_0"
" #f"
" 0"
" 0"
" #f"
" temp21_0"
" temp18_0"
" void"
" #f"
" temp20_0"
" 'racket"
" unsafe-undefined"
" null"
" core-mpi19_0"
" #f"
" null"
" #f)))"
"((core-module-name16_0) core-module-name))"
"(declare-module!.1 #t ns14_0 temp15_0 core-module-name16_0)))))"
"(define-values"
"(core-form-sym)"
"(lambda(s_0 phase_0)"
"(begin"
"(let-values(((ok?_0 id29_0 _30_0)"
"(let-values(((s_1) s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2)))"
"(let-values(((or-part_0)(if(syntax?$1 s_3)(symbol?(syntax-e$1 s_3)) #f)))"
"(if or-part_0 or-part_0(symbol? s_3))))"
"(let-values(((s_3)(cdr s_2))) #t)"
" #f)"
" #f))"
"(let-values()"
"(let-values(((id29_0 _30_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((id31_0)(let-values(((s_3)(car s_2))) s_3))"
"((_32_0)(let-values(((s_3)(cdr s_2))) s_3)))"
"(values id31_0 _32_0)))))"
"(values #t id29_0 _30_0)))"
"(values #f #f #f)))))"
"(if ok?_0"
"(let-values(((b_0)"
"(let-values(((temp33_0) id29_0)((phase34_0) phase_0))"
"(resolve+shift.1 #f #f null unsafe-undefined #f temp33_0 phase34_0))))"
"(if(module-binding? b_0)"
"(if(eq? core-module-name(1/module-path-index-resolve(module-binding-module b_0)))"
"(module-binding-sym b_0)"
" #f)"
" #f))"
" #f)))))"
"(define-values"
"(select-defined-syms-and-bind!.1)"
"(lambda(as-transformer?5_0"
" frame-id1_0"
" in4_0"
" requires+provides3_0"
" top-level-bind-scope2_0"
" ids11_0"
" defined-syms12_0"
" self13_0"
" phase14_0"
" all-scopes-stx15_0)"
"(begin"
" 'select-defined-syms-and-bind!"
"(let-values(((ids_0) ids11_0))"
"(let-values(((defined-syms_0) defined-syms12_0))"
"(let-values(((self_0) self13_0))"
"(let-values(((phase_0) phase14_0))"
"(let-values(((all-scopes-stx_0) all-scopes-stx15_0))"
"(let-values(((frame-id_0) frame-id1_0))"
"(let-values(((top-level-bind-scope_0) top-level-bind-scope2_0))"
"(let-values(((requires+provides_0) requires+provides3_0))"
"(let-values(((orig-s_0) in4_0))"
"(let-values(((as-transformer?_0) as-transformer?5_0))"
"(let-values()"
"(let-values(((defined-syms-at-phase_0)"
"(let-values(((or-part_0)(hash-ref defined-syms_0 phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))"
"(begin(hash-set! defined-syms_0 phase_0 ht_0) ht_0))))))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((sym_0)"
"(syntax-e$1"
" id_0)))"
"(let-values(((defined-sym_0)"
"(if(if(not"
"(defined-as-other?"
"(hash-ref"
" defined-syms-at-phase_0"
" sym_0"
" #f)"
" id_0"
" phase_0"
" top-level-bind-scope_0))"
"(if(no-extra-scopes?"
" id_0"
" all-scopes-stx_0"
" top-level-bind-scope_0"
" phase_0)"
"(symbol-interned?"
" sym_0)"
" #f)"
" #f)"
"(let-values()"
" sym_0)"
"(let-values()"
"(begin"
"(check-non-simple-due-to-interned-scope"
" id_0"
" requires+provides_0)"
"((letrec-values(((loop_0)"
"(lambda(pos_0)"
"(begin"
" 'loop"
"(let-values(((s_0)"
"(string->unreadable-symbol"
"(string-append"
"(symbol->string"
" sym_0)"
"                                                                                                                                                              \".\""
"(number->string"
" pos_0)))))"
"(if(defined-as-other?"
"(hash-ref"
" defined-syms-at-phase_0"
" s_0"
" #f)"
" id_0"
" phase_0"
" top-level-bind-scope_0)"
"(loop_0"
"(add1"
" pos_0))"
" s_0))))))"
" loop_0)"
" 1))))))"
"(let-values((()"
"(begin"
"(hash-set!"
" defined-syms-at-phase_0"
" defined-sym_0"
" id_0)"
"(values))))"
"(let-values(((b_0)"
"(let-values(((self21_0)"
" self_0)"
"((phase22_0)"
" phase_0)"
"((defined-sym23_0)"
" defined-sym_0)"
"((frame-id24_0)"
" frame-id_0)"
"((sym25_0)"
" sym_0))"
"(make-module-binding.1"
" #f"
" null"
" frame-id24_0"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" sym25_0"
" self21_0"
" phase22_0"
" defined-sym23_0))))"
"(begin"
"(if requires+provides_0"
"(let-values()"
"(remove-required-id!"
" requires+provides_0"
" id_0"
" phase_0))"
"(void))"
"(let-values(((id17_0)"
" id_0)"
"((b18_0)"
" b_0)"
"((phase19_0)"
" phase_0)"
"((orig-s20_0)"
" orig-s_0))"
"(add-binding!.1"
" orig-s20_0"
" #f"
" id17_0"
" b18_0"
" phase19_0))"
"(if requires+provides_0"
"(let-values()"
"(let-values(((requires+provides26_0)"
" requires+provides_0)"
"((id27_0)"
" id_0)"
"((phase28_0)"
" phase_0)"
"((b29_0)"
" b_0)"
"((as-transformer?30_0)"
" as-transformer?_0))"
"(add-defined-or-required-id!.1"
" as-transformer?30_0"
" #f"
" requires+provides26_0"
" id27_0"
" phase28_0"
" b29_0)))"
"(void))"
" defined-sym_0))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))))))))))))"
"(define-values"
"(no-extra-scopes?)"
"(lambda(id_0 all-scopes-stx_0 top-level-bind-scope_0 phase_0)"
"(begin"
"(let-values(((m-id_0)(datum->syntax$1 all-scopes-stx_0(syntax-e$1 id_0))))"
"(let-values(((or-part_0)(bound-identifier=?$1 id_0 m-id_0 phase_0)))"
"(if or-part_0"
" or-part_0"
"(if top-level-bind-scope_0"
"(bound-identifier=?$1 id_0(add-scope m-id_0 top-level-bind-scope_0) phase_0)"
" #f)))))))"
"(define-values"
"(defined-as-other?)"
"(lambda(prev-id_0 id_0 phase_0 top-level-bind-scope_0)"
"(begin"
"(if prev-id_0"
"(if(not(bound-identifier=?$1 prev-id_0 id_0 phase_0))"
"(let-values(((or-part_0)(not top-level-bind-scope_0)))"
"(if or-part_0"
" or-part_0"
"(not"
"(bound-identifier=?$1"
"(remove-scope prev-id_0 top-level-bind-scope_0)"
"(remove-scope id_0 top-level-bind-scope_0)"
" phase_0))))"
" #f)"
" #f))))"
"(define-values"
"(check-non-simple-due-to-interned-scope)"
"(lambda(id_0 r+p_0)"
"(begin"
"(if(if r+p_0(if(requires+provides-all-bindings-simple? r+p_0)(syntax-has-interned-scope? id_0) #f) #f)"
"(let-values()(set-requires+provides-all-bindings-simple?! r+p_0 #f))"
"(void)))))"
"(define-values"
"(select-defined-syms-and-bind!/ctx)"
"(lambda(tl-ids_0 ctx_0)"
"(begin"
"(let-values(((tl-ids31_0) tl-ids_0)"
"((temp32_0)(root-expand-context-defined-syms ctx_0))"
"((temp33_0)(root-expand-context-self-mpi ctx_0))"
"((temp34_0)(expand-context-phase ctx_0))"
"((temp35_0)(root-expand-context-all-scopes-stx ctx_0))"
"((temp36_0)(root-expand-context-frame-id ctx_0))"
"((temp37_0)(root-expand-context-top-level-bind-scope ctx_0)))"
"(select-defined-syms-and-bind!.1 #f temp36_0 #f #f temp37_0 tl-ids31_0 temp32_0 temp33_0 temp34_0 temp35_0)))))"
"(define-values"
"(add-defined-sym!)"
"(lambda(defined-syms_0 phase_0 sym_0 id_0)"
"(begin"
"(let-values(((defined-syms-at-phase_0)"
"(let-values(((or-part_0)(hash-ref defined-syms_0 phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))(begin(hash-set! defined-syms_0 phase_0 ht_0) ht_0))))))"
"(hash-set! defined-syms-at-phase_0 sym_0 id_0)))))"
"(define-values"
"(make-create-root-expand-context-from-module)"
"(lambda(requires_0 evaled-ld-h_0)"
"(begin"
"(lambda(ns_0 phase-shift_0 original-self_0 self_0)"
"(let-values(((root-ctx_0)"
"(let-values(((temp1_0)(namespace-mpi ns_0)))"
"(make-root-expand-context.1 #f null unsafe-undefined unsafe-undefined temp1_0))))"
"(let-values(((s_0)(add-scopes empty-syntax(root-expand-context-module-scopes root-ctx_0))))"
"(let-values((()"
"(begin"
"(let-values()"
"(let-values(((lst_0) requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase+reqs_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((phase_0)"
"(car"
" phase+reqs_0)))"
"(begin"
"(let-values()"
"(let-values(((lst_2)"
"(cdr"
" phase+reqs_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((req_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((mpi_0)"
"(module-path-index-shift"
" req_0"
" original-self_0"
" self_0)))"
"(let-values(((mpi2_0)"
" mpi_0)"
"((s3_0)"
" s_0)"
"((self4_0)"
" self_0)"
"((s5_0)"
" s_0)"
"((ns6_0)"
" ns_0)"
"((temp7_0)"
"(phase+"
" phase_0"
" phase-shift_0))"
"((phase-shift8_0)"
" phase-shift_0)"
"((temp9_0)"
" 'module))"
"(perform-require!.1"
" #f"
" #t"
" #f"
" #f"
" #f"
" #f"
" 'all"
" #t"
" temp7_0"
" #f"
" phase-shift8_0"
" #f"
" #f"
" unsafe-undefined"
" #t"
" temp9_0"
" mpi2_0"
" s3_0"
" self4_0"
" s5_0"
" ns6_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2))))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(values))))"
"(let-values()"
"(let-values(((defined-syms_0)(root-expand-context-defined-syms root-ctx_0)))"
"(begin"
"(let-values()"
"(let-values(((ht_0) evaled-ld-h_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 linklet_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(linklet-export-variables$1"
" linklet_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((id_0)"
"(datum->syntax$1"
" s_0"
" sym_0)))"
"(begin"
"(let-values(((id10_0)"
" id_0)"
"((temp11_0)"
"(let-values(((self13_0)"
" self_0)"
"((phase14_0)"
" phase_0)"
"((sym15_0)"
" sym_0))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" self13_0"
" phase14_0"
" sym15_0)))"
"((phase12_0)"
" phase_0))"
"(add-binding!.1"
" #f"
" #f"
" id10_0"
" temp11_0"
" phase12_0))"
"(add-defined-sym!"
" defined-syms_0"
" phase_0"
" sym_0"
" id_0))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_0))))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)"
" root-ctx_0))))))))))"
"(define-values"
"(shift-to-inside-root-context)"
"(lambda(root-context_0)"
"(begin"
"(let-values(((outside-mpi_0)(root-expand-context-self-mpi root-context_0)))"
"(let-values(((inside-mpi_0)(make-self-module-path-index(module-path-index-resolved outside-mpi_0))))"
"(let-values(((v_0) root-context_0))"
"(let-values(((the-struct_0) v_0))"
"(if(root-expand-context/outer? the-struct_0)"
"(let-values(((inner16_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(root-expand-context/inner? the-struct_1)"
"(let-values(((self-mpi17_0) inside-mpi_0)"
"((all-scopes-stx18_0)"
"(let-values(((temp19_0)"
"(root-expand-context-all-scopes-stx root-context_0))"
"((outside-mpi20_0) outside-mpi_0)"
"((inside-mpi21_0) inside-mpi_0))"
"(syntax-module-path-index-shift.1"
" #f"
" temp19_0"
" outside-mpi20_0"
" inside-mpi21_0"
" #f))))"
"(root-expand-context/inner2.1"
" self-mpi17_0"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
" all-scopes-stx18_0"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)))"
"                                  (raise-argument-error 'struct-copy \"root-expand-context/inner?\" the-struct_1)))))"
"(root-expand-context/outer1.1"
" inner16_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)))"
"                (raise-argument-error 'struct-copy \"root-expand-context/outer?\" the-struct_0)))))))))"
"(define-values(cell.1$3)(unsafe-make-place-local(make-weak-hasheq)))"
"(define-values(module-cache-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$3(make-weak-hasheq)))))"
"(define-values"
"(make-module-cache-key)"
"(lambda(hash-code_0)"
"(begin"
"(if hash-code_0"
"(string->symbol"
"(format"
"          \"~s\""
"(list"
" hash-code_0"
"(path->directory-path"
"(let-values(((or-part_0)(current-load-relative-directory)))"
"(if or-part_0 or-part_0(current-directory)))))))"
" #f))))"
"(define-values"
"(module-cache-set!)"
"(lambda(key_0 proc_0)(begin(hash-set!(unsafe-place-local-ref cell.1$3) key_0(make-ephemeron key_0 proc_0)))))"
"(define-values"
"(module-cache-ref)"
"(lambda(key_0)"
"(begin"
"(let-values(((e_0)(hash-ref(unsafe-place-local-ref cell.1$3) key_0 #f)))(if e_0(ephemeron-value e_0) #f)))))"
"(define-values"
"(1/module-cache-clear!)"
"(lambda()"
"(begin 'module-cache-clear!(let-values()(let-values()(hash-clear!(unsafe-place-local-ref cell.1$3)))))))"
"(define-values(current-module-declare-as-predefined)(make-parameter #f #f 'current-module-declare-as-predefined))"
"(define-values"
"(eval-module.1)"
"(lambda(namespace1_0 supermodule-name3_0 with-submodules?2_0 c7_0)"
"(begin"
" 'eval-module"
"(let-values(((c_0) c7_0))"
"(let-values(((ns_0)(if(eq? namespace1_0 unsafe-undefined)(1/current-namespace) namespace1_0)))"
"(let-values(((with-submodules?_0) with-submodules?2_0))"
"(let-values(((supermodule-name_0) supermodule-name3_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'eval 'module))(void))"
"(begin0"
"(let-values()"
"(let-values(((dh_0 h_0 data-instance_0 declaration-instance_0)"
"(compiled-module->dh+h+data-instance+declaration-instance c_0)))"
"(let-values(((syntax-literals-data-instance_0)"
"(if(compiled-in-memory? c_0)"
"(make-syntax-literal-data-instance-from-compiled-in-memory c_0)"
"(let-values(((l_0)(hash-ref h_0 'stx-data #f)))"
"(if l_0"
"(let-values()"
"(instantiate-linklet$1"
"(eval-linklet* l_0)"
"(list deserialize-instance data-instance_0)))"
"(if(eq?(hash-ref h_0 'module->namespace #f) 'empty)"
"(let-values() empty-syntax-literals-instance/empty-namespace)"
"(let-values() empty-syntax-literals-data-instance)))))))"
"(let-values(((decl_0)"
"(lambda(key_0)"
"(begin 'decl(1/instance-variable-value declaration-instance_0 key_0)))))"
"(let-values(((pre-submodule-names_0)(hash-ref h_0 'pre null)))"
"(let-values(((post-submodule-names_0)(hash-ref h_0 'post null)))"
"(let-values(((default-name_0)(hash-ref h_0 'name 'module)))"
"(let-values(((cache-key_0)"
"(make-module-cache-key"
"(if(null? pre-submodule-names_0)"
"(if(null? post-submodule-names_0)(hash-ref h_0 'hash-code #f) #f)"
" #f))))"
"(let-values(((cross-phase-persistent?_0)"
"(hash-ref h_0 'cross-phase-persistent? #f)))"
"(let-values(((min-phase_0)(hash-ref h_0 'min-phase 0)))"
"(let-values(((max-phase_0)(hash-ref h_0 'max-phase 0)))"
"(let-values(((language-info_0)(hash-ref h_0 'language-info #f)))"
"(let-values(((realm_0)(hash-ref h_0 'realm 'racket)))"
"(let-values(((phases-h_0)"
"(let-values(((table_0)"
"(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((start_0) min-phase_0)"
"((end_0)(add1 max-phase_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values(((phase-level_0)"
" pos_0))"
"(let-values(((table_2)"
"(let-values(((id*_0)"
"(hash-ref"
" h_0"
" phase-level_0"
" #f)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2)"
"(begin"
" 'for-loop"
"(let-values(((v_0)"
" id*_0))"
"(let-values(((table_3)"
"(if v_0"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase-level_0"
"(eval-linklet*"
" v_0)))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values"
" table_3))"
" table_2)))"
" table_3))))))"
" for-loop_1)"
" table_1))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(+ pos_0 inc_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" start_0))))))"
"(let-values(((syntax-literals-linklet_0)"
"(let-values(((l_0)(hash-ref h_0 'stx #f)))"
"(if l_0(eval-linklet* l_0) #f))))"
"(let-values(((extra-inspector_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-compile-time-inspector c_0)"
" #f)))"
"(let-values(((phase-to-link-extra-inspectorsss_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss"
" c_0)"
" '#hasheqv())))"
"(let-values(((requires_0)(decl_0 'requires)))"
"(let-values(((recur-requires_0)(decl_0 'recur-requires)))"
"(let-values(((flattened-requires_0)"
"(decl_0 'flattened-requires)))"
"(let-values(((provides_0)(decl_0 'provides)))"
"(let-values(((original-self_0)(decl_0 'self-mpi)))"
"(let-values(((phase-to-link-modules_0)"
"(decl_0 'phase-to-link-modules)))"
"(let-values(((module-use-resolution-cache_0)"
"(make-hasheq)))"
"(let-values(((portal-stxes_0)"
"(decl_0 'portal-stxes)))"
"(let-values(((create-root-expand-context-from-module_0)"
"(make-create-root-expand-context-from-module"
" requires_0"
" phases-h_0)))"
"(let-values(((declare-submodules_0)"
"(if dh_0"
"(lambda(ns_1"
" names_0"
" declare-name_0"
" pre?_0)"
"(begin"
" 'declare-submodules"
"(if(compiled-in-memory?"
" c_0)"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(if pre?_0"
"(compiled-in-memory-pre-compiled-in-memorys"
" c_0)"
"(compiled-in-memory-post-compiled-in-memorys"
" c_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((c_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((c10_0)"
" c_1)"
"((ns11_0)"
" ns_1)"
"((declare-name12_0)"
" declare-name_0))"
"(eval-module.1"
" ns11_0"
" declare-name12_0"
" #t"
" c10_0)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" names_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((name_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((sm-cd_0)"
"(hash-ref"
" dh_0"
" name_0"
" #f)))"
"(begin"
"(if sm-cd_0"
"(void)"
"(let-values()"
"(error"
"                                                                                                                                                                           \"missing submodule declaration:\""
" name_0)))"
"(let-values(((sm-cd13_0)"
" sm-cd_0)"
"((ns14_0)"
" ns_1)"
"((declare-name15_0)"
" declare-name_0))"
"(eval-module.1"
" ns14_0"
" declare-name15_0"
" #t"
" sm-cd13_0)))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))"
" void)))"
"(let-values(((declare-this-module_0)"
"(lambda(ns_1)"
"(begin"
" 'declare-this-module"
"(let-values(((m_0)"
"(let-values(((temp20_0)"
"(1/current-module-declare-source))"
"((original-self21_0)"
" original-self_0)"
"((requires22_0)"
" requires_0)"
"((recur-requires23_0)"
" recur-requires_0)"
"((flattened-requires24_0)"
" flattened-requires_0)"
"((provides25_0)"
" provides_0)"
"((language-info26_0)"
" language-info_0)"
"((realm27_0)"
" realm_0)"
"((min-phase28_0)"
" min-phase_0)"
"((max-phase29_0)"
" max-phase_0)"
"((cross-phase-persistent?30_0)"
" cross-phase-persistent?_0)"
"((temp31_0)"
"(current-module-declare-as-predefined))"
"((temp32_0)"
"(append"
" pre-submodule-names_0"
" post-submodule-names_0))"
"((supermodule-name33_0)"
" supermodule-name_0)"
"((temp34_0)"
"(lambda()"
"(get-all-variables"
" phases-h_0)))"
"((temp35_0)"
"(lambda(phase-level_0"
" ns_2"
" insp_0)"
"(module-linklet-info2.1"
"(hash-ref"
" phases-h_0"
" phase-level_0"
" #f)"
"(hash-ref"
" phase-to-link-modules_0"
" phase-level_0"
" #f)"
" original-self_0"
" insp_0"
" extra-inspector_0"
"(hash-ref"
" phase-to-link-extra-inspectorsss_0"
" phase-level_0"
" #f))))"
"((temp36_0)"
"(lambda(bulk-binding-registry_0)"
"(force-syntax-deserialize"
" syntax-literals-data-instance_0"
" bulk-binding-registry_0)))"
"((temp37_0)"
"(lambda(data-box_0"
" ns_2"
" phase-shift_0"
" self_0"
" bulk-binding-registry_0"
" insp_0)"
"(if(unbox"
" data-box_0)"
"(void)"
"(let-values()"
"(init-instance-data!"
" data-box_0"
" cache-key_0"
" ns_2"
" syntax-literals-linklet_0"
" data-instance_0"
" syntax-literals-data-instance_0"
" phase-shift_0"
" original-self_0"
" self_0"
" bulk-binding-registry_0"
" insp_0"
" create-root-expand-context-from-module_0)))))"
"((temp38_0)"
"(lambda(data-box_0"
" phase_0"
" sym_0)"
"(let-values(((ht_0)"
"(hash-ref"
" portal-stxes_0"
" phase_0"
" '#hasheq())))"
"(let-values(((pos_0)"
"(hash-ref"
" ht_0"
" sym_0"
" #f)))"
"(if pos_0"
"(let-values()"
"(let-values(((syntax-literals-instance_0)"
"(instance-data-syntax-literals-instance"
"(unbox"
" data-box_0))))"
"((1/instance-variable-value"
" syntax-literals-instance_0"
" get-syntax-literal!-id)"
" pos_0)))"
"(let-values()"
" #f))))))"
"((temp39_0)"
"(lambda(data-box_0"
" ns_2"
" phase-shift_0"
" phase-level_0"
" self_0"
" bulk-binding-registry_0"
" insp_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'eval"
" 'instantiate))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((syntax-literals-instance_0)"
"(instance-data-syntax-literals-instance"
"(unbox"
" data-box_0))))"
"(let-values(((phase-portal-stxes_0)"
"(hash-ref"
" portal-stxes_0"
"(sub1"
" phase-level_0)"
" '#hasheq())))"
"(let-values((()"
"(begin"
"(if(zero?"
"(hash-count"
" phase-portal-stxes_0))"
"(void)"
"(let-values()"
"(let-values(((get-syntax-literal!_0)"
"(1/instance-variable-value"
" syntax-literals-instance_0"
" get-syntax-literal!-id)))"
"(begin"
"(let-values()"
"(let-values(((ht_0)"
" phase-portal-stxes_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0"
" pos_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(symbol?"
" key_0)"
"(let-values()"
"(namespace-set-transformer!"
" ns_2"
"(sub1"
" phase-level_0)"
" key_0"
"(portal-syntax1.1"
" get-syntax-literal!_0"
" pos_0)))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
"(hash-iterate-next"
" ht_0"
" i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first"
" ht_0)))))"
"(void)))))"
"(values))))"
"(let-values(((phase-linklet_0)"
"(hash-ref"
" phases-h_0"
" phase-level_0"
" #f)))"
"(if phase-linklet_0"
"(let-values()"
"(let-values(((module-uses_0)"
"(hash-ref"
" phase-to-link-modules_0"
" phase-level_0)))"
"(let-values(((import-module-instances_0"
" import-instances_0)"
"(let-values(((mis_0"
" is_0)"
"(let-values(((mis_0)"
"(let-values(((mis_0)"
" null))"
" mis_0))"
"((is_0)"
"(let-values(((is_0)"
" null))"
" is_0)))"
"(let-values(((lst_0)"
" module-uses_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(mis_1"
" is_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((mu_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((mis_2"
" is_2)"
"(let-values(((mis_2"
" is_2)"
"(let-values()"
"(let-values(((mis47_0"
" is48_0)"
"(let-values()"
"(let-values(((ns49_0)"
" ns_2)"
"((mu50_0)"
" mu_0)"
"((original-self51_0)"
" original-self_0)"
"((self52_0)"
" self_0)"
"((temp53_0)"
"(phase+"
"(phase-"
" phase-level_0"
"(module-use-phase"
" mu_0))"
" phase-shift_0))"
"((module-use-resolution-cache54_0)"
" module-use-resolution-cache_0))"
"(namespace-module-use->module+linklet-instances.1"
" temp53_0"
" module-use-resolution-cache54_0"
" original-self51_0"
" self52_0"
" ns49_0"
" mu50_0)))))"
"(values"
"(cons"
" mis47_0"
" mis_1)"
"(cons"
" is48_0"
" is_1))))))"
"(values"
" mis_2"
" is_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" mis_2"
" is_2"
" rest_0)"
"(values"
" mis_2"
" is_2))))"
"(values"
" mis_1"
" is_1)))))))"
" for-loop_0)"
" mis_0"
" is_0"
" lst_0))))))"
"(values"
"(reverse$1"
" mis_0)"
"(reverse$1"
" is_0)))))"
"(let-values((()"
"(begin"
"(let-values(((phase-linklet40_0)"
" phase-linklet_0)"
"((temp41_0)"
" 2)"
"((module-uses42_0)"
" module-uses_0)"
"((import-module-instances43_0)"
" import-module-instances_0)"
"((insp44_0)"
" insp_0)"
"((extra-inspector45_0)"
" extra-inspector_0)"
"((temp46_0)"
"(hash-ref"
" phase-to-link-extra-inspectorsss_0"
" phase-level_0"
" #f)))"
"(check-require-access.1"
" temp41_0"
" phase-linklet40_0"
" module-uses42_0"
" import-module-instances43_0"
" insp44_0"
" extra-inspector45_0"
" temp46_0))"
"(values))))"
"(let-values(((module-body-instance-instance_0)"
"(let-values(((temp55_0)"
"(if(zero-phase?"
" phase-level_0)"
"(let-values()"
"(lambda(name_0"
" val_0)"
"(begin"
" 'temp55"
"(error"
" 'define-syntax"
"                                                                                                                                                                                       \"should not happen at phase level 0\"))))"
"(let-values()"
"(lambda(name_0"
" val_0)"
"(begin"
" 'temp55"
"(namespace-set-transformer!"
" ns_2"
"(sub1"
" phase-level_0)"
" name_0"
" val_0)))))))"
"(make-module-body-instance-instance.1"
" temp55_0))))"
"(let-values(((instantiate-body_0)"
"(lambda()"
"(begin"
" 'instantiate-body"
"(instantiate-linklet$1"
" phase-linklet_0"
"(list*"
" syntax-literals-instance_0"
" module-body-instance-instance_0"
" import-instances_0)"
"(namespace->instance"
" ns_2"
" phase-level_0))))))"
"(if(zero-phase?"
" phase-level_0)"
"(let-values()"
"(if(zero-phase?"
" phase-shift_0)"
"(let-values()"
"(instantiate-body_0))"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" ns_2)"
"(let-values()"
"(instantiate-body_0))))))"
"(let-values()"
"(let-values(((ns-1_0)"
"(namespace->namespace-at-phase"
" ns_2"
"(phase+"
" phase-shift_0"
"(sub1"
" phase-level_0)))))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" ns_2)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
"(promise1.1"
"(lambda()"
"(let-values(((ns-156_0)"
" ns-1_0)"
"((temp57_0)"
" #t))"
"(make-expand-context.1"
" #f"
" #f"
" temp57_0"
" #f"
" #f"
" ns-156_0)))"
" #f)"
"(with-continuation-mark"
" current-module-code-inspector"
" insp_0"
"(let-values()"
"(instantiate-body_0)))))))))))))))"
"(void)))))))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void)))))))"
"(make-module.1"
" cross-phase-persistent?30_0"
" flattened-requires24_0"
" temp36_0"
" temp34_0"
" temp38_0"
" temp39_0"
" language-info26_0"
" max-phase29_0"
" min-phase28_0"
" #f"
" temp35_0"
" temp31_0"
" temp37_0"
" #f"
" provides25_0"
" realm27_0"
" recur-requires23_0"
" requires22_0"
" original-self21_0"
" temp20_0"
" temp32_0"
" supermodule-name33_0))))"
"(let-values(((declare-name_0)"
"(substitute-module-declare-name"
" default-name_0)))"
"(begin"
"(if with-submodules?_0"
"(let-values()"
"(declare-submodules_0"
" ns_1"
" pre-submodule-names_0"
" declare-name_0"
" #t))"
"(void))"
"(let-values(((ns16_0)"
" ns_1)"
"((m17_0)"
" m_0)"
"((declare-name18_0)"
" declare-name_0)"
"((with-submodules?19_0)"
" with-submodules?_0))"
"(declare-module!.1"
" with-submodules?19_0"
" ns16_0"
" m17_0"
" declare-name18_0))"
"(if with-submodules?_0"
"(let-values()"
"(declare-submodules_0"
" ns_1"
" post-submodule-names_0"
" declare-name_0"
" #f))"
"(void)))))))))"
"(begin"
"(if cache-key_0"
"(let-values()"
"(module-cache-set!"
" cache-key_0"
" declare-this-module_0))"
"(void))"
"(declare-this-module_0"
" ns_0))))))))))))))))))))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))"
"(define-values"
"(struct:instance-data instance-data9.1 instance-data? instance-data-syntax-literals-instance instance-data-cache-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'instance-data #f 2 0 #f null(current-inspector) #f '(0 1) #f 'instance-data)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'syntax-literals-instance)"
"(make-struct-field-accessor -ref_0 1 'cache-key))))"
"(define-values"
"(init-instance-data!)"
"(lambda(data-box_0"
" cache-key_0"
" ns_0"
" syntax-literals-linklet_0"
" data-instance_0"
" syntax-literals-data-instance_0"
" phase-shift_0"
" original-self_0"
" self_0"
" bulk-binding-registry_0"
" insp_0"
" create-root-expand-context-from-module_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(not(load-on-demand-enabled))"
"(let-values()"
"(force-syntax-deserialize syntax-literals-data-instance_0 bulk-binding-registry_0))"
"(void))"
"(values))))"
"(let-values(((inst_0)"
"(let-values(((ns59_0) ns_0)"
"((phase-shift60_0) phase-shift_0)"
"((self61_0) self_0)"
"((insp62_0) insp_0)"
"((bulk-binding-registry63_0) bulk-binding-registry_0)"
"((temp64_0)"
"                                    (lambda (name_0 val_0) (error \"shouldn't get here for the root-ctx linklet\"))))"
"(make-instance-instance.1"
" bulk-binding-registry63_0"
" insp62_0"
" ns59_0"
" phase-shift60_0"
" self61_0"
" temp64_0))))"
"(let-values(((syntax-literals-instance_0)"
"(if syntax-literals-linklet_0"
"(instantiate-linklet$1"
" syntax-literals-linklet_0"
"(list deserialize-instance data-instance_0 syntax-literals-data-instance_0 inst_0))"
" empty-syntax-literals-instance)))"
"(let-values((()"
"(begin"
"(set-box! data-box_0(instance-data9.1 syntax-literals-instance_0 cache-key_0))"
"(values))))"
"(let-values(((get-encoded-root-expand-ctx_0)"
"(1/instance-variable-value syntax-literals-instance_0 'get-encoded-root-expand-ctx)))"
"(if(eq? get-encoded-root-expand-ctx_0 'empty)"
"(let-values()"
"(namespace-set-root-expand-ctx!"
" ns_0"
"(promise1.1"
"(lambda()"
"(shift-to-inside-root-context"
"(let-values(((self65_0) self_0))"
"(make-root-expand-context.1 #f null unsafe-undefined unsafe-undefined self65_0))))"
" #f)))"
"(if(procedure? get-encoded-root-expand-ctx_0)"
"(let-values()"
"(namespace-set-root-expand-ctx!"
" ns_0"
"(promise1.1"
"(lambda()"
"(shift-to-inside-root-context"
"(root-expand-context-decode-for-module(get-encoded-root-expand-ctx_0) self_0)))"
" #f)))"
"(let-values()"
"(namespace-set-root-expand-ctx!"
" ns_0"
"(promise1.1"
"(lambda()"
"(shift-to-inside-root-context"
"(create-root-expand-context-from-module_0 ns_0 phase-shift_0 original-self_0 self_0)))"
" #f)))))))))))))"
"(define-values"
"(force-syntax-deserialize)"
"(lambda(syntax-literals-data-instance_0 bulk-binding-registry_0)"
"(begin"
"(if(let-values(((or-part_0)(eq? syntax-literals-data-instance_0 empty-syntax-literals-data-instance)))"
"(if or-part_0"
" or-part_0"
"(eq? syntax-literals-data-instance_0 empty-syntax-literals-instance/empty-namespace)))"
"(void)"
"(let-values()"
"(let-values(((deserialize-syntax_0)"
"(1/instance-variable-value syntax-literals-data-instance_0 deserialize-syntax-id)))"
"(if deserialize-syntax_0(let-values()(deserialize-syntax_0 bulk-binding-registry_0))(void))))))))"
"(define-values"
"(compiled-module->dh+h)"
"(lambda(c_0)"
"(begin"
"(let-values(((ld/h_0)(if(compiled-in-memory? c_0)(compiled-in-memory-linklet-directory c_0) c_0)))"
"(let-values(((dh_0)"
"(if(linklet-directory?$1 ld/h_0)"
"(let-values()(linklet-directory->hash$1 ld/h_0))"
"(let-values() #f))))"
"(let-values(((h_0)(1/linklet-bundle->hash(if dh_0(hash-ref dh_0 #f) ld/h_0))))(values dh_0 h_0)))))))"
"(define-values(compiled-module->h)(lambda(c_0)(begin(let-values(((dh_0 h_0)(compiled-module->dh+h c_0))) h_0))))"
"(define-values"
"(compiled-module->dh+h+data-instance+declaration-instance)"
"(lambda(c_0)"
"(begin"
"(let-values(((dh_0 h_0)(compiled-module->dh+h c_0)))"
"(let-values(((data-instance_0)"
"(if(compiled-in-memory? c_0)"
"(make-data-instance-from-compiled-in-memory c_0)"
"(instantiate-linklet$1(eval-linklet*(hash-ref h_0 'data))(list deserialize-instance)))))"
"(let-values(((declaration-instance_0)"
"(if(if(compiled-in-memory? c_0)(compiled-in-memory-original-self c_0) #f)"
"(make-declaration-instance-from-compiled-in-memory c_0)"
"(instantiate-linklet$1"
"(eval-linklet*(hash-ref h_0 'decl))"
"(list deserialize-instance data-instance_0)))))"
"(values dh_0 h_0 data-instance_0 declaration-instance_0)))))))"
"(define-values"
"(compiled-module->declaration-instance)"
"(lambda(c_0)"
"(begin"
"(let-values(((dh_0 h_0 data-instance_0 declaration-instance_0)"
"(compiled-module->dh+h+data-instance+declaration-instance c_0)))"
" declaration-instance_0))))"
"(define-values"
"(compiled-module->h+declaration-instance)"
"(lambda(c_0)"
"(begin"
"(let-values(((dh_0 h_0 data-instance_0 declaration-instance_0)"
"(compiled-module->dh+h+data-instance+declaration-instance c_0)))"
"(values h_0 declaration-instance_0)))))"
"(define-values"
"(make-data-instance-from-compiled-in-memory)"
"(lambda(cim_0)(begin(1/make-instance 'data #f 'constant mpi-vector-id(compiled-in-memory-mpis cim_0)))))"
"(define-values"
"(make-declaration-instance-from-compiled-in-memory)"
"(lambda(cim_0)"
"(begin"
"(1/make-instance"
" 'decl"
" #f"
" 'constant"
" 'self-mpi"
"(compiled-in-memory-original-self cim_0)"
" 'requires"
"(compiled-in-memory-requires cim_0)"
" 'recur-requires"
"(compiled-in-memory-recur-requires cim_0)"
" 'flattened-requires"
"(compiled-in-memory-flattened-requires cim_0)"
" 'provides"
"(compiled-in-memory-provides cim_0)"
" 'phase-to-link-modules"
"(compiled-in-memory-phase-to-link-module-uses cim_0)"
" 'portal-stxes"
"(compiled-in-memory-portal-stxes cim_0)))))"
"(define-values"
"(make-syntax-literal-data-instance-from-compiled-in-memory)"
"(lambda(cim_0)"
"(begin"
"(1/make-instance"
" 'syntax-literal-data"
" #f"
" #f"
" deserialize-syntax-id"
" void"
" deserialized-syntax-vector-id"
"(compiled-in-memory-syntax-literals cim_0)))))"
"(define-values"
"(empty-syntax-literals-instance/empty-namespace)"
"(1/make-instance"
" 'empty-stx/empty-ns"
" #f"
" 'constant"
" get-syntax-literal!-id"
"(lambda(pos_0) #f)"
" 'get-encoded-root-expand-ctx"
" 'empty))"
"(define-values"
"(get-all-variables)"
"(lambda(phases-h_0)"
"(begin"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0) phases-h_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 linklet_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" phase_0"
"(linklet-export-variables$1"
" linklet_0)))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2(hash-iterate-next ht_0 i_0)) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0))))))))"
"(define-values(eval-linklet*)(lambda(l_0)(begin(eval-linklet$1(force-compile-linklet l_0)))))"
"(define-values"
"(check-provides-verbosity)"
"(lambda(who_0 verbosity_0)"
"(begin"
"(if(let-values(((or-part_0)(not verbosity_0)))(if or-part_0 or-part_0(eq? verbosity_0 'defined-names)))"
"(void)"
"        (let-values () (raise-argument-error who_0 \"(or/c #f 'defined-names)\" verbosity_0))))))"
"(define-values"
"(provides->api-provides)"
"(lambda(provides_0 self_0 verbosity_0)"
"(begin"
"(let-values(((defined-names?_0)(eq? verbosity_0 'defined-names)))"
"(let-values(((extract_0)"
"(lambda(ok?_0)"
"(begin"
" 'extract"
"(let-values(((result-l_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 at-phase_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((fold-var_2)"
"(let-values(((id*_0)"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((ht_1)"
" at-phase_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((sym_0"
" b/p_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((fold-var_4)"
"(if(ok?_0"
" b/p_0)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((b_0)"
"(provided-as-binding"
" b/p_0)))"
"(list*"
" sym_0"
"(if(eq?"
" self_0"
"(module-binding-module"
" b_0))"
"(let-values()"
" null)"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
" null))"
" fold-var_4)))"
"(let-values(((lst_0)"
"(cons"
" b_0"
"(module-binding-extra-nominal-bindings"
" b_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_2)"
"(lambda(fold-var_5"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((b_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_6)"
"(let-values(((fold-var_6)"
"(let-values()"
"(cons"
"(let-values()"
"(if(if(eqv?"
"(module-binding-nominal-phase+space"
" b_1)"
" phase_0)"
"(eq?"
"(module-binding-nominal-sym"
" b_1)"
" sym_0)"
" #f)"
"(let-values()"
"(module-binding-nominal-module"
" b_1))"
"(let-values()"
"(list"
"(module-binding-nominal-module"
" b_1)"
"(module-binding-phase"
" b_1)"
"(module-binding-nominal-sym"
" b_1)"
"(module-binding-nominal-phase+space"
" b_1)))))"
" fold-var_5))))"
"(values"
" fold-var_6))))"
"(if(not"
" #f)"
"(for-loop_2"
" fold-var_6"
" rest_0)"
" fold-var_6)))"
" fold-var_5))))))"
" for-loop_2)"
" fold-var_4"
" lst_0)))))))"
"(if defined-names?_0"
"(list"
"(module-binding-sym"
" b_0))"
" null))))"
" fold-var_3))))"
"(values"
" fold-var_4))"
" fold-var_3)))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
"(hash-iterate-next"
" ht_1"
" i_1))"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
"(hash-iterate-first"
" ht_1))))))))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2)"
"(begin"
" 'for-loop"
"(let-values(((l_0)"
" id*_0))"
"(let-values(((fold-var_3)"
"(if(null?"
" l_0)"
" fold-var_2"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" phase_0"
"(let-values(((l4_0)"
" l_0)"
"((symbol<?5_0)"
" symbol<?)"
"((car6_0)"
" car))"
"(sort.1"
" #f"
" car6_0"
" l4_0"
" symbol<?5_0))))"
" fold-var_2))))"
"(values"
" fold-var_3)))))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_1))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
"(hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_0))))))))"
"(let-values(((result-l1_0) result-l_0)((phase+space<?2_0) phase+space<?)((car3_0) car))"
"(sort.1 #f car3_0 result-l1_0 phase+space<?2_0)))))))"
"(values"
"(extract_0(lambda(b/p_0)(not(provided-as-transformer? b/p_0))))"
"(extract_0 provided-as-transformer?)))))))"
"(define-values"
"(variables->api-nonprovides)"
"(lambda(provides_0 all-vars_0)"
"(begin"
"(let-values(((result-l_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0) all-vars_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 vars_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_2)"
"(let-values(((id*_0)"
"(let-values(((syms_0)"
"(hash-ref"
" provides_0"
" phase_0"
" '#hasheq())))"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_0) vars_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((var-sym_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_4)"
"(if(hash-ref"
" syms_0"
" var-sym_0"
" #f)"
" fold-var_3"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
" var-sym_0)"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_0)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_0))))))))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2)"
"(begin"
" 'for-loop"
"(let-values(((l_0) id*_0))"
"(let-values(((fold-var_3)"
"(if(null?"
" l_0)"
" fold-var_2"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" phase_0"
"(let-values(((l10_0)"
" l_0)"
"((symbol<?11_0)"
" symbol<?))"
"(sort.1"
" #f"
" #f"
" l10_0"
" symbol<?11_0))))"
" fold-var_2))))"
"(values"
" fold-var_3)))))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_1))))"
"(if(not #f)"
"(for-loop_0 fold-var_2(hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_0))))))))"
"(let-values(((result-l7_0) result-l_0)((phase+space<?8_0) phase+space<?)((car9_0) car))"
"(sort.1 #f car9_0 result-l7_0 phase+space<?8_0))))))"
"(define-values"
"(1/compiled-expression?)"
"(lambda(c_0)"
"(begin"
" 'compiled-expression?"
"(let-values(((or-part_0)(compiled-in-memory? c_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(linklet-directory?$1 c_0)))(if or-part_1 or-part_1(1/linklet-bundle? c_0))))))))"
"(define-values"
"(1/compiled-module-expression?)"
"(lambda(c_0)"
"(begin"
" 'compiled-module-expression?"
"(let-values(((ld_0)(compiled->linklet-directory-or-bundle c_0)))"
"(let-values(((or-part_0)"
"(if(linklet-directory?$1 ld_0)"
"(if(let-values(((b_0)(hash-ref(linklet-directory->hash$1 ld_0) #f #f)))"
"(if b_0(hash-ref(1/linklet-bundle->hash b_0) 'decl #f) #f))"
" #t"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(1/linklet-bundle? ld_0)(if(hash-ref(1/linklet-bundle->hash ld_0) 'decl #f) #t #f) #f)))))))"
"(define-values"
"(compiled->linklet-directory-or-bundle)"
"(lambda(c_0)(begin(if(compiled-in-memory? c_0)(compiled-in-memory-linklet-directory c_0) c_0))))"
"(define-values"
"(normalize-to-linklet-directory)"
"(lambda(c_0)"
"(begin"
"(if(linklet-directory?$1(compiled->linklet-directory-or-bundle c_0))"
"(let-values() c_0)"
"(if(1/linklet-bundle? c_0)"
"(let-values()(1/hash->linklet-directory(hasheq #f c_0)))"
"(let-values()"
"(let-values(((the-struct_0) c_0))"
"(if(compiled-in-memory? the-struct_0)"
"(let-values(((linklet-directory1_0)"
"(normalize-to-linklet-directory(compiled-in-memory-linklet-directory c_0))))"
"(compiled-in-memory1.1"
" linklet-directory1_0"
"(compiled-in-memory-original-self the-struct_0)"
"(compiled-in-memory-requires the-struct_0)"
"(compiled-in-memory-recur-requires the-struct_0)"
"(compiled-in-memory-flattened-requires the-struct_0)"
"(compiled-in-memory-provides the-struct_0)"
"(compiled-in-memory-phase-to-link-module-uses the-struct_0)"
"(compiled-in-memory-compile-time-inspector the-struct_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss the-struct_0)"
"(compiled-in-memory-portal-stxes the-struct_0)"
"(compiled-in-memory-mpis the-struct_0)"
"(compiled-in-memory-syntax-literals the-struct_0)"
"(compiled-in-memory-pre-compiled-in-memorys the-struct_0)"
"(compiled-in-memory-post-compiled-in-memorys the-struct_0)"
"(compiled-in-memory-namespace-scopes the-struct_0)"
"(compiled-in-memory-purely-functional? the-struct_0)))"
"                (raise-argument-error 'struct-copy \"compiled-in-memory?\" the-struct_0)))))))))"
"(define-values"
"(1/module-compiled-name)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((c_0)"
"(begin"
" 'module-compiled-name"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"              (let-values () (raise-argument-error 'module-compiled-name \"compiled-module-expression?\" c_0)))"
"(module-compiled-current-name c_0))))"
"((c_0 name_0)"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"                            (raise-argument-error 'module-compiled-name \"compiled-module-expression?\" c_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(symbol? name_0)))"
"(if or-part_0"
" or-part_0"
"(if(pair? name_0)(if(list? name_0)(andmap2 symbol? name_0) #f) #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-compiled-name"
"                               \"(or/c symbol? (cons/c symbol? (non-empty-listof symbol?)))\""
" name_0)))"
"(values))))"
"(let-values(((i-name_0 prefix_0)"
"(if(symbol? name_0)"
"(values name_0 null)"
"(let-values(((r_0)(reverse$1 name_0)))(values(car r_0)(reverse$1(cdr r_0)))))))"
"(change-module-name c_0 i-name_0 prefix_0)))))))))"
"(define-values"
"(module-compiled-current-name)"
"(lambda(c_0)"
"(begin"
"(let-values(((ld_0)(compiled->linklet-directory-or-bundle c_0)))"
"(let-values(((b_0)(if(1/linklet-bundle? ld_0) ld_0(hash-ref(linklet-directory->hash$1 ld_0) #f))))"
"(hash-ref(1/linklet-bundle->hash b_0) 'name))))))"
"(define-values"
"(module-compiled-immediate-name)"
"(lambda(c_0)"
"(begin(let-values(((n_0)(module-compiled-current-name c_0)))(if(pair? n_0)(car(reverse$1 n_0)) n_0)))))"
"(define-values"
"(change-module-name)"
"(lambda(c_0 name_0 prefix_0)"
"(begin"
"(let-values(((full-name_0)(if(null? prefix_0) name_0(append prefix_0(list name_0)))))"
"(let-values(((next-prefix_0)(if(null? prefix_0)(list name_0) full-name_0)))"
"(let-values(((recur_0)"
"(lambda(sub-c_0 name_1)"
"(begin"
" 'recur"
"(if(equal?(module-compiled-current-name sub-c_0)(append next-prefix_0(list name_1)))"
" sub-c_0"
"(change-module-name sub-c_0 name_1 next-prefix_0))))))"
"(if(compiled-in-memory? c_0)"
"(let-values()"
"(let-values(((change-submodule-name_0)"
"(lambda(sub-c_0)"
"(begin"
" 'change-submodule-name"
"(recur_0 sub-c_0(module-compiled-immediate-name sub-c_0))))))"
"(let-values(((pre-compiled-in-memorys_0)"
"(map2 change-submodule-name_0(compiled-in-memory-pre-compiled-in-memorys c_0))))"
"(let-values(((post-compiled-in-memorys_0)"
"(map2 change-submodule-name_0(compiled-in-memory-post-compiled-in-memorys c_0))))"
"(let-values(((the-struct_0) c_0))"
"(if(compiled-in-memory? the-struct_0)"
"(let-values(((pre-compiled-in-memorys7_0) pre-compiled-in-memorys_0)"
"((post-compiled-in-memorys8_0) post-compiled-in-memorys_0)"
"((linklet-directory9_0)"
"(let-values(((temp10_0)"
"(update-one-name"
"(let-values(((ld_0)"
"(compiled->linklet-directory-or-bundle c_0)))"
"(if(1/linklet-bundle? ld_0)"
" ld_0"
"(hash-ref(linklet-directory->hash$1 ld_0) #f)))"
" full-name_0))"
"((temp11_0)(symbol? full-name_0))"
"((temp12_0)"
"(append pre-compiled-in-memorys_0 post-compiled-in-memorys_0)))"
"(rebuild-linklet-directory.1 temp11_0 temp10_0 temp12_0))))"
"(compiled-in-memory1.1"
" linklet-directory9_0"
"(compiled-in-memory-original-self the-struct_0)"
"(compiled-in-memory-requires the-struct_0)"
"(compiled-in-memory-recur-requires the-struct_0)"
"(compiled-in-memory-flattened-requires the-struct_0)"
"(compiled-in-memory-provides the-struct_0)"
"(compiled-in-memory-phase-to-link-module-uses the-struct_0)"
"(compiled-in-memory-compile-time-inspector the-struct_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss the-struct_0)"
"(compiled-in-memory-portal-stxes the-struct_0)"
"(compiled-in-memory-mpis the-struct_0)"
"(compiled-in-memory-syntax-literals the-struct_0)"
" pre-compiled-in-memorys7_0"
" post-compiled-in-memorys8_0"
"(compiled-in-memory-namespace-scopes the-struct_0)"
"(compiled-in-memory-purely-functional? the-struct_0)))"
"                          (raise-argument-error 'struct-copy \"compiled-in-memory?\" the-struct_0)))))))"
"(if(linklet-directory?$1 c_0)"
"(let-values()"
"(1/hash->linklet-directory"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0)(linklet-directory->hash$1 c_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((key_0 val_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_1 val_1)"
"(let-values()"
"(values"
" key_0"
"(if(not key_0)"
"(update-one-name"
" val_0"
" full-name_0)"
"(recur_0"
" val_0"
" key_0))))))"
"(hash-set table_1 key_1 val_1)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values()(update-one-name c_0 full-name_0))))))))))"
"(define-values"
"(update-one-name)"
"(lambda(lb_0 name_0)(begin(1/hash->linklet-bundle(hash-set(1/linklet-bundle->hash lb_0) 'name name_0)))))"
"(define-values"
"(rebuild-linklet-directory.1)"
"(lambda(bundle-ok?1_0 main3_0 submods4_0)"
"(begin"
" 'rebuild-linklet-directory"
"(let-values(((main_0) main3_0))"
"(let-values(((submods_0) submods4_0))"
"(let-values(((bundle-ok?_0) bundle-ok?1_0))"
"(let-values()"
"(if(if(null? submods_0) bundle-ok?_0 #f)"
"(let-values() main_0)"
"(let-values()"
"(1/hash->linklet-directory"
"(hash-set"
"(let-values(((ht_0)(let-values(((ht_0) '#hasheq())) ht_0)))"
"(let-values(((lst_0) submods_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((submod_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_2)"
"(let-values(((ht_2)"
"(let-values()"
"(let-values(((name_0)"
"(module-compiled-immediate-name"
" submod_0)))"
"(if(hash-ref ht_1 name_0 #f)"
"(let-values()"
"(raise-arguments-error"
" 'module-compiled-submodules"
"                                                                                           \"change would result in duplicate submodule name\""
"                                                                                           \"name\""
" name_0))"
"(let-values()"
"(hash-set"
" ht_1"
" name_0"
"(compiled->linklet-directory-or-bundle"
" submod_0))))))))"
"(values ht_2))))"
"(if(not #f)(for-loop_0 ht_2 rest_0) ht_2)))"
" ht_1))))))"
" for-loop_0)"
" ht_0"
" lst_0))))"
" #f"
" main_0)))))))))))"
"(define-values"
"(1/module-compiled-submodules)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((c_0 non-star?_0)"
"(begin"
" 'module-compiled-submodules"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"              (let-values () (raise-argument-error 'module-compiled-submodules \"compiled-module-expression?\" c_0)))"
"(if(compiled-in-memory? c_0)"
"(let-values()"
"(if non-star?_0"
"(compiled-in-memory-pre-compiled-in-memorys c_0)"
"(compiled-in-memory-post-compiled-in-memorys c_0)))"
"(let-values()"
"(if(linklet-directory?$1 c_0)"
"(let-values()"
"(let-values(((ht_0)(linklet-directory->hash$1 c_0)))"
"(let-values(((bh_0)(1/linklet-bundle->hash(hash-ref ht_0 #f))))"
"(let-values(((names_0)(hash-ref bh_0(if non-star?_0 'pre 'post) null)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) names_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((name_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(hash-ref ht_0 name_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))"
"(let-values() null)))))))"
"((c_0 non-star?_0 submods_0)"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"            (let-values () (raise-argument-error 'module-compiled-submodules \"compiled-module-expression?\" c_0)))"
"(if(if(list? submods_0)(andmap2 1/compiled-module-expression? submods_0) #f)"
"(void)"
"(let-values()"
"              (raise-argument-error 'module-compiled-submodules \"(listof compiled-module-expression?)\" submods_0)))"
"(if(if(null? submods_0)"
"(let-values(((or-part_0)(1/linklet-bundle?(compiled->linklet-directory-or-bundle c_0))))"
"(if or-part_0"
" or-part_0"
"(if(compiled-in-memory? c_0)"
"(null?"
"(if non-star?_0"
"(compiled-in-memory-pre-compiled-in-memorys c_0)"
"(compiled-in-memory-post-compiled-in-memorys c_0)))"
" #f)))"
" #f)"
"(let-values() c_0)"
"(if(if(compiled-in-memory? c_0)(andmap2 compiled-in-memory? submods_0) #f)"
"(let-values()"
"(let-values(((pre-compiled-in-memorys_0)"
"(if non-star?_0 submods_0(compiled-in-memory-pre-compiled-in-memorys c_0))))"
"(let-values(((post-compiled-in-memorys_0)"
"(if non-star?_0(compiled-in-memory-post-compiled-in-memorys c_0) submods_0)))"
"(let-values(((n-c_0)(normalize-to-linklet-directory c_0)))"
"(fixup-submodule-names"
"(let-values(((the-struct_0) n-c_0))"
"(if(compiled-in-memory? the-struct_0)"
"(let-values(((pre-compiled-in-memorys2_0) pre-compiled-in-memorys_0)"
"((post-compiled-in-memorys3_0) post-compiled-in-memorys_0)"
"((linklet-directory4_0)"
"(let-values(((temp5_0)"
"(reset-submodule-names"
"(hash-ref"
"(linklet-directory->hash$1"
"(compiled->linklet-directory-or-bundle n-c_0))"
" #f)"
" non-star?_0"
" submods_0))"
"((temp6_0)(symbol?(module-compiled-current-name c_0)))"
"((temp7_0)"
"(append pre-compiled-in-memorys_0 post-compiled-in-memorys_0)))"
"(rebuild-linklet-directory.1 temp6_0 temp5_0 temp7_0))))"
"(compiled-in-memory1.1"
" linklet-directory4_0"
"(compiled-in-memory-original-self the-struct_0)"
"(compiled-in-memory-requires the-struct_0)"
"(compiled-in-memory-recur-requires the-struct_0)"
"(compiled-in-memory-flattened-requires the-struct_0)"
"(compiled-in-memory-provides the-struct_0)"
"(compiled-in-memory-phase-to-link-module-uses the-struct_0)"
"(compiled-in-memory-compile-time-inspector the-struct_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss the-struct_0)"
"(compiled-in-memory-portal-stxes the-struct_0)"
"(compiled-in-memory-mpis the-struct_0)"
"(compiled-in-memory-syntax-literals the-struct_0)"
" pre-compiled-in-memorys2_0"
" post-compiled-in-memorys3_0"
"(compiled-in-memory-namespace-scopes the-struct_0)"
"(compiled-in-memory-purely-functional? the-struct_0)))"
"                           (raise-argument-error 'struct-copy \"compiled-in-memory?\" the-struct_0))))))))"
"(let-values()"
"(let-values(((n-c_0)(normalize-to-linklet-directory c_0)))"
"(fixup-submodule-names"
"(let-values(((temp8_0)"
"(reset-submodule-names"
"(hash-ref"
"(linklet-directory->hash$1(compiled->linklet-directory-or-bundle n-c_0))"
" #f)"
" non-star?_0"
" submods_0))"
"((temp9_0)"
"(map2"
" compiled->linklet-directory-or-bundle"
"(append"
"(if non-star?_0 submods_0(1/module-compiled-submodules c_0 #t))"
"(if non-star?_0(1/module-compiled-submodules c_0 #f) submods_0)))))"
"(rebuild-linklet-directory.1 #f temp8_0 temp9_0)))))))))))))"
"(define-values"
"(fixup-submodule-names)"
"(lambda(c_0)(begin(1/module-compiled-name c_0(1/module-compiled-name c_0)))))"
"(define-values"
"(reset-submodule-names)"
"(lambda(b_0 pre?_0 submods_0)"
"(begin"
"(1/hash->linklet-bundle"
"(hash-set"
"(1/linklet-bundle->hash b_0)"
"(if pre?_0 'pre 'post)"
"(let-values(((temp10_0)(map2 module-compiled-immediate-name submods_0))((symbol<?11_0) symbol<?))"
"(sort.1 #f #f temp10_0 symbol<?11_0)))))))"
"(define-values"
"(1/module-compiled-language-info)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-language-info"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'module-compiled-language-info \"compiled-module-expression?\" c_0)))"
"(values))))"
"(let-values(((h_0)(compiled-module->h c_0)))(hash-ref h_0 'language-info #f))))))))"
"(define-values"
"(1/module-compiled-imports)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-imports"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'module-compiled-imports \"compiled-module-expression?\" c_0)))"
"(values))))"
"(let-values(((inst_0)(compiled-module->declaration-instance c_0)))"
"(1/instance-variable-value inst_0 'requires))))))))"
"(define-values"
"(1/module-compiled-exports)"
"(let-values(((module-compiled-exports_0)"
"(lambda(c2_0 verbosity1_0)"
"(begin"
" 'module-compiled-exports"
"(let-values(((c_0) c2_0))"
"(let-values(((verbosity_0) verbosity1_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-compiled-exports"
"                                                   \"compiled-module-expression?\""
" c_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(check-provides-verbosity 'module-compiled-exports verbosity_0)"
"(values))))"
"(let-values(((inst_0)(compiled-module->declaration-instance c_0)))"
"(provides->api-provides"
"(1/instance-variable-value inst_0 'provides)"
"(1/instance-variable-value inst_0 'self-mpi)"
" verbosity_0)))))))))))))"
"(case-lambda"
"((c_0)(begin 'module-compiled-exports(module-compiled-exports_0 c_0 #f)))"
"((c_0 verbosity1_0)(module-compiled-exports_0 c_0 verbosity1_0)))))"
"(define-values"
"(1/module-compiled-indirect-exports)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-indirect-exports"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-compiled-indirect-exports"
"                               \"compiled-module-expression?\""
" c_0)))"
"(values))))"
"(let-values(((h_0 inst_0)(compiled-module->h+declaration-instance c_0)))"
"(let-values(((min-phase_0)(hash-ref h_0 'min-phase 0)))"
"(let-values(((max-phase_0)(hash-ref h_0 'max-phase 0)))"
"(variables->api-nonprovides"
"(1/instance-variable-value inst_0 'provides)"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((start_0) min-phase_0)((end_0)(add1 max-phase_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values(((phase-level_0) pos_0))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(let-values(((linklet_0)"
"(hash-ref"
" h_0"
" phase-level_0"
" #f)))"
"(values"
" phase-level_0"
"(if linklet_0"
"(linklet-export-variables$1"
" linklet_0)"
" null))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)(for-loop_0 table_2(+ pos_0 inc_0)) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" start_0))))))))))))))"
"(define-values"
"(1/module-compiled-cross-phase-persistent?)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-cross-phase-persistent?"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-compiled-cross-phase-persistent?"
"                               \"compiled-module-expression?\""
" c_0)))"
"(values))))"
"(let-values(((h_0)(compiled-module->h c_0)))(hash-ref h_0 'cross-phase-persistent? #f))))))))"
"(define-values"
"(1/module-compiled-realm)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-realm"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'module-compiled-realm \"compiled-module-expression?\" c_0)))"
"(values))))"
"(let-values(((h_0)(compiled-module->h c_0)))(hash-ref h_0 'realm 'racket))))))))"
"(define-values"
"(compile-module.1)"
"(lambda(force-linklet-directory?1_0"
" modules-being-compiled4_0"
" need-compiled-submodule-rename?5_0"
" serializable?2_0"
" to-correlated-linklet?3_0"
" p11_0"
" cctx12_0)"
"(begin"
" 'compile-module"
"(let-values(((p_0) p11_0))"
"(let-values(((cctx_0) cctx12_0))"
"(let-values(((force-linklet-directory?_0) force-linklet-directory?1_0))"
"(let-values(((serializable?_0) serializable?2_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?3_0))"
"(let-values(((modules-being-compiled_0)"
"(if(eq? modules-being-compiled4_0 unsafe-undefined)"
"(make-hasheq)"
" modules-being-compiled4_0)))"
"(let-values(((need-compiled-submodule-rename?_0) need-compiled-submodule-rename?5_0))"
"(let-values()"
"(let-values(((full-module-name_0)"
"(let-values(((parent-full-name_0)(compile-context-full-module-name cctx_0))"
"((name_0)(syntax-e$1(parsed-module-name-id p_0))))"
"(if parent-full-name_0"
"(append"
"(if(list? parent-full-name_0) parent-full-name_0(list parent-full-name_0))"
"(list name_0))"
" name_0))))"
"(let-values(((compiled-submodules_0)(parsed-module-compiled-submodules p_0)))"
"(let-values(((get-submodules_0)"
"(lambda(star?_0)"
"(begin"
" 'get-submodules"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0) compiled-submodules_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((name_0 star?+compiled_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((fold-var_2)"
"(if(eq?"
" star?_0"
"(car"
" star?+compiled_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" name_0"
"(if(if need-compiled-submodule-rename?_0"
"(not"
"(parsed-module-compiled-module"
" p_0))"
" #f)"
"(update-submodule-names"
"(cdr"
" star?+compiled_0)"
" name_0"
" full-module-name_0)"
"(cdr"
" star?+compiled_0))))"
" fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
"(hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_0))))))))))"
"(let-values(((pre-submodules_0)"
"(let-values(((temp33_0)(get-submodules_0 #f))"
"((symbol<?34_0) symbol<?)"
"((car35_0) car))"
"(sort.1 #f car35_0 temp33_0 symbol<?34_0))))"
"(let-values(((post-submodules_0)"
"(let-values(((temp36_0)(get-submodules_0 #t))"
"((symbol<?37_0) symbol<?)"
"((car38_0) car))"
"(sort.1 #f car38_0 temp36_0 symbol<?37_0))))"
"(let-values(((c1_0)(parsed-module-compiled-module p_0)))"
"(if c1_0"
"((lambda(c_0)"
"(let-values(((name_0 prefix_0)"
"(if(symbol? full-module-name_0)"
"(values full-module-name_0 null)"
"(let-values(((r_0)(reverse$1 full-module-name_0)))"
"(values(car r_0)(reverse$1(cdr r_0)))))))"
"(let-values(((m_0)(change-module-name c_0 name_0 prefix_0)))"
"(1/module-compiled-submodules"
"(1/module-compiled-submodules m_0 #t(map2 cdr pre-submodules_0))"
" #f"
"(map2 cdr post-submodules_0)))))"
" c1_0)"
"(let-values()"
"(let-values(((p39_0) p_0)"
"((cctx40_0) cctx_0)"
"((full-module-name41_0) full-module-name_0)"
"((force-linklet-directory?42_0) force-linklet-directory?_0)"
"((serializable?43_0) serializable?_0)"
"((to-correlated-linklet?44_0) to-correlated-linklet?_0)"
"((modules-being-compiled45_0) modules-being-compiled_0)"
"((pre-submodules46_0) pre-submodules_0)"
"((post-submodules47_0) post-submodules_0)"
"((need-compiled-submodule-rename?48_0)"
" need-compiled-submodule-rename?_0))"
"(compile-module-from-parsed.1"
" force-linklet-directory?42_0"
" full-module-name41_0"
" modules-being-compiled45_0"
" need-compiled-submodule-rename?48_0"
" post-submodules47_0"
" pre-submodules46_0"
" serializable?43_0"
" to-correlated-linklet?44_0"
" p39_0"
" cctx40_0)))))))))))))))))))))"
"(define-values"
"(compile-module-from-parsed.1)"
"(lambda(force-linklet-directory?15_0"
" full-module-name14_0"
" modules-being-compiled18_0"
" need-compiled-submodule-rename?21_0"
" post-submodules20_0"
" pre-submodules19_0"
" serializable?16_0"
" to-correlated-linklet?17_0"
" p30_0"
" cctx31_0)"
"(begin"
" 'compile-module-from-parsed"
"(let-values(((p_0) p30_0))"
"(let-values(((cctx_0) cctx31_0))"
"(let-values(((full-module-name_0) full-module-name14_0))"
"(let-values(((force-linklet-directory?_0) force-linklet-directory?15_0))"
"(let-values(((serializable?_0) serializable?16_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?17_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled18_0))"
"(let-values(((pre-submodules_0) pre-submodules19_0))"
"(let-values(((post-submodules_0) post-submodules20_0))"
"(let-values(((need-compiled-submodule-rename?_0) need-compiled-submodule-rename?21_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'compile 'module))(void))"
"(begin0"
"(let-values()"
"(let-values(((enclosing-self_0)(compile-context-module-self cctx_0)))"
"(let-values(((self_0)(parsed-module-self p_0)))"
"(let-values(((requires_0)(parsed-module-requires p_0)))"
"(let-values(((recur-requires_0)(parsed-module-recur-requires p_0)))"
"(let-values(((flattened-requires_0)(parsed-module-flattened-requires p_0)))"
"(let-values(((provides_0)(parsed-module-provides p_0)))"
"(let-values(((encoded-root-expand-ctx-box_0)"
"(box(parsed-module-encoded-root-ctx p_0))))"
"(let-values(((body-context-simple?_0)"
"(parsed-module-root-ctx-simple? p_0)))"
"(let-values(((language-info_0)"
"(filter-language-info"
"(syntax-property$1(parsed-s p_0) 'module-language))))"
"(let-values(((realm_0)(parsed-module-realm p_0)))"
"(let-values(((bodys_0)(parsed-module-body p_0)))"
"(let-values(((portal-syntaxes_0)"
"(parsed-module-portal-syntaxes p_0)))"
"(let-values(((empty-result-for-module->namespace?_0) #f))"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values(((body-cctx_0)"
"(let-values(((the-struct_0) cctx_0))"
"(if(compile-context? the-struct_0)"
"(let-values(((phase49_0) 0)"
"((self50_0) self_0)"
"((module-self51_0) self_0)"
"((full-module-name52_0)"
" full-module-name_0)"
"((lazy-syntax-literals?53_0)"
" #t))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase49_0"
" self50_0"
" module-self51_0"
" full-module-name52_0"
" lazy-syntax-literals?53_0"
"(compile-context-header"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                 \"compile-context?\""
" the-struct_0)))))"
"(let-values(((cross-phase-persistent?_0) #f))"
"(let-values(((unsafe?-box_0)(box #f)))"
"(let-values(((unlimited-compile?-box_0)(box #f)))"
"(let-values(((side-effects_0)(make-hasheqv)))"
"(let-values(((check-side-effects!_0)"
"(lambda(e_0"
" expected-results_0"
" phase_0"
" required-reference?_0)"
"(begin"
" 'check-side-effects!"
"(if(hash-ref"
" side-effects_0"
" phase_0"
" #f)"
"(void)"
"(let-values()"
"(if(let-values(((e54_0)"
" e_0)"
"((expected-results55_0)"
" expected-results_0)"
"((required-reference?56_0)"
" required-reference?_0))"
"(any-side-effects?.1"
" '#hasheq()"
" '#hasheq()"
" required-reference?56_0"
" e54_0"
" expected-results55_0))"
"(let-values()"
"(hash-set!"
" side-effects_0"
" phase_0"
" #t))"
"(void))))))))"
"(let-values((()"
"(begin"
"(if(if need-compiled-submodule-rename?_0"
" modules-being-compiled_0"
" #f)"
"(let-values()"
"(begin"
"(if(null?"
" post-submodules_0)"
"(void)"
"(let-values()"
"(error"
"                                                                                                     \"internal error: have post submodules, but not already compiled\")))"
"(register-compiled-submodules"
" modules-being-compiled_0"
" pre-submodules_0"
" self_0)))"
"(void))"
"(values))))"
"(let-values(((body-linklets_0"
" body-min-phase_0"
" body-max-phase_0"
" phase-to-link-module-uses_0"
" phase-to-link-module-uses-expr_0"
" phase-to-link-extra-inspectorsss_0"
" syntax-literals_0"
" root-ctx-pos_0)"
"(let-values(((bodys57_0)"
" bodys_0)"
"((body-cctx58_0)"
" body-cctx_0)"
"((mpis59_0)"
" mpis_0)"
"((temp60_0)"
"(list"
"(list"
" get-syntax-literal!-id)"
"(list"
" set-transformer!-id)))"
"((temp61_0)"
"(list"
" empty-syntax-literals-instance"
" empty-module-body-instance))"
"((temp62_0)"
" '((void)))"
"((temp63_0) '(0))"
"((encoded-root-expand-ctx-box64_0)"
" encoded-root-expand-ctx-box_0)"
"((body-context-simple?65_0)"
" body-context-simple?_0)"
"((check-side-effects!66_0)"
" check-side-effects!_0)"
"((temp67_0)"
"(lambda(body_0"
" cctx_1)"
"(if(parsed-#%declare?"
" body_0)"
"(let-values()"
"(let-values(((ok?_0"
" _75_0"
" kw76_0)"
"(let-values(((s_0)"
"(parsed-s"
" body_0)))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((_75_0"
" kw76_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((_77_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((kw78_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                           \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _77_0"
" kw78_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                   \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _75_0"
" kw76_0))))))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" kw76_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((kw_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((tmp_0)"
"(syntax-e$1"
" kw_0)))"
"(if(equal?"
" tmp_0"
" '#:cross-phase-persistent)"
"(let-values()"
"(set! cross-phase-persistent?_0"
" #t))"
"(if(equal?"
" tmp_0"
" '#:empty-namespace)"
"(let-values()"
"(begin"
"(set! empty-result-for-module->namespace?_0"
" #t)"
"(set-box!"
" encoded-root-expand-ctx-box_0"
" #f)))"
"(if(equal?"
" tmp_0"
" '#:unsafe)"
"(let-values()"
"(set-box!"
" unsafe?-box_0"
" #t))"
"(if(equal?"
" tmp_0"
" '#:unlimited-compile)"
"(let-values()"
"(set-box!"
" unlimited-compile?-box_0"
" #t))"
"(let-values()"
"(void))))))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
" #f)))"
"(let-values()"
" #f))))"
"((temp68_0)"
"(lambda(mod-name_0"
" phase_0)"
"(let-values(((ht_0)"
"(if modules-being-compiled_0"
"(hash-ref"
" modules-being-compiled_0"
" mod-name_0"
" #f)"
" #f)))"
"(if ht_0"
"(hash-ref"
" ht_0"
" phase_0"
" #f)"
" #f))))"
"((serializable?69_0)"
" serializable?_0)"
"((temp70_0) #t)"
"((unlimited-compile?-box71_0)"
" unlimited-compile?-box_0)"
"((to-correlated-linklet?72_0)"
" to-correlated-linklet?_0)"
"((unsafe?-box73_0)"
" unsafe?-box_0)"
"((realm74_0)"
" realm_0))"
"(compile-forms.1"
" temp61_0"
" temp60_0"
" temp62_0"
" check-side-effects!66_0"
" void"
" encoded-root-expand-ctx-box64_0"
" temp63_0"
" temp68_0"
" temp70_0"
" #t"
" temp67_0"
" realm74_0"
" body-context-simple?65_0"
" serializable?69_0"
" to-correlated-linklet?72_0"
" unlimited-compile?-box71_0"
" unsafe?-box73_0"
" bodys57_0"
" body-cctx58_0"
" mpis59_0))))"
"(let-values(((portal-stxes_0"
" max-phase_0"
" min-phase_0)"
"(add-portal-syntaxes"
" syntax-literals_0"
" portal-syntaxes_0"
" body-max-phase_0"
" body-min-phase_0)))"
"(let-values((()"
"(begin"
"(if modules-being-compiled_0"
"(let-values()"
"(hash-set!"
" modules-being-compiled_0"
"(1/module-path-index-resolve"
" self_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheq()))"
" table_0)))"
"(let-values(((ht_0)"
" body-linklets_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0"
" linklet_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_0"
"(module-linklet-info2.1"
" linklet_0"
"(hash-ref"
" phase-to-link-module-uses_0"
" phase_0"
" #f)"
" self_0"
" #f"
" #f"
"(if phase-to-link-extra-inspectorsss_0"
"(hash-ref"
" phase-to-link-extra-inspectorsss_0"
" phase_0"
" #f)"
" #f))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first"
" ht_0)))))))"
"(void))"
"(values))))"
"(let-values(((declaration-linklet_0)"
"(if serializable?_0"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet"
" s_0"
" 'decl)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(1/compile-linklet"
" s_0"
"(hasheq"
" 'module"
" full-module-name_0"
" 'name"
" 'decl)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(generate-module-declaration-linklet"
" mpis_0"
" self_0"
" requires_0"
" recur-requires_0"
" flattened-requires_0"
" provides_0"
" phase-to-link-module-uses-expr_0"
" portal-stxes_0))"
" #f)))"
"(let-values(((syntax-literals-linklet_0)"
"(if(not"
"(syntax-literals-empty?"
" syntax-literals_0))"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet"
" s_0"
" 'syntax-literals)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((linklet_0"
" new-keys_0)"
"(1/compile-linklet"
" s_0"
"(hasheq"
" 'module"
" full-module-name_0"
" 'name"
" 'syntax-literals)"
"(vector"
" deserialize-instance"
" empty-top-syntax-literal-instance"
" empty-syntax-literals-data-instance"
" empty-instance-instance)"
"(lambda(inst_0)"
"(values"
" inst_0"
" #f))"
"(if serializable?_0"
" '(serializable)"
" '()))))"
" linklet_0))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(list*"
" 'linklet"
"(list"
" deserialize-imports"
"(list"
" mpi-vector-id)"
"(list*"
" deserialized-syntax-vector-id"
"(if serializable?_0"
"(list"
" deserialize-syntax-id)"
" '()))"
" instance-imports)"
"(list*"
" get-syntax-literal!-id"
" '(get-encoded-root-expand-ctx))"
"(qq-append"
"(let-values(((syntax-literals79_0)"
" syntax-literals_0)"
"((mpis80_0)"
" mpis_0)"
"((self81_0)"
" self_0)"
"((temp82_0)"
"(not"
" serializable?_0)))"
"(generate-lazy-syntax-literals!.1"
" temp82_0"
" syntax-literals79_0"
" mpis80_0"
" self81_0))"
"(list"
"(list"
" 'define-values"
" '(get-encoded-root-expand-ctx)"
"(if root-ctx-pos_0"
"(let-values()"
"(list"
" 'lambda"
" '()"
"(generate-lazy-syntax-literal-lookup"
" root-ctx-pos_0)))"
"(if empty-result-for-module->namespace?_0"
"(let-values()"
" ''empty)"
"(let-values()"
" ''#f))))))))"
" #f)))"
"(let-values(((syntax-literals-data-linklet_0)"
"(if serializable?_0"
"(if(not"
"(syntax-literals-empty?"
" syntax-literals_0))"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet"
" s_0"
" 'syntax-literals-data)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(1/compile-linklet"
" s_0"
"(hasheq"
" 'module"
" full-module-name_0"
" 'name"
" 'syntax-literals-data)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(list*"
" 'linklet"
"(list"
" deserialize-imports"
"(list"
" mpi-vector-id))"
"(list"
" deserialized-syntax-vector-id"
" deserialize-syntax-id)"
"(list"
" 'define-values"
"(list"
" deserialized-syntax-vector-id)"
"(list*"
" 'make-vector"
"(syntax-literals-count"
" syntax-literals_0)"
" '(#f)))"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'serialize))"
"(void))"
"(begin0"
"(let-values()"
"(generate-lazy-syntax-literals-data!"
" syntax-literals_0"
" mpis_0))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
" #f)"
" #f)))"
"(let-values(((data-linklet_0)"
"(if serializable?_0"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet"
" s_0"
" 'data)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(1/compile-linklet"
" s_0"
"(hasheq"
" 'module"
" full-module-name_0"
" 'name"
" 'data)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(generate-module-data-linklet"
" mpis_0))"
" #f)))"
"(let-values(((bundle_0)"
"(let-values(((bundle_0)"
"(hash-set"
" body-linklets_0"
" 'name"
" full-module-name_0)))"
"(let-values(((bundle_1)"
"(hash-set"
" bundle_0"
" 'decl"
"(let-values(((or-part_0)"
" declaration-linklet_0))"
"(if or-part_0"
" or-part_0"
" 'in-memory)))))"
"(let-values(((bundle_2)"
"(if data-linklet_0"
"(hash-set"
" bundle_1"
" 'data"
" data-linklet_0)"
" bundle_1)))"
"(let-values(((bundle_3)"
"(if syntax-literals-linklet_0"
"(hash-set"
" bundle_2"
" 'stx"
" syntax-literals-linklet_0)"
" bundle_2)))"
"(let-values(((bundle_4)"
"(if syntax-literals-data-linklet_0"
"(hash-set"
" bundle_3"
" 'stx-data"
" syntax-literals-data-linklet_0)"
" bundle_3)))"
"(let-values(((bundle_5)"
"(if(null?"
" pre-submodules_0)"
" bundle_4"
"(hash-set"
" bundle_4"
" 'pre"
"(map2"
" car"
" pre-submodules_0)))))"
"(let-values(((bundle_6)"
"(if(null?"
" post-submodules_0)"
" bundle_5"
"(hash-set"
" bundle_5"
" 'post"
"(map2"
" car"
" post-submodules_0)))))"
"(let-values(((bundle_7)"
"(if cross-phase-persistent?_0"
"(hash-set"
" bundle_6"
" 'cross-phase-persistent?"
" #t)"
" bundle_6)))"
"(let-values(((bundle_8)"
"(if language-info_0"
"(hash-set"
" bundle_7"
" 'language-info"
" language-info_0)"
" bundle_7)))"
"(let-values(((bundle_9)"
"(if(not"
"(eq?"
" realm_0"
" 'racket))"
"(hash-set"
" bundle_8"
" 'realm"
" realm_0)"
" bundle_8)))"
"(let-values(((bundle_10)"
"(if(zero?"
" min-phase_0)"
" bundle_9"
"(hash-set"
" bundle_9"
" 'min-phase"
" min-phase_0))))"
"(let-values(((bundle_11)"
"(if(zero?"
" max-phase_0)"
" bundle_10"
"(hash-set"
" bundle_10"
" 'max-phase"
" max-phase_0))))"
"(let-values(((bundle_12)"
"(if(hash-count"
" side-effects_0)"
"(hash-set"
" bundle_11"
" 'side-effects"
"(let-values(((temp83_0)"
"(hash-keys"
" side-effects_0))"
"((<84_0)"
" <))"
"(sort.1"
" #f"
" #f"
" temp83_0"
" <84_0)))"
" bundle_11)))"
"(let-values(((bundle_13)"
"(if empty-result-for-module->namespace?_0"
"(hash-set"
" bundle_12"
" 'module->namespace"
" 'empty)"
" bundle_12)))"
"(let-values(((bundle_14)"
"(if(unbox"
" unsafe?-box_0)"
"(hash-set"
" bundle_13"
" 'unsafe?"
" #t)"
" bundle_13)))"
"(1/hash->linklet-bundle"
" bundle_14))))))))))))))))))"
"(let-values(((ld_0)"
"(if(if(null?"
" pre-submodules_0)"
"(if(null?"
" post-submodules_0)"
"(not"
" force-linklet-directory?_0)"
" #f)"
" #f)"
"(let-values()"
" bundle_0)"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((ht_0)"
"(let-values(((ht_0)"
"(hasheq"
" #f"
" bundle_0)))"
" ht_0)))"
"(let-values(((lst_0)"
"(append"
" pre-submodules_0"
" post-submodules_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((sm_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((ht_2)"
"(let-values(((ht_2)"
"(let-values()"
"(hash-set"
" ht_1"
"(car"
" sm_0)"
"(compiled-in-memory-linklet-directory"
"(cdr"
" sm_0))))))"
"(values"
" ht_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" ht_2"
" rest_0)"
" ht_2)))"
" ht_1))))))"
" for-loop_0)"
" ht_0"
" lst_0))))))"
"(1/hash->linklet-directory"
" ht_0))))))"
"(compiled-in-memory1.1"
" ld_0"
" self_0"
" requires_0"
" recur-requires_0"
" flattened-requires_0"
" provides_0"
" phase-to-link-module-uses_0"
"(current-code-inspector)"
" phase-to-link-extra-inspectorsss_0"
" portal-stxes_0"
"(mpis-as-vector mpis_0)"
"(syntax-literals-as-vector"
" syntax-literals_0)"
"(map2"
" cdr"
" pre-submodules_0)"
"(map2"
" cdr"
" post-submodules_0)"
" #f"
" #f))))))))))))))))))))))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))))))))"
"(define-values"
"(update-submodule-names)"
"(lambda(cim_0 name_0 full-module-name_0)"
"(begin"
"(change-module-name"
" cim_0"
" name_0"
"(if(symbol? full-module-name_0)(list full-module-name_0)(reverse$1(cdr(reverse$1 full-module-name_0))))))))"
"(define-values"
"(register-compiled-submodules)"
"(lambda(modules-being-compiled_0 pre-submodules_0 self_0)"
"(begin"
"(begin"
"(let-values()"
"(let-values(((lst_0) pre-submodules_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((name_0)(car s_0)))"
"(let-values(((cim_0)(cdr s_0)))"
"(let-values(((phase-to-link-module-uses_0)"
"(compiled-in-memory-phase-to-link-module-uses"
" cim_0)))"
"(let-values(((ld_0)"
"(compiled-in-memory-linklet-directory"
" cim_0)))"
"(let-values(((sm-self_0)"
"(1/module-path-index-join"
"(list"
" 'submod"
"                                                                                                  \".\""
" name_0)"
" self_0)))"
"(let-values(((phase-to-extra-inspectorsss_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss"
" cim_0)))"
"(hash-set!"
" modules-being-compiled_0"
"(1/module-path-index-resolve"
" sm-self_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheq()))"
" table_0)))"
"(let-values(((ht_0)"
"(1/linklet-bundle->hash"
"(if(linklet-directory?$1"
" ld_0)"
"(hash-ref"
"(linklet-directory->hash$1"
" ld_0)"
" #f)"
" ld_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_1"
" i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0"
" linklet_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(if(number?"
" phase_0)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_0"
"(module-linklet-info2.1"
" linklet_0"
"(hash-ref"
" phase-to-link-module-uses_0"
" phase_0"
" #f)"
"(compiled-in-memory-original-self"
" cim_0)"
" #f"
"(compiled-in-memory-compile-time-inspector"
" cim_0)"
"(if phase-to-extra-inspectorsss_0"
"(hash-ref"
" phase-to-extra-inspectorsss_0"
" phase_0"
" #f)"
" #f))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))"
" table_1)))"
"(if(not"
" #f)"
"(for-loop_1"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_1)"
" table_0"
"(hash-iterate-first"
" ht_0)))))))))))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))"
"(define-values"
"(add-portal-syntaxes)"
"(lambda(syntax-literals_0 portal-syntaxes_0 body-max-phase_0 body-min-phase_0)"
"(begin"
"(let-values(((portal-stxes_0)(let-values(((portal-stxes_0) '#hasheq())) portal-stxes_0))"
"((max-phase_0)(let-values(((max-phase_0) body-max-phase_0)) max-phase_0))"
"((min-phase_0)(let-values(((min-phase_0) body-min-phase_0)) min-phase_0)))"
"(let-values(((ht_0) portal-syntaxes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(portal-stxes_1 max-phase_1 min-phase_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 ht_1)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((portal-stxes_2 max-phase_2 min-phase_2)"
"(let-values(((portal-stxes_2 max-phase_2 min-phase_2)"
"(let-values()"
"(let-values(((new-portal-stxes_0)"
"(hash-set"
" portal-stxes_1"
" phase_0"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheq()))"
" table_0)))"
"(let-values(((ht_2) ht_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_1"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((sym_0"
" stx_0)"
"(hash-iterate-key+value"
" ht_2"
" i_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
"(add-syntax-literal!"
" syntax-literals_0"
" stx_0)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_2"
"(hash-iterate-next"
" ht_2"
" i_1))"
" table_2)))"
" table_1))))))"
" for-loop_1)"
" table_0"
"(hash-iterate-first"
" ht_2))))))))"
"(if(integer? phase_0)"
"(values"
" new-portal-stxes_0"
"(max(add1 phase_0) max-phase_1)"
"(min(add1 phase_0) min-phase_1))"
"(values"
" new-portal-stxes_0"
" max-phase_1"
" min-phase_1))))))"
"(values portal-stxes_2 max-phase_2 min-phase_2))))"
"(if(not #f)"
"(for-loop_0"
" portal-stxes_2"
" max-phase_2"
" min-phase_2"
"(hash-iterate-next ht_0 i_0))"
"(values portal-stxes_2 max-phase_2 min-phase_2))))"
"(values portal-stxes_1 max-phase_1 min-phase_1)))))))"
" for-loop_0)"
" portal-stxes_0"
" max-phase_0"
" min-phase_0"
"(hash-iterate-first ht_0))))))))"
"(define-values"
"(filter-language-info)"
"(lambda(li_0)"
"(begin"
"(if(vector? li_0)"
"(if(= 3(vector-length li_0))"
"(if(1/module-path?(vector-ref li_0 0))(if(symbol?(vector-ref li_0 1)) li_0 #f) #f)"
" #f)"
" #f))))"
"(define-values"
"(1/compiled-expression-recompile)"
"(lambda(c_0)"
"(begin"
" 'compiled-expression-recompile"
"(let-values((()"
"(begin"
"(if(1/compiled-expression? c_0)"
"(void)"
"(let-values()"
"                          (raise-argument-error 'compiled-expression-recompile \"compiled-expression?\" c_0)))"
"(values))))"
"(let-values(((target-machine_0)(current-compile-target-machine)))"
"(if(not target-machine_0)"
"(let-values() c_0)"
"(if(let-values(((or-part_0)(1/linklet-bundle? c_0)))(if or-part_0 or-part_0(linklet-directory?$1 c_0)))"
"(let-values()"
"(let-values(((ns_0)(1/current-namespace)))"
"(let-values(((bundles_0)(extract-linklet-bundles c_0 '() '#hash())))"
"(let-values(((recompileds_0)(make-hash)))"
"(letrec-values(((force-recompile-bundle_0)"
"(lambda(k_0)"
"(begin"
" 'force-recompile-bundle"
"(begin"
"(if(hash-ref recompileds_0 k_0 #f)"
"(void)"
"(let-values()"
"(let-values((()"
"(begin"
"(hash-set! recompileds_0 k_0 'in-process)"
"(values))))"
"(let-values(((b_0)(hash-ref bundles_0 k_0 #f)))"
"(begin"
"(if b_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'compiled-expression-recompile"
"                                                            \"cannot find submodule\""
"                                                            \"submodule path\""
" k_0)))"
"(hash-set!"
" recompileds_0"
" k_0"
"(recompile-bundle"
" b_0"
" force-recompile-bundle_0"
" ns_0"
" target-machine_0)))))))"
"(hash-ref recompileds_0 k_0))))))"
"(begin"
"(let-values()"
"(let-values(((ht_0) bundles_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)(hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(force-recompile-bundle_0"
" k_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)"
"(replace-linklet-bundles c_0 '() recompileds_0)))))))"
"(let-values()(1/compiled-expression-recompile(compiled-in-memory-linklet-directory c_0))))))))))"
"(define-values"
"(extract-linklet-bundles)"
"(lambda(c_0 rev-path_0 accum_0)"
"(begin"
"(if(1/linklet-bundle? c_0)"
"(let-values()(hash-set accum_0(reverse$1 rev-path_0) c_0))"
"(if(linklet-directory?$1 c_0)"
"(let-values()"
"(let-values(((accum_1)(let-values(((accum_1) accum_0)) accum_1)))"
"(let-values(((ht_0)(linklet-directory->hash$1 c_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(accum_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((accum_3)"
"(let-values(((accum_3)"
"(let-values()"
"(if(symbol? k_0)"
"(let-values()"
"(extract-linklet-bundles"
" v_0"
"(cons k_0 rev-path_0)"
" accum_2))"
"(if(not k_0)"
"(let-values()"
"(extract-linklet-bundles"
" v_0"
" rev-path_0"
" accum_2))"
"(let-values() accum_2))))))"
"(values accum_3))))"
"(if(not #f)"
"(for-loop_0 accum_3(hash-iterate-next ht_0 i_0))"
" accum_3)))"
" accum_2))))))"
" for-loop_0)"
" accum_1"
"(hash-iterate-first ht_0))))))"
"(let-values() accum_0))))))"
"(define-values"
"(replace-linklet-bundles)"
"(lambda(c_0 rev-path_0 recompileds_0)"
"(begin"
"(if(1/linklet-bundle? c_0)"
"(let-values()(recompiled-bundle(hash-ref recompileds_0(reverse$1 rev-path_0))))"
"(if(linklet-directory?$1 c_0)"
"(let-values()"
"(1/hash->linklet-directory"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0)(linklet-directory->hash$1 c_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" k_0"
"(if(symbol? k_0)"
"(let-values()"
"(replace-linklet-bundles"
" v_0"
"(cons k_0 rev-path_0)"
" recompileds_0))"
"(if(not k_0)"
"(let-values()"
"(replace-linklet-bundles"
" v_0"
" rev-path_0"
" recompileds_0))"
"(void)))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values() c_0))))))"
"(define-values"
"(struct:recompiled recompiled1.1 recompiled? recompiled-bundle recompiled-phase-to-link-module-uses recompiled-self)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'recompiled"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'recompiled)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'bundle)"
"(make-struct-field-accessor -ref_0 1 'phase-to-link-module-uses)"
"(make-struct-field-accessor -ref_0 2 'self))))"
"(define-values"
"(recompile-bundle)"
"(lambda(b_0 get-submodule-recompiled_0 ns_0 target-machine_0)"
"(begin"
"(let-values(((orig-h_0)(1/linklet-bundle->hash b_0)))"
"(let-values(((h_0)"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0) orig-h_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(if(if(not"
"(exact-integer?"
" k_0))"
"(correlated-linklet?"
" v_0)"
" #f)"
"(let-values()"
"(values"
" k_0"
"(force-compile-linklet"
" v_0)))"
"(let-values()"
"(values"
" k_0"
" v_0))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values(((can-eval-compiled?_0)(eq? target-machine_0(system-type 'target-machine))))"
"(let-values(((eval-metadata-linklet_0)"
"(lambda(key_0)"
"(begin"
" 'eval-metadata-linklet"
"(if can-eval-compiled?_0"
"(eval-linklet$1(hash-ref h_0 key_0))"
"(eval-correlated-linklet(hash-ref orig-h_0 key_0)))))))"
"(let-values(((data-instance_0)"
"(instantiate-linklet$1(eval-metadata-linklet_0 'data)(list deserialize-instance))))"
"(let-values(((declaration-instance_0)"
"(instantiate-linklet$1"
"(eval-metadata-linklet_0 'decl)"
"(list deserialize-instance data-instance_0))))"
"(let-values(((decl_0)"
"(lambda(key_0)"
"(begin 'decl(1/instance-variable-value declaration-instance_0 key_0)))))"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values((()"
"(begin"
"(let-values()"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0)"
"(1/instance-variable-value"
" data-instance_0"
" mpi-vector-id)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_0)))"
"(values vec_0(unsafe-vector-length vec_0)))))"
"((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0 pos_1)"
"(begin"
" 'for-loop"
"(if(if(unsafe-fx< pos_0 len_0) #t #f)"
"(let-values(((mpi_0)"
"(unsafe-vector-ref vec_0 pos_0))"
"((i_0) pos_1))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(eqv?"
"(add-module-path-index!/pos"
" mpis_0"
" mpi_0)"
" i_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'compiled-expression-recompile"
"                                                                                                             \"invalid or duplicate entry in MPI vector\""
"                                                                                                             \"entry\""
" mpi_0))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(unsafe-fx+ 1 pos_0)(+ pos_1 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0"
" start_0))))"
"(values))))"
"(let-values()"
"(let-values(((self_0)(decl_0 'self-mpi)))"
"(let-values(((phase-to-link-modules_0)(decl_0 'phase-to-link-modules)))"
"(let-values(((portal-stxes_0)(decl_0 'portal-stxes)))"
"(let-values(((unsafe?_0)(hash-ref orig-h_0 'unsafe? #f)))"
"(let-values(((module-prompt?_0)(hash-ref orig-h_0 'module-prompt? #t)))"
"(let-values(((unlimited-compile?_0)(hash-ref orig-h_0 'unlimited-compile? #f)))"
"(let-values(((realm_0)(hash-ref orig-h_0 'realm 'racket)))"
"(let-values(((find-submodule_0)"
"(lambda(mod-name_0 phase_0)"
"(begin"
" 'find-submodule"
"(let-values(((find-l_0)"
"(1/resolved-module-path-name mod-name_0)))"
"(let-values(((self-l_0)"
"(1/resolved-module-path-name"
"(1/module-path-index-resolve self_0))))"
"(let-values(((root-of_0)"
"(lambda(l_0)"
"(begin"
" 'root-of"
"(if(pair? l_0)(car l_0) l_0)))))"
"(if(equal?(root-of_0 find-l_0)(root-of_0 self-l_0))"
"(let-values()"
"(let-values(((submod_0)"
"(if(pair? find-l_0)"
"(cdr find-l_0)"
" '())))"
"(let-values(((r_0)"
"(get-submodule-recompiled_0"
" submod_0)))"
"(let-values((()"
"(begin"
"(if(eq? r_0 'in-process)"
"(let-values()"
"(raise-arguments-error"
" 'compiled-expression-recompile"
"                                                                                             \"cycle in linklet imports\"))"
"(void))"
"(values))))"
"(let-values(((b_1)(recompiled-bundle r_0)))"
"(let-values(((linklet_0)"
"(let-values(((or-part_0)"
"(hash-ref"
"(1/linklet-bundle->hash"
" b_1)"
" phase_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(raise-arguments-error"
" 'compiled-expression-recompile"
"                                                                                               \"cannot find (sub)module at phase\""
"                                                                                               \"module\""
"(unquoted-printing-string"
"(format"
"                                                                                                 \"~a\""
" mod-name_0))"
"                                                                                               \"phase\""
" phase_0)))))"
"(module-linklet-info2.1"
" linklet_0"
"(hash-ref"
"(recompiled-phase-to-link-module-uses"
" r_0)"
" phase_0"
" #f)"
"(recompiled-self r_0)"
" #f"
"(current-code-inspector)"
" #f)))))))"
"(let-values() #f)))))))))"
"(let-values(((body-linklets+module-use*s_0)"
"(let-values(((table_0)"
"(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0) h_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0"
" body-linklet_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(if(exact-integer?"
" phase_0)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((module-use*s_0)"
"(module-uses-add-extra-inspectorsss"
"(hash-ref"
" phase-to-link-modules_0"
" phase_0)"
" #f)))"
"(let-values(((linklet_0"
" new-module-use*s_0)"
"(let-values(((temp3_0)"
"(if(correlated-linklet?"
" body-linklet_0)"
"(correlated-linklet-expr"
" body-linklet_0)"
" body-linklet_0))"
"((temp4_0)"
"(if(correlated-linklet?"
" body-linklet_0)"
" 1/compile-linklet"
" recompile-linklet$1))"
"((temp5_0)"
"(hasheq"
" 'phase"
" phase_0))"
"((temp6_0)"
"(list"
"(list"
" get-syntax-literal!-id)"
"(list"
" set-transformer!-id)))"
"((temp7_0)"
"(list"
" empty-syntax-literals-instance"
" empty-module-body-instance))"
"((find-submodule8_0)"
" find-submodule_0)"
"((temp9_0)"
" #t)"
"((module-prompt?10_0)"
" module-prompt?_0)"
"((unlimited-compile?11_0)"
" unlimited-compile?_0)"
"((module-use*s12_0)"
" module-use*s_0)"
"((temp13_0)"
" #t)"
"((unsafe?14_0)"
" unsafe?_0)"
"((temp15_0)"
" #t)"
"((ns16_0)"
" ns_0)"
"((realm17_0)"
" realm_0))"
"(compile-module-linklet.1"
" temp7_0"
" temp6_0"
" temp5_0"
" temp4_0"
" find-submodule8_0"
" temp15_0"
" module-prompt?10_0"
" module-use*s12_0"
" ns16_0"
" temp13_0"
" realm17_0"
" temp9_0"
" unlimited-compile?11_0"
" unsafe?14_0"
" temp3_0))))"
"(values"
" phase_0"
"(cons"
" linklet_0"
" new-module-use*s_0)))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))"
" table_1)))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values(((h/new-body-linklets_0)"
"(let-values(((h_1)(let-values(((h_1) h_0)) h_1)))"
"(let-values(((ht_0) body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(h_2 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0"
" l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((h_3)"
"(let-values(((h_3)"
"(let-values()"
"(hash-set"
" h_2"
" phase_0"
"(car"
" l+mu*s_0)))))"
"(values"
" h_3))))"
"(if(not #f)"
"(for-loop_0"
" h_3"
"(hash-iterate-next"
" ht_0"
" i_0))"
" h_3)))"
" h_2))))))"
" for-loop_0)"
" h_1"
"(hash-iterate-first ht_0)))))))"
"(let-values(((phase-to-link-module-uses_0)"
"(let-values(((table_0)"
"(let-values(((table_0) '#hasheq()))"
" table_0)))"
"(let-values(((ht_0) body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0"
" l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_0"
"(module-uses-strip-extra-inspectorsss"
"(cdr"
" l+mu*s_0))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values(((phase-to-link-module-uses-expr_0)"
"(serialize-phase-to-link-module-uses"
" phase-to-link-module-uses_0"
" mpis_0)))"
"(let-values(((data-linklet_0)"
"(1/compile-linklet"
"(generate-module-data-linklet mpis_0)"
" 'data)))"
"(let-values(((declaration-linklet_0)"
"(1/compile-linklet"
"(generate-module-declaration-linklet"
" mpis_0"
" self_0"
"(decl_0 'requires)"
"(decl_0 'recur-requires)"
"(decl_0 'flattened-requires)"
"(decl_0 'provides)"
" phase-to-link-module-uses-expr_0"
" portal-stxes_0)"
" 'decl)))"
"(let-values(((new-bundle_0)"
"(1/hash->linklet-bundle"
"(let-values(((h_1) h/new-body-linklets_0))"
"(let-values(((h_2)"
"(hash-set"
" h_1"
" 'data"
" data-linklet_0)))"
"(let-values(((h_3)"
"(hash-set"
" h_2"
" 'decl"
" declaration-linklet_0)))"
" h_3))))))"
"(recompiled1.1"
" new-bundle_0"
" phase-to-link-module-uses_0"
" self_0)))))))))))))))))))))))))))))"
"(define-values"
"(1/compiled-expression-add-target-machine)"
"(lambda(c_0 from-c_0)"
"(begin"
" 'compiled-expression-add-target-machine"
"(let-values(((who_0) 'compiled-expression-add-target-machine))"
"(let-values((()"
"(begin"
"(if(1/compiled-expression? c_0)"
"(void)"
"                          (let-values () (raise-argument-error who_0 \"compiled-expression?\" c_0)))"
"(values))))"
"(let-values(((from-hash?_0)(hash? from-c_0)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0) from-hash?_0))"
"(if or-part_0 or-part_0(1/compiled-expression? from-c_0)))"
"(void)"
"                              (let-values () (raise-argument-error who_0 \"(or/c compiled-expression? hash?)\" from-c_0)))"
"(values))))"
"(let-values(((looks-wrong_0)"
"(lambda()"
"(begin"
" 'looks-wrong"
"(raise-arguments-error"
" who_0"
"(string-append"
"                                  \"compiled expressions are not compatible;\\n\""
"                                  \" they appear to be from compiling different modules\"))))))"
"(let-values(((get-linklet_0)"
"(lambda(c_1)"
"(begin"
" 'get-linklet"
"(if(let-values(((or-part_0)(1/linklet-bundle? c_1)))"
"(if or-part_0 or-part_0(linklet-directory?$1 c_1)))"
" c_1"
"(compiled-in-memory-linklet-directory c_1))))))"
"(let-values(((c_1)(get-linklet_0 c_0))"
"((from-c_1)(if from-hash?_0 from-c_0(get-linklet_0 from-c_0))))"
"(let-values(((bundles_0)(extract-linklet-bundles c_1 '() '#hash())))"
"(let-values(((from-bundles_0)"
"(if from-hash?_0 from-c_1(extract-linklet-bundles from-c_1 '() '#hash()))))"
"(let-values((()"
"(begin"
"(if(=(hash-count bundles_0)(hash-count from-bundles_0))"
"(void)"
"(let-values()(looks-wrong_0)))"
"(values))))"
"(let-values(((new-bundles_0)"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0) bundles_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0)"
"(hash-iterate-key ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((b_0)"
"(hash-ref"
" bundles_0"
" k_0)))"
"(let-values(((from-b_0)"
"(hash-ref"
" from-bundles_0"
" k_0"
" #f)))"
"(let-values((()"
"(begin"
"(if from-b_0"
"(void)"
"(let-values()"
"(looks-wrong_0)))"
"(values))))"
"(let-values(((h_0)"
"(1/linklet-bundle->hash"
" b_0)))"
"(let-values(((from-h_0)"
"(if from-hash?_0"
"(let-values()"
"(begin"
"(if(hash?"
" from-b_0)"
"(void)"
"(let-values()"
"(looks-wrong_0)))"
" from-b_0))"
"(let-values()"
"(1/linklet-bundle->hash"
" from-b_0)))))"
"(let-values(((new-b_0)"
"(1/hash->linklet-bundle"
"(let-values(((h_1)"
"(let-values(((h_1)"
" h_0))"
" h_1)))"
"(let-values(((ht_1)"
" h_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(h_2"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((phase_0"
" body-linklet_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((h_3)"
"(if(exact-integer?"
" phase_0)"
"(let-values(((h_3)"
"(let-values()"
"(let-values(((from-body-linklet_0)"
"(hash-ref"
" from-h_0"
" phase_0"
" #f)))"
"(begin"
"(if from-body-linklet_0"
"(void)"
"(let-values()"
"(looks-wrong_0)))"
"(hash-set"
" h_2"
" phase_0"
"(1/linklet-add-target-machine-info"
" body-linklet_0"
" from-body-linklet_0)))))))"
"(values"
" h_3))"
" h_2)))"
"(if(not"
" #f)"
"(for-loop_1"
" h_3"
"(hash-iterate-next"
" ht_1"
" i_1))"
" h_3)))"
" h_2))))))"
" for-loop_1)"
" h_1"
"(hash-iterate-first"
" ht_1))))))))"
"(values"
" k_0"
"(recompiled1.1"
" new-b_0"
" #f"
" #f)))))))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(replace-linklet-bundles c_1 '() new-bundles_0)))))))))))))))"
"(define-values"
"(1/compiled-expression-summarize-target-machine)"
"(lambda(from-c_0)"
"(begin"
" 'compiled-expression-summarize-target-machine"
"(let-values((()"
"(begin"
"(if(1/compiled-expression? from-c_0)"
"(void)"
"(let-values()"
"                          (raise-argument-error 'compiled-expression-recompile \"compiled-expression?\" from-c_0)))"
"(values))))"
"(let-values(((get-linklet_0)"
"(lambda(c_0)"
"(begin"
" 'get-linklet"
"(if(let-values(((or-part_0)(1/linklet-bundle? c_0)))"
"(if or-part_0 or-part_0(linklet-directory?$1 c_0)))"
" c_0"
"(compiled-in-memory-linklet-directory c_0))))))"
"(let-values(((from-c_1)(get-linklet_0 from-c_0)))"
"(let-values(((from-bundles_0)(extract-linklet-bundles from-c_1 '() '#hash())))"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0) from-bundles_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 from-b_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(let-values(((from-h_0)"
"(1/linklet-bundle->hash"
" from-b_0)))"
"(let-values(((new-h_0)"
"(let-values(((table_2)"
"(let-values(((table_2)"
" '#hash()))"
" table_2)))"
"(let-values(((ht_1)"
" from-h_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_3"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((phase_0"
" from-body-linklet_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((table_4)"
"(if(exact-integer?"
" phase_0)"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_0"
"(1/linklet-summarize-target-machine-info"
" from-body-linklet_0)))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))"
" table_3)))"
"(if(not"
" #f)"
"(for-loop_1"
" table_4"
"(hash-iterate-next"
" ht_1"
" i_1))"
" table_4)))"
" table_3))))))"
" for-loop_1)"
" table_2"
"(hash-iterate-first"
" ht_1)))))))"
"(values"
" k_0"
" new-h_0))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0))))))))))))"
"(define-values"
"(create-compiled-in-memorys-using-shared-data)"
"(lambda(tops_0 data-linklet_0 ns_0)"
"(begin"
"(let-values(((data-instance_0)"
"(instantiate-linklet$1"
"(force-compile-linklet data-linklet_0)"
"(list"
" deserialize-instance"
"(let-values(((ns1_0) ns_0)"
"((temp2_0)(namespace-phase ns_0))"
"((temp3_0)(namespace-mpi ns_0))"
"((temp4_0)(namespace-bulk-binding-registry ns_0))"
"((temp5_0)(current-code-inspector)))"
"(make-eager-instance-instance.1 temp4_0 temp2_0 temp5_0 ns1_0 temp3_0))))))"
"(let-values(((data_0)(lambda(key_0)(begin 'data(1/instance-variable-value data-instance_0 key_0)))))"
"(let-values(((mpi-vector_0)(data_0 mpi-vector-id)))"
"(let-values(((mpi-vector-trees_0)(data_0 'mpi-vector-trees)))"
"(let-values(((phase-to-link-modules-vector_0)(data_0 'phase-to-link-modules-vector)))"
"(let-values(((phase-to-link-modules-trees_0)(data_0 'phase-to-link-modules-trees)))"
"(let-values(((syntax-literals_0)(data_0 'syntax-literals)))"
"(let-values(((syntax-literals-trees_0)(data_0 'syntax-literals-trees)))"
"(let-values(((namespace-scopes_0)(extract-namespace-scopes ns_0)))"
"(letrec-values(((construct-compiled-in-memory_0)"
"(lambda(ld_0"
" mpi-vector-tree_0"
" phase-to-link-modules-tree_0"
" syntax-literals-tree_0)"
"(begin"
" 'construct-compiled-in-memory"
"(let-values(((is-module?_0)"
"(let-values(((or-part_0)(1/linklet-bundle? ld_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((b_0)"
"(hash-ref"
"(linklet-directory->hash$1 ld_0)"
" #f"
" #f)))"
"(if b_0"
"(hash-ref(1/linklet-bundle->hash b_0) 'decl #f)"
" #f))))))"
"(let-values(((mpi-pos-vec_0)(vector-ref mpi-vector-tree_0 0)))"
"(let-values(((syntax-literals-spec_0)"
"(vector-ref syntax-literals-tree_0 0)))"
"(let-values(((pres_0)"
"(if is-module?_0"
"(extract-submodules ld_0 'pre)"
"(compiled-top->compiled-tops ld_0))))"
"(let-values(((posts_0)"
"(if is-module?_0"
"(extract-submodules ld_0 'post)"
" null)))"
"(let-values(((map-construct-compiled-in-memory_0)"
"(lambda(l_0 vec-pos_0)"
"(begin"
" 'map-construct-compiled-in-memory"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0) l_0)"
"((lst_1)"
"(vector-ref"
" mpi-vector-tree_0"
" vec-pos_0))"
"((lst_2)"
"(vector-ref"
" phase-to-link-modules-tree_0"
" vec-pos_0))"
"((lst_3)"
"(vector-ref"
" syntax-literals-tree_0"
" vec-pos_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_3)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_4"
" lst_5"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_4)"
"(if(pair?"
" lst_5)"
"(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
" #f)"
" #f)"
"(let-values(((sub-ld_0)"
"(unsafe-car"
" lst_4))"
"((rest_0)"
"(unsafe-cdr"
" lst_4))"
"((mpi-vector-tree_1)"
"(unsafe-car"
" lst_5))"
"((rest_1)"
"(unsafe-cdr"
" lst_5))"
"((phase-to-link-modules-tree_1)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((syntax-literals-tree_1)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(construct-compiled-in-memory_0"
" sub-ld_0"
" mpi-vector-tree_1"
" phase-to-link-modules-tree_1"
" syntax-literals-tree_1))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0"
" rest_1"
" rest_2"
" rest_3)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1"
" lst_2"
" lst_3)))))))))"
"(compiled-in-memory1.1"
" ld_0"
" #f"
" #f"
" #f"
" #f"
" #f"
"(vector-ref"
" phase-to-link-modules-vector_0"
"(vector-ref phase-to-link-modules-tree_0 0))"
" #f"
" '#hasheqv()"
" '#hasheqv()"
"(let-values(((len_0)(vector-length mpi-pos-vec_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(1/raise-argument-error"
" 'for/vector"
"                                                                   \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0)"
" mpi-pos-vec_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-vector vec_0)))"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx<"
" pos_0"
" len_1)"
"(let-values(((pos_1)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values(((i_2)"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(vector-ref"
" mpi-vector_0"
" pos_1)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values"
" i_2))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_2"
" len_0))"
" pos_1))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_2"
"(unsafe-fx+"
" 1"
" pos_0))"
" i_2)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" 0)))))"
" v_0))))"
"(let-values(((len_0)(cdr syntax-literals-spec_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(1/raise-argument-error"
" 'for/vector"
"                                                                   \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((start_0) 0)"
"((end_0)"
"(cdr syntax-literals-spec_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values(((i_2)"
" pos_0))"
"(let-values(((i_3)"
"(let-values(((i_3)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(if syntax-literals_0"
"(vector-ref"
" syntax-literals_0"
"(+"
"(car"
" syntax-literals-spec_0)"
" i_2))"
" #f)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values"
" i_3))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_3"
" len_0))"
" i_2))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_3"
"(+"
" pos_0"
" inc_0))"
" i_3)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" start_0))))))"
" v_0))))"
"(map-construct-compiled-in-memory_0 pres_0 1)"
"(map-construct-compiled-in-memory_0 posts_0 2)"
" namespace-scopes_0"
" #f)))))))))))"
"(map2"
" construct-compiled-in-memory_0"
" tops_0"
" mpi-vector-trees_0"
" phase-to-link-modules-trees_0"
" syntax-literals-trees_0))))))))))))))"
"(define-values"
"(extract-submodules)"
"(lambda(ld_0 names-key_0)"
"(begin"
"(if(1/linklet-bundle? ld_0)"
"(let-values() null)"
"(let-values()"
"(let-values(((h_0)(linklet-directory->hash$1 ld_0)))"
"(let-values(((mod_0)(hash-ref h_0 #f #f)))"
"              (let-values ((() (begin (if mod_0 (void) (let-values () (error \"missing main module\"))) (values))))"
"(let-values(((mh_0)(1/linklet-bundle->hash mod_0)))"
"(let-values(((names_0)(hash-ref mh_0 names-key_0 null)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) names_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((name_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(hash-ref"
" h_0"
" name_0"
"(lambda()"
"(error"
"                                                                                            \"missing submodule declaration:\""
" name_0))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))))))))"
"(define-values"
"(eval-single-top)"
"(lambda(c_0 ns_0)"
"(begin(let-values(((c11_0) c_0)((ns12_0) ns_0)((temp13_0) #t))(eval-one-top.1 temp13_0 c11_0 ns12_0 #t)))))"
"(define-values"
"(compiled-multiple-top?)"
"(lambda(c_0)"
"(begin"
"(let-values(((ld_0)(if(compiled-in-memory? c_0)(compiled-in-memory-linklet-directory c_0) c_0)))"
"(if(linklet-directory?$1 ld_0)(not(hash-ref(linklet-directory->hash$1 ld_0) #f #f)) #f)))))"
"(define-values"
"(eval-top)"
"(let-values(((eval-top_0)"
"(lambda(c3_0 ns4_0 eval-compiled1_0 as-tail?2_0)"
"(begin"
" 'eval-top"
"(let-values(((c_0) c3_0))"
"(let-values(((ns_0) ns4_0))"
"(let-values(((eval-compiled_0)"
"(if(eq? eval-compiled1_0 unsafe-undefined) eval-top eval-compiled1_0)))"
"(let-values(((as-tail?_0) as-tail?2_0))"
"(let-values()"
"(if(compiled-multiple-top? c_0)"
"(eval-multiple-tops c_0 ns_0 eval-compiled_0 as-tail?_0)"
"(let-values(((c14_0) c_0)((ns15_0) ns_0)((as-tail?16_0) as-tail?_0))"
"(eval-one-top.1 #f c14_0 ns15_0 as-tail?16_0))))))))))))"
"(case-lambda"
"((c_0 ns_0)(begin(eval-top_0 c_0 ns_0 unsafe-undefined #t)))"
"((c_0 ns_0 eval-compiled_0 as-tail?2_0)(eval-top_0 c_0 ns_0 eval-compiled_0 as-tail?2_0))"
"((c_0 ns_0 eval-compiled1_0)(eval-top_0 c_0 ns_0 eval-compiled1_0 #t)))))"
"(define-values"
"(eval-multiple-tops)"
"(lambda(c_0 ns_0 eval-compiled_0 as-tail?_0)"
"(begin"
"(let-values(((eval-compiled-parts_0)"
"(lambda(l_0)"
"(begin"
" 'eval-compiled-parts"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values() void)"
"(if(null?(cdr l_1))"
"(let-values()(eval-compiled_0(car l_1) ns_0 as-tail?_0))"
"(let-values()"
"(begin"
"(eval-compiled_0(car l_1) ns_0 #f)"
"(loop_0(cdr l_1))))))))))"
" loop_0)"
" l_0)))))"
"(if(compiled-in-memory? c_0)"
"(let-values()(eval-compiled-parts_0(compiled-in-memory-pre-compiled-in-memorys c_0)))"
"(let-values(((c1_0)(hash-ref(linklet-directory->hash$1 c_0) 'data #f)))"
"(if c1_0"
"((lambda(data-ld_0)"
"(eval-compiled-parts_0"
"(create-compiled-in-memorys-using-shared-data"
"(compiled-top->compiled-tops c_0)"
"(hash-ref(1/linklet-bundle->hash(hash-ref(linklet-directory->hash$1 data-ld_0) #f)) 0)"
" ns_0)))"
" c1_0)"
"(let-values()(eval-compiled-parts_0(compiled-top->compiled-tops c_0))))))))))"
"(define-values"
"(eval-one-top.1)"
"(lambda(single-expression?5_0 c8_0 ns9_0 as-tail?7_0)"
"(begin"
" 'eval-one-top"
"(let-values(((c_0) c8_0))"
"(let-values(((ns_0) ns9_0))"
"(let-values(((as-tail?_0) as-tail?7_0))"
"(let-values(((single-expression?_0) single-expression?5_0))"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'eval(if single-expression?_0 'transformer 'top)))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((ld_0)"
"(if(compiled-in-memory? c_0)(compiled-in-memory-linklet-directory c_0) c_0)))"
"(let-values(((h_0)(1/linklet-bundle->hash(hash-ref(linklet-directory->hash$1 ld_0) #f))))"
"(let-values(((link-instance_0)"
"(if(compiled-in-memory? c_0)"
"(link-instance-from-compiled-in-memory"
" c_0"
"(if(not single-expression?_0) ns_0 #f))"
"(instantiate-linklet$1"
"(force-compile-linklet(hash-ref h_0 'link))"
"(list"
" deserialize-instance"
"(let-values(((ns17_0) ns_0)"
"((temp18_0)(namespace-phase ns_0))"
"((temp19_0)(namespace-mpi ns_0))"
"((temp20_0)(namespace-bulk-binding-registry ns_0))"
"((temp21_0)(current-code-inspector)))"
"(make-eager-instance-instance.1"
" temp20_0"
" temp18_0"
" temp21_0"
" ns17_0"
" temp19_0)))))))"
"(let-values(((orig-phase_0)(hash-ref h_0 'original-phase)))"
"(let-values(((max-phase_0)(hash-ref h_0 'max-phase)))"
"(let-values(((phase-shift_0)(phase-(namespace-phase ns_0) orig-phase_0)))"
"(let-values(((extra-inspector_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-compile-time-inspector c_0)"
" #f)))"
"(let-values(((phase-to-link-extra-inspectorsss_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss c_0)"
" '#hasheqv())))"
"(let-values(((phase-to-link-modules_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-phase-to-link-module-uses c_0)"
"(1/instance-variable-value"
" link-instance_0"
" 'phase-to-link-modules))))"
"(let-values(((thunk_0)"
"(let-values(((prev-thunk_0)"
"(let-values(((prev-thunk_0) void)) prev-thunk_0)))"
"(let-values(((start_0) max-phase_0)"
"((end_0)(sub1 orig-phase_0))"
"((inc_0) -1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(prev-thunk_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(> pos_0 end_0)"
"(let-values(((phase_0) pos_0))"
"(let-values(((prev-thunk_2)"
"(let-values(((prev-thunk_2)"
"(let-values()"
"(let-values((()"
"(begin"
"(prev-thunk_1"
" #f)"
"(values))))"
"(let-values(((module-uses_0)"
"(hash-ref"
" phase-to-link-modules_0"
" phase_0"
" null)))"
"(let-values(((import-module-instances_0"
" import-instances_0)"
"(let-values(((mis_0"
" is_0)"
"(let-values(((mis_0)"
"(let-values(((mis_0)"
" null))"
" mis_0))"
"((is_0)"
"(let-values(((is_0)"
" null))"
" is_0)))"
"(let-values(((lst_0)"
" module-uses_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(mis_1"
" is_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((mu_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((mis_2"
" is_2)"
"(let-values(((mis_2"
" is_2)"
"(let-values()"
"(let-values(((mis22_0"
" is23_0)"
"(let-values()"
"(let-values(((ns24_0)"
" ns_0)"
"((mu25_0)"
" mu_0)"
"((temp26_0)"
"(phase-"
"(phase+"
" phase_0"
" phase-shift_0)"
"(module-use-phase"
" mu_0))))"
"(namespace-module-use->module+linklet-instances.1"
" temp26_0"
" #f"
" #f"
" #f"
" ns24_0"
" mu25_0)))))"
"(values"
"(cons"
" mis22_0"
" mis_1)"
"(cons"
" is23_0"
" is_1))))))"
"(values"
" mis_2"
" is_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" mis_2"
" is_2"
" rest_0)"
"(values"
" mis_2"
" is_2))))"
"(values"
" mis_1"
" is_1)))))))"
" for-loop_1)"
" mis_0"
" is_0"
" lst_0))))))"
"(values"
"(reverse$1"
" mis_0)"
"(reverse$1"
" is_0)))))"
"(let-values(((phase-ns_0)"
"(namespace->namespace-at-phase"
" ns_0"
"(phase+"
" phase_0"
" phase-shift_0))))"
"(let-values(((inst_0)"
"(if single-expression?_0"
" link-instance_0"
"(let-values(((phase-ns27_0)"
" phase-ns_0)"
"((phase-shift28_0)"
" phase-shift_0)"
"((temp29_0)"
"(namespace-mpi"
" ns_0))"
"((temp30_0)"
"(namespace-inspector"
" ns_0))"
"((temp31_0)"
"(namespace-bulk-binding-registry"
" ns_0))"
"((temp32_0)"
"(lambda(name_0"
" val_0)"
"(namespace-set-transformer!"
" ns_0"
"(phase+"
"(sub1"
" phase_0)"
" phase-shift_0)"
" name_0"
" val_0))))"
"(make-instance-instance.1"
" temp31_0"
" temp30_0"
" phase-ns27_0"
" phase-shift28_0"
" temp29_0"
" temp32_0)))))"
"(let-values(((linklet_0)"
"(force-compile-linklet"
"(hash-ref"
" h_0"
" phase_0"
" #f))))"
"(if linklet_0"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((linklet33_0)"
" linklet_0)"
"((temp34_0)"
" 3)"
"((module-uses35_0)"
" module-uses_0)"
"((import-module-instances36_0)"
" import-module-instances_0)"
"((temp37_0)"
"(current-code-inspector))"
"((extra-inspector38_0)"
" extra-inspector_0)"
"((temp39_0)"
"(hash-ref"
" phase-to-link-extra-inspectorsss_0"
" phase_0"
" #f)))"
"(check-require-access.1"
" temp34_0"
" linklet33_0"
" module-uses35_0"
" import-module-instances36_0"
" temp37_0"
" extra-inspector38_0"
" temp39_0))"
"(values))))"
"(let-values(((instantiate_0)"
"(lambda(tail?_0)"
"(begin"
" 'instantiate"
"(instantiate-linklet$1"
" linklet_0"
"(list*"
" top-level-instance"
" link-instance_0"
" inst_0"
" import-instances_0)"
"(namespace->instance"
" ns_0"
"(phase-"
"(phase+"
" phase_0"
" phase-shift_0)"
"(namespace-0-phase"
" ns_0)))"
"(not"
" tail?_0))))))"
"(if(zero-phase?"
" phase_0)"
"(let-values()"
" instantiate_0)"
"(if single-expression?_0"
"(let-values()"
"(lambda(tail?_0)"
"(begin"
" 'prev-thunk"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" phase-ns_0)"
"(let-values()"
"(instantiate_0"
" tail?_0))))))"
"(let-values()"
"(let-values(((ns-1_0)"
"(namespace->namespace-at-phase"
" phase-ns_0"
"(sub1"
" phase_0))))"
"(lambda(tail?_0)"
"(begin"
" 'prev-thunk"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" phase-ns_0)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
"(let-values(((ns-140_0)"
" ns-1_0))"
"(make-expand-context.1"
" #f"
" #f"
" #f"
" #f"
" #f"
" ns-140_0))"
"(let-values()"
"(instantiate_0"
" tail?_0))))))))))))))"
"(let-values()"
" void)))))))))))"
"(values"
" prev-thunk_2))))"
"(if(not #f)"
"(for-loop_0"
" prev-thunk_2"
"(+ pos_0 inc_0))"
" prev-thunk_2)))"
" prev-thunk_1))))))"
" for-loop_0)"
" prev-thunk_0"
" start_0))))))"
"(thunk_0 as-tail?_0))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))"
"(define-values"
"(link-instance-from-compiled-in-memory)"
"(lambda(cim_0 to-ns_0)"
"(begin"
"(let-values(((orig-syntax-literals_0)(compiled-in-memory-syntax-literals cim_0)))"
"(let-values(((syntax-literals_0)"
"(if(not to-ns_0)"
"(let-values() orig-syntax-literals_0)"
"(if(namespace-scopes=?"
"(compiled-in-memory-namespace-scopes cim_0)"
"(extract-namespace-scopes to-ns_0))"
"(let-values() orig-syntax-literals_0)"
"(let-values()"
"(let-values(((len_0)(vector-length orig-syntax-literals_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"                                    (1/raise-argument-error 'for/vector \"exact-nonnegative-integer?\" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) orig-syntax-literals_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_0)))"
"(values vec_0(unsafe-vector-length vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_1)"
"(let-values(((s_0)"
"(unsafe-vector-ref vec_0 pos_0)))"
"(let-values(((i_2)"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(swap-top-level-scopes"
" s_0"
"(compiled-in-memory-namespace-scopes"
" cim_0)"
" to-ns_0)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values i_2))))"
"(if(if(not"
"((lambda x_0(unsafe-fx= i_2 len_0))"
" s_0))"
"(not #f)"
" #f)"
"(for-loop_0 i_2(unsafe-fx+ 1 pos_0))"
" i_2)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" 0)))))"
" v_0)))))))))"
"(1/make-instance"
" 'link"
" #f"
" 'constant"
" mpi-vector-id"
"(compiled-in-memory-mpis cim_0)"
" syntax-literals-id"
" syntax-literals_0))))))"
"(define-values(not-available)(gensym 'not-available))"
"(define-values(get-not-available)(lambda()(begin not-available)))"
"(define-values"
"(can-direct-eval?)"
"(lambda(p_0 ns_0 self-mpi_0)"
"(begin"
"(if(parsed-app? p_0)"
"(let-values()"
"(if(can-direct-eval?(parsed-app-rator p_0) ns_0 self-mpi_0)"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0)(parsed-app-rands p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((r_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(can-direct-eval? r_0 ns_0 self-mpi_0)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) r_0))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f))"
"(if(parsed-id? p_0)"
"(let-values()(not(eq?(get-id-value p_0 ns_0 self-mpi_0) not-available)))"
"(if(parsed-quote? p_0)"
"(let-values() #t)"
"(if(parsed-quote-syntax? p_0)(let-values() #t)(let-values() #f))))))))"
"(define-values"
"(direct-eval)"
"(lambda(p_0 ns_0 self-mpi_0)"
"(begin"
"(if(parsed-app? p_0)"
"(let-values()"
"(apply"
"(direct-eval(parsed-app-rator p_0) ns_0 self-mpi_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(parsed-app-rands p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((r_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(direct-eval r_0 ns_0 self-mpi_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(if(parsed-id? p_0)"
"(let-values()(get-id-value p_0 ns_0 self-mpi_0))"
"(if(parsed-quote? p_0)"
"(let-values()(parsed-quote-datum p_0))"
"(if(parsed-quote-syntax? p_0)(let-values()(parsed-quote-syntax-datum p_0))(let-values() #f))))))))"
"(define-values"
"(get-id-value)"
"(lambda(p_0 ns_0 self-mpi_0)"
"(begin"
"(let-values(((b_0)(parsed-id-binding p_0)))"
"(if(parsed-primitive-id? p_0)"
"(let-values()(hash-ref(1/primitive-table '#%kernel)(module-binding-sym b_0) get-not-available))"
"(if(let-values(((or-part_0)(parsed-top-id? p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(not b_0)))"
"(if or-part_1 or-part_1(eq? self-mpi_0(module-binding-module b_0))))))"
"(let-values()"
"(namespace-get-variable"
" ns_0"
"(if b_0(module-binding-phase b_0)(namespace-phase ns_0))"
"(if b_0(module-binding-sym b_0)(syntax-e$1(parsed-s p_0)))"
" get-not-available))"
"(let-values()"
"(let-values(((mi_0)"
"(let-values(((ns1_0) ns_0)"
"((temp2_0)(1/module-path-index-resolve(module-binding-module b_0)))"
"((temp3_0)(phase-(namespace-phase ns_0)(module-binding-phase b_0))))"
"(namespace->module-instance.1 #f #f void ns1_0 temp2_0 temp3_0))))"
"(if(not mi_0)"
"(let-values() not-available)"
"(if(check-single-require-access"
" mi_0"
"(module-binding-phase b_0)"
"(module-binding-sym b_0)"
"(module-binding-extra-inspector b_0))"
"(let-values()"
"(namespace-get-variable"
"(module-instance-namespace mi_0)"
"(module-binding-phase b_0)"
"(module-binding-sym b_0)"
" get-not-available))"
"(let-values() not-available)))))))))))"
"(define-values(runtime-scope)(new-multi-scope))"
"(define-values(runtime-stx)(add-scope empty-syntax runtime-scope))"
"(define-values(runtime-module-name)(1/make-resolved-module-path '#%runtime))"
"(define-values(runtime-mpi)(module-path-index-join* ''#%runtime #f))"
"(define-values"
"(add-runtime-primitive!)"
"(lambda(sym_0)"
"(begin"
"(let-values(((temp1_0)(syntax-scope-set runtime-stx 0))"
"((sym2_0) sym_0)"
"((temp3_0)"
"(let-values(((runtime-mpi4_0) runtime-mpi)((temp5_0) 0)((sym6_0) sym_0))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" runtime-mpi4_0"
" temp5_0"
" sym6_0))))"
"(add-binding-in-scopes!.1 #f temp1_0 sym2_0 temp3_0)))))"
"(void"
"(begin"
"(add-runtime-primitive! 'values)"
"(add-runtime-primitive! 'cons)"
"(add-runtime-primitive! 'list)"
"(add-runtime-primitive! 'make-struct-type)"
"(add-runtime-primitive! 'make-struct-type-property)"
"(add-runtime-primitive! 'gensym)"
"(add-runtime-primitive! 'string->uninterned-symbol)))"
"(define-values"
"(runtime-instances)"
" '(#%kernel #%paramz #%foreign #%unsafe #%flfxnum #%extfl #%network #%place #%futures #%terminal))"
"(define-values(box-cons!)(lambda(b_0 v_0)(begin(set-box! b_0(cons v_0(unbox b_0))))))"
"(define-values(box-clear!)(lambda(b_0)(begin(begin0(reverse$1(unbox b_0))(set-box! b_0 null)))))"
"(define-values"
"(struct:lift-context lift-context1.1 lift-context? lift-context-convert lift-context-lifts lift-context-module*-ok?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'lift-context"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'lift-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'convert)"
"(make-struct-field-accessor -ref_0 1 'lifts)"
"(make-struct-field-accessor -ref_0 2 'module*-ok?))))"
"(define-values"
"(struct:lifted-bind lifted-bind2.1 lifted-bind? lifted-bind-ids lifted-bind-keys lifted-bind-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'lifted-bind"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'lifted-bind)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'ids)"
"(make-struct-field-accessor -ref_0 1 'keys)"
"(make-struct-field-accessor -ref_0 2 'rhs))))"
"(define-values"
"(make-lift-context.1)"
"(lambda(module*-ok?3_0 convert5_0)"
"(begin"
" 'make-lift-context"
"(let-values(((convert_0) convert5_0))"
"(let-values(((module*-ok?_0) module*-ok?3_0))"
"(let-values()(lift-context1.1 convert_0(box null) module*-ok?_0)))))))"
"(define-values"
"(add-lifted!)"
"(lambda(lifts_0 ids_0 rhs_0 phase_0)"
"(begin"
"(let-values(((lifted-ids_0 lifted_0)((lift-context-convert lifts_0) ids_0 rhs_0 phase_0)))"
"(begin(box-cons!(lift-context-lifts lifts_0) lifted_0) lifted-ids_0)))))"
"(define-values(get-and-clear-lifts!)(lambda(lifts_0)(begin(box-clear!(lift-context-lifts lifts_0)))))"
"(define-values"
"(make-local-lift)"
"(lambda(lift-env_0 counter_0 local-sym_0)"
"(begin"
"(lambda(ids_0 rhs_0 phase_0)"
"(let-values(((keys_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((key_0)"
"(let-values(((id29_0)"
" id_0)"
"((phase30_0)"
" phase_0)"
"((counter31_0)"
" counter_0)"
"((local-sym32_0)"
" local-sym_0))"
"(add-local-binding!.1"
" #f"
" #f"
" local-sym32_0"
" id29_0"
" phase30_0"
" counter31_0))))"
"(begin"
"(set-box!"
" lift-env_0"
"(env-extend"
"(unbox lift-env_0)"
" key_0"
" variable))"
" key_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(values ids_0(lifted-bind2.1 ids_0 keys_0 rhs_0)))))))"
"(define-values"
"(make-top-level-lift)"
"(lambda(ctx_0)"
"(begin"
"(lambda(ids_0 rhs_0 phase_0)"
"(let-values(((post-scope_0)"
"(post-expansion-scope"
"(root-expand-context-post-expansion"
"(namespace-get-root-expand-ctx(expand-context-namespace ctx_0))))))"
"(let-values(((tl-ids_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" post-scope_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((syms_0)(select-defined-syms-and-bind!/ctx tl-ids_0 ctx_0)))"
"(values tl-ids_0(lifted-bind2.1 tl-ids_0 syms_0 rhs_0)))))))))"
"(define-values"
"(wrap-lifts-as-let)"
"(lambda(lifts_0 body_0 phase_0)"
"(begin"
"(datum->syntax$1"
" #f"
"(let-values(((body_1)(let-values(((body_1) body_0)) body_1)))"
"(let-values(((lst_0)(reverse$1 lifts_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(body_2 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((lift_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((body_3)"
"(let-values(((body_3)"
"(let-values()"
"(begin"
"(if(lifted-bind? lift_0)"
"(void)"
"(let-values()"
"                                                                             (error \"non-bindings in `lift-context`\")))"
"(list"
"(datum->syntax$1"
"(syntax-shift-phase-level$1 core-stx phase_0)"
" 'let-values)"
"(list"
"(list"
"(lifted-bind-ids lift_0)"
"(lifted-bind-rhs lift_0)))"
" body_2)))))"
"(values body_3))))"
"(if(not #f)(for-loop_0 body_3 rest_0) body_3)))"
" body_2))))))"
" for-loop_0)"
" body_1"
" lst_0))))))))"
"(define-values"
"(wrap-lifts-as-begin.1)"
"(lambda(adjust-body8_0 adjust-form7_0 lifts11_0 body12_0 phase13_0)"
"(begin"
" 'wrap-lifts-as-begin"
"(let-values(((lifts_0) lifts11_0))"
"(let-values(((body_0) body12_0))"
"(let-values(((phase_0) phase13_0))"
"(let-values(((adjust-form_0)(if(eq? adjust-form7_0 unsafe-undefined) values adjust-form7_0)))"
"(let-values(((adjust-body_0)(if(eq? adjust-body8_0 unsafe-undefined) values adjust-body8_0)))"
"(let-values()"
"(datum->syntax$1"
" #f"
"(cons"
"(datum->syntax$1(syntax-shift-phase-level$1 core-stx phase_0) 'begin)"
"(append"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) lifts_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((lift_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(adjust-form_0"
"(if(lifted-bind? lift_0)"
"(let-values()"
"(datum->syntax$1"
" #f"
"(list"
"(datum->syntax$1"
"(syntax-shift-phase-level$1"
" core-stx"
" phase_0)"
" 'define-values)"
"(lifted-bind-ids lift_0)"
"(lifted-bind-rhs"
" lift_0))))"
"(let-values() lift_0))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
"(list(adjust-body_0 body_0))))))))))))))"
"(define-values"
"(get-lifts-as-lists)"
"(lambda(lifts_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) lifts_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((lift_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
"(lifted-bind-ids lift_0)"
"(lifted-bind-keys lift_0)"
"(lifted-bind-rhs lift_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(define-values"
"(struct:module-lift-context"
" module-lift-context15.1"
" module-lift-context?"
" module-lift-context-wrt-phase"
" module-lift-context-lifts"
" module-lift-context-module*-ok?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-lift-context"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'module-lift-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'wrt-phase)"
"(make-struct-field-accessor -ref_0 1 'lifts)"
"(make-struct-field-accessor -ref_0 2 'module*-ok?))))"
"(define-values"
"(make-module-lift-context)"
"(lambda(phase_0 module*-ok?_0)(begin(module-lift-context15.1 phase_0(box null) module*-ok?_0))))"
"(define-values"
"(get-and-clear-module-lifts!)"
"(lambda(module-lifts_0)(begin(box-clear!(module-lift-context-lifts module-lifts_0)))))"
"(define-values"
"(add-lifted-module!)"
"(lambda(module-lifts_0 s_0 phase_0)"
"(begin"
"(begin"
"(if(let-values(((or-part_0)"
"(if(module-lift-context? module-lifts_0)"
"(module-lift-context-module*-ok? module-lifts_0)"
" #f)))"
"(if or-part_0 or-part_0(if(lift-context? module-lifts_0)(lift-context-module*-ok? module-lifts_0) #f)))"
"(void)"
"(let-values()"
"(let-values(((tmp_0)(core-form-sym s_0 phase_0)))"
"(if(equal? tmp_0 'module)"
"(let-values()(void))"
"(if(equal? tmp_0 'module*)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-local-lift-module"
"                     \"cannot lift `module*' to a top-level context\""
"                     \"syntax\""
" s_0))"
"(let-values()"
"                    (raise-arguments-error 'syntax-local-lift-module \"not a `module' declaration\" \"syntax\" s_0)))))))"
"(if(module-lift-context? module-lifts_0)"
"(let-values()(box-cons!(module-lift-context-lifts module-lifts_0) s_0))"
"(if(lift-context? module-lifts_0)"
"(let-values()(box-cons!(lift-context-lifts module-lifts_0) s_0))"
"            (let-values () (error \"internal error: unrecognized lift-context type for module lift\"))))))))"
"(define-values"
"(struct:require-lift-context"
" require-lift-context16.1"
" require-lift-context?"
" require-lift-context-do-require"
" require-lift-context-wrt-phase"
" require-lift-context-requires)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'require-lift-context"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'require-lift-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'do-require)"
"(make-struct-field-accessor -ref_0 1 'wrt-phase)"
"(make-struct-field-accessor -ref_0 2 'requires))))"
"(define-values"
"(make-require-lift-context)"
"(let-values(((make-require-lift-context_0)"
"(lambda(wrt-phase18_0 do-require19_0 initial-lifts17_0)"
"(begin"
" 'make-require-lift-context"
"(let-values(((wrt-phase_0) wrt-phase18_0))"
"(let-values(((do-require_0) do-require19_0))"
"(let-values(((initial-lifts_0) initial-lifts17_0))"
"(let-values()"
"(require-lift-context16.1 do-require_0 wrt-phase_0(box initial-lifts_0))))))))))"
"(case-lambda"
"((wrt-phase_0 do-require_0)(begin(make-require-lift-context_0 wrt-phase_0 do-require_0 null)))"
"((wrt-phase_0 do-require_0 initial-lifts17_0)"
"(make-require-lift-context_0 wrt-phase_0 do-require_0 initial-lifts17_0)))))"
"(define-values"
"(get-require-lifts)"
"(lambda(require-lifts_0)(begin(unbox(require-lift-context-requires require-lifts_0)))))"
"(define-values"
"(get-and-clear-require-lifts!)"
"(lambda(require-lifts_0)(begin(box-clear!(require-lift-context-requires require-lifts_0)))))"
"(define-values"
"(add-lifted-require!)"
"(lambda(require-lifts_0 s_0 phase_0)"
"(begin"
"(let-values(((r_0)((require-lift-context-do-require require-lifts_0) s_0 phase_0)))"
"(box-cons!(require-lift-context-requires require-lifts_0) r_0)))))"
"(define-values"
"(struct:to-module-lift-context"
" to-module-lift-context20.1"
" to-module-lift-context?"
" to-module-lift-context-wrt-phase"
" to-module-lift-context-provides"
" to-module-lift-context-end-as-expressions?"
" to-module-lift-context-ends)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'to-module-lift-context"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'to-module-lift-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'wrt-phase)"
"(make-struct-field-accessor -ref_0 1 'provides)"
"(make-struct-field-accessor -ref_0 2 'end-as-expressions?)"
"(make-struct-field-accessor -ref_0 3 'ends))))"
"(define-values"
"(make-to-module-lift-context.1)"
"(lambda(end-as-expressions?22_0 shared-module-ends21_0 phase25_0)"
"(begin"
" 'make-to-module-lift-context"
"(let-values(((phase_0) phase25_0))"
"(let-values(((ends_0) shared-module-ends21_0))"
"(let-values(((end-as-expressions?_0) end-as-expressions?22_0))"
"(let-values()(to-module-lift-context20.1 phase_0(box null) end-as-expressions?_0 ends_0))))))))"
"(define-values(make-shared-module-ends)(lambda()(begin(box null))))"
"(define-values"
"(get-and-clear-end-lifts!)"
"(lambda(to-module-lifts_0)(begin(box-clear!(to-module-lift-context-ends to-module-lifts_0)))))"
"(define-values"
"(get-and-clear-provide-lifts!)"
"(lambda(to-module-lifts_0)(begin(box-clear!(to-module-lift-context-provides to-module-lifts_0)))))"
"(define-values"
"(add-lifted-to-module-provide!)"
"(lambda(to-module-lifts_0 s_0 phase_0)(begin(box-cons!(to-module-lift-context-provides to-module-lifts_0) s_0))))"
"(define-values"
"(add-lifted-to-module-end!)"
"(lambda(to-module-lifts_0 s_0 phase_0)(begin(box-cons!(to-module-lift-context-ends to-module-lifts_0) s_0))))"
"(define-values"
"(struct:already-expanded already-expanded1.1 already-expanded? already-expanded-s already-expanded-binding-layer)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'expanded-syntax"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'already-expanded)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'binding-layer))))"
"(define-values"
"(1/prop:liberal-define-context has-liberal-define-context-property? liberal-define-context-value)"
"(make-struct-type-property 'liberal-define-context))"
"(define-values"
"(struct:liberal-define-context make-liberal-define-context 1/liberal-define-context?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'liberal-define-context"
" #f"
" 0"
" 0"
" #f"
"(list(cons 1/prop:liberal-define-context #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'make-liberal-define-context)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(1/prop:expansion-contexts expansion-contexts? expansion-contexts-ref)"
"(make-struct-type-property"
" 'expansion-contexts"
"(lambda(v_0 info_0)"
"(begin"
"(if(if(list? v_0)"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((lst_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(memq"
" s_0"
" '(expression"
" top-level"
" module"
" module-begin"
" definition-context))))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) s_0))(not #f) #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'guard-for-prop:expansion-contexts"
"            \"(listof (or/c 'expression 'top-level 'module 'module-begin 'definition-context))\""
" v_0)))"
" v_0))))"
"(define-values"
"(not-in-this-expand-context?)"
"(lambda(t_0 ctx_0)"
"(begin"
"(if(expansion-contexts? t_0)"
"(not(memq(context->symbol(expand-context-context ctx_0))(expansion-contexts-ref t_0)))"
" #f))))"
"(define-values(context->symbol)(lambda(context_0)(begin(if(symbol? context_0) context_0 'definition-context))))"
"(define-values"
"(avoid-current-expand-context)"
"(lambda(s_0 t_0 ctx_0)"
"(begin"
"(let-values(((wrap_0)"
"(lambda(sym_0)"
"(begin"
" 'wrap"
"(datum->syntax$1"
" #f"
"(list"
"(syntax-shift-phase-level$1(datum->syntax$1 core-stx sym_0)(expand-context-phase ctx_0))"
" s_0))))))"
"(let-values(((fail_0)"
"(lambda()"
"(begin"
" 'fail"
"(raise-syntax-error$1"
" #f"
"(format"
"                            \"not allowed in context\\n  expansion context: ~a\""
"(context->symbol(expand-context-context ctx_0)))"
" s_0)))))"
"(let-values(((tmp_0)(context->symbol(expand-context-context ctx_0))))"
"(if(equal? tmp_0 'module-begin)"
"(let-values()(wrap_0 'begin))"
"(if(if(equal? tmp_0 'module) #t(if(equal? tmp_0 'top-level) #t(equal? tmp_0 'definition-context)))"
"(let-values()(if(memq 'expression(expansion-contexts-ref t_0))(wrap_0 '#%expression)(fail_0)))"
"(let-values()(fail_0))))))))))"
"(define-values"
"(struct:reference-record"
" reference-record1.1"
" reference-record?"
" reference-record-already-bound"
" reference-record-reference-before-bound"
" reference-record-all-referenced?"
" set-reference-record-already-bound!"
" set-reference-record-reference-before-bound!"
" set-reference-record-all-referenced?!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'reference-record"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
" #f"
" #f"
" '()"
" #f"
" 'reference-record)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'already-bound)"
"(make-struct-field-accessor -ref_0 1 'reference-before-bound)"
"(make-struct-field-accessor -ref_0 2 'all-referenced?)"
"(make-struct-field-mutator -set!_0 0 'already-bound)"
"(make-struct-field-mutator -set!_0 1 'reference-before-bound)"
"(make-struct-field-mutator -set!_0 2 'all-referenced?))))"
"(define-values(make-reference-record)(lambda()(begin(reference-record1.1(seteq)(seteq) #f))))"
"(define-values"
"(reference-record-used!)"
"(lambda(rr_0 key_0)"
"(begin"
"(if(set-member?(reference-record-already-bound rr_0) key_0)"
"(void)"
"(let-values()"
"(set-reference-record-reference-before-bound!"
" rr_0"
"(set-add(reference-record-reference-before-bound rr_0) key_0)))))))"
"(define-values"
"(reference-records-all-used!)"
"(lambda(rrs_0)"
"(begin"
"(begin"
"(let-values()"
"(let-values(((lst_0) rrs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((rr_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values()"
"(let-values(((next-k-proc_0)"
"(lambda()(begin 'next-k-proc(for-loop_0 rest_0)))))"
"(if(reference-record-all-referenced? rr_0)"
"(values)"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(set-reference-record-all-referenced?! rr_0 #t))"
"(values)))))"
"(let-values()(next-k-proc_0)))))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))"
"(define-values"
"(reference-record-bound!)"
"(lambda(rr_0 keys_0)"
"(begin"
"(begin"
"(set-reference-record-already-bound!"
" rr_0"
"(let-values(((ab_0)(let-values(((ab_0)(reference-record-already-bound rr_0))) ab_0)))"
"(let-values(((lst_0) keys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ab_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((key_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ab_2)"
"(let-values(((ab_2)(let-values()(set-add ab_1 key_0))))"
"(values ab_2))))"
"(if(not #f)(for-loop_0 ab_2 rest_0) ab_2)))"
" ab_1))))))"
" for-loop_0)"
" ab_0"
" lst_0)))))"
"(set-reference-record-reference-before-bound!"
" rr_0"
"(let-values(((rbb_0)(let-values(((rbb_0)(reference-record-reference-before-bound rr_0))) rbb_0)))"
"(let-values(((lst_0) keys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(rbb_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((key_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((rbb_2)"
"(let-values(((rbb_2)"
"(let-values()(set-remove rbb_1 key_0))))"
"(values rbb_2))))"
"(if(not #f)(for-loop_0 rbb_2 rest_0) rbb_2)))"
" rbb_1))))))"
" for-loop_0)"
" rbb_0"
" lst_0)))))))))"
"(define-values"
"(reference-record-forward-references?)"
"(lambda(rr_0)"
"(begin"
"(let-values(((or-part_0)(reference-record-all-referenced? rr_0)))"
"(if or-part_0 or-part_0(positive?(set-count(reference-record-reference-before-bound rr_0))))))))"
"(define-values"
"(reference-record-clear!)"
"(lambda(rr_0)"
"(begin"
"(begin(set-reference-record-already-bound! rr_0 #f)(set-reference-record-reference-before-bound! rr_0 #f)))))"
"(define-values"
"(call-expand-observe)"
"(lambda(obs_0 key_0 . args_0)"
"(begin"
"(begin"
"(let-values(((c1_0)(hash-ref key->arity key_0 #f)))"
"(if c1_0"
"((lambda(arity_0)"
"(if(let-values(((or-part_0)(eq? arity_0 'any)))"
"(if or-part_0 or-part_0(eqv?(length args_0) arity_0)))"
"(void)"
"                 (let-values () (error 'call-expand-observe \"wrong arity for ~s: ~e\" key_0 args_0))))"
" c1_0)"
"            (let-values () (error 'call-expand-observe \"bad key: ~s\" key_0))))"
"(obs_0 key_0(if(null? args_0)(let-values() #f)(let-values()(apply list* args_0))))))))"
"(define-values"
"(key->arity)"
" '#hash((block->letrec . 3)"
"(block->list . 0)"
"(block-renames . 2)"
"(enter-begin-for-syntax . 0)"
"(enter-bind . 0)"
"(enter-block . 1)"
"(enter-list . 1)"
"(enter-local . 1)"
"(enter-macro . 2)"
"(enter-prim . 1)"
"(exit-begin-for-syntax . 0)"
"(exit-bind . 0)"
"(exit-case . 1)"
"(exit-list . 1)"
"(exit-local . 1)"
"(exit-local-bind . 0)"
"(exit-macro . 2)"
"(exit-prim . 1)"
"(exit-prim/return . 1)"
"(finish-block . 1)"
"(lambda-renames . 2)"
"(letX-renames . 5)"
"(letlift-loop . 1)"
"(lift-end-decl . 3)"
"(lift-expr . 3)"
"(lift-loop . 1)"
"(lift-module . 2)"
"(lift-provide . 1)"
"(lift-require . 3)"
"(local-bind . 1)"
"(local-post . 1)"
"(local-pre . 1)"
"(local-value . 1)"
"(local-value-result . 1)"
"(macro-post-x . 2)"
"(macro-pre-x . 1)"
"(module-body . 1)"
"(module-end-lifts . 1)"
"(module-lift-end-loop . 1)"
"(module-lift-loop . 1)"
"(module-pass1-case . 1)"
"(module-pass1-lifts . 3)"
"(module-pass2-lifts . 3)"
"(next . 0)"
"(next-group . 0)"
"(opaque-expr . 1)"
"(phase-up . 0)"
"(prepare-env . 0)"
"(prim-#%app . 1)"
"(prim-#%datum . 1)"
"(prim-#%expression . 1)"
"(prim-#%stratified . 1)"
"(prim-#%top . 1)"
"(prim-#%variable-reference . 1)"
"(prim-begin . 1)"
"(prim-begin-for-syntax . 1)"
"(prim-begin0 . 1)"
"(prim-case-lambda . 1)"
"(prim-declare . 1)"
"(prim-define-syntaxes . 1)"
"(prim-define-values . 1)"
"(prim-if . 1)"
"(prim-lambda . 1)"
"(prim-let-values . 1)"
"(prim-letrec-syntaxes+values . 1)"
"(prim-letrec-values . 1)"
"(prim-module . 1)"
"(prim-module-begin . 1)"
"(prim-provide . 1)"
"(prim-quote . 1)"
"(prim-quote-syntax . 1)"
"(prim-require . 1)"
"(prim-set! . 1)"
"(prim-stop . 1)"
"(prim-submodule . 1)"
"(prim-submodule* . 1)"
"(prim-with-continuation-mark . 1)"
"(rename-list . 1)"
"(rename-one . 1)"
"(rename-transformer . 1)"
"(resolve . 1)"
"(return . 1)"
"(splice . 1)"
"(start . 0)"
"(start-top . 0)"
"(stop/return . 1)"
"(tag . 1)"
"(tag/context . 1)"
"(tag2 . 2)"
"(track-syntax . 3)"
"(variable . 2)"
"(visit . 1)))"
"(define-values"
"(rebuild.1)"
"(lambda(track?1_0 orig-s3_0 new4_0)"
"(begin"
" 'rebuild"
"(let-values(((orig-s_0) orig-s3_0))"
"(let-values(((new_0) new4_0))"
"(let-values(((track?_0) track?1_0))"
"(let-values()(datum->syntax$1 orig-s_0 new_0 orig-s_0(if track?_0 orig-s_0 #f)))))))))"
"(define-values"
"(struct:expanded+parsed expanded+parsed1.1 expanded+parsed? expanded+parsed-s expanded+parsed-parsed)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'expanded+parsed"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'expanded+parsed)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'parsed))))"
"(define-values"
"(struct:semi-parsed-define-values"
" semi-parsed-define-values2.1"
" semi-parsed-define-values?"
" semi-parsed-define-values-s"
" semi-parsed-define-values-syms"
" semi-parsed-define-values-ids"
" semi-parsed-define-values-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'semi-parsed-define-values"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'semi-parsed-define-values)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'syms)"
"(make-struct-field-accessor -ref_0 2 'ids)"
"(make-struct-field-accessor -ref_0 3 'rhs))))"
"(define-values"
"(struct:semi-parsed-begin-for-syntax"
" semi-parsed-begin-for-syntax3.1"
" semi-parsed-begin-for-syntax?"
" semi-parsed-begin-for-syntax-s"
" semi-parsed-begin-for-syntax-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'semi-parsed-begin-for-syntax"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'semi-parsed-begin-for-syntax)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'body))))"
"(define-values(extract-syntax)(lambda(s_0)(begin(if(expanded+parsed? s_0)(expanded+parsed-s s_0) s_0))))"
"(define-values"
"(parsed-only)"
"(lambda(l_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(if(let-values(((or-part_0)(parsed? i_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(expanded+parsed? i_0)))"
"(if or-part_1"
" or-part_1"
"(semi-parsed-begin-for-syntax? i_0)))))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(expanded+parsed? i_0)"
"(let-values()"
"(expanded+parsed-parsed i_0))"
"(if(semi-parsed-begin-for-syntax? i_0)"
"(let-values()"
"(parsed-begin-for-syntax21.1"
"(semi-parsed-begin-for-syntax-s i_0)"
"(parsed-only"
"(semi-parsed-begin-for-syntax-body"
" i_0))))"
"(let-values() i_0))))"
" fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(define-values"
"(syntax-only)"
"(lambda(l_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(if(let-values(((or-part_0)(syntax?$1 i_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(expanded+parsed? i_0)))"
"(if or-part_1"
" or-part_1"
"(semi-parsed-begin-for-syntax? i_0)))))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(expanded+parsed? i_0)"
"(let-values()(expanded+parsed-s i_0))"
"(if(semi-parsed-begin-for-syntax? i_0)"
"(let-values()"
"(let-values(((s_0)"
"(semi-parsed-begin-for-syntax-s"
" i_0)))"
"(let-values(((nested-bodys_0)"
"(semi-parsed-begin-for-syntax-body"
" i_0)))"
"(let-values(((ok?_0"
" begin-for-syntax7_0"
" _8_0)"
"(let-values(((s_1)"
" s_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((begin-for-syntax7_0"
" _8_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((begin-for-syntax9_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((_10_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_4)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin-for-syntax9_0"
" _10_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                           \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin-for-syntax7_0"
" _8_0))))))"
"(let-values(((s11_0) s_0)"
"((temp12_0)"
"(list*"
" begin-for-syntax7_0"
"(syntax-only"
" nested-bodys_0))))"
"(rebuild.1"
" #t"
" s11_0"
" temp12_0))))))"
"(let-values() i_0))))"
" fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(define-values(implicit-made-explicit-properties)(hasheq 'implicit-made-explicit #t))"
"(define-values"
"(original-implicit-made-explicit-properties)"
"(hash-set implicit-made-explicit-properties original-property-sym #t))"
"(define-values"
"(raise-bindings-arity-error)"
"(lambda(who_0 ids_0 vals_0)"
"(begin"
"(apply"
" raise-result-arity-error"
" who_0"
"(length ids_0)"
"(if(null? ids_0)"
"         (let-values () \"\")"
"(let-values()"
"           (format \"\\n  in: definition of ~a~a\" (syntax-e$1 (car ids_0)) (if (pair? (cdr ids_0)) \" ...\" \"\"))))"
" vals_0))))"
"(define-values"
"(expand.1)"
"(lambda(alternate-id1_0 fail-non-transformer2_0 s5_0 ctx6_0)"
"(begin"
" 'expand"
"(let-values(((s_0) s5_0))"
"(let-values(((ctx_0) ctx6_0))"
"(let-values(((alternate-id_0) alternate-id1_0))"
"(let-values(((fail-non-transformer_0) fail-non-transformer2_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'visit s_0)))"
"(void)))"
"(values))))"
"(let-values(((content_0)(syntax-content s_0)))"
"(if(symbol? content_0)"
"(let-values()(expand-identifier s_0 ctx_0 alternate-id_0))"
"(if(if(pair? content_0)(syntax-identifier?(car content_0)) #f)"
"(let-values()"
"(let-values(((s109_0) s_0)"
"((ctx110_0) ctx_0)"
"((alternate-id111_0) alternate-id_0)"
"((fail-non-transformer112_0) fail-non-transformer_0))"
"(expand-id-application-form.1 fail-non-transformer112_0 s109_0 ctx110_0 alternate-id111_0)))"
"(if(let-values(((or-part_0)(pair? content_0)))(if or-part_0 or-part_0(null? content_0)))"
"(let-values()(expand-implicit '#%app s_0 ctx_0 #f))"
"(if(already-expanded? content_0)"
"(let-values()(expand-already-expanded s_0 ctx_0))"
"(let-values()(expand-implicit '#%datum s_0 ctx_0 #f))))))))))))))))"
"(define-values"
"(expand-identifier)"
"(lambda(s_0 ctx_0 alternate-id_0)"
"(begin"
"(let-values(((id_0)(let-values(((or-part_0) alternate-id_0))(if or-part_0 or-part_0 s_0))))"
"(if(if(not(free-id-set-empty?(expand-context-stops ctx_0)))"
"(free-id-set-member?(expand-context-stops ctx_0)(expand-context-phase ctx_0) id_0)"
" #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin(call-expand-observe obs_0 'resolve id_0)(call-expand-observe obs_0 'stop/return s_0))))"
"(void)))"
" s_0))"
"(let-values()"
"(let-values(((binding_0)"
"(let-values(((id113_0) id_0)"
"((temp114_0)(expand-context-phase ctx_0))"
"((temp115_0) 'ambiguous)"
"((temp116_0) #t))"
"(resolve+shift.1 temp115_0 #f null temp116_0 #f id113_0 temp114_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'resolve id_0)))(void)))"
"(if(eq? binding_0 'ambiguous)"
"(let-values()(raise-ambiguous-error id_0 ctx_0))"
"(if(not binding_0)"
"(let-values()(expand-implicit '#%top(substitute-alternate-id s_0 alternate-id_0) ctx_0 s_0))"
"(let-values()"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(let-values(((binding125_0) binding_0)"
"((ctx126_0) ctx_0)"
"((id127_0) id_0)"
"((temp128_0)(if alternate-id_0 s_0 #f))"
"((temp129_0)(expand-context-in-local-expand? ctx_0)))"
"(lookup.1 temp128_0 temp129_0 binding125_0 ctx126_0 id127_0))))"
"(let-values(((t117_0) t_0)"
"((insp-of-t118_0) insp-of-t_0)"
"((s119_0) s_0)"
"((id120_0) id_0)"
"((ctx121_0) ctx_0)"
"((binding122_0) binding_0)"
"((primitive?123_0) primitive?_0)"
"((protected?124_0) protected?_0))"
"(dispatch.1"
" #f"
" t117_0"
" insp-of-t118_0"
" s119_0"
" id120_0"
" ctx121_0"
" binding122_0"
" primitive?123_0"
" protected?124_0))))))))))))))"
"(define-values"
"(expand-id-application-form.1)"
"(lambda(fail-non-transformer8_0 s10_0 ctx11_0 alternate-id12_0)"
"(begin"
" 'expand-id-application-form"
"(let-values(((s_0) s10_0))"
"(let-values(((ctx_0) ctx11_0))"
"(let-values(((alternate-id_0) alternate-id12_0))"
"(let-values(((fail-non-transformer_0) fail-non-transformer8_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((or-part_0) alternate-id_0))"
"(if or-part_0 or-part_0(car(syntax-e$1 s_0))))))"
"(if(if(not(free-id-set-empty?(expand-context-stops ctx_0)))"
"(free-id-set-member?(expand-context-stops ctx_0)(expand-context-phase ctx_0) id_0)"
" #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'resolve id_0)"
"(call-expand-observe obs_0 'stop/return s_0))))"
"(void)))"
" s_0))"
"(let-values()"
"(let-values(((binding_0)"
"(let-values(((id130_0) id_0)"
"((temp131_0)(expand-context-phase ctx_0))"
"((temp132_0) 'ambiguous)"
"((temp133_0) #t))"
"(resolve+shift.1 temp132_0 #f null temp133_0 #f id130_0 temp131_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'resolve id_0)))(void)))"
"(if(eq? binding_0 'ambiguous)"
"(let-values()"
"(begin"
"(if fail-non-transformer_0(let-values()(fail-non-transformer_0))(void))"
"(raise-ambiguous-error id_0 ctx_0)))"
"(if(not binding_0)"
"(let-values()"
"(begin"
"(if fail-non-transformer_0(let-values()(fail-non-transformer_0))(void))"
"(expand-implicit '#%app(substitute-alternate-id s_0 alternate-id_0) ctx_0 id_0)))"
"(let-values()"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(let-values(((binding134_0) binding_0)"
"((ctx135_0) ctx_0)"
"((id136_0) id_0)"
"((temp137_0)(if alternate-id_0(car(syntax-e$1 s_0)) #f))"
"((temp138_0)(expand-context-in-local-expand? ctx_0)))"
"(lookup.1 temp137_0 temp138_0 binding134_0 ctx135_0 id136_0))))"
"(if(variable? t_0)"
"(let-values()"
"(begin"
"(if fail-non-transformer_0(let-values()(fail-non-transformer_0))(void))"
"(expand-implicit"
" '#%app"
"(substitute-alternate-id s_0 alternate-id_0)"
" ctx_0"
" id_0)))"
"(let-values()"
"(let-values(((t139_0) t_0)"
"((insp-of-t140_0) insp-of-t_0)"
"((s141_0) s_0)"
"((id142_0) id_0)"
"((ctx143_0) ctx_0)"
"((binding144_0) binding_0)"
"((primitive?145_0) primitive?_0)"
"((protected?146_0) protected?_0)"
"((fail-non-transformer147_0) fail-non-transformer_0))"
"(dispatch.1"
" fail-non-transformer147_0"
" t139_0"
" insp-of-t140_0"
" s141_0"
" id142_0"
" ctx143_0"
" binding144_0"
" primitive?145_0"
" protected?146_0)))))))))))))))))))))"
"(define-values"
"(expand-implicit)"
"(lambda(sym_0 s_0 ctx_0 trigger-id_0)"
"(begin"
"(if(expand-context-only-immediate? ctx_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'stop/return s_0)))(void)))"
" s_0))"
"(let-values()"
"(let-values(((id_0)(datum->syntax$1 s_0 sym_0)))"
"(if(if(not(free-id-set-empty?(expand-context-stops ctx_0)))"
"(free-id-set-member?(expand-context-stops ctx_0)(expand-context-phase ctx_0) id_0)"
" #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'resolve id_0)"
"(call-expand-observe obs_0 'stop/return s_0))))"
"(void)))"
" s_0))"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id148_0) id_0)"
"((temp149_0)(expand-context-phase ctx_0))"
"((temp150_0) 'ambiguous)"
"((temp151_0) #t))"
"(resolve+shift.1 temp150_0 #f null temp151_0 #f id148_0 temp149_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'resolve id_0)))(void)))"
"(if(eq? b_0 'ambiguous)"
"(let-values()(raise-ambiguous-error id_0 ctx_0))"
"(let-values()"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(if b_0"
"(let-values(((b152_0) b_0)((ctx153_0) ctx_0)((id154_0) id_0))"
"(lookup.1 #f #f b152_0 ctx153_0 id154_0))"
"(values #f #f #f #f))))"
"(if(transformer? t_0)"
"(let-values()"
"(let-values(((fail-non-transformer_0)"
"(if(1/rename-transformer? t_0)"
"(lambda()"
"(begin"
" 'fail-non-transformer"
"(raise-syntax-implicit-error s_0 sym_0 trigger-id_0 ctx_0)))"
" #f)))"
"(let-values(((t155_0) t_0)"
"((insp-of-t156_0) insp-of-t_0)"
"((temp157_0)(make-explicit ctx_0 sym_0 s_0))"
"((id158_0) id_0)"
"((ctx159_0) ctx_0)"
"((b160_0) b_0)"
"((fail-non-transformer161_0) fail-non-transformer_0))"
"(dispatch-transformer.1"
" fail-non-transformer161_0"
" t155_0"
" insp-of-t156_0"
" temp157_0"
" id158_0"
" ctx159_0"
" b160_0))))"
"(if(core-form? t_0)"
"(let-values()"
"(if(if(eq? sym_0 '#%top)"
"(if(eq?(core-form-name t_0) '#%top)(expand-context-in-local-expand? ctx_0) #f)"
" #f)"
"(let-values()(dispatch-implicit-#%top-core-form t_0 s_0 ctx_0))"
"(let-values()(dispatch-core-form t_0(make-explicit ctx_0 sym_0 s_0) ctx_0))))"
"(let-values()"
"(let-values(((tl-id_0)"
"(if(eq? sym_0 '#%top)"
"(if(root-expand-context-top-level-bind-scope ctx_0)"
"(add-scope s_0(root-expand-context-top-level-bind-scope ctx_0))"
" #f)"
" #f)))"
"(let-values(((tl-b_0)"
"(if tl-id_0"
"(let-values(((tl-id162_0) tl-id_0)"
"((temp163_0)(expand-context-phase ctx_0)))"
"(resolve.1 #f #f null #f tl-id162_0 temp163_0))"
" #f)))"
"(if tl-b_0"
"(let-values()"
"(if(if(expand-context-to-parsed? ctx_0)"
"(free-id-set-empty?(expand-context-stops ctx_0))"
" #f)"
"(parsed-id2.1 tl-id_0 tl-b_0 #f)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'variable tl-id_0)"
"(call-expand-observe obs_0 'return tl-id_0))))"
"(void)))"
" tl-id_0)))"
"(let-values()"
"(raise-syntax-implicit-error s_0 sym_0 trigger-id_0 ctx_0)))))))))))))))))))))"
"(define-values"
"(expand-already-expanded)"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((ae_0)(syntax-e$1 s_0)))"
"(let-values(((exp-s_0)(already-expanded-s ae_0)))"
"(begin"
"(if(let-values(((or-part_0)(syntax-any-macro-scopes? s_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(not"
"(eq?(expand-context-binding-layer ctx_0)(already-expanded-binding-layer ae_0)))))"
"(if or-part_1"
" or-part_1"
"(if(parsed? exp-s_0)"
"(not"
"(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f))"
" #f)))))"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(string-append"
"                  \"expanded syntax not in its original lexical context;\\n\""
"                  \" extra bindings or scopes in the current context\")"
"(if(not(parsed? exp-s_0)) exp-s_0 #f)))"
"(void))"
"(if(expand-context-only-immediate? ctx_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'stop/return s_0)))(void)))"
" s_0))"
"(if(parsed? exp-s_0)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((result-s_0)(syntax-track-origin$1 exp-s_0 s_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'opaque-expr result-s_0)))"
"(void)))"
"(if(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f)"
"(let-values(((result-s164_0) result-s_0)((ctx165_0) ctx_0))"
"(expand.1 #f #f result-s164_0 ctx165_0))"
" result-s_0))))))))))))"
"(define-values"
"(make-explicit)"
"(lambda(ctx_0 sym_0 s_0)"
"(begin"
"(let-values(((insp_0)(current-module-code-inspector)))"
"(let-values(((sym-s_0)"
"(immediate-datum->syntax"
" s_0"
" sym_0"
" s_0"
"(if(syntax-has-property? s_0 original-property-sym)"
" original-implicit-made-explicit-properties"
" implicit-made-explicit-properties)"
" insp_0)))"
"(let-values(((new-s_0)(immediate-datum->syntax s_0(cons sym-s_0 s_0) s_0(syntax-props s_0) insp_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'tag2 new-s_0 s_0)))(void)))"
" new-s_0)))))))"
"(define-values"
"(dispatch.1)"
"(lambda(fail-non-transformer14_0 t16_0 insp-of-t17_0 s18_0 id19_0 ctx20_0 binding21_0 primitive?22_0 protected?23_0)"
"(begin"
" 'dispatch"
"(let-values(((t_0) t16_0))"
"(let-values(((insp-of-t_0) insp-of-t17_0))"
"(let-values(((s_0) s18_0))"
"(let-values(((id_0) id19_0))"
"(let-values(((ctx_0) ctx20_0))"
"(let-values(((binding_0) binding21_0))"
"(let-values(((primitive?_0) primitive?22_0))"
"(let-values(((protected?_0) protected?23_0))"
"(let-values(((fail-non-transformer_0) fail-non-transformer14_0))"
"(let-values()"
"(if(core-form? t_0)"
"(let-values()(dispatch-core-form t_0 s_0 ctx_0))"
"(if(transformer? t_0)"
"(let-values()"
"(let-values(((t166_0) t_0)"
"((insp-of-t167_0) insp-of-t_0)"
"((s168_0) s_0)"
"((id169_0) id_0)"
"((ctx170_0) ctx_0)"
"((binding171_0) binding_0)"
"((fail-non-transformer172_0) fail-non-transformer_0))"
"(dispatch-transformer.1"
" fail-non-transformer172_0"
" t166_0"
" insp-of-t167_0"
" s168_0"
" id169_0"
" ctx170_0"
" binding171_0)))"
"(if(variable? t_0)"
"(let-values()"
"(dispatch-variable t_0 s_0 id_0 ctx_0 binding_0 primitive?_0 protected?_0))"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                   \"illegal use of syntax\""
" s_0"
" #f"
" null"
"(format"
"                                    \"\\n  value at phase ~s: ~e\""
"(add1(expand-context-phase ctx_0))"
" t_0)))))))))))))))))))"
"(define-values"
"(dispatch-core-form)"
"(lambda(t_0 s_0 ctx_0)"
"(begin"
"(if(expand-context-only-immediate? ctx_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'stop/return s_0)))(void)))"
" s_0))"
"(if(expand-context-observer ctx_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'enter-prim s_0)))"
"(void)))"
"(values))))"
"(let-values(((result-s_0)((core-form-expander t_0) s_0 ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'exit-prim/return(extract-syntax result-s_0))))"
"(void)))"
" result-s_0))))"
"(let-values()((core-form-expander t_0) s_0 ctx_0)))))))"
"(define-values"
"(dispatch-implicit-#%top-core-form)"
"(lambda(t_0 s_0 ctx_0)"
"(begin"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'enter-prim s_0)))(void)))"
"(values))))"
"(let-values(((result-s_0)((core-form-expander t_0) s_0 ctx_0 #t)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'exit-prim/return result-s_0)))"
"(void)))"
" result-s_0))))))"
"(define-values"
"(dispatch-transformer.1)"
"(lambda(fail-non-transformer25_0 t27_0 insp-of-t28_0 s29_0 id30_0 ctx31_0 binding32_0)"
"(begin"
" 'dispatch-transformer"
"(let-values(((t_0) t27_0))"
"(let-values(((insp-of-t_0) insp-of-t28_0))"
"(let-values(((s_0) s29_0))"
"(let-values(((id_0) id30_0))"
"(let-values(((ctx_0) ctx31_0))"
"(let-values(((binding_0) binding32_0))"
"(let-values(((fail-non-transformer_0) fail-non-transformer25_0))"
"(let-values()"
"(if(not-in-this-expand-context? t_0 ctx_0)"
"(let-values()"
"(let-values(((adj-s_0)"
"(avoid-current-expand-context(substitute-alternate-id s_0 id_0) t_0 ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'tag/context adj-s_0)))"
"(void)))"
"(let-values(((adj-s173_0) adj-s_0)((ctx174_0) ctx_0))"
"(expand.1 #f #f adj-s173_0 ctx174_0)))))"
"(if(if(expand-context-parsing-expanded? ctx_0)(not(1/rename-transformer? t_0)) #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                             \"encountered a macro binding in form that should be fully expanded\""
" s_0))"
"(if(1/rename-transformer? t_0)"
"(let-values()"
"(if(expand-context-just-once? ctx_0)"
"(let-values() s_0)"
"(let-values()"
"(let-values(((alt-id_0)(apply-rename-transformer t_0 id_0 ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'rename-transformer alt-id_0)))"
"(void)))"
"(let-values(((s175_0) s_0)"
"((ctx176_0) ctx_0)"
"((alt-id177_0) alt-id_0)"
"((fail-non-transformer178_0) fail-non-transformer_0))"
"(expand.1 alt-id177_0 fail-non-transformer178_0 s175_0 ctx176_0)))))))"
"(let-values()"
"(let-values(((exp-s_0 re-ctx_0)"
"(let-values(((t179_0) t_0)"
"((insp-of-t180_0) insp-of-t_0)"
"((s181_0) s_0)"
"((id182_0) id_0)"
"((ctx183_0) ctx_0)"
"((binding184_0) binding_0))"
"(apply-transformer.1"
" #f"
" t179_0"
" insp-of-t180_0"
" s181_0"
" id182_0"
" ctx183_0"
" binding184_0))))"
"(if(expand-context-just-once? ctx_0)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((exp-s185_0) exp-s_0)((re-ctx186_0) re-ctx_0))"
"(expand.1 #f #f exp-s185_0 re-ctx186_0))))))))))))))))))))"
"(define-values"
"(dispatch-variable)"
"(lambda(t_0 s_0 id_0 ctx_0 binding_0 primitive?_0 protected?_0)"
"(begin"
"(if(expand-context-only-immediate? ctx_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'stop/return id_0)))(void)))"
" id_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'variable s_0 id_0)))"
"(void)))"
"(values))))"
"(let-values((()(begin(register-variable-referenced-if-local! binding_0 ctx_0)(values))))"
"(let-values(((result-s_0)"
"(let-values(((id187_0) id_0)"
"((t188_0) t_0)"
"((temp189_0)"
"(free-id-set-empty-or-just-module*?(expand-context-stops ctx_0))))"
"(substitute-variable.1 temp189_0 id187_0 t188_0))))"
"(if(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f)"
"(let-values()"
"(let-values(((prop-s_0)(keep-properties-only~ result-s_0)))"
"(let-values(((insp_0)(syntax-inspector result-s_0)))"
"(if primitive?_0"
"(parsed-primitive-id3.1 prop-s_0 binding_0 insp_0)"
"(parsed-id2.1 prop-s_0 binding_0 insp_0)))))"
"(let-values()"
"(let-values(((protected-result-s_0)"
"(if protected?_0(syntax-property$1 result-s_0 'protected #t) result-s_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'return protected-result-s_0)))"
"(void)))"
" protected-result-s_0))))))))))))"
"(define-values"
"(apply-transformer.1)"
"(lambda(origin-id34_0 t36_0 insp-of-t37_0 s38_0 id39_0 ctx40_0 binding41_0)"
"(begin"
" 'apply-transformer"
"(let-values(((t_0) t36_0))"
"(let-values(((insp-of-t_0) insp-of-t37_0))"
"(let-values(((s_0) s38_0))"
"(let-values(((id_0) id39_0))"
"(let-values(((ctx_0) ctx40_0))"
"(let-values(((binding_0) binding41_0))"
"(let-values(((origin-id_0) origin-id34_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand '_ 'macro))(void))"
"(begin0"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'enter-macro s_0 s_0)))"
"(void)))"
"(values))))"
"(let-values(((intro-scope_0)(new-scope 'macro)))"
"(let-values(((intro-s_0)(flip-scope s_0 intro-scope_0)))"
"(let-values(((use-scopes_0)(maybe-create-use-site-scope ctx_0 binding_0)))"
"(let-values(((use-s_0)(add-scopes intro-s_0 use-scopes_0)))"
"(let-values(((def-ctx-scopes_0)(box null)))"
"(let-values(((transformed-s_0)"
"(apply-transformer-in-context$1"
" t_0"
" use-s_0"
" ctx_0"
" insp-of-t_0"
" intro-scope_0"
" use-scopes_0"
" def-ctx-scopes_0"
" id_0)))"
"(let-values(((result-s_0)(flip-scope transformed-s_0 intro-scope_0)))"
"(let-values(((post-s_0)(maybe-add-post-expansion result-s_0 ctx_0)))"
"(let-values(((tracked-s_0)"
"(syntax-track-origin$1"
" post-s_0"
" use-s_0"
"(let-values(((or-part_0) origin-id_0))"
"(if or-part_0"
" or-part_0"
"(if(syntax-identifier? s_0)"
" s_0"
"(car(syntax-e$1 s_0))))))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'exit-macro tracked-s_0 post-s_0)))"
"(void)))"
"(values"
" tracked-s_0"
"(accumulate-def-ctx-scopes ctx_0 def-ctx-scopes_0))))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))))))))))"
"(define-values"
"(apply-transformer-in-context$1)"
"(lambda(t_0 use-s_0 ctx_0 insp-of-t_0 intro-scope_0 use-scopes_0 def-ctx-scopes_0 id_0)"
"(begin"
" 'apply-transformer-in-context"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'macro-pre-x use-s_0)))"
"(void)))"
"(values))))"
"(let-values(((confine-def-ctx-scopes?_0)"
"(not"
"(let-values(((or-part_0)(expand-context-only-immediate? ctx_0)))"
"(if or-part_0"
" or-part_0"
"(not(free-id-set-empty-or-just-module*?(expand-context-stops ctx_0))))))))"
"(let-values(((accum-ctx_0)"
"(if(if confine-def-ctx-scopes?_0"
"(if(expand-context-def-ctx-scopes ctx_0)"
"(not(null?(unbox(expand-context-def-ctx-scopes ctx_0))))"
" #f)"
" #f)"
"(accumulate-def-ctx-scopes ctx_0(expand-context-def-ctx-scopes ctx_0))"
" ctx_0)))"
"(let-values(((m-ctx_0)"
"(let-values(((v_0) accum-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((current-introduction-scopes190_0)(list intro-scope_0))"
"((current-use-scopes191_0) use-scopes_0)"
"((def-ctx-scopes192_0)"
"(if confine-def-ctx-scopes?_0"
" def-ctx-scopes_0"
"(expand-context-def-ctx-scopes ctx_0)))"
"((inner193_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner193_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
" def-ctx-scopes192_0"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
" current-introduction-scopes190_0"
" current-use-scopes191_0"
"(expand-context/outer-name the-struct_0)))"
"                                (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))"
"(let-values(((transformed-s_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
"(namespace->namespace-at-phase"
"(expand-context-namespace ctx_0)"
"(add1(expand-context-phase ctx_0))))"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" m-ctx_0"
"(with-continuation-mark"
" current-module-code-inspector"
" insp-of-t_0"
"(let-values()"
"(call-with-continuation-barrier"
"(lambda()((transformer->procedure t_0) use-s_0))))))))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'macro-post-x transformed-s_0 use-s_0)))"
"(void)))"
"(if(syntax?$1 transformed-s_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
"(syntax-e$1 id_0)"
"                       \"received value from syntax expander was not syntax\""
"                       \"received\""
" transformed-s_0)))"
" transformed-s_0)))))))))"
"(define-values"
"(maybe-create-use-site-scope)"
"(lambda(ctx_0 binding_0)"
"(begin"
"(if(if(root-expand-context-use-site-scopes ctx_0)"
"(let-values(((or-part_0)(not binding_0)))"
"(if or-part_0"
" or-part_0"
"(matching-frame?(root-expand-context-frame-id ctx_0)(binding-frame-id binding_0))))"
" #f)"
"(let-values()"
"(let-values(((sc_0)(new-scope 'use-site)))"
"(let-values(((b_0)(root-expand-context-use-site-scopes ctx_0)))"
"(let-values((()(begin(set-box! b_0(cons sc_0(unbox b_0)))(values))))"
"(let-values(((def-ctx-b_0)(expand-context-def-ctx-scopes ctx_0)))"
"(begin"
"(if def-ctx-b_0(let-values()(set-box! def-ctx-b_0(cons sc_0(unbox def-ctx-b_0))))(void))"
"(list sc_0)))))))"
"(let-values() null)))))"
"(define-values"
"(matching-frame?)"
"(lambda(current-frame-id_0 bind-frame-id_0)"
"(begin"
"(if current-frame-id_0"
"(let-values(((or-part_0)(eq? current-frame-id_0 bind-frame-id_0)))"
"(if or-part_0 or-part_0(eq? current-frame-id_0 'all)))"
" #f))))"
"(define-values"
"(maybe-add-post-expansion)"
"(lambda(s_0 ctx_0)(begin(apply-post-expansion(root-expand-context-post-expansion ctx_0) s_0))))"
"(define-values"
"(accumulate-def-ctx-scopes)"
"(lambda(ctx_0 def-ctx-scopes_0)"
"(begin"
"(if(null?(unbox def-ctx-scopes_0))"
" ctx_0"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((scopes194_0)(append(unbox def-ctx-scopes_0)(expand-context-scopes ctx_0)))"
"((inner195_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner195_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
" scopes194_0"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"              (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))))"
"(define-values"
"(apply-rename-transformer)"
"(lambda(t_0 id_0 ctx_0)"
"(begin"
"(let-values(((target-id_0)(rename-transformer-target-in-context t_0 ctx_0)))"
"(let-values(((intro-scope_0)(new-scope 'macro)))"
"(let-values(((intro-id_0)(add-scope target-id_0 intro-scope_0)))"
"(syntax-track-origin$1(transfer-srcloc intro-id_0 id_0) id_0 id_0)))))))"
"(define-values"
"(lookup.1)"
"(lambda(in43_0 out-of-context-as-variable?44_0 b47_0 ctx48_0 id49_0)"
"(begin"
" 'lookup"
"(let-values(((b_0) b47_0))"
"(let-values(((ctx_0) ctx48_0))"
"(let-values(((id_0) id49_0))"
"(let-values(((in-s_0) in43_0))"
"(let-values(((out-of-context-as-variable?_0) out-of-context-as-variable?44_0))"
"(let-values()"
"(let-values(((b196_0) b_0)"
"((temp197_0)(expand-context-env ctx_0))"
"((temp198_0)(expand-context-lift-envs ctx_0))"
"((temp199_0)(expand-context-namespace ctx_0))"
"((temp200_0)(expand-context-phase ctx_0))"
"((id201_0) id_0)"
"((in-s202_0) in-s_0)"
"((out-of-context-as-variable?203_0) out-of-context-as-variable?_0))"
"(binding-lookup.1"
" #t"
" in-s202_0"
" out-of-context-as-variable?203_0"
" b196_0"
" temp197_0"
" temp198_0"
" temp199_0"
" temp200_0"
" id201_0)))))))))))"
"(define-values"
"(substitute-alternate-id)"
"(lambda(s_0 alternate-id_0)"
"(begin"
"(if(not alternate-id_0)"
"(let-values() s_0)"
"(if(syntax-identifier? s_0)"
"(let-values()(syntax-track-origin$1 alternate-id_0 s_0))"
"(let-values()"
"(syntax-track-origin$1(datum->syntax$1 s_0(cons alternate-id_0(cdr(syntax-e$1 s_0))) s_0) s_0)))))))"
"(define-values"
"(register-variable-referenced-if-local!)"
"(lambda(binding_0 ctx_0)"
"(begin"
"(if(if(local-binding? binding_0)"
"(if(reference-record?(binding-frame-id binding_0))(not(expand-context-parsing-expanded? ctx_0)) #f)"
" #f)"
"(let-values()(reference-record-used!(binding-frame-id binding_0)(local-binding-key binding_0)))"
"(void)))))"
"(define-values"
"(expand/capture-lifts.1)"
"(lambda(always-wrap?54_0 begin-form?52_0 expand-lifts?51_0 lift-key53_0 s59_0 ctx60_0)"
"(begin"
" 'expand/capture-lifts"
"(let-values(((s_0) s59_0))"
"(let-values(((ctx_0) ctx60_0))"
"(let-values(((expand-lifts?_0) expand-lifts?51_0))"
"(let-values(((begin-form?_0) begin-form?52_0))"
"(let-values(((lift-key_0)(if(eq? lift-key53_0 unsafe-undefined)(generate-lift-key) lift-key53_0)))"
"(let-values(((always-wrap?_0) always-wrap?54_0))"
"(let-values()"
"(let-values(((context_0)(expand-context-context ctx_0)))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((local?_0)(not begin-form?_0)))"
"((letrec-values(((loop_0)"
"(lambda(s_1 always-wrap?_1 ctx_1)"
"(begin"
" 'loop"
"(let-values(((lift-env_0)(if local?_0(box empty-env) #f)))"
"(let-values(((lift-ctx_0)"
"(let-values(((temp204_0)"
"(if local?_0"
"(make-local-lift"
" lift-env_0"
"(root-expand-context-counter ctx_1)"
"(if(expand-context-normalize-locals?"
" ctx_1)"
" 'lift"
" #f))"
"(make-top-level-lift ctx_1)))"
"((temp205_0)"
"(if(not local?_0)"
"(eq? context_0 'module)"
" #f)))"
"(make-lift-context.1 temp205_0 temp204_0))))"
"(let-values(((capture-ctx_0)"
"(let-values(((v_0) ctx_1))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner206_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((lift-key207_0)"
" lift-key_0)"
"((lifts208_0)"
" lift-ctx_0)"
"((lift-envs209_0)"
"(if local?_0"
"(cons"
" lift-env_0"
"(expand-context-lift-envs"
" ctx_1))"
"(expand-context-lift-envs"
" ctx_1)))"
"((module-lifts210_0)"
"(if(let-values(((or-part_0)"
" local?_0))"
"(if or-part_0"
" or-part_0"
"(not"
"(memq"
" context_0"
" '(top-level"
" module)))))"
"(expand-context-module-lifts"
" ctx_1)"
" lift-ctx_0)))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
" lift-key207_0"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
" lifts208_0"
" lift-envs209_0"
" module-lifts210_0"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                           \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner206_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                         \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((rebuild-s_0)(keep-properties-only s_1)))"
"(let-values(((exp-s_0)"
"(let-values(((s211_0) s_1)"
"((capture-ctx212_0) capture-ctx_0))"
"(expand.1 #f #f s211_0 capture-ctx212_0))))"
"(let-values(((lifts_0)"
"(get-and-clear-lifts!"
"(expand-context-lifts capture-ctx_0))))"
"(let-values(((with-lifts-s_0)"
"(if(let-values(((or-part_0)"
"(pair? lifts_0)))"
"(if or-part_0 or-part_0 always-wrap?_1))"
"(let-values()"
"(if(expand-context-to-parsed? ctx_1)"
"(let-values()"
"(begin"
"(if expand-lifts?_0"
"(void)"
"(let-values()"
"(error"
"                                                                                         \"internal error: to-parsed mode without expanding lifts\")))"
"(wrap-lifts-as-parsed-let"
" lifts_0"
" exp-s_0"
" rebuild-s_0"
" ctx_1"
"(lambda(rhs_0 rhs-ctx_0)"
"(loop_0 rhs_0 #f rhs-ctx_0)))))"
"(let-values()"
"(if begin-form?_0"
"(let-values(((lifts213_0) lifts_0)"
"((exp-s214_0) exp-s_0)"
"((phase215_0) phase_0))"
"(wrap-lifts-as-begin.1"
" unsafe-undefined"
" unsafe-undefined"
" lifts213_0"
" exp-s214_0"
" phase215_0))"
"(wrap-lifts-as-let"
" lifts_0"
" exp-s_0"
" phase_0)))))"
"(let-values() exp-s_0))))"
"(if(let-values(((or-part_0)(not expand-lifts?_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(null? lifts_0)))"
"(if or-part_1"
" or-part_1"
"(expand-context-to-parsed? ctx_1)))))"
"(let-values() with-lifts-s_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'letlift-loop"
" with-lifts-s_0)))"
"(void)))"
"(loop_0 with-lifts-s_0 #f ctx_1)))))))))))))))"
" loop_0)"
" s_0"
" always-wrap?_0"
" ctx_0))))))))))))))"
"(define-values"
"(expand-transformer.1)"
"(lambda(always-wrap?66_0 begin-form?63_0 context62_0 expand-lifts?64_0 keep-stops?67_0 lift-key65_0 s74_0 ctx75_0)"
"(begin"
" 'expand-transformer"
"(let-values(((s_0) s74_0))"
"(let-values(((ctx_0) ctx75_0))"
"(let-values(((context_0) context62_0))"
"(let-values(((begin-form?_0) begin-form?63_0))"
"(let-values(((expand-lifts?_0) expand-lifts?64_0))"
"(let-values(((lift-key_0)(if(eq? lift-key65_0 unsafe-undefined)(generate-lift-key) lift-key65_0)))"
"(let-values(((always-wrap?_0) always-wrap?66_0))"
"(let-values(((keep-stops?_0) keep-stops?67_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand 'transformer))(void))"
"(begin0"
"(let-values()"
"(let-values(((trans-ctx_0)"
"(let-values(((ctx222_0) ctx_0)"
"((context223_0) context_0)"
"((keep-stops?224_0) keep-stops?_0))"
"(context->transformer-context.1 keep-stops?224_0 ctx222_0 context223_0))))"
"(let-values(((s216_0) s_0)"
"((trans-ctx217_0) trans-ctx_0)"
"((expand-lifts?218_0) expand-lifts?_0)"
"((begin-form?219_0) begin-form?_0)"
"((lift-key220_0) lift-key_0)"
"((always-wrap?221_0) always-wrap?_0))"
"(expand/capture-lifts.1"
" always-wrap?221_0"
" begin-form?219_0"
" expand-lifts?218_0"
" lift-key220_0"
" s216_0"
" trans-ctx217_0))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))))))"
"(define-values"
"(context->transformer-context.1)"
"(lambda(keep-stops?77_0 ctx80_0 context79_0)"
"(begin"
" 'context->transformer-context"
"(let-values(((ctx_0) ctx80_0))"
"(let-values(((context_0) context79_0))"
"(let-values(((keep-stops?_0) keep-stops?77_0))"
"(let-values()"
"(let-values(((phase_0)(add1(expand-context-phase ctx_0))))"
"(let-values(((ns_0)(namespace->namespace-at-phase(expand-context-namespace ctx_0) phase_0)))"
"(begin"
"(namespace-visit-available-modules! ns_0 phase_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context225_0) context_0)"
"((scopes226_0) null)"
"((env227_0) empty-env)"
"((only-immediate?228_0)"
"(if keep-stops?_0(expand-context-only-immediate? ctx_0) #f))"
"((def-ctx-scopes229_0) #f)"
"((use-site-scopes230_0)(box null))"
"((post-expansion231_0) #f)"
"((inner232_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((phase233_0) phase_0)"
"((namespace234_0) ns_0)"
"((in-local-expand?235_0) #f)"
"((stops236_0)"
"(if keep-stops?_0"
"(expand-context-stops ctx_0)"
" empty-free-id-set)))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
"(expand-context/inner-to-parsed? the-struct_1)"
" phase233_0"
" namespace234_0"
"(expand-context/inner-just-once? the-struct_1)"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
" in-local-expand?235_0"
"(expand-context/inner-keep-#%expression? the-struct_1)"
" stops236_0"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-parsing-expanded? the-struct_1)"
"(expand-context/inner-skip-visit-available? the-struct_1)))"
"                                            (raise-argument-error 'struct-copy \"expand-context/inner?\" the-struct_1)))))"
"(expand-context/outer1.1"
" inner232_0"
" post-expansion231_0"
" use-site-scopes230_0"
"(root-expand-context/outer-frame-id the-struct_0)"
" context225_0"
" env227_0"
" scopes226_0"
" def-ctx-scopes229_0"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
" only-immediate?228_0"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"                          (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))))))))))"
"(define-values"
"(expand+eval-for-syntaxes-binding.1)"
"(lambda(log-next?82_0 wrap83_0 who86_0 rhs87_0 ids88_0 ctx89_0)"
"(begin"
" 'expand+eval-for-syntaxes-binding"
"(let-values(((who_0) who86_0))"
"(let-values(((rhs_0) rhs87_0))"
"(let-values(((ids_0) ids88_0))"
"(let-values(((ctx_0) ctx89_0))"
"(let-values(((log-next?_0) log-next?82_0))"
"(let-values(((wrap_0) wrap83_0))"
"(let-values()"
"(let-values(((exp-rhs_0)"
"(let-values(((rhs237_0) rhs_0)((temp238_0)(as-named-context ctx_0 ids_0)))"
"(expand-transformer.1"
" #f"
" #f"
" 'expression"
" #t"
" #f"
" unsafe-undefined"
" rhs237_0"
" temp238_0))))"
"(let-values(((phase_0)(add1(expand-context-phase ctx_0))))"
"(let-values(((parsed-rhs_0)"
"(if(expand-context-to-parsed? ctx_0)"
" exp-rhs_0"
"(let-values(((exp-rhs239_0) exp-rhs_0)"
"((temp240_0)"
"(let-values(((temp241_0)(as-to-parsed-context ctx_0)))"
"(context->transformer-context.1 #f temp241_0 'expression))))"
"(expand.1 #f #f exp-rhs239_0 temp240_0)))))"
"(begin"
"(if log-next?_0"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'next)))(void))))"
"(void))"
"(values"
" exp-rhs_0"
" parsed-rhs_0"
"(let-values(((who242_0) who_0)"
"((ids243_0) ids_0)"
"((parsed-rhs244_0) parsed-rhs_0)"
"((phase245_0) phase_0)"
"((temp246_0)"
"(namespace->namespace-at-phase(expand-context-namespace ctx_0) phase_0))"
"((ctx247_0) ctx_0)"
"((wrap248_0) wrap_0))"
"(eval-for-bindings.1"
" wrap248_0"
" who242_0"
" ids243_0"
" parsed-rhs244_0"
" phase245_0"
" temp246_0"
" ctx247_0)))))))))))))))))"
"(define-values"
"(eval-for-syntaxes-binding)"
"(lambda(who_0 rhs_0 ids_0 ctx_0)"
"(begin"
"(let-values(((exp-rhs_0 parsed-rhs_0 vals_0)"
"(let-values(((who249_0) who_0)((rhs250_0) rhs_0)((ids251_0) ids_0)((ctx252_0) ctx_0))"
"(expand+eval-for-syntaxes-binding.1 #t #f who249_0 rhs250_0 ids251_0 ctx252_0))))"
" vals_0))))"
"(define-values"
"(eval-for-bindings.1)"
"(lambda(wrap91_0 who93_0 ids94_0 p95_0 phase96_0 ns97_0 ctx98_0)"
"(begin"
" 'eval-for-bindings"
"(let-values(((who_0) who93_0))"
"(let-values(((ids_0) ids94_0))"
"(let-values(((p_0) p95_0))"
"(let-values(((phase_0) phase96_0))"
"(let-values(((ns_0) ns97_0))"
"(let-values(((ctx_0) ctx98_0))"
"(let-values(((wrap_0) wrap91_0))"
"(let-values()"
"(let-values(((compiled_0)"
"(if(can-direct-eval? p_0 ns_0(root-expand-context-self-mpi ctx_0))"
" #f"
"(compile-single"
" p_0"
"(let-values(((ns253_0) ns_0)((phase254_0) phase_0))"
"(make-compile-context.1"
" #f"
" unsafe-undefined"
" #f"
" ns253_0"
" phase254_0"
" unsafe-undefined))))))"
"(let-values(((vals_0)"
"(call-with-values"
"(lambda()"
"(call-with-continuation-barrier"
"(lambda()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" ns_0"
" eval-jit-enabled"
" #f)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" ctx_0"
"(let-values()"
"(if compiled_0"
"(if wrap_0"
"(wrap_0(lambda()(eval-single-top compiled_0 ns_0)))"
"(eval-single-top compiled_0 ns_0))"
"(let-values(((self-mpi_0)(root-expand-context-self-mpi ctx_0)))"
"(if wrap_0"
"(wrap_0(lambda()(direct-eval p_0 ns_0 self-mpi_0)))"
"(direct-eval p_0 ns_0 self-mpi_0)))))))))))"
" list)))"
"(begin"
"(if(let-values(((or-part_0) wrap_0))"
"(if or-part_0 or-part_0(=(length vals_0)(length ids_0))))"
"(void)"
"(let-values()(raise-bindings-arity-error who_0 ids_0 vals_0)))"
" vals_0))))))))))))))"
"(define-values(keep-properties-only)(lambda(s_0)(begin(datum->syntax$1 #f 'props s_0 s_0))))"
"(define-values(keep-properties-only~)(lambda(s_0)(begin #f)))"
"(define-values"
"(keep-as-needed.1)"
"(lambda(for-track?100_0 keep-for-error?102_0 keep-for-parsed?101_0 ctx106_0 s107_0)"
"(begin"
" 'keep-as-needed"
"(let-values(((ctx_0) ctx106_0))"
"(let-values(((s_0) s107_0))"
"(let-values(((for-track?_0) for-track?100_0))"
"(let-values(((keep-for-parsed?_0) keep-for-parsed?101_0))"
"(let-values(((keep-for-error?_0) keep-for-error?102_0))"
"(let-values()"
"(let-values(((d_0)(syntax-e$1 s_0)))"
"(let-values(((keep-e_0)"
"(if(symbol? d_0)"
"(let-values() d_0)"
"(if(if(pair? d_0)(syntax-identifier?(car d_0)) #f)"
"(let-values()(syntax-e$1(car d_0)))"
"(let-values() #f)))))"
"(if(expand-context-to-parsed? ctx_0)"
"(let-values()"
"(if(let-values(((or-part_0) keep-for-parsed?_0))(if or-part_0 or-part_0 keep-for-error?_0))"
"(datum->syntax$1 #f keep-e_0 s_0 s_0)"
" #f))"
"(if(if for-track?_0(if(pair? d_0) keep-e_0 #f) #f)"
"(let-values()(datum->syntax$1 #f(list(car d_0)) s_0 s_0))"
"(let-values()(datum->syntax$1 s_0 keep-e_0 s_0 s_0)))))))))))))))"
"(define-values"
"(attach-disappeared-transformer-bindings)"
"(lambda(s_0 trans-idss_0)"
"(begin"
"(if(null? trans-idss_0)"
"(let-values() s_0)"
"(let-values()"
"(syntax-property$1"
" s_0"
" 'disappeared-binding"
"(append"
"(apply append trans-idss_0)"
"(let-values(((or-part_0)(syntax-property$1 s_0 'disappeared-binding)))"
"(if or-part_0 or-part_0 null)))))))))"
"(define-values"
"(increment-binding-layer)"
"(lambda(ids_0 ctx_0 layer-val_0)"
"(begin"
"(if((letrec-values(((loop_0)"
"(lambda(ids_1)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(identifier? ids_1)))"
"(if or-part_0"
" or-part_0"
"(if(pair? ids_1)"
"(let-values(((or-part_1)(loop_0(car ids_1))))"
"(if or-part_1 or-part_1(loop_0(cdr ids_1))))"
" #f)))))))"
" loop_0)"
" ids_0)"
" layer-val_0"
"(expand-context-binding-layer ctx_0)))))"
"(define-values"
"(wrap-lifts-as-parsed-let)"
"(lambda(lifts_0 exp-s_0 rebuild-s_0 ctx_0 parse-rhs_0)"
"(begin"
"(let-values(((idss+keyss+rhss_0)(get-lifts-as-lists lifts_0)))"
"((letrec-values(((lets-loop_0)"
"(lambda(idss+keyss+rhss_1 rhs-ctx_0)"
"(begin"
" 'lets-loop"
"(if(null? idss+keyss+rhss_1)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((ids_0)(caar idss+keyss+rhss_1)))"
"(let-values(((keys_0)(cadar idss+keyss+rhss_1)))"
"(let-values(((rhs_0)(caddar idss+keyss+rhss_1)))"
"(let-values(((exp-rhs_0)(parse-rhs_0 rhs_0 rhs-ctx_0)))"
"(parsed-let-values17.1"
" rebuild-s_0"
"(list ids_0)"
"(list(list keys_0 exp-rhs_0))"
"(list"
"(lets-loop_0"
"(cdr idss+keyss+rhss_1)"
"(let-values(((v_0) rhs-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((env255_0)"
"(let-values(((env_0)"
"(let-values(((env_0)"
"(expand-context-env"
" rhs-ctx_0)))"
" env_0)))"
"(let-values(((lst_0) ids_0)((lst_1) keys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)"
"(pair? lst_3)"
" #f)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((key_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((env_2)"
"(let-values(((env_2)"
"(let-values()"
"(env-extend"
" env_1"
" key_0"
"(local-variable1.1"
" id_0)))))"
"(values"
" env_2))))"
"(if(not #f)"
"(for-loop_0"
" env_2"
" rest_0"
" rest_1)"
" env_2)))"
" env_1))))))"
" for-loop_0)"
" env_0"
" lst_0"
" lst_1)))))"
"((inner256_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner256_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
" env255_0"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                    \"expand-context/outer?\""
" the-struct_0)))))))))))))))))"
" lets-loop_0)"
" idss+keyss+rhss_0"
" ctx_0)))))"
"(define-values"
"(rename-transformer-target-in-context)"
"(lambda(t_0 ctx_0)"
"(begin(with-continuation-mark current-expand-context ctx_0(let-values()(1/rename-transformer-target t_0))))))"
"(define-values"
"(maybe-install-free=id-in-context!)"
"(lambda(val_0 id_0 phase_0 ctx_0)"
"(begin"
"(if(1/rename-transformer? val_0)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" ctx_0"
"(let-values()(maybe-install-free=id! val_0 id_0 phase_0))))"
"(void)))))"
"(define-values"
"(transfer-srcloc)"
"(lambda(new-s_0 old-s_0)"
"(begin"
"(let-values(((srcloc_0)(syntax-srcloc$1 old-s_0)))"
"(if srcloc_0"
"(let-values(((the-struct_0) new-s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((srcloc257_0) srcloc_0))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
" srcloc257_0"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
" new-s_0)))))"
"(define-values"
"(stop-ids->all-stop-ids)"
"(lambda(stop-ids_0 phase_0)"
"(begin"
"(if(null? stop-ids_0)"
"(let-values() stop-ids_0)"
"(let-values()"
"(let-values(((p-core-stx_0)(syntax-shift-phase-level$1 core-stx phase_0)))"
"(if(if(= 1(length stop-ids_0))"
"(free-identifier=?$1(car stop-ids_0)(datum->syntax$1 p-core-stx_0 'module*) phase_0 phase_0)"
" #f)"
"(let-values() stop-ids_0)"
"(let-values()"
"(append"
" stop-ids_0"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) auto-stop-syms))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1"
" p-core-stx_0"
" sym_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))))))"
"(define-values"
"(auto-stop-syms)"
" '(begin"
" quote"
" set!"
" lambda"
" case-lambda"
" let-values"
" letrec-values"
" if"
" begin0"
" with-continuation-mark"
" letrec-syntaxes+values"
" #%app"
" #%expression"
" #%top"
" #%variable-reference))"
"(define-values"
"(module-expand-stop-ids)"
"(lambda(phase_0)"
"(begin"
"(let-values(((p-core-stx_0)(syntax-shift-phase-level$1 core-stx phase_0)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) module-stop-syms))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1 p-core-stx_0 sym_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))"
"(define-values"
"(module-stop-syms)"
"(append"
" auto-stop-syms"
" '(define-values define-syntaxes begin-for-syntax #%require #%provide module module* #%declare #%stratified-body)))"
"(define-values"
"(struct:internal-definition-context"
" internal-definition-context1.1"
" 1/internal-definition-context?"
" internal-definition-context-frame-id"
" internal-definition-context-outside-edge"
" internal-definition-context-inside-edge"
" internal-definition-context-add-scope?"
" internal-definition-context-env-mixins"
" internal-definition-context-use-site-scopes"
" internal-definition-context-parent-ctx)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'internal-definition-context"
" #f"
" 7"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'internal-definition-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'frame-id)"
"(make-struct-field-accessor -ref_0 1 'outside-edge)"
"(make-struct-field-accessor -ref_0 2 'inside-edge)"
"(make-struct-field-accessor -ref_0 3 'add-scope?)"
"(make-struct-field-accessor -ref_0 4 'env-mixins)"
"(make-struct-field-accessor -ref_0 5 'use-site-scopes)"
"(make-struct-field-accessor -ref_0 6 'parent-ctx))))"
"(define-values"
"(struct:env-mixin env-mixin2.1 env-mixin? env-mixin-id env-mixin-sym env-mixin-value env-mixin-cache)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'env-mixin #f 4 0 #f null(current-inspector) #f '(0 1 2 3) #f 'env-mixin)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'sym)"
"(make-struct-field-accessor -ref_0 2 'value)"
"(make-struct-field-accessor -ref_0 3 'cache))))"
"(define-values"
"(1/syntax-local-make-definition-context)"
"(let-values(((syntax-local-make-definition-context_0)"
"(lambda(parent-ctx3_0 add-scope?4_0)"
"(begin"
" 'syntax-local-make-definition-context"
"(let-values(((parent-ctx_0) parent-ctx3_0))"
"(let-values(((add-scope?_0) add-scope?4_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not parent-ctx_0)))"
"(if or-part_0 or-part_0(1/internal-definition-context? parent-ctx_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-make-definition-context"
"                                               \"(or/c #f internal-definition-context?)\""
" parent-ctx_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp40_0) 'syntax-local-make-definition-context))"
"(get-current-expand-context.1 #f temp40_0))))"
"(let-values(((frame-id_0)"
"(let-values(((or-part_0)"
"(if parent-ctx_0"
"(internal-definition-context-frame-id parent-ctx_0)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(not(eq? 'expression(expand-context-context ctx_0)))"
"(root-expand-context-frame-id ctx_0)"
" #f)))"
"(if or-part_1 or-part_1(gensym)))))))"
"(let-values(((outside-edge_0)(new-scope 'intdef-outside)))"
"(let-values(((inside-edge_0)(new-scope 'intdef)))"
"(let-values(((def-ctx-scopes_0)(expand-context-def-ctx-scopes ctx_0)))"
"(let-values((()"
"(begin"
"(if def-ctx-scopes_0"
"(let-values()"
"(set-box!"
" def-ctx-scopes_0"
"(cons"
" inside-edge_0"
"(cons outside-edge_0(unbox def-ctx-scopes_0)))))"
"(void))"
"(values))))"
"(let-values(((use-site-scopes_0)(box '())))"
"(internal-definition-context1.1"
" frame-id_0"
" outside-edge_0"
" inside-edge_0"
" add-scope?_0"
"(box null)"
" use-site-scopes_0"
" parent-ctx_0))))))))))))))))"
"(case-lambda"
"(()(begin 'syntax-local-make-definition-context(syntax-local-make-definition-context_0 #f #t)))"
"((parent-ctx_0 add-scope?4_0)(syntax-local-make-definition-context_0 parent-ctx_0 add-scope?4_0))"
"((parent-ctx3_0)(syntax-local-make-definition-context_0 parent-ctx3_0 #t)))))"
"(define-values"
"(1/syntax-local-make-definition-context-introducer)"
"(let-values(((syntax-local-make-definition-context-introducer_0)"
"(lambda(name5_0)"
"(begin"
" 'syntax-local-make-definition-context-introducer"
"(let-values(((name_0) name5_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if((lambda(name_1)(if(symbol? name_1)(not(eq? name_1 'macro)) #f))"
" name_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-make-definition-context-introducer"
"                                                 \"(and/c symbol? (not/c 'macro))\""
" name_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((who42_0) 'syntax-local-make-definition-context-introducer))"
"(get-current-expand-context.1 #f who42_0))))"
"(let-values(((scope_0)(new-scope name_0)))"
"(let-values(((def-ctx-scopes_0)(expand-context-def-ctx-scopes ctx_0)))"
"(begin"
"(if def-ctx-scopes_0"
"(let-values()"
"(set-box! def-ctx-scopes_0(cons scope_0(unbox def-ctx-scopes_0))))"
"(void))"
"(let-values(((...finition-context.rkt:86:2_0)"
"(lambda(s44_0 mode43_0)"
"(begin"
" '...finition-context.rkt:86:2"
"(let-values(((s_0) s44_0))"
"(let-values(((mode_0) mode43_0))"
"(let-values()"
"(let-values(((who_0) 'definition-context-introducer))"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                                                     \"syntax?\""
" s_0)))"
"(values))))"
"(let-values(((new-s_0)"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(add-scope s_0 scope_0))"
"(if(equal? tmp_0 'remove)"
"(let-values()"
"(remove-scope s_0 scope_0))"
"(if(equal? tmp_0 'flip)"
"(let-values()"
"(flip-scope s_0 scope_0))"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                                                           \"(or/c 'add 'remove 'flip)\""
" mode_0))))))))"
"(let-values(((ctx_1)"
"(let-values(((temp45_0) #t))"
"(get-current-expand-context.1"
" temp45_0"
" 'unexpected))))"
"(begin"
"(if ctx_1"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'track-syntax"
" who_0"
" new-s_0"
" s_0)))"
"(void))))"
"(void))"
" new-s_0))))))))))))"
"(case-lambda"
"((s_0)"
"(begin"
" '...finition-context.rkt:86:2"
"(...finition-context.rkt:86:2_0 s_0 'flip)))"
"((s_0 mode43_0)(...finition-context.rkt:86:2_0 s_0 mode43_0)))))))))))))))))"
"(case-lambda"
"(()"
"(begin"
" 'syntax-local-make-definition-context-introducer"
"(syntax-local-make-definition-context-introducer_0 'intdef)))"
"((name5_0)(syntax-local-make-definition-context-introducer_0 name5_0)))))"
"(define-values"
"(1/syntax-local-bind-syntaxes)"
"(let-values(((syntax-local-bind-syntaxes_0)"
"(lambda(ids7_0 s8_0 intdef9_0 extra-intdefs6_0)"
"(begin"
" 'syntax-local-bind-syntaxes"
"(let-values(((ids_0) ids7_0))"
"(let-values(((s_0) s8_0))"
"(let-values(((intdef_0) intdef9_0))"
"(let-values(((extra-intdefs_0) extra-intdefs6_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if(list? ids_0)(andmap2 identifier? ids_0) #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-bind-syntaxes"
"                                                   \"(listof identifier?)\""
" ids_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not s_0)))"
"(if or-part_0 or-part_0(syntax?$1 s_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-bind-syntaxes"
"                                                     \"(or/c syntax? #f)\""
" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-bind-syntaxes"
"                                                       \"internal-definition-context?\""
" intdef_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(intdefs? extra-intdefs_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-bind-syntaxes"
" intdefs?-string"
" extra-intdefs_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp46_0) 'local-expand))"
"(get-current-expand-context.1 #f temp46_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'local-bind ids_0)))"
"(void)))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((all-intdefs_0)"
"(if(null? extra-intdefs_0)"
" intdef_0"
"(if(list? extra-intdefs_0)"
"(cons intdef_0 extra-intdefs_0)"
"(list intdef_0 extra-intdefs_0)))))"
"(let-values(((intdef-ids_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((pre-id_0)"
"(remove-intdef-use-site-scopes"
"(flip-introduction-scopes"
" id_0"
" ctx_0)"
" intdef_0)))"
"(let-values(((temp47_0)"
"(let-values(((pre-id49_0)"
" pre-id_0)"
"((intdef50_0)"
" intdef_0)"
"((temp51_0)"
" #t))"
"(add-intdef-scopes.1"
" unsafe-undefined"
" temp51_0"
" pre-id49_0"
" intdef50_0)))"
"((extra-intdefs48_0)"
" extra-intdefs_0))"
"(add-intdef-scopes.1"
" unsafe-undefined"
" #f"
" temp47_0"
" extra-intdefs48_0))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-list"
" intdef-ids_0)))"
"(void)))"
"(values))))"
"(let-values(((counter_0)(root-expand-context-counter ctx_0)))"
"(let-values(((local-sym_0)"
"(if(expand-context-normalize-locals? ctx_0)"
" 'loc"
" #f)))"
"(let-values(((syms_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) intdef-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((intdef-id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((intdef-id52_0)"
" intdef-id_0)"
"((phase53_0)"
" phase_0)"
"((counter54_0)"
" counter_0)"
"((temp55_0)"
"(internal-definition-context-frame-id"
" intdef_0))"
"((local-sym56_0)"
" local-sym_0))"
"(add-local-binding!.1"
" temp55_0"
" #f"
" local-sym56_0"
" intdef-id52_0"
" phase53_0"
" counter54_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((local-ctx_0)"
"(if s_0"
"(let-values()"
"(let-values(((tmp-env_0)"
"(let-values(((env_0)"
"(let-values(((env_0)"
"(expand-context-env"
" ctx_0)))"
" env_0)))"
"(let-values(((lst_0) syms_0)"
"((lst_1)"
" intdef-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_1"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((intdef-id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((env_2)"
"(let-values(((env_2)"
"(let-values()"
"(env-extend"
" env_1"
" sym_0"
"(local-variable1.1"
" intdef-id_0)))))"
"(values"
" env_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_2"
" rest_0"
" rest_1)"
" env_2)))"
" env_1))))))"
" for-loop_0)"
" env_0"
" lst_0"
" lst_1))))))"
"(let-values(((temp57_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((env61_0)"
" tmp-env_0)"
"((inner62_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner62_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
" env61_0"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                 \"expand-context/outer?\""
" the-struct_0)))))"
"((temp58_0) 'expression)"
"((all-intdefs59_0)"
" all-intdefs_0)"
"((temp60_0) #f))"
"(make-local-expand-context.1"
" temp58_0"
" temp60_0"
" all-intdefs59_0"
" #t"
" unsafe-undefined"
" #f"
" #f"
" #f"
" temp57_0))))"
" #f)))"
"(let-values(((vals_0)"
"(if s_0"
"(let-values()"
"(let-values(((input-s_0)"
"(flip-introduction-scopes"
"(let-values(((s63_0) s_0)"
"((all-intdefs64_0)"
" all-intdefs_0))"
"(add-intdef-scopes.1"
" unsafe-undefined"
" #f"
" s63_0"
" all-intdefs64_0))"
" ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-bind)))"
"(void)))"
"(values))))"
"(let-values(((vals_0)"
"(eval-for-syntaxes-binding"
" 'syntax-local-bind-syntaxes"
" input-s_0"
" ids_0"
" local-ctx_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-bind)))"
"(void)))"
" vals_0)))))"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0) intdef-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((intdef-id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(local-variable1.1"
" intdef-id_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))"
"(let-values(((env-mixins_0)"
"(internal-definition-context-env-mixins"
" intdef_0)))"
"(begin"
"(set-box!"
" env-mixins_0"
"(append"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) intdef-ids_0)"
"((lst_1) syms_0)"
"((lst_2) vals_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_3"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_3)"
"(if(pair? lst_4)"
"(pair? lst_5)"
" #f)"
" #f)"
"(let-values(((intdef-id_0)"
"(unsafe-car"
" lst_3))"
"((rest_0)"
"(unsafe-cdr"
" lst_3))"
"((sym_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((val_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(if local-ctx_0"
"(let-values()"
"(maybe-install-free=id-in-context!"
" val_0"
" intdef-id_0"
" phase_0"
" local-ctx_0))"
"(void))"
"(env-mixin2.1"
" intdef-id_0"
" sym_0"
" val_0"
"(make-weak-hasheq))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0"
" rest_1"
" rest_2)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1"
" lst_2)))))"
"(unbox env-mixins_0)))"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'exit-local-bind)))"
"(void)))"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) intdef-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(flip-introduction-scopes"
" id_0"
" ctx_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))))))))))))))))))))))))"
"(case-lambda"
"((ids_0 s_0 intdef_0)(begin 'syntax-local-bind-syntaxes(syntax-local-bind-syntaxes_0 ids_0 s_0 intdef_0 '())))"
"((ids_0 s_0 intdef_0 extra-intdefs6_0)(syntax-local-bind-syntaxes_0 ids_0 s_0 intdef_0 extra-intdefs6_0)))))"
"(define-values"
"(1/internal-definition-context-binding-identifiers)"
"(lambda(intdef_0)"
"(begin"
" 'internal-definition-context-binding-identifiers"
"(begin"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'internal-definition-context-binding-identifiers"
"             \"internal-definition-context?\""
" intdef_0)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(unbox(internal-definition-context-env-mixins intdef_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((env-mixin_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()(env-mixin-id env-mixin_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))"
"(define-values"
"(1/internal-definition-context-introduce)"
"(let-values(((internal-definition-context-introduce_0)"
"(lambda(intdef11_0 s12_0 mode10_0)"
"(begin"
" 'internal-definition-context-introduce"
"(let-values(((intdef_0) intdef11_0))"
"(let-values(((s_0) s12_0))"
"(let-values(((mode_0) mode10_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'internal-definition-context-introduce"
"                                                 \"internal-definition-context?\""
" intdef_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'internal-definition-context-introduce"
"                                                   \"syntax?\""
" s_0)))"
"(values))))"
"(let-values(((new-s_0)"
"(let-values(((s65_0) s_0)"
"((intdef66_0) intdef_0)"
"((temp67_0) #t)"
"((temp68_0)"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'add)"
"(let-values() add-scope)"
"(if(equal? tmp_0 'remove)"
"(let-values() remove-scope)"
"(if(equal? tmp_0 'flip)"
"(let-values() flip-scope)"
"(let-values()"
"(raise-argument-error"
" 'internal-definition-context-introduce"
"                                                                       \"(or/c 'add 'remove 'flip)\""
" mode_0))))))))"
"(add-intdef-scopes.1 temp68_0 temp67_0 s65_0 intdef66_0))))"
"(let-values(((ctx_0)"
"(let-values(((temp69_0) #t))"
"(get-current-expand-context.1 temp69_0 'unexpected))))"
"(begin"
"(if ctx_0"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'track-syntax"
" 'internal-definition-context-introduce"
" new-s_0"
" s_0)))"
"(void))))"
"(void))"
" new-s_0)))))))))))))"
"(case-lambda"
"((intdef_0 s_0)"
"(begin 'internal-definition-context-introduce(internal-definition-context-introduce_0 intdef_0 s_0 'flip)))"
"((intdef_0 s_0 mode10_0)(internal-definition-context-introduce_0 intdef_0 s_0 mode10_0)))))"
"(define-values"
"(1/internal-definition-context-seal)"
"(lambda(intdef_0)"
"(begin"
" 'internal-definition-context-seal"
"(begin"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"            (raise-argument-error 'internal-definition-context-seal \"internal-definition-context?\" intdef_0)))"
"(void)))))"
"(define-values"
"(1/identifier-remove-from-definition-context)"
"(lambda(id_0 intdef_0)"
"(begin"
" 'identifier-remove-from-definition-context"
"(begin"
"(if(identifier? id_0)"
"(void)"
"          (let-values () (raise-argument-error 'identifier-remove-from-definition-context \"identifier?\" id_0)))"
"(if(let-values(((or-part_0)(1/internal-definition-context? intdef_0)))"
"(if or-part_0 or-part_0(if(list? intdef_0)(andmap2 1/internal-definition-context? intdef_0) #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'identifier-remove-from-definition-context"
"             \"(or/c internal-definition-context? (listof internal-definition-context?))\""
" intdef_0)))"
"(let-values(((id_1)(let-values(((id_1) id_0)) id_1)))"
"(let-values(((x_0)"
"(let-values(((a_0) intdef_0))"
"(if(list? a_0)"
"(let-values()(reverse$1 a_0))"
"(if(not a_0)(let-values() null)(let-values()(list a_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(id_2 a_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? a_0)"
"(let-values(((intdef_1)(car a_0)))"
"(let-values(((id_3)"
"(let-values(((id_3)"
"(let-values()"
"(1/internal-definition-context-introduce"
" intdef_1"
" id_2"
" 'remove))))"
"(values id_3))))"
"(if(not #f)(for-loop_0 id_3(cdr a_0)) id_3)))"
" id_2))))))"
" for-loop_0)"
" id_1"
" x_0))))))))"
"(define-values"
"(1/internal-definition-context-add-scopes)"
"(lambda(intdef_0 s_0)"
"(begin"
" 'internal-definition-context-add-scopes"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"          (let-values () (raise-argument-error 'internal-definition-context-add-scopes \"syntax?\" s_0)))"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"            (raise-argument-error 'internal-definition-context-add-scopes \"internal-definition-context?\" intdef_0)))"
"(add-scope"
"(add-scope s_0(internal-definition-context-inside-edge intdef_0))"
"(internal-definition-context-outside-edge intdef_0))))))"
"(define-values"
"(1/internal-definition-context-splice-binding-identifier)"
"(lambda(intdef_0 id_0)"
"(begin"
" 'internal-definition-context-splice-binding-identifier"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"            (raise-argument-error 'internal-definition-context-splice-binding-identifier \"identifier?\" id_0)))"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'internal-definition-context-splice-binding-identifier"
"             \"internal-definition-context?\""
" intdef_0)))"
"(remove-intdef-use-site-scopes"
"(remove-scope"
"(remove-scope id_0(internal-definition-context-inside-edge intdef_0))"
"(internal-definition-context-outside-edge intdef_0))"
" intdef_0)))))"
"(define-values"
"(intdefs?)"
"(lambda(x_0)"
"(begin"
"(let-values(((or-part_0)(1/internal-definition-context? x_0)))"
"(if or-part_0 or-part_0(if(list? x_0)(andmap2 1/internal-definition-context? x_0) #f))))))"
" (define-values (intdefs?-string) \"(or/c internal-definition-context? (listof internal-definition-context?))\")"
"(define-values"
"(intdefs-or-false?)"
"(lambda(x_0)(begin(let-values(((or-part_0)(not x_0)))(if or-part_0 or-part_0(intdefs? x_0))))))"
"(define-values"
"(intdefs-or-false?-string)"
"  \"(or/c internal-definition-context? (listof internal-definition-context?) #f)\")"
"(define-values"
"(add-intdef-bindings)"
"(lambda(env_0 intdefs_0)"
"(begin"
"(let-values(((env_1)(let-values(((env_1) env_0)) env_1)))"
"(let-values(((x_0)"
"(let-values(((a_0) intdefs_0))"
"(if(list? a_0)"
"(let-values()(reverse$1 a_0))"
"(if(not a_0)(let-values() null)(let-values()(list a_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(env_2 a_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? a_0)"
"(let-values(((intdef_0)(car a_0)))"
"(let-values(((env_3)"
"(let-values(((env_3)"
"(let-values()"
"(let-values(((parent-ctx_0)"
"(internal-definition-context-parent-ctx"
" intdef_0)))"
"(let-values(((parent-env_0)"
"(if parent-ctx_0"
"(add-intdef-bindings"
" env_2"
" parent-ctx_0)"
" env_2)))"
"(let-values(((env-mixins_0)"
"(unbox"
"(internal-definition-context-env-mixins"
" intdef_0))))"
"((letrec-values(((loop_0)"
"(lambda(env_3"
" env-mixins_1)"
"(begin"
" 'loop"
"(if(null?"
" env-mixins_1)"
"(let-values()"
" env_3)"
"(let-values()"
"(let-values(((env-mixin_0)"
"(car"
" env-mixins_1)))"
"(let-values(((or-part_0)"
"(hash-ref"
"(env-mixin-cache"
" env-mixin_0)"
" env_3"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((new-env_0)"
"(env-extend"
"(loop_0"
" env_3"
"(cdr"
" env-mixins_1))"
"(env-mixin-sym"
" env-mixin_0)"
"(env-mixin-value"
" env-mixin_0))))"
"(begin"
"(hash-set!"
"(env-mixin-cache"
" env-mixin_0)"
" env_3"
" new-env_0)"
" new-env_0)))))))))))"
" loop_0)"
" parent-env_0"
" env-mixins_0)))))))"
"(values env_3))))"
"(if(not #f)(for-loop_0 env_3(cdr a_0)) env_3)))"
" env_2))))))"
" for-loop_0)"
" env_1"
" x_0)))))))"
"(define-values"
"(add-intdef-scopes.1)"
"(lambda(action14_0 always?13_0 s17_0 intdefs18_0)"
"(begin"
" 'add-intdef-scopes"
"(let-values(((s_0) s17_0))"
"(let-values(((intdefs_0) intdefs18_0))"
"(let-values(((always?_0) always?13_0))"
"(let-values(((action_0)(if(eq? action14_0 unsafe-undefined) add-scope action14_0)))"
"(let-values()"
"(let-values(((s_1)(let-values(((s_1) s_0)) s_1)))"
"(let-values(((x_0)"
"(let-values(((a_0) intdefs_0))"
"(if(list? a_0)"
"(let-values()(reverse$1 a_0))"
"(if(not a_0)(let-values() null)(let-values()(list a_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(s_2 a_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? a_0)"
"(let-values(((intdef_0)(car a_0)))"
"(let-values(((s_3)"
"(if(let-values(((or-part_0) always?_0))"
"(if or-part_0"
" or-part_0"
"(internal-definition-context-add-scope?"
" intdef_0)))"
"(let-values(((s_3)"
"(let-values()"
"(action_0"
" s_2"
"(internal-definition-context-inside-edge"
" intdef_0)))))"
"(values s_3))"
" s_2)))"
"(if(not #f)(for-loop_0 s_3(cdr a_0)) s_3)))"
" s_2))))))"
" for-loop_0)"
" s_1"
" x_0))))))))))))"
"(define-values"
"(make-local-expand-context.1)"
"(lambda(context20_0"
" in-local-expand?27_0"
" intdefs22_0"
" keep-#%expression?26_0"
" phase21_0"
" stop-ids23_0"
" to-parsed-ok?24_0"
" track-to-be-defined?25_0"
" ctx36_0)"
"(begin"
" 'make-local-expand-context"
"(let-values(((ctx_0) ctx36_0))"
"(let-values(((context_0) context20_0))"
"(let-values(((phase_0)(if(eq? phase21_0 unsafe-undefined)(expand-context-phase ctx_0) phase21_0)))"
"(let-values(((intdefs_0) intdefs22_0))"
"(let-values(((stop-ids_0) stop-ids23_0))"
"(let-values(((to-parsed-ok?_0) to-parsed-ok?24_0))"
"(let-values(((track-to-be-defined?_0) track-to-be-defined?25_0))"
"(let-values(((keep-#%expression?_0) keep-#%expression?26_0))"
"(let-values(((in-local-expand?_0) in-local-expand?27_0))"
"(let-values()"
"(let-values(((same-kind?_0)"
"(let-values(((or-part_0)(eq? context_0(expand-context-context ctx_0))))"
"(if or-part_0"
" or-part_0"
"(if(list? context_0)(list?(expand-context-context ctx_0)) #f)))))"
"(let-values(((all-stop-ids_0)"
"(if stop-ids_0(stop-ids->all-stop-ids stop-ids_0 phase_0) #f)))"
"(let-values(((def-ctx-scopes_0)"
"(if(expand-context-def-ctx-scopes ctx_0)"
"(unbox(expand-context-def-ctx-scopes ctx_0))"
" null)))"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context70_0) context_0)"
"((env71_0)"
"(add-intdef-bindings(expand-context-env ctx_0) intdefs_0))"
"((use-site-scopes72_0)"
"(if(let-values(((or-part_0)(eq? context_0 'module)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? context_0 'module-begin)))"
"(if or-part_1 or-part_1(list? context_0)))))"
"(if(1/internal-definition-context? intdefs_0)"
"(internal-definition-context-use-site-scopes intdefs_0)"
"(let-values(((or-part_0)"
"(root-expand-context-use-site-scopes ctx_0)))"
"(if or-part_0 or-part_0(box null))))"
" #f))"
"((frame-id73_0)"
"(if(1/internal-definition-context? intdefs_0)"
"(let-values()(internal-definition-context-frame-id intdefs_0))"
"(if(not intdefs_0)"
"(let-values()(root-expand-context-frame-id ctx_0))"
"(if(list? intdefs_0)"
"(let-values()"
"(let-values(((frame-id_0)"
"(let-values(((frame-id_0)"
"(if(not"
"(eq?"
" 'expression"
"(expand-context-context"
" ctx_0)))"
"(root-expand-context-frame-id"
" ctx_0)"
" #f)))"
" frame-id_0)))"
"(let-values(((x_0)"
"(let-values(((a_0) intdefs_0))"
"(if(list? a_0)"
"(let-values()(reverse$1 a_0))"
"(if(not a_0)"
"(let-values() null)"
"(let-values()(list a_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(frame-id_1 a_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? a_0)"
"(let-values(((intdef_0)"
"(car a_0)))"
"(let-values(((frame-id_2)"
"(let-values(((frame-id_2)"
"(let-values()"
"(let-values(((i-frame-id_0)"
"(internal-definition-context-frame-id"
" intdef_0)))"
"(if(if frame-id_1"
"(if i-frame-id_0"
"(not"
"(eq?"
" frame-id_1"
" i-frame-id_0))"
" #f)"
" #f)"
"(let-values()"
" 'all)"
"(let-values()"
"(let-values(((or-part_0)"
" frame-id_1))"
"(if or-part_0"
" or-part_0"
" i-frame-id_0))))))))"
"(values"
" frame-id_2))))"
"(if(not #f)"
"(for-loop_0"
" frame-id_2"
"(cdr a_0))"
" frame-id_2)))"
" frame-id_1))))))"
" for-loop_0)"
" frame-id_0"
" x_0)))))"
"(void)))))"
"((post-expansion74_0)"
"(let-values(((pe_0)"
"(if same-kind?_0"
"(if(let-values(((or-part_0)(pair? context_0)))"
"(if or-part_0"
" or-part_0"
"(memq"
" context_0"
" '(module module-begin top-level))))"
"(root-expand-context-post-expansion ctx_0)"
" #f)"
" #f)))"
"(if(if intdefs_0(not(null? intdefs_0)) #f)"
"(let-values()"
"(lambda(s_0)"
"(begin"
" 'post-expansion74"
"(let-values(((temp80_0)(apply-post-expansion pe_0 s_0))"
"((intdefs81_0) intdefs_0))"
"(add-intdef-scopes.1"
" unsafe-undefined"
" #f"
" temp80_0"
" intdefs81_0)))))"
"(let-values() pe_0))))"
"((scopes75_0)"
"(append def-ctx-scopes_0(expand-context-scopes ctx_0)))"
"((only-immediate?76_0)(not stop-ids_0))"
"((current-introduction-scopes77_0) null)"
"((need-eventually-defined78_0)"
"(let-values(((ht_0)"
"(expand-context-need-eventually-defined ctx_0)))"
"(if track-to-be-defined?_0"
"(let-values() ht_0)"
"(if ht_0(let-values()(make-hasheqv))(let-values() #f)))))"
"((inner79_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((to-parsed?82_0)"
"(if to-parsed-ok?_0"
"(expand-context-to-parsed? ctx_0)"
" #f))"
"((just-once?83_0) #f)"
"((in-local-expand?84_0) in-local-expand?_0)"
"((keep-#%expression?85_0) keep-#%expression?_0)"
"((stops86_0)"
"(free-id-set"
" phase_0"
"(let-values(((or-part_0) all-stop-ids_0))"
"(if or-part_0 or-part_0 null)))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
" to-parsed?82_0"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
" just-once?83_0"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
" in-local-expand?84_0"
" keep-#%expression?85_0"
" stops86_0"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-parsing-expanded? the-struct_1)"
"(expand-context/inner-skip-visit-available? the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                         \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner79_0"
" post-expansion74_0"
" use-site-scopes72_0"
" frame-id73_0"
" context70_0"
" env71_0"
" scopes75_0"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
" only-immediate?76_0"
" need-eventually-defined78_0"
" current-introduction-scopes77_0"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                       \"expand-context/outer?\""
" the-struct_0))))))))))))))))))))"
"(define-values"
"(flip-introduction-scopes)"
"(lambda(s_0 ctx_0)(begin(flip-scopes s_0(expand-context-current-introduction-scopes ctx_0)))))"
"(define-values"
"(flip-introduction-and-use-scopes)"
"(lambda(s_0 ctx_0)"
"(begin(flip-scopes(flip-introduction-scopes s_0 ctx_0)(expand-context-current-use-scopes ctx_0)))))"
"(define-values"
"(remove-intdef-use-site-scopes)"
"(lambda(s_0 intdef_0)"
"(begin"
"(let-values(((use-sites_0)(internal-definition-context-use-site-scopes intdef_0)))"
"(if(syntax?$1 s_0)"
"(remove-scopes s_0(unbox use-sites_0))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(remove-scopes id_0(unbox use-sites_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))))"
"(define-values"
"(1/syntax-transforming?)"
"(lambda()"
"(begin"
" 'syntax-transforming?"
"(if(let-values(((temp48_0) #t))(get-current-expand-context.1 temp48_0 'unexpected)) #t #f))))"
"(define-values"
"(1/syntax-transforming-with-lifts?)"
"(lambda()"
"(begin"
" 'syntax-transforming-with-lifts?"
"(let-values(((ctx_0)(let-values(((temp49_0) #t))(get-current-expand-context.1 temp49_0 'unexpected))))"
"(if ctx_0(if(expand-context-lifts ctx_0) #t #f) #f)))))"
"(define-values"
"(1/syntax-transforming-module-expression?)"
"(lambda()"
"(begin"
" 'syntax-transforming-module-expression?"
"(let-values(((ctx_0)(let-values(((temp50_0) #t))(get-current-expand-context.1 temp50_0 'unexpected))))"
"(if ctx_0(if(expand-context-to-module-lifts ctx_0) #t #f) #f)))))"
"(define-values"
"(1/syntax-local-transforming-module-provides?)"
"(lambda()"
"(begin"
" 'syntax-local-transforming-module-provides?"
"(let-values(((ctx_0)(let-values(((temp51_0) #t))(get-current-expand-context.1 temp51_0 'unexpected))))"
"(if ctx_0(if(expand-context-requires+provides ctx_0) #t #f) #f)))))"
"(define-values"
"(1/syntax-local-compiling-module?)"
"(lambda()"
"(begin"
" 'syntax-local-compiling-module?"
"(let-values(((ctx_0)(let-values(((temp52_0) #t))(get-current-expand-context.1 temp52_0 'unexpected))))"
"(if ctx_0"
"(if(eq?(expand-context-context ctx_0) 'module-begin)"
"(if(expand-context-to-parsed? ctx_0)(module-path-index-resolved(root-expand-context-self-mpi ctx_0)) #f)"
" #f)"
" #f)))))"
"(define-values"
"(1/syntax-local-context)"
"(lambda()"
"(begin"
" 'syntax-local-context"
"(let-values(((ctx_0)"
"(let-values(((temp53_0) 'syntax-local-context))(get-current-expand-context.1 #f temp53_0))))"
"(expand-context-context ctx_0)))))"
"(define-values"
"(1/syntax-local-introduce)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-introduce"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-local-introduce \"syntax?\" s_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp55_0) 'syntax-local-introduce))"
"(get-current-expand-context.1 #f temp55_0))))"
"(let-values(((new-s_0)(flip-introduction-and-use-scopes s_0 ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'track-syntax 'syntax-local-introduce new-s_0 s_0)))"
"(void)))"
" new-s_0)))))))))"
"(define-values"
"(1/syntax-local-identifier-as-binding)"
"(let-values(((syntax-local-identifier-as-binding_0)"
"(lambda(id2_0 intdef1_0)"
"(begin"
" 'syntax-local-identifier-as-binding"
"(let-values(((id_0) id2_0))"
"(let-values(((intdef_0) intdef1_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-identifier-as-binding"
"                                                   \"identifier?\""
" id_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if intdef_0"
"(let-values()"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-identifier-as-binding"
"                                                         \"internal-definition-context?\""
" intdef_0))))"
"(void))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp57_0) 'syntax-local-identifier-as-binding))"
"(get-current-expand-context.1 #f temp57_0))))"
"(let-values(((new-id_0)"
"(if intdef_0"
"(remove-intdef-use-site-scopes id_0 intdef_0)"
"(remove-use-site-scopes id_0 ctx_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'track-syntax"
" 'syntax-local-identifier-as-binding"
" new-id_0"
" id_0)))"
"(void)))"
" new-id_0))))))))))))))"
"(case-lambda"
"((id_0)(begin 'syntax-local-identifier-as-binding(syntax-local-identifier-as-binding_0 id_0 #f)))"
"((id_0 intdef1_0)(syntax-local-identifier-as-binding_0 id_0 intdef1_0)))))"
"(define-values"
"(1/syntax-local-phase-level)"
"(lambda()"
"(begin"
" 'syntax-local-phase-level"
"(let-values(((ctx_0)(let-values(((temp58_0) #t))(get-current-expand-context.1 temp58_0 'unexpected))))"
"(if ctx_0(expand-context-phase ctx_0) 0)))))"
"(define-values"
"(1/syntax-local-name)"
"(lambda()"
"(begin"
" 'syntax-local-name"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0)"
"(let-values(((who60_0) 'syntax-local-name))(get-current-expand-context.1 #f who60_0))))"
"(let-values(((id_0)(expand-context-name ctx_0)))"
"(if id_0(datum->syntax$1 #f(syntax-e$1 id_0) id_0) #f))))))))"
"(define-values"
"(1/make-syntax-introducer)"
"(let-values(((make-syntax-introducer_0)"
"(lambda(as-use-site?3_0)"
"(begin"
" 'make-syntax-introducer"
"(let-values(((as-use-site?_0) as-use-site?3_0))"
"(let-values()(do-make-syntax-introducer(new-scope(if as-use-site?_0 'use-site 'macro)))))))))"
"(case-lambda"
"(()(begin 'make-syntax-introducer(make-syntax-introducer_0 #f)))"
"((as-use-site?3_0)(make-syntax-introducer_0 as-use-site?3_0)))))"
"(define-values"
"(1/make-interned-syntax-introducer)"
"(lambda(sym-key_0)"
"(begin"
" 'make-interned-syntax-introducer"
"(let-values()"
"(let-values()"
"(begin"
"(if((lambda(v_0)(if(symbol? v_0)(symbol-interned? v_0) #f)) sym-key_0)"
"(void)"
"(let-values()"
"                (raise-argument-error 'make-interned-syntax-introducer \"(and/c symbol? symbol-interned?)\" sym-key_0)))"
"(do-make-syntax-introducer(make-interned-scope sym-key_0))))))))"
"(define-values"
"(do-make-syntax-introducer)"
"(lambda(sc_0)"
"(begin"
"(let-values(((...and/syntax-local.rkt:148:2_0)"
"(lambda(s63_0 mode62_0)"
"(begin"
" '...and/syntax-local.rkt:148:2"
"(let-values(((s_0) s63_0))"
"(let-values(((mode_0) mode62_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                                (let-values () (raise-argument-error 'syntax-introducer \"syntax?\" s_0)))"
"(values))))"
"(let-values(((new-s_0)"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'add)"
"(let-values()(add-scope s_0 sc_0))"
"(if(equal? tmp_0 'remove)"
"(let-values()(remove-scope s_0 sc_0))"
"(if(equal? tmp_0 'flip)"
"(let-values()(flip-scope s_0 sc_0))"
"(let-values()"
"(raise-argument-error"
" 'syntax-introducer"
"                                                         \"(or/c 'add 'remove 'flip)\""
" mode_0))))))))"
"(let-values(((ctx_0)"
"(let-values(((temp64_0) #t))"
"(get-current-expand-context.1 temp64_0 'unexpected))))"
"(begin"
"(if ctx_0"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'track-syntax mode_0 new-s_0 s_0)))"
"(void))))"
"(void))"
" new-s_0)))))))))))"
"(case-lambda"
"((s_0)(begin '...and/syntax-local.rkt:148:2(...and/syntax-local.rkt:148:2_0 s_0 'flip)))"
"((s_0 mode62_0)(...and/syntax-local.rkt:148:2_0 s_0 mode62_0)))))))"
"(define-values"
"(1/make-syntax-delta-introducer)"
"(let-values(((make-syntax-delta-introducer_0)"
"(lambda(ext-s5_0 base-s6_0 phase4_0)"
"(begin"
" 'make-syntax-delta-introducer"
"(let-values(((ext-s_0) ext-s5_0))"
"(let-values(((base-s_0) base-s6_0))"
"(let-values(((phase_0)"
"(if(eq? phase4_0 unsafe-undefined)(1/syntax-local-phase-level) phase4_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 ext-s_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-syntax-delta-introducer"
"                                                     \"syntax?\""
" ext-s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(syntax?$1 x_0))))"
" base-s_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-syntax-delta-introducer"
"                                                       \"(or/c syntax? #f)\""
" base-s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(phase? phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-syntax-delta-introducer"
" phase?-string"
" phase_0)))"
"(values))))"
"(let-values(((ext-scs_0)(syntax-scope-set ext-s_0 phase_0)))"
"(let-values(((base-scs_0)"
"(syntax-scope-set"
"(let-values(((or-part_0) base-s_0))"
"(if or-part_0 or-part_0 empty-syntax))"
" phase_0)))"
"(let-values(((use-base-scs_0)"
"(if(subset? base-scs_0 ext-scs_0)"
" base-scs_0"
"(let-values(((or-part_0)"
"(if(identifier? base-s_0)"
"(let-values(((base-s66_0) base-s_0)"
"((phase67_0) phase_0)"
"((temp68_0) #t))"
"(resolve.1"
" #f"
" #f"
" null"
" temp68_0"
" base-s66_0"
" phase67_0))"
" #f)))"
"(if or-part_0 or-part_0(seteq))))))"
"(let-values(((delta-scs_0)"
"(set->list(set-subtract ext-scs_0 use-base-scs_0))))"
"(let-values(((maybe-taint_0)"
"(if(syntax-clean? ext-s_0) values syntax-taint$1)))"
"(let-values(((shifts_0)(syntax-mpi-shifts ext-s_0)))"
"(let-values(((...and/syntax-local.rkt:174:2_0)"
"(lambda(s70_0 mode69_0)"
"(begin"
" '...and/syntax-local.rkt:174:2"
"(let-values(((s_0) s70_0))"
"(let-values(((mode_0) mode69_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-introducer"
"                                                                                               \"syntax?\""
" s_0)))"
"(values))))"
"(let-values(((new-s_0)"
"(maybe-taint_0"
"(let-values(((tmp_0)"
" mode_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(let-values(((temp71_0)"
"(add-scopes"
" s_0"
" delta-scs_0))"
"((shifts72_0)"
" shifts_0)"
"((temp73_0)"
" #t))"
"(syntax-add-shifts.1"
" temp73_0"
" temp71_0"
" shifts72_0"
" #f)))"
"(if(equal?"
" tmp_0"
" 'remove)"
"(let-values()"
"(remove-scopes"
" s_0"
" delta-scs_0))"
"(if(equal?"
" tmp_0"
" 'flip)"
"(let-values()"
"(let-values(((temp74_0)"
"(flip-scopes"
" s_0"
" delta-scs_0))"
"((shifts75_0)"
" shifts_0)"
"((temp76_0)"
" #t))"
"(syntax-add-shifts.1"
" temp76_0"
" temp74_0"
" shifts75_0"
" #f)))"
"(let-values()"
"(raise-argument-error"
" 'syntax-introducer"
"                                                                                                      \"(or/c 'add 'remove 'flip)\""
" mode_0)))))))))"
"(let-values(((ctx_0)"
"(let-values(((temp77_0)"
" #t))"
"(get-current-expand-context.1"
" temp77_0"
" 'unexpected))))"
"(begin"
"(if ctx_0"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'track-syntax"
" mode_0"
" new-s_0"
" s_0)))"
"(void))))"
"(void))"
" new-s_0)))))))))))"
"(case-lambda"
"((s_0)"
"(begin"
" '...and/syntax-local.rkt:174:2"
"(...and/syntax-local.rkt:174:2_0 s_0 'add)))"
"((s_0 mode69_0)"
"(...and/syntax-local.rkt:174:2_0"
" s_0"
" mode69_0)))))))))))))))))))))))"
"(case-lambda"
"((ext-s_0 base-s_0)"
"(begin 'make-syntax-delta-introducer(make-syntax-delta-introducer_0 ext-s_0 base-s_0 unsafe-undefined)))"
"((ext-s_0 base-s_0 phase4_0)(make-syntax-delta-introducer_0 ext-s_0 base-s_0 phase4_0)))))"
"(define-values"
"(1/syntax-local-make-delta-introducer)"
"(lambda(id-stx_0)"
"(begin"
" 'syntax-local-make-delta-introducer"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id-stx_0)"
"(void)"
"              (let-values () (raise-argument-error 'syntax-local-make-delta-introducer \"identifier?\" id-stx_0)))"
"(raise"
"(exn:fail:unsupported"
"              \"syntax-local-make-delta-introducer: not supported anymore\""
"(current-continuation-marks)))))))))"
"(define-values"
"(do-syntax-local-value.1)"
"(lambda(immediate?7_0 who9_0 id10_0 intdefs11_0 failure-thunk12_0)"
"(begin"
" 'do-syntax-local-value"
"(let-values(((who_0) who9_0))"
"(let-values(((id_0) id10_0))"
"(let-values(((intdefs_0) intdefs11_0))"
"(let-values(((failure-thunk_0) failure-thunk12_0))"
"(let-values(((immediate?_0) immediate?7_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"                                    (let-values () (raise-argument-error who_0 \"identifier?\" id_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0"
" or-part_0"
"((lambda(p_0)"
"(if(procedure? p_0)(procedure-arity-includes? p_0 0) #f))"
" x_0))))"
" failure-thunk_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                         \"(or/c #f (procedure-arity-includes/c 0))\""
" failure-thunk_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(intdefs-or-false? intdefs_0)"
"(void)"
"(let-values()(raise-argument-error who_0 intdefs-or-false?-string intdefs_0)))"
"(values))))"
"(let-values(((current-ctx_0)"
"(let-values(((who79_0) who_0))(get-current-expand-context.1 #f who79_0))))"
"(let-values(((ctx_0)"
"(if intdefs_0"
"(let-values(((v_0) current-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((env80_0)"
"(add-intdef-bindings"
"(expand-context-env current-ctx_0)"
" intdefs_0))"
"((inner81_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner81_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
" env80_0"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                 \"expand-context/outer?\""
" the-struct_0))))"
" current-ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'local-value id_0)))"
"(void)))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"((letrec-values(((loop_0)"
"(lambda(id_1)"
"(begin"
" 'loop"
"(let-values(((b_0)"
"(if immediate?_0"
"(let-values(((id82_0) id_1)"
"((phase83_0) phase_0)"
"((temp84_0) #t))"
"(resolve+shift.1"
" #f"
" #f"
" null"
" temp84_0"
" #f"
" id82_0"
" phase83_0))"
"(resolve+shift/extra-inspector"
" id_1"
" phase_0"
"(expand-context-namespace ctx_0)))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'resolve id_1)))"
"(void)))"
"(if(not b_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-value-result"
" #f)))"
"(void)))"
"(if failure-thunk_0"
"(failure-thunk_0)"
"                                                                  (error who_0 \"unbound identifier: ~v\" id_1))))"
"(let-values()"
"(let-values(((v_0 primitive?_0 insp_0 protected?_0)"
"(let-values(((b85_0) b_0)"
"((ctx86_0) ctx_0)"
"((id87_0) id_1)"
"((temp88_0) #t))"
"(lookup.1"
" #f"
" temp88_0"
" b85_0"
" ctx86_0"
" id87_0))))"
"(if(let-values(((or-part_0)(variable? v_0)))"
"(if or-part_0 or-part_0(core-form? v_0)))"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-value-result"
" #f)))"
"(void)))"
"(if failure-thunk_0"
"(failure-thunk_0)"
"(error"
" who_0"
"                                                                         \"identifier is not bound to syntax: ~v\""
" id_1))))"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not"
"(if(1/rename-transformer? v_0)"
"(not immediate?_0)"
" #f))"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-value-result"
" #t))"
"(void)))"
"(void)))"
"(if(1/rename-transformer? v_0)"
"(let-values()"
"(if immediate?_0"
"(values"
" v_0"
"(rename-transformer-target-in-context"
" v_0"
" ctx_0))"
"(loop_0"
"(rename-transformer-target-in-context"
" v_0"
" ctx_0))))"
"(if immediate?_0"
"(let-values()(values v_0 #f))"
"(let-values() v_0)))))))))))))))"
" loop_0)"
"(flip-introduction-scopes id_0 ctx_0))))))))))))))))))"
"(define-values"
"(1/syntax-local-value)"
"(let-values(((syntax-local-value_0)"
"(lambda(id16_0 failure-thunk14_0 intdef15_0)"
"(begin"
" 'syntax-local-value"
"(let-values(((id_0) id16_0))"
"(let-values(((failure-thunk_0) failure-thunk14_0))"
"(let-values(((intdef_0) intdef15_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who90_0) 'syntax-local-value)"
"((temp91_0) #f)"
"((id92_0) id_0)"
"((intdef93_0) intdef_0)"
"((failure-thunk94_0) failure-thunk_0))"
"(do-syntax-local-value.1"
" temp91_0"
" who90_0"
" id92_0"
" intdef93_0"
" failure-thunk94_0))))))))))))"
"(case-lambda"
"((id_0)(begin 'syntax-local-value(syntax-local-value_0 id_0 #f #f)))"
"((id_0 failure-thunk_0 intdef15_0)(syntax-local-value_0 id_0 failure-thunk_0 intdef15_0))"
"((id_0 failure-thunk14_0)(syntax-local-value_0 id_0 failure-thunk14_0 #f)))))"
"(define-values"
"(1/syntax-local-value/immediate)"
"(let-values(((syntax-local-value/immediate_0)"
"(lambda(id19_0 failure-thunk17_0 intdef18_0)"
"(begin"
" 'syntax-local-value/immediate"
"(let-values(((id_0) id19_0))"
"(let-values(((failure-thunk_0) failure-thunk17_0))"
"(let-values(((intdef_0) intdef18_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who96_0) 'syntax-local-value/immediate)"
"((temp97_0) #t)"
"((id98_0) id_0)"
"((intdef99_0) intdef_0)"
"((failure-thunk100_0) failure-thunk_0))"
"(do-syntax-local-value.1"
" temp97_0"
" who96_0"
" id98_0"
" intdef99_0"
" failure-thunk100_0))))))))))))"
"(case-lambda"
"((id_0)(begin 'syntax-local-value/immediate(syntax-local-value/immediate_0 id_0 #f #f)))"
"((id_0 failure-thunk_0 intdef18_0)(syntax-local-value/immediate_0 id_0 failure-thunk_0 intdef18_0))"
"((id_0 failure-thunk17_0)(syntax-local-value/immediate_0 id_0 failure-thunk17_0 #f)))))"
"(define-values"
"(do-lift-values-expression)"
"(lambda(who_0 n_0 s_0)"
"(begin"
"(let-values((()"
"(begin"
"                      (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error who_0 \"syntax?\" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(exact-nonnegative-integer? n_0)"
"(void)"
"                          (let-values () (raise-argument-error who_0 \"exact-nonnegative-integer?\" n_0)))"
"(values))))"
"(let-values(((ctx_0)(let-values(((who101_0) who_0))(get-current-expand-context.1 #f who101_0))))"
"(let-values(((lifts_0)(expand-context-lifts ctx_0)))"
"(let-values((()"
"(begin"
"                              (if lifts_0 (void) (let-values () (raise-arguments-error who_0 \"no lift target\")))"
"(values))))"
"(let-values(((counter_0)(root-expand-context-counter ctx_0)))"
"(let-values(((ids_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((start_0) 0)((end_0) n_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(< pos_0 end_0)"
"(let-values()"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values((()"
"(begin"
"(set-box!"
" counter_0"
"(add1"
"(unbox"
" counter_0)))"
"(values))))"
"(let-values(((name_0)"
"(string->unreadable-symbol"
"(format"
"                                                                                                                      \"lifted/~a\""
"(unbox"
" counter_0)))))"
"(add-scope"
"(datum->syntax$1"
" #f"
" name_0)"
"(new-scope"
" 'macro)))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2(+ pos_0 inc_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" start_0)))))))"
"(let-values(((added-s_0)(flip-introduction-scopes s_0 ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'lift-expr ids_0 s_0 added-s_0)))"
"(void)))"
"(map2"
"(lambda(id_0)(flip-introduction-scopes id_0 ctx_0))"
"(add-lifted! lifts_0 ids_0 added-s_0(expand-context-phase ctx_0)))))))))))))))"
"(define-values"
"(1/syntax-local-lift-expression)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-lift-expression"
"(let-values()(let-values()(car(do-lift-values-expression 'syntax-local-lift-expression 1 s_0)))))))"
"(define-values"
"(1/syntax-local-lift-values-expression)"
"(lambda(n_0 s_0)"
"(begin"
" 'syntax-local-lift-values-expression"
"(let-values()(let-values()(do-lift-values-expression 'syntax-local-lift-values-expression n_0 s_0))))))"
"(define-values"
"(1/syntax-local-lift-context)"
"(lambda()"
"(begin"
" 'syntax-local-lift-context"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0)"
"(let-values(((who105_0) 'syntax-local-lift-context))"
"(get-current-expand-context.1 #f who105_0))))"
"(root-expand-context-lift-key ctx_0)))))))"
"(define-values"
"(1/syntax-local-lift-module)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-lift-module"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-local-lift-module \"syntax?\" s_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((who107_0) 'syntax-local-lift-module))"
"(get-current-expand-context.1 #f who107_0))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((tmp_0)(core-form-sym s_0 phase_0)))"
"(if(if(equal? tmp_0 'module) #t(equal? tmp_0 'module*))"
"(let-values()"
"(let-values(((lifts_0)(expand-context-module-lifts ctx_0)))"
"(let-values((()"
"(begin"
"(if lifts_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-local-lift-module"
"                                             \"not currently transforming within a module declaration or top level\""
"                                             \"form to lift\""
" s_0)))"
"(values))))"
"(let-values(((added-s_0)(flip-introduction-scopes s_0 ctx_0)))"
"(begin"
"(add-lifted-module! lifts_0 added-s_0 phase_0)"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'lift-module s_0 added-s_0)))"
"(void))))))))"
"(let-values()"
"                      (raise-arguments-error 'syntax-local-lift-module \"not a module form\" \"given form\" s_0))))))))))))"
"(define-values"
"(do-local-lift-to-module.1)"
"(lambda(add-lifted!25_0"
" get-lift-ctx24_0"
" get-wrt-phase26_0"
" intro?22_0"
" log-tag20_0"
" more-checks23_0"
" no-target-msg21_0"
" post-wrap29_0"
" pre-wrap27_0"
" shift-wrap28_0"
" who40_0"
" s41_0)"
"(begin"
" 'do-local-lift-to-module"
"(let-values(((who_0) who40_0))"
"(let-values(((s_0) s41_0))"
"(let-values(((log-tag_0) log-tag20_0))"
"(let-values(((no-target-msg_0) no-target-msg21_0))"
"(let-values(((intro?_0) intro?22_0))"
"(let-values(((more-checks_0) more-checks23_0))"
"(let-values(((get-lift-ctx_0) get-lift-ctx24_0))"
"(let-values(((add-lifted!_0) add-lifted!25_0))"
"(let-values(((get-wrt-phase_0) get-wrt-phase26_0))"
"(let-values(((pre-wrap_0)"
"(if(eq? pre-wrap27_0 unsafe-undefined)"
"(lambda(s_1 phase_0 lift-ctx_0)(begin 'pre-wrap s_1))"
" pre-wrap27_0)))"
"(let-values(((shift-wrap_0)"
"(if(eq? shift-wrap28_0 unsafe-undefined)"
"(lambda(s_1 phase_0 lift-ctx_0)(begin 'shift-wrap s_1))"
" shift-wrap28_0)))"
"(let-values(((post-wrap_0)"
"(if(eq? post-wrap29_0 unsafe-undefined)"
"(lambda(s_1 phase_0 lift-ctx_0)(begin 'post-wrap s_1))"
" post-wrap29_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                                  (let-values () (raise-argument-error who_0 \"syntax?\" s_0)))"
"(values))))"
"(let-values((()(begin(more-checks_0)(values))))"
"(let-values(((ctx_0)"
"(let-values(((who108_0) who_0))"
"(get-current-expand-context.1 #f who108_0))))"
"(let-values(((lift-ctx_0)(get-lift-ctx_0 ctx_0)))"
"(let-values((()"
"(begin"
"(if lift-ctx_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
" no-target-msg_0"
"                                                             \"form to lift\""
" s_0)))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((wrt-phase_0)(get-wrt-phase_0 lift-ctx_0)))"
"(let-values(((added-s_0)"
"(if intro?_0(flip-introduction-scopes s_0 ctx_0) s_0)))"
"(let-values(((pre-s_0)(pre-wrap_0 added-s_0 phase_0 lift-ctx_0)))"
"(let-values(((shift-s_0)"
"(let-values(((s_1)(let-values(((s_1) pre-s_0)) s_1)))"
"(let-values(((start_0) phase_0)"
"((end_0) wrt-phase_0)"
"((inc_0) -1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_2 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(> pos_0 end_0)"
"(let-values(((phase_1)"
" pos_0))"
"(let-values(((s_3)"
"(let-values(((s_3)"
"(let-values()"
"(shift-wrap_0"
" s_2"
"(sub1"
" phase_1)"
" lift-ctx_0))))"
"(values"
" s_3))))"
"(if(not #f)"
"(for-loop_0"
" s_3"
"(+ pos_0 inc_0))"
" s_3)))"
" s_2))))))"
" for-loop_0)"
" s_1"
" start_0))))))"
"(let-values(((post-s_0)"
"(post-wrap_0 shift-s_0 wrt-phase_0 lift-ctx_0)))"
"(begin"
"(if log-tag_0"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" log-tag_0"
" s_0"
" added-s_0"
" post-s_0)))"
"(void))))"
"(void))"
"(add-lifted!_0 lift-ctx_0 post-s_0 wrt-phase_0)"
"(values ctx_0 post-s_0)))))))))))))))))))))))))))))"
"(define-values"
"(1/syntax-local-lift-require)"
"(let-values(((syntax-local-lift-require_0)"
"(lambda(s44_0 use-s45_0 new-scope?43_0)"
"(begin"
" 'syntax-local-lift-require"
"(let-values(((s_0) s44_0))"
"(let-values(((use-s_0) use-s45_0))"
"(let-values(((new-scope?_0) new-scope?43_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((sc_0)(if new-scope?_0(new-scope 'lifted-require) #f)))"
"(let-values(((ctx_0 added-s_0)"
"(let-values(((who110_0) 'syntax-local-lift-require)"
"((temp111_0)(datum->syntax$1 #f s_0))"
"                                                             ((temp112_0) \"could not find target context\")"
"((temp113_0) #f)"
"((temp114_0)"
"(lambda()"
"(if(syntax?$1 use-s_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-lift-require"
"                                                                     \"syntax?\""
" use-s_0)))))"
"((expand-context-require-lifts115_0)"
" expand-context-require-lifts)"
"((require-lift-context-wrt-phase116_0)"
" require-lift-context-wrt-phase)"
"((add-lifted-require!117_0) add-lifted-require!)"
"((temp118_0)"
"(lambda(s_1 phase_0 require-lift-ctx_0)"
"(require-spec-shift-for-syntax s_1)))"
"((temp119_0)"
"(lambda(s_1 phase_0 require-lift-ctx_0)"
"(wrap-form"
" '#%require"
"(if sc_0(add-scope s_1 sc_0) s_1)"
" phase_0))))"
"(do-local-lift-to-module.1"
" add-lifted-require!117_0"
" expand-context-require-lifts115_0"
" require-lift-context-wrt-phase116_0"
" temp113_0"
" #f"
" temp114_0"
" temp112_0"
" temp119_0"
" unsafe-undefined"
" temp118_0"
" who110_0"
" temp111_0))))"
"(let-values((()"
"(begin"
"(with-continuation-mark"
" current-expand-context"
" #f"
"(let-values()"
"(namespace-visit-available-modules!"
"(expand-context-namespace ctx_0)"
"(expand-context-phase ctx_0))))"
"(values))))"
"(let-values(((result-s_0)(if sc_0(add-scope use-s_0 sc_0) use-s_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'lift-require"
" added-s_0"
" use-s_0"
" result-s_0)))"
"(void)))"
" result-s_0)))))))))))))))"
"(case-lambda"
"((s_0 use-s_0)(begin 'syntax-local-lift-require(syntax-local-lift-require_0 s_0 use-s_0 #t)))"
"((s_0 use-s_0 new-scope?43_0)(syntax-local-lift-require_0 s_0 use-s_0 new-scope?43_0)))))"
"(define-values"
"(1/syntax-local-lift-provide)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-lift-provide"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0 result-s_0)"
"(let-values(((who121_0) 'syntax-local-lift-provide)"
"((s122_0) s_0)"
"                                     ((temp123_0) \"not expanding in a module run-time body\")"
"((expand-context-to-module-lifts124_0) expand-context-to-module-lifts)"
"((to-module-lift-context-wrt-phase125_0) to-module-lift-context-wrt-phase)"
"((add-lifted-to-module-provide!126_0) add-lifted-to-module-provide!)"
"((temp127_0)"
"(lambda(s_1 phase_0 to-module-lift-ctx_0)(wrap-form 'for-syntax s_1 #f)))"
"((temp128_0)"
"(lambda(s_1 phase_0 to-module-lift-ctx_0)(wrap-form '#%provide s_1 phase_0))))"
"(do-local-lift-to-module.1"
" add-lifted-to-module-provide!126_0"
" expand-context-to-module-lifts124_0"
" to-module-lift-context-wrt-phase125_0"
" #t"
" #f"
" void"
" temp123_0"
" temp128_0"
" unsafe-undefined"
" temp127_0"
" who121_0"
" s122_0))))"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'lift-provide result-s_0)))"
"(void)))))))))"
"(define-values"
"(1/syntax-local-lift-module-end-declaration)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-lift-module-end-declaration"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0 also-s_0)"
"(let-values(((who130_0) 'syntax-local-lift-module-end-declaration)"
"((s131_0) s_0)"
"((temp132_0) 'lift-end-decl)"
"((temp133_0)"
"                                      \"not currently transforming an expression within a module declaration\")"
"((expand-context-to-module-lifts134_0) expand-context-to-module-lifts)"
"((temp135_0)(lambda(lift-ctx_0) 0))"
"((add-lifted-to-module-end!136_0) add-lifted-to-module-end!)"
"((temp137_0)"
"(lambda(orig-s_0 phase_0 to-module-lift-ctx_0)"
"(if(to-module-lift-context-end-as-expressions? to-module-lift-ctx_0)"
"(wrap-form '#%expression orig-s_0 phase_0)"
" orig-s_0)))"
"((temp138_0)"
"(lambda(s_1 phase_0 to-module-lift-ctx_0)"
"(wrap-form 'begin-for-syntax s_1 phase_0))))"
"(do-local-lift-to-module.1"
" add-lifted-to-module-end!136_0"
" expand-context-to-module-lifts134_0"
" temp135_0"
" #t"
" temp132_0"
" void"
" temp133_0"
" unsafe-undefined"
" temp137_0"
" temp138_0"
" who130_0"
" s131_0))))"
"(void)))))))"
"(define-values"
"(wrap-form)"
"(lambda(sym_0 s_0 phase_0)"
"(begin"
"(datum->syntax$1"
" #f"
"(list(datum->syntax$1(if phase_0(syntax-shift-phase-level$1 core-stx phase_0) #f) sym_0) s_0)))))"
"(define-values"
"(1/syntax-local-module-defined-identifiers)"
"(lambda()"
"(begin"
" 'syntax-local-module-defined-identifiers"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/syntax-local-transforming-module-provides?)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-local-module-defined-identifiers"
"                               \"not currently transforming module provides\")))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp140_0) 'syntax-local-module-defined-identifiers))"
"(get-current-expand-context.1 #f temp140_0))))"
"(requireds->phase-ht(extract-module-definitions(expand-context-requires+provides ctx_0))))))))))"
"(define-values"
"(1/syntax-local-module-required-identifiers)"
"(lambda(mod-path_0 phase+space-shift_0)"
"(begin"
" 'syntax-local-module-required-identifiers"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not mod-path_0)))"
"(if or-part_0 or-part_0(1/module-path? mod-path_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-module-required-identifiers"
"                               \"(or/c module-path? #f)\""
" mod-path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(eq? phase+space-shift_0 #t)))"
"(if or-part_0 or-part_0(phase+space-shift? phase+space-shift_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-module-required-identifiers"
"                                 (format \"(or/c ~a #t)\" phase+space-shift?-string)"
" phase+space-shift_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/syntax-local-transforming-module-provides?)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-local-module-required-identifiers"
"                                   \"not currently transforming module provides\")))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp142_0) 'syntax-local-module-required-identifiers))"
"(get-current-expand-context.1 #f temp142_0))))"
"(let-values(((requires+provides_0)(expand-context-requires+provides ctx_0)))"
"(let-values(((mpi_0)(if mod-path_0(module-path->mpi/context mod-path_0 ctx_0) #f)))"
"(let-values(((requireds_0)"
"(extract-all-module-requires"
" requires+provides_0"
" mpi_0"
"(if(eq? phase+space-shift_0 #t)"
" 'all"
"(intern-phase+space-shift phase+space-shift_0)))))"
"(if requireds_0"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0)(requireds->phase-ht requireds_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase+space-shift_1 ids_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" phase+space-shift_1"
" ids_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2(hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_0))))))"
" #f)))))))))))))"
"(define-values"
"(requireds->phase-ht)"
"(lambda(requireds_0)"
"(begin"
"(let-values(((ht_0)(let-values(((ht_0)(hasheqv))) ht_0)))"
"(let-values(((lst_0) requireds_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((r_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_2)"
"(let-values(((ht_2)"
"(let-values()"
"(hash-update"
" ht_1"
"(required-phase+space r_0)"
"(lambda(l_0)(cons(required-id r_0) l_0))"
" null))))"
"(values ht_2))))"
"(if(not #f)(for-loop_0 ht_2 rest_0) ht_2)))"
" ht_1))))))"
" for-loop_0)"
" ht_0"
" lst_0)))))))"
"(define-values"
"(1/syntax-local-module-exports)"
"(lambda(mod-path_0)"
"(begin"
" 'syntax-local-module-exports"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(1/module-path? mod-path_0)))"
"(if or-part_0"
" or-part_0"
"(if(syntax?$1 mod-path_0)(1/module-path?(syntax->datum$1 mod-path_0)) #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-module-exports"
"(string-append"
"                                \"(or/c module-path?\\n\""
"                                \"      (and/c syntax?\\n\""
"                                \"             (lambda (stx)\\n\""
"                                \"               (module-path? (syntax->datum stx)))))\")"
" mod-path_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp144_0) 'syntax-local-module-exports))"
"(get-current-expand-context.1 #f temp144_0))))"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"(let-values(((mod-name_0)"
"(1/module-path-index-resolve"
"(module-path->mpi/context"
"(if(syntax?$1 mod-path_0)(syntax->datum$1 mod-path_0) mod-path_0)"
" ctx_0)"
" #t)))"
"(let-values(((m_0)(namespace->module ns_0 mod-name_0)))"
"(begin"
"(if m_0"
"(void)"
"(let-values()(raise-unknown-module-error 'syntax-local-module-exports mod-name_0)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0)(module-provides m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((phase_0 syms_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" phase_0"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((ht_1)"
" syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" i_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_1"
"(let-values(((sym_0)"
"(hash-iterate-key"
" ht_1"
" i_1)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
" sym_0)"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
"(hash-iterate-next"
" ht_1"
" i_1))"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
"(hash-iterate-first"
" ht_1))))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2(hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_0)))))))))))))))))"
"(define-values"
"(1/syntax-local-submodules)"
"(lambda()"
"(begin"
" 'syntax-local-submodules"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0)"
"(let-values(((who146_0) 'syntax-local-submodules))"
"(get-current-expand-context.1 #f who146_0))))"
"(let-values(((submods_0)(expand-context-declared-submodule-names ctx_0)))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0) submods_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((name_0 kind_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_2)"
"(if(eq? kind_0 'module)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values() name_0)"
" fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)"
"(for-loop_0 fold-var_2(hash-iterate-next ht_0 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_0)))))))))))))"
"(define-values"
"(1/syntax-local-module-interned-scope-symbols)"
"(lambda()"
"(begin"
" 'syntax-local-module-interned-scope-symbols"
"(let-values()"
"(let-values()"
"(begin"
"(void"
"(let-values(((who148_0) 'syntax-local-module-interned-scope-symbols))"
"(get-current-expand-context.1 #f who148_0)))"
"(interned-scope-symbols)))))))"
"(define-values"
"(syntax-local-expand-observer)"
"(lambda()"
"(begin"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0)"
"(let-values(((temp150_0) 'syntax-local-expand-observer))"
"(get-current-expand-context.1 #f temp150_0))))"
"(expand-context-observer ctx_0)))))))"
"(define-values"
"(1/syntax-local-get-shadower)"
"(let-values(((syntax-local-get-shadower_0)"
"(lambda(id47_0 only-generated?46_0)"
"(begin"
" 'syntax-local-get-shadower"
"(let-values(((id_0) id47_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"                                                  (raise-argument-error 'syntax-local-get-shadower \"identifier?\" id_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((who152_0) 'syntax-local-get-shadower))"
"(get-current-expand-context.1 #f who152_0))))"
"(let-values(((new-id_0)(add-scopes id_0(expand-context-scopes ctx_0))))"
"(if(syntax-clean? id_0) new-id_0(syntax-taint$1 new-id_0))))))))))))))"
"(case-lambda"
"((id_0)(begin 'syntax-local-get-shadower(syntax-local-get-shadower_0 id_0 #f)))"
"((id_0 only-generated?46_0)(syntax-local-get-shadower_0 id_0 only-generated?46_0)))))"
"(define-values"
"(1/syntax-source)"
"(lambda(s_0)"
"(begin"
" 'syntax-source"
"(let-values((()"
"(begin"
"                      (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-source \"syntax?\" s_0)))"
"(values))))"
"(let-values(((srcloc_0)(syntax-srcloc$1 s_0)))(if srcloc_0(srcloc-source srcloc_0) #f))))))"
"(define-values"
"(1/syntax-line)"
"(lambda(s_0)"
"(begin"
" 'syntax-line"
"(let-values((()"
"(begin"
"                      (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-line \"syntax?\" s_0)))"
"(values))))"
"(let-values(((srcloc_0)(syntax-srcloc$1 s_0)))(if srcloc_0(srcloc-line srcloc_0) #f))))))"
"(define-values"
"(1/syntax-column)"
"(lambda(s_0)"
"(begin"
" 'syntax-column"
"(let-values((()"
"(begin"
"                      (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-column \"syntax?\" s_0)))"
"(values))))"
"(let-values(((srcloc_0)(syntax-srcloc$1 s_0)))(if srcloc_0(srcloc-column srcloc_0) #f))))))"
"(define-values"
"(1/syntax-position)"
"(lambda(s_0)"
"(begin"
" 'syntax-position"
"(let-values((()"
"(begin"
"                      (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-position \"syntax?\" s_0)))"
"(values))))"
"(let-values(((srcloc_0)(syntax-srcloc$1 s_0)))(if srcloc_0(srcloc-position srcloc_0) #f))))))"
"(define-values"
"(1/syntax-span)"
"(lambda(s_0)"
"(begin"
" 'syntax-span"
"(let-values((()"
"(begin"
"                      (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-span \"syntax?\" s_0)))"
"(values))))"
"(let-values(((srcloc_0)(syntax-srcloc$1 s_0)))(if srcloc_0(srcloc-span srcloc_0) #f))))))"
"(define-values"
"(encoded-srcloc?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(if(list? v_0)(if(=(length v_0) 5)(srcloc-vector?(list->vector v_0)) #f) #f)))"
"(if or-part_0 or-part_0(if(vector? v_0)(if(=(vector-length v_0) 5)(srcloc-vector? v_0) #f) #f))))))"
"(define-values"
"(srcloc-vector?)"
"(lambda(v_0)"
"(begin"
"(if(let-values(((or-part_0)(not(vector-ref v_0 1))))"
"(if or-part_0 or-part_0(exact-positive-integer?(vector-ref v_0 1))))"
"(if(let-values(((or-part_0)(not(vector-ref v_0 2))))"
"(if or-part_0 or-part_0(exact-nonnegative-integer?(vector-ref v_0 2))))"
"(if(let-values(((or-part_0)(not(vector-ref v_0 3))))"
"(if or-part_0 or-part_0(exact-positive-integer?(vector-ref v_0 3))))"
"(let-values(((or-part_0)(not(vector-ref v_0 4))))"
"(if or-part_0 or-part_0(exact-nonnegative-integer?(vector-ref v_0 4))))"
" #f)"
" #f)"
" #f))))"
"(define-values"
"(to-srcloc-stx)"
"(lambda(v_0)"
"(begin"
"(if(srcloc? v_0)"
"(let-values()"
"(let-values(((the-struct_0) empty-syntax))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((srcloc1_0) v_0))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
" srcloc1_0"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))"
"(if(pair? v_0)"
"(let-values()(to-srcloc-stx(list->vector v_0)))"
"(if(vector? v_0)"
"(let-values()"
"(let-values(((the-struct_0) empty-syntax))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((srcloc2_0)"
"(srcloc"
"(vector-ref v_0 0)"
"(vector-ref v_0 1)"
"(vector-ref v_0 2)"
"(vector-ref v_0 3)"
"(vector-ref v_0 4))))"
"(syntax2.1"
"(syntax-content* the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
" srcloc2_0"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))"
"(let-values() v_0)))))))"
"(define-values"
"(1/syntax-e)"
"(lambda(s_0)"
"(begin"
" 'syntax-e"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-e \"syntax?\" s_0)))"
"(syntax-e$1 s_0)))))))"
"(define-values"
"(1/syntax-srcloc)"
"(lambda(s_0)"
"(begin"
" 'syntax-srcloc"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-srcloc \"syntax?\" s_0)))"
"(syntax-srcloc$1 s_0)))))))"
"(define-values"
"(1/syntax->datum)"
"(lambda(s_0)"
"(begin"
" 'syntax->datum"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax->datum \"syntax?\" s_0)))"
"(syntax->datum$1 s_0)))))))"
"(define-values(maybe-syntax->datum)(lambda(s_0)(begin(if(syntax?$1 s_0)(syntax->datum$1 s_0) s_0))))"
"(define-values"
"(1/datum->syntax)"
"(let-values(((datum->syntax_0)"
"(lambda(stx-c4_0 s5_0 stx-l1_0 stx-p2_0 ignored3_0)"
"(begin"
" 'datum->syntax"
"(let-values(((stx-c_0) stx-c4_0))"
"(let-values(((s_0) s5_0))"
"(let-values(((stx-l_0) stx-l1_0))"
"(let-values(((stx-p_0) stx-p2_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(let-values(((or-part_0)(not stx-c_0)))"
"(if or-part_0 or-part_0(syntax?$1 stx-c_0)))"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'datum->syntax \"(or/c #f syntax?)\" stx-c_0)))"
"(if(let-values(((or-part_0)(not stx-l_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(syntax?$1 stx-l_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(srcloc? stx-l_0)))"
"(if or-part_2 or-part_2(encoded-srcloc? stx-l_0)))))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'datum->syntax"
"(string-append"
"                                            \"(or/c #f syntax?\\n\""
"                                            \"         srcloc?\\n\""
"                                            \"         (list/c any/c\\n\""
"                                            \"                 (or/c exact-positive-integer? #f)\\n\""
"                                            \"                 (or/c exact-nonnegative-integer? #f)\\n\""
"                                            \"                 (or/c exact-positive-integer? #f)\\n\""
"                                            \"                 (or/c exact-nonnegative-integer? #f))\\n\""
"                                            \"         (vector/c any/c\\n\""
"                                            \"                   (or/c exact-positive-integer? #f)\\n\""
"                                            \"                   (or/c exact-nonnegative-integer? #f)\\n\""
"                                            \"                   (or/c exact-positive-integer? #f)\\n\""
"                                            \"                   (or/c exact-nonnegative-integer? #f)))\")"
" stx-l_0)))"
"(if(let-values(((or-part_0)(not stx-p_0)))"
"(if or-part_0 or-part_0(syntax?$1 stx-p_0)))"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'datum->syntax \"(or/c #f syntax?)\" stx-p_0)))"
"(datum->syntax$1 stx-c_0 s_0(to-srcloc-stx stx-l_0) stx-p_0))))))))))))))"
"(case-lambda"
"((stx-c_0 s_0)(begin 'datum->syntax(datum->syntax_0 stx-c_0 s_0 #f #f #f)))"
"((stx-c_0 s_0 stx-l_0 stx-p_0 ignored3_0)(datum->syntax_0 stx-c_0 s_0 stx-l_0 stx-p_0 ignored3_0))"
"((stx-c_0 s_0 stx-l_0 stx-p2_0)(datum->syntax_0 stx-c_0 s_0 stx-l_0 stx-p2_0 #f))"
"((stx-c_0 s_0 stx-l1_0)(datum->syntax_0 stx-c_0 s_0 stx-l1_0 #f #f)))))"
"(define-values"
"(1/syntax-binding-set)"
"(lambda()(begin 'syntax-binding-set(let-values()(let-values()(syntax-binding-set1.1 null))))))"
"(define-values"
"(1/syntax-binding-set-extend)"
"(let-values(((syntax-binding-set-extend_0)"
"(lambda(bs13_0"
" as-sym14_0"
" as-phase15_0"
" mpi16_0"
" sym6_0"
" phase7_0"
" nominal-mpi8_0"
" nominal-phase+space9_0"
" nominal-sym10_0"
" nominal-require-phase+space-shift11_0"
" insp12_0)"
"(begin"
" 'syntax-binding-set-extend"
"(let-values(((bs_0) bs13_0))"
"(let-values(((as-sym_0) as-sym14_0))"
"(let-values(((as-phase_0) as-phase15_0))"
"(let-values(((mpi_0) mpi16_0))"
"(let-values(((sym_0)(if(eq? sym6_0 unsafe-undefined) as-sym_0 sym6_0)))"
"(let-values(((phase_0)(if(eq? phase7_0 unsafe-undefined) as-phase_0 phase7_0)))"
"(let-values(((nominal-mpi_0)"
"(if(eq? nominal-mpi8_0 unsafe-undefined) mpi_0 nominal-mpi8_0)))"
"(let-values(((nominal-phase+space_0)"
"(if(eq? nominal-phase+space9_0 unsafe-undefined)"
" phase_0"
" nominal-phase+space9_0)))"
"(let-values(((nominal-sym_0)"
"(if(eq? nominal-sym10_0 unsafe-undefined) sym_0 nominal-sym10_0)))"
"(let-values(((nominal-require-phase+space-shift_0)"
" nominal-require-phase+space-shift11_0))"
"(let-values(((insp_0) insp12_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/syntax-binding-set? bs_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"syntax-binding-set?\""
" bs_0)))"
"(if(symbol? as-sym_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"symbol?\""
" as-sym_0)))"
"(if(phase? as-phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
" phase?-string"
" as-phase_0)))"
"(if(1/module-path-index? mpi_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"module-path-index?\""
" mpi_0)))"
"(if(symbol? sym_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"symbol?\""
" sym_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
" phase?-string"
" phase_0)))"
"(if(1/module-path-index? nominal-mpi_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"module-path-index?\""
" nominal-mpi_0)))"
"(if(phase+space? nominal-phase+space_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
" phase+space?-string"
" nominal-phase+space_0)))"
"(if(symbol? nominal-sym_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"symbol?\""
" nominal-sym_0)))"
"(if(phase+space-shift? nominal-require-phase+space-shift_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
" phase+space-shift?-string"
" nominal-require-phase+space-shift_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(inspector? x_0))))"
" insp_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"(or/c inspector? #f)\""
" insp_0)))"
"(syntax-binding-set-extend$1"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
"(intern-phase+space nominal-phase+space_0)"
" nominal-sym_0"
"(intern-phase+space-shift nominal-require-phase+space-shift_0)"
" insp_0))))))))))))))))))))"
"(case-lambda"
"((bs_0 as-sym_0 as-phase_0 mpi_0)"
"(begin"
" 'syntax-binding-set-extend"
"(syntax-binding-set-extend_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" #f)))"
"((bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase+space_0"
" nominal-sym_0"
" nominal-require-phase+space-shift_0"
" insp12_0)"
"(syntax-binding-set-extend_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase+space_0"
" nominal-sym_0"
" nominal-require-phase+space-shift_0"
" insp12_0))"
"((bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase+space_0"
" nominal-sym_0"
" nominal-require-phase+space-shift11_0)"
"(syntax-binding-set-extend_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase+space_0"
" nominal-sym_0"
" nominal-require-phase+space-shift11_0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym_0 phase_0 nominal-mpi_0 nominal-phase+space_0 nominal-sym10_0)"
"(syntax-binding-set-extend_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase+space_0"
" nominal-sym10_0"
" 0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym_0 phase_0 nominal-mpi_0 nominal-phase+space9_0)"
"(syntax-binding-set-extend_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase+space9_0"
" unsafe-undefined"
" 0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym_0 phase_0 nominal-mpi8_0)"
"(syntax-binding-set-extend_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi8_0"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym_0 phase7_0)"
"(syntax-binding-set-extend_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase7_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym6_0)"
"(syntax-binding-set-extend_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym6_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" #f)))))"
"(define-values"
"(1/syntax-binding-set->syntax)"
"(lambda(bs_0 datum_0)"
"(begin"
" 'syntax-binding-set->syntax"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/syntax-binding-set? bs_0)"
"(void)"
"              (let-values () (raise-argument-error 'syntax-binding-set->syntax \"syntax-binding-set?\" bs_0)))"
"(syntax-binding-set->syntax$1 bs_0 datum_0)))))))"
"(define-values"
"(1/syntax->list)"
"(lambda(s_0)"
"(begin"
" 'syntax->list"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax->list \"syntax?\" s_0)))"
"(syntax->list$1 s_0)))))))"
"(define-values"
"(1/syntax-original?)"
"(lambda(s_0)"
"(begin"
" 'syntax-original?"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-original? \"syntax?\" s_0)))"
"(if(syntax-property$1 s_0 original-property-sym)(not(syntax-any-macro-scopes? s_0)) #f)))))))"
"(define-values"
"(1/bound-identifier=?)"
"(let-values(((bound-identifier=?_0)"
"(lambda(a18_0 b19_0 phase17_0)"
"(begin"
" 'bound-identifier=?"
"(let-values(((a_0) a18_0))"
"(let-values(((b_0) b19_0))"
"(let-values(((phase_0)"
"(if(eq? phase17_0 unsafe-undefined)(1/syntax-local-phase-level) phase17_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'bound-identifier=? \"identifier?\" a_0)))"
"(if(identifier? b_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'bound-identifier=? \"identifier?\" b_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()(raise-argument-error 'bound-identifier=? phase?-string phase_0)))"
"(bound-identifier=?$1 a_0 b_0 phase_0))))))))))))"
"(case-lambda"
"((a_0 b_0)(begin 'bound-identifier=?(bound-identifier=?_0 a_0 b_0 unsafe-undefined)))"
"((a_0 b_0 phase17_0)(bound-identifier=?_0 a_0 b_0 phase17_0)))))"
"(define-values"
"(1/free-identifier=?)"
"(let-values(((free-identifier=?_0)"
"(lambda(a22_0 b23_0 a-phase20_0 b-phase21_0)"
"(begin"
" 'free-identifier=?"
"(let-values(((a_0) a22_0))"
"(let-values(((b_0) b23_0))"
"(let-values(((a-phase_0)"
"(if(eq? a-phase20_0 unsafe-undefined)(1/syntax-local-phase-level) a-phase20_0)))"
"(let-values(((b-phase_0)(if(eq? b-phase21_0 unsafe-undefined) a-phase_0 b-phase21_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'free-identifier=? \"identifier?\" a_0)))"
"(if(identifier? b_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'free-identifier=? \"identifier?\" b_0)))"
"(if(phase? a-phase_0)"
"(void)"
"(let-values()(raise-argument-error 'free-identifier=? phase?-string a-phase_0)))"
"(if(phase? b-phase_0)"
"(void)"
"(let-values()(raise-argument-error 'free-identifier=? phase?-string b-phase_0)))"
"(free-identifier=?$1 a_0 b_0 a-phase_0 b-phase_0)))))))))))))"
"(case-lambda"
"((a_0 b_0)(begin 'free-identifier=?(free-identifier=?_0 a_0 b_0 unsafe-undefined unsafe-undefined)))"
"((a_0 b_0 a-phase_0 b-phase21_0)(free-identifier=?_0 a_0 b_0 a-phase_0 b-phase21_0))"
"((a_0 b_0 a-phase20_0)(free-identifier=?_0 a_0 b_0 a-phase20_0 unsafe-undefined)))))"
"(define-values"
"(1/free-transformer-identifier=?)"
"(lambda(a_0 b_0)"
"(begin"
" 'free-transformer-identifier=?"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"                            (let-values () (raise-argument-error 'free-transformer-identifier=? \"identifier?\" a_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(identifier? b_0)"
"(void)"
"                              (let-values () (raise-argument-error 'free-transformer-identifier=? \"identifier?\" b_0)))"
"(values))))"
"(let-values(((phase_0)(add1(1/syntax-local-phase-level))))"
"(free-identifier=?$1 a_0 b_0 phase_0 phase_0)))))))))"
"(define-values"
"(1/free-template-identifier=?)"
"(lambda(a_0 b_0)"
"(begin"
" 'free-template-identifier=?"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"                            (let-values () (raise-argument-error 'free-template-identifier=? \"identifier?\" a_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(identifier? b_0)"
"(void)"
"                              (let-values () (raise-argument-error 'free-template-identifier=? \"identifier?\" b_0)))"
"(values))))"
"(let-values(((phase_0)(sub1(1/syntax-local-phase-level))))"
"(free-identifier=?$1 a_0 b_0 phase_0 phase_0)))))))))"
"(define-values"
"(1/free-label-identifier=?)"
"(lambda(a_0 b_0)"
"(begin"
" 'free-label-identifier=?"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"              (let-values () (raise-argument-error 'free-label-identifier=? \"identifier?\" a_0)))"
"(if(identifier? b_0)"
"(void)"
"              (let-values () (raise-argument-error 'free-label-identifier=? \"identifier?\" b_0)))"
"(free-identifier=?$1 a_0 b_0 #f #f)))))))"
"(define-values"
"(1/identifier-binding)"
"(let-values(((identifier-binding_0)"
"(lambda(id27_0 phase24_0 top-level-symbol?25_0 exactly?26_0)"
"(begin"
" 'identifier-binding"
"(let-values(((id_0) id27_0))"
"(let-values(((phase_0)"
"(if(eq? phase24_0 unsafe-undefined)(1/syntax-local-phase-level) phase24_0)))"
"(let-values(((top-level-symbol?_0) top-level-symbol?25_0))"
"(let-values(((exactly?_0) exactly?26_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'identifier-binding \"identifier?\" id_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()(raise-argument-error 'identifier-binding phase?-string phase_0)))"
"(let-values(((id64_0) id_0)"
"((phase65_0) phase_0)"
"((top-level-symbol?66_0) top-level-symbol?_0)"
"((exactly?67_0) exactly?_0))"
"(identifier-binding.1"
" exactly?67_0"
" id64_0"
" phase65_0"
" top-level-symbol?66_0))))))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-binding(identifier-binding_0 id_0 unsafe-undefined #f #f)))"
"((id_0 phase_0 top-level-symbol?_0 exactly?26_0)"
"(identifier-binding_0 id_0 phase_0 top-level-symbol?_0 exactly?26_0))"
"((id_0 phase_0 top-level-symbol?25_0)(identifier-binding_0 id_0 phase_0 top-level-symbol?25_0 #f))"
"((id_0 phase24_0)(identifier-binding_0 id_0 phase24_0 #f #f)))))"
"(define-values"
"(1/identifier-transformer-binding)"
"(let-values(((identifier-transformer-binding_0)"
"(lambda(id29_0 phase28_0)"
"(begin"
" 'identifier-transformer-binding"
"(let-values(((id_0) id29_0))"
"(let-values(((phase_0)"
"(if(eq? phase28_0 unsafe-undefined)(1/syntax-local-phase-level) phase28_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'identifier-transformer-binding \"identifier?\" id_0)))"
"(let-values(((id69_0) id_0)((temp70_0)(if phase_0(add1 phase_0) #f)))"
"(identifier-binding.1 #f id69_0 temp70_0 #f))))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-transformer-binding(identifier-transformer-binding_0 id_0 unsafe-undefined)))"
"((id_0 phase28_0)(identifier-transformer-binding_0 id_0 phase28_0)))))"
"(define-values"
"(1/identifier-template-binding)"
"(lambda(id_0)"
"(begin"
" 'identifier-template-binding"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"              (let-values () (raise-argument-error 'identifier-template-binding \"identifier?\" id_0)))"
"(let-values(((id72_0) id_0)((temp73_0)(sub1(1/syntax-local-phase-level))))"
"(identifier-binding.1 #f id72_0 temp73_0 #f))))))))"
"(define-values"
"(1/identifier-label-binding)"
"(lambda(id_0)"
"(begin"
" 'identifier-label-binding"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"              (let-values () (raise-argument-error 'identifier-label-binding \"identifier?\" id_0)))"
"(let-values(((id75_0) id_0)((temp76_0) #f))(identifier-binding.1 #f id75_0 temp76_0 #f))))))))"
"(define-values"
"(1/identifier-binding-symbol)"
"(let-values(((identifier-binding-symbol_0)"
"(lambda(id31_0 phase30_0)"
"(begin"
" 'identifier-binding-symbol"
"(let-values(((id_0) id31_0))"
"(let-values(((phase_0)"
"(if(eq? phase30_0 unsafe-undefined)(1/syntax-local-phase-level) phase30_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'identifier-binding-symbol \"identifier?\" id_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error 'identifier-binding-symbol phase?-string phase_0)))"
"(identifier-binding-symbol$1 id_0 phase_0)))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-binding-symbol(identifier-binding-symbol_0 id_0 unsafe-undefined)))"
"((id_0 phase30_0)(identifier-binding-symbol_0 id_0 phase30_0)))))"
"(define-values"
"(1/identifier-distinct-binding)"
"(let-values(((identifier-distinct-binding_0)"
"(lambda(id34_0 other-id35_0 phase32_0 top-level-symbol?33_0)"
"(begin"
" 'identifier-distinct-binding"
"(let-values(((id_0) id34_0))"
"(let-values(((other-id_0) other-id35_0))"
"(let-values(((phase_0)"
"(if(eq? phase32_0 unsafe-undefined)(1/syntax-local-phase-level) phase32_0)))"
"(let-values(((top-level-symbol?_0) top-level-symbol?33_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"                                        (raise-argument-error 'identifier-distinct-binding \"identifier?\" id_0)))"
"(if(identifier? other-id_0)"
"(void)"
"(let-values()"
"                                        (raise-argument-error 'identifier-distinct-binding \"identifier?\" other-id_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error 'identifier-distinct-binding phase?-string phase_0)))"
"(identifier-distinct-binding$1"
" id_0"
" other-id_0"
" phase_0"
" top-level-symbol?_0)))))))))))))"
"(case-lambda"
"((id_0 other-id_0)"
"(begin 'identifier-distinct-binding(identifier-distinct-binding_0 id_0 other-id_0 unsafe-undefined #f)))"
"((id_0 other-id_0 phase_0 top-level-symbol?33_0)"
"(identifier-distinct-binding_0 id_0 other-id_0 phase_0 top-level-symbol?33_0))"
"((id_0 other-id_0 phase32_0)(identifier-distinct-binding_0 id_0 other-id_0 phase32_0 #f)))))"
"(define-values"
"(1/identifier-binding-portal-syntax)"
"(let-values(((identifier-binding-portal-syntax_0)"
"(lambda(id37_0 phase36_0)"
"(begin"
" 'identifier-binding-portal-syntax"
"(let-values(((id_0) id37_0))"
"(let-values(((phase_0)"
"(if(eq? phase36_0 unsafe-undefined)(1/syntax-local-phase-level) phase36_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'identifier-binding-portal-syntax"
"                                                   \"identifier?\""
" id_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(phase? phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'identifier-binding-portal-syntax"
" phase?-string"
" phase_0)))"
"(values))))"
"(let-values(((b_0)"
"(let-values(((id80_0) id_0)((phase81_0) phase_0)((temp82_0) #t))"
"(resolve+shift.1"
" #f"
" #f"
" null"
" unsafe-undefined"
" temp82_0"
" id80_0"
" phase81_0))))"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((ctx_0)"
"(let-values(((temp83_0) #t))"
"(get-current-expand-context.1 temp83_0 'unexpected))))"
"(let-values(((phase-shift_0)"
"(if(module-binding-phase b_0)"
"(phase- phase_0(module-binding-phase b_0))"
" 0)))"
"(let-values(((portal-syntax-lookup_0)"
"(namespace-module-get-portal-syntax-lookup"
"(if ctx_0"
"(expand-context-namespace ctx_0)"
"(1/current-namespace))"
"(module-binding-module b_0)"
" phase-shift_0)))"
"(portal-syntax-lookup_0"
"(module-binding-phase b_0)"
"(module-binding-sym b_0))))))"
"(let-values() #f))))))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-binding-portal-syntax(identifier-binding-portal-syntax_0 id_0 unsafe-undefined)))"
"((id_0 phase36_0)(identifier-binding-portal-syntax_0 id_0 phase36_0)))))"
"(define-values"
"(1/identifier-prune-lexical-context)"
"(let-values(((identifier-prune-lexical-context_0)"
"(lambda(id39_0 syms38_0)"
"(begin"
" 'identifier-prune-lexical-context"
"(let-values(((id_0) id39_0))"
"(let-values(((syms_0) syms38_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'identifier-prune-lexical-context \"identifier?\" id_0)))"
"(if(if(list? syms_0)(andmap2 symbol? syms_0) #f)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'identifier-prune-lexical-context \"(listof symbol?)\" syms_0)))"
" id_0))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-prune-lexical-context(identifier-prune-lexical-context_0 id_0 null)))"
"((id_0 syms38_0)(identifier-prune-lexical-context_0 id_0 syms38_0)))))"
"(define-values"
"(1/syntax-debug-info)"
"(let-values(((syntax-debug-info_0)"
"(lambda(s42_0 phase40_0 all-bindings?41_0)"
"(begin"
" 'syntax-debug-info"
"(let-values(((s_0) s42_0))"
"(let-values(((phase_0)"
"(if(eq? phase40_0 unsafe-undefined)(1/syntax-local-phase-level) phase40_0)))"
"(let-values(((all-bindings?_0) all-bindings?41_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'syntax-debug-info \"syntax?\" s_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()(raise-argument-error 'syntax-debug-info phase?-string phase_0)))"
"(syntax-debug-info$1 s_0 phase_0 all-bindings?_0))))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-debug-info(syntax-debug-info_0 s_0 unsafe-undefined #f)))"
"((s_0 phase_0 all-bindings?41_0)(syntax-debug-info_0 s_0 phase_0 all-bindings?41_0))"
"((s_0 phase40_0)(syntax-debug-info_0 s_0 phase40_0 #f)))))"
"(define-values"
"(1/syntax-shift-phase-level)"
"(lambda(s_0 phase_0)"
"(begin"
" 'syntax-shift-phase-level"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-shift-phase-level \"syntax?\" s_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()(raise-argument-error 'syntax-shift-phase-level phase?-string phase_0)))"
"(syntax-shift-phase-level$1 s_0 phase_0)))))))"
"(define-values"
"(1/syntax-track-origin)"
"(lambda(new-stx_0 old-stx_0 id_0)"
"(begin"
" 'syntax-track-origin"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 new-stx_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-track-origin \"syntax?\" new-stx_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(syntax?$1 old-stx_0)"
"(void)"
"                              (let-values () (raise-argument-error 'syntax-track-origin \"syntax?\" old-stx_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"                                (let-values () (raise-argument-error 'syntax-track-origin \"identifier?\" id_0)))"
"(values))))"
"(let-values(((s_0)(syntax-track-origin$1 new-stx_0 old-stx_0 id_0)))"
"(let-values(((ctx_0)"
"(let-values(((temp88_0) #t))(get-current-expand-context.1 temp88_0 'unexpected))))"
"(begin"
"(if ctx_0"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'track-syntax 'track-origin new-stx_0 s_0)))"
"(void))))"
"(void))"
" s_0)))))))))))"
"(define-values"
"(1/syntax-bound-symbols)"
"(let-values(((syntax-bound-symbols_0)"
"(lambda(stx45_0 phase43_0 exactly?44_0)"
"(begin"
" 'syntax-bound-symbols"
"(let-values(((stx_0) stx45_0))"
"(let-values(((phase_0)"
"(if(eq? phase43_0 unsafe-undefined)(1/syntax-local-phase-level) phase43_0)))"
"(let-values(((exactly?_0) exactly?44_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 stx_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'syntax-bound-symbols \"syntax?\" stx_0)))"
"(set->list"
"(let-values(((stx90_0) stx_0)"
"((phase91_0) phase_0)"
"((temp92_0) #t)"
"((exactly?93_0) exactly?_0))"
"(syntax-mapped-names.1 exactly?93_0 temp92_0 stx90_0 phase91_0))))))))))))))"
"(case-lambda"
"((stx_0)(begin 'syntax-bound-symbols(syntax-bound-symbols_0 stx_0 unsafe-undefined #f)))"
"((stx_0 phase_0 exactly?44_0)(syntax-bound-symbols_0 stx_0 phase_0 exactly?44_0))"
"((stx_0 phase43_0)(syntax-bound-symbols_0 stx_0 phase43_0 #f)))))"
"(define-values"
"(1/syntax-bound-phases)"
"(lambda(stx_0)"
"(begin"
" 'syntax-bound-phases"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 stx_0) (void) (let-values () (raise-argument-error 'syntax-bound-phases \"syntax?\" stx_0)))"
"(set->list(syntax-mapped-phases stx_0))))))))"
"(define-values"
"(1/syntax-bound-interned-scope-symbols)"
"(let-values(((syntax-bound-interned-scope-symbols_0)"
"(lambda(stx48_0 phase46_0 exactly?47_0)"
"(begin"
" 'syntax-bound-interned-scope-symbols"
"(let-values(((stx_0) stx48_0))"
"(let-values(((phase_0)"
"(if(eq? phase46_0 unsafe-undefined)(1/syntax-local-phase-level) phase46_0)))"
"(let-values(((exactly?_0) exactly?47_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 stx_0)"
"(void)"
"(let-values()"
"                                      (raise-argument-error 'syntax-bound-interned-scope-symbols \"syntax?\" stx_0)))"
"(set->list"
"(let-values(((stx96_0) stx_0)((phase97_0) phase_0)((exactly?98_0) exactly?_0))"
"(syntax-mapped-interned-scope-symbols.1"
" exactly?98_0"
" stx96_0"
" phase97_0))))))))))))))"
"(case-lambda"
"((stx_0)"
"(begin 'syntax-bound-interned-scope-symbols(syntax-bound-interned-scope-symbols_0 stx_0 unsafe-undefined #f)))"
"((stx_0 phase_0 exactly?47_0)(syntax-bound-interned-scope-symbols_0 stx_0 phase_0 exactly?47_0))"
"((stx_0 phase46_0)(syntax-bound-interned-scope-symbols_0 stx_0 phase46_0 #f)))))"
"(define-values"
"(1/namespace-attach-module)"
"(let-values(((namespace-attach-module_0)"
"(lambda(src-namespace2_0 mod-path3_0 dest-namespace1_0)"
"(begin"
" 'namespace-attach-module"
"(let-values(((src-namespace_0) src-namespace2_0))"
"(let-values(((mod-path_0) mod-path3_0))"
"(let-values(((dest-namespace_0)"
"(if(eq? dest-namespace1_0 unsafe-undefined)"
"(1/current-namespace)"
" dest-namespace1_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who15_0) 'namespace-attach-module)"
"((src-namespace16_0) src-namespace_0)"
"((mod-path17_0) mod-path_0)"
"((dest-namespace18_0) dest-namespace_0)"
"((temp19_0) #t))"
"(do-attach-module.1"
" temp19_0"
" who15_0"
" src-namespace16_0"
" mod-path17_0"
" dest-namespace18_0))))))))))))"
"(case-lambda"
"((src-namespace_0 mod-path_0)"
"(begin 'namespace-attach-module(namespace-attach-module_0 src-namespace_0 mod-path_0 unsafe-undefined)))"
"((src-namespace_0 mod-path_0 dest-namespace1_0)"
"(namespace-attach-module_0 src-namespace_0 mod-path_0 dest-namespace1_0)))))"
"(define-values"
"(1/namespace-attach-module-declaration)"
"(let-values(((namespace-attach-module-declaration_0)"
"(lambda(src-namespace5_0 mod-path6_0 dest-namespace4_0)"
"(begin"
" 'namespace-attach-module-declaration"
"(let-values(((src-namespace_0) src-namespace5_0))"
"(let-values(((mod-path_0) mod-path6_0))"
"(let-values(((dest-namespace_0)"
"(if(eq? dest-namespace4_0 unsafe-undefined)"
"(1/current-namespace)"
" dest-namespace4_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who21_0) 'namespace-attach-module-declaration)"
"((src-namespace22_0) src-namespace_0)"
"((mod-path23_0) mod-path_0)"
"((dest-namespace24_0) dest-namespace_0)"
"((temp25_0) #f))"
"(do-attach-module.1"
" temp25_0"
" who21_0"
" src-namespace22_0"
" mod-path23_0"
" dest-namespace24_0))))))))))))"
"(case-lambda"
"((src-namespace_0 mod-path_0)"
"(begin"
" 'namespace-attach-module-declaration"
"(namespace-attach-module-declaration_0 src-namespace_0 mod-path_0 unsafe-undefined)))"
"((src-namespace_0 mod-path_0 dest-namespace4_0)"
"(namespace-attach-module-declaration_0 src-namespace_0 mod-path_0 dest-namespace4_0)))))"
"(define-values"
"(do-attach-module.1)"
"(lambda(attach-instances?7_0 who9_0 src-namespace10_0 mod-path11_0 dest-namespace12_0)"
"(begin"
" 'do-attach-module"
"(let-values(((who_0) who9_0))"
"(let-values(((src-namespace_0) src-namespace10_0))"
"(let-values(((mod-path_0) mod-path11_0))"
"(let-values(((dest-namespace_0) dest-namespace12_0))"
"(let-values(((attach-instances?_0) attach-instances?7_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/namespace? src-namespace_0)"
"(void)"
"                                    (let-values () (raise-argument-error who_0 \"namespace?\" src-namespace_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(1/module-path? mod-path_0)))"
"(if or-part_0 or-part_0(1/resolved-module-path? mod-path_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                         \"(or/c module-path? resolved-module-path?)\""
" mod-path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/namespace? dest-namespace_0)"
"(void)"
"                                        (let-values () (raise-argument-error who_0 \"namespace?\" dest-namespace_0)))"
"(values))))"
"(let-values(((phase_0)(namespace-phase src-namespace_0)))"
"(let-values((()"
"(begin"
"(if(eqv? phase_0(namespace-phase dest-namespace_0))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                               \"source and destination namespace phases do not match\""
"                                               \"source phase\""
" phase_0"
"                                               \"destination phase\""
"(namespace-phase dest-namespace_0))))"
"(values))))"
"(let-values(((todo_0)(make-hasheq)))"
"(let-values(((missing_0) '#:missing))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(mpi_0"
" maybe-mod-name_0"
" phase_1"
" attach-instances?_1"
" attach-phase_0"
" recur?_0)"
"(begin"
" 'loop"
"(let-values(((mod-name_0)"
"(let-values(((or-part_0)"
" maybe-mod-name_0))"
"(if or-part_0"
" or-part_0"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" src-namespace_0)"
"(let-values()"
"(1/module-path-index-resolve"
" mpi_0)))))))"
"(let-values(((m-ns_0)"
"(hash-ref"
"(hash-ref"
" todo_0"
" mod-name_0"
" '#hasheqv())"
" phase_1"
" missing_0)))"
"(if(eq? missing_0 m-ns_0)"
"(let-values()"
"(let-values(((mi_0)"
"(let-values(((src-namespace26_0)"
" src-namespace_0)"
"((mod-name27_0)"
" mod-name_0)"
"((phase28_0)"
" phase_1))"
"(namespace->module-instance.1"
" #f"
" #f"
" void"
" src-namespace26_0"
" mod-name27_0"
" phase28_0))))"
"(let-values(((m_0)"
"(if mi_0"
"(module-instance-module"
" mi_0)"
"(namespace->module"
" src-namespace_0"
" mod-name_0))))"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                                                         \"module not declared (in the source namespace)\""
"                                                                                         \"module name\""
" mod-name_0)))"
"(if(if(module-cross-phase-persistent?"
" m_0)"
"(if(not"
"(label-phase? phase_1))"
"(not(zero-phase? phase_1))"
" #f)"
" #f)"
"(let-values()"
"(loop_0"
" mpi_0"
" mod-name_0"
" 0"
" attach-instances?_1"
" 0"
" recur?_0))"
"(let-values()"
"(let-values(((already-m_0)"
"(namespace->module"
" dest-namespace_0"
" mod-name_0)))"
"(let-values((()"
"(begin"
"(if(if already-m_0"
"(not"
"(eq?"
" already-m_0"
" m_0))"
" #f)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                                                                               \"a different declaration is already in the destination namespace\""
"                                                                                                               \"module name\""
" mod-name_0))"
"(void))"
"(values))))"
"(let-values(((attach-this-instance?_0)"
"(if attach-instances?_1"
"(module-instantiates-at-level?"
" m_0"
"(phase-"
" attach-phase_0"
" phase_1))"
" #f)))"
"(let-values(((m-ns_1"
" already?_0)"
"(if(let-values(((or-part_0)"
" attach-this-instance?_0))"
"(if or-part_0"
" or-part_0"
"(if(module-cross-phase-persistent?"
" m_0)"
"(not"
"(label-phase?"
" phase_1))"
" #f)))"
"(let-values()"
"(let-values(((m-ns_1)"
"(let-values(((src-namespace29_0)"
" src-namespace_0)"
"((mod-name30_0)"
" mod-name_0)"
"((phase31_0)"
" phase_1))"
"(namespace->module-namespace.1"
" #f"
" #f"
" void"
" src-namespace29_0"
" mod-name30_0"
" phase31_0))))"
"(let-values((()"
"(begin"
"(if m-ns_1"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                                                                                                       \"module not instantiated (in the source namespace)\""
"                                                                                                                                       \"module name\""
" mod-name_0"
"                                                                                                                                       \"instance phase\""
" phase_1)))"
"(values))))"
"(let-values(((already-m-ns_0)"
"(if already-m_0"
"(let-values(((dest-namespace32_0)"
" dest-namespace_0)"
"((mod-name33_0)"
" mod-name_0)"
"((phase34_0)"
" phase_1))"
"(namespace->module-namespace.1"
" #f"
" #f"
" void"
" dest-namespace32_0"
" mod-name33_0"
" phase34_0))"
" #f)))"
"(begin"
"(if(if already-m-ns_0"
"(if(not"
"(eq?"
" m-ns_1"
" already-m-ns_0))"
"(not"
"(namespace-same-instance?"
" m-ns_1"
" already-m-ns_0"
"(phase-"
" attach-phase_0"
" phase_1)))"
" #f)"
" #f)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                                                                                             \"a different instance is already in the destination namespace\""
"                                                                                                                             \"module name\""
" mod-name_0"
"                                                                                                                             \"instance phase\""
" phase_1))"
"(void))"
"(values"
" m-ns_1"
"(if already-m-ns_0"
" #t"
" #f)))))))"
"(let-values()"
"(begin"
"(if(if(label-phase?"
" phase_1)"
"(not"
"(let-values(((src-namespace35_0)"
" src-namespace_0)"
"((mod-name36_0)"
" mod-name_0)"
"((phase37_0)"
" phase_1))"
"(namespace->module-namespace.1"
" #f"
" #f"
" void"
" src-namespace35_0"
" mod-name36_0"
" phase37_0)))"
" #f)"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" src-namespace_0)"
"(let-values()"
"(let-values(((src-namespace38_0)"
" src-namespace_0)"
"((mpi39_0)"
" mpi_0)"
"((phase40_0)"
" phase_1))"
"(namespace-module-instantiate!.1"
" #f"
" #t"
" #t"
" unsafe-undefined"
" '#hasheq()"
" null"
" #f"
" #f"
" src-namespace38_0"
" mpi39_0"
" phase40_0)))))"
"(void))"
"(values"
" #f"
"(if already-m_0"
"(not"
" attach-instances?_1)"
" #f)))))))"
"(begin"
"(hash-update!"
" todo_0"
" mod-name_0"
"(lambda(ht_0)"
"(hash-set"
" ht_0"
" phase_1"
" m-ns_1))"
" '#hasheqv())"
"(if(let-values(((or-part_0)"
" already?_0))"
"(if or-part_0"
" or-part_0"
"(not"
" recur?_0)))"
"(void)"
"(let-values()"
"(let-values(((shifted-requires_0)"
"(let-values(((or-part_0)"
"(if mi_0"
"(module-instance-shifted-requires"
" mi_0)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(build-module-instance-shifted-requires"
" src-namespace_0"
" m_0"
" mpi_0"
" mod-name_0)))))"
"(begin"
"(if(not"
"(module-flattened-requires"
" m_0))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" shifted-requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((phase+mpis_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values(((lst_2)"
"(cdr"
" phase+mpis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((mpi_1)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if mpi_1"
"(let-values()"
"(loop_0"
" mpi_1"
" #f"
"(phase+"
" phase_1"
"(car"
" phase+mpis_0))"
" attach-instances?_1"
" attach-phase_0"
" #t))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" shifted-requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((mpi+phases_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((mpi_1)"
"(vector-ref"
" mpi+phases_0"
" 0)))"
"(begin"
"(let-values()"
"(let-values(((lst_2)"
"(vector-ref"
" mpi+phases_0"
" 1)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((req-phase_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" mpi_1"
" #f"
"(phase+"
" phase_1"
" req-phase_0)"
" attach-instances?_1"
" attach-phase_0"
" #f))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2))))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))"
"(if(non-self-derived-module-path-index?"
" mpi_0)"
"(let-values()"
"(namespace-save-shifted-requires!"
" src-namespace_0"
" m_0"
" mod-name_0"
" shifted-requires_0))"
"(void))"
"(let-values()"
"(let-values(((lst_0)"
"(module-submodule-names"
" m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((submod-name_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
"(module-path-index-join*"
"(list"
" 'submod"
"                                                                                                                                                                               \".\""
" submod-name_0)"
" mpi_0)"
"(1/make-resolved-module-path"
"(let-values(((n_0)"
"(1/resolved-module-path-name"
" mod-name_0)))"
"(if(pair?"
" n_0)"
"(append"
" n_0"
"(list"
" submod-name_0))"
"(list"
" n_0"
" submod-name_0))))"
" #f"
" #f"
" attach-phase_0"
" #t))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(if(module-supermodule-name"
" m_0)"
"(let-values()"
"(loop_0"
"(module-path-index-join*"
" '(submod"
"                                                                                                                  \"..\")"
" mpi_0)"
" #f"
" #f"
" #f"
" attach-phase_0"
" #t))"
"(void)))))))))))))))))"
"(void))))))))"
" loop_0)"
"(module-path-index-join*"
"(if(1/resolved-module-path? mod-path_0)"
"(resolved-module-path->module-path mod-path_0)"
" mod-path_0)"
" #f)"
"(if(1/resolved-module-path? mod-path_0) mod-path_0 #f)"
" phase_0"
" attach-instances?_0"
" phase_0"
" #t)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values()"
"(let-values(((ht_0) todo_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((mod-name_0 phases_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((m_0)"
"(namespace->module"
" src-namespace_0"
" mod-name_0)))"
"(begin"
"(module-force-bulk-binding!"
" m_0"
" src-namespace_0)"
"(if(eq?"
" m_0"
"(namespace->module"
" dest-namespace_0"
" mod-name_0))"
"(void)"
"(let-values()"
"(begin"
"(namespace-copy-shifted-requires!"
" dest-namespace_0"
" src-namespace_0"
" mod-name_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" dest-namespace_0)"
"(let-values()"
"(let-values(((dest-namespace41_0)"
" dest-namespace_0)"
"((m42_0)"
" m_0)"
"((mod-name43_0)"
" mod-name_0))"
"(declare-module!.1"
" #t"
" dest-namespace41_0"
" m42_0"
" mod-name43_0)))))))"
"(let-values()"
"(let-values(((ht_1)"
" phases_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((m-phase_0"
" m-ns_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if m-ns_0"
"(let-values()"
"(begin"
"(namespace-record-module-instance-attached!"
" src-namespace_0"
" mod-name_0"
" m-phase_0)"
"(let-values(((or-part_0)"
"(let-values(((dest-namespace44_0)"
" dest-namespace_0)"
"((mod-name45_0)"
" mod-name_0)"
"((m-phase46_0)"
" m-phase_0))"
"(namespace->module-namespace.1"
" #f"
" #f"
" void"
" dest-namespace44_0"
" mod-name45_0"
" m-phase46_0))))"
"(if or-part_0"
" or-part_0"
"(namespace-install-module-namespace!"
" dest-namespace_0"
" mod-name_0"
" m-phase_0"
" m_0"
" m-ns_0"
" phase_0)))))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
"(hash-iterate-next"
" ht_1"
" i_1))"
"(values))))"
"(values))))))"
" for-loop_1)"
"(hash-iterate-first"
" ht_1)))))"
"(void))))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(values))))"
"(let-values()"
"(let-values(((mnr_0)(1/current-module-name-resolver)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" dest-namespace_0)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_0) todo_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((mod-name_0)"
"(hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(mnr_0"
" mod-name_0"
" src-namespace_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void))))))))))))))))))))))))"
"(define-values"
"(1/make-empty-namespace)"
"(lambda()"
"(begin"
" 'make-empty-namespace"
"(let-values(((current-ns_0)(1/current-namespace)))"
"(let-values(((phase_0)(namespace-phase current-ns_0)))"
"(let-values(((ns_0)(namespace->namespace-at-phase(make-namespace) phase_0)))"
"(begin"
"(1/namespace-attach-module current-ns_0 ''#%kernel ns_0)"
"(namespace-primitive-module-visit! ns_0 '#%kernel)"
" ns_0)))))))"
"(define-values"
"(1/namespace-syntax-introduce)"
"(let-values(((namespace-syntax-introduce_0)"
"(lambda(s2_0 ns1_0)"
"(begin"
" 'namespace-syntax-introduce"
"(let-values(((s_0) s2_0))"
"(let-values(((ns_0)(if(eq? ns1_0 unsafe-undefined)(1/current-namespace) ns1_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"(let-values()"
"                                                  (raise-argument-error 'namespace-syntax-introduce \"syntax?\" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-syntax-introduce"
"                                                     \"namespace?\""
" ns_0)))"
"(values))))"
"(let-values(((root-ctx_0)(namespace-get-root-expand-ctx ns_0)))"
"(let-values(((post-scope_0)"
"(post-expansion-scope"
"(root-expand-context-post-expansion root-ctx_0))))"
"(let-values(((other-namespace-scopes_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_0)"
"(syntax-scope-set"
"(root-expand-context-all-scopes-stx root-ctx_0)"
" 0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((fold-var_2)"
"(if(equal?"
" sc_0"
" post-scope_0)"
" fold-var_1"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" sc_0)"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(let-values(((add-ns-scopes_0)"
"(lambda(s_1)"
"(begin"
" 'add-ns-scopes"
"(let-values(((temp40_0)"
"(add-scopes"
"(push-scope s_1 post-scope_0)"
" other-namespace-scopes_0))"
"((temp41_0)"
"(root-expand-context-all-scopes-stx root-ctx_0))"
"((temp42_0)"
"(let-values(((or-part_0)"
"(namespace-declaration-inspector"
" ns_0)))"
"(if or-part_0"
" or-part_0"
"(current-code-inspector))))"
"((temp43_0) #t))"
"(syntax-transfer-shifts.1"
" temp43_0"
" temp40_0"
" temp41_0"
" temp42_0))))))"
"(let-values(((maybe-module-id_0)"
"(if(pair?(1/syntax-e s_0))"
"(if(identifier?(car(1/syntax-e s_0)))"
"(add-ns-scopes_0(car(1/syntax-e s_0)))"
" #f)"
" #f)))"
"(if(if maybe-module-id_0"
"(1/free-identifier=?"
" maybe-module-id_0"
"(1/namespace-module-identifier ns_0)"
"(namespace-phase ns_0))"
" #f)"
"(let-values()"
"(1/datum->syntax"
" s_0"
"(cons maybe-module-id_0(cdr(1/syntax-e s_0)))"
" s_0"
" s_0))"
"(let-values()(add-ns-scopes_0 s_0)))))))))))))))))))"
"(case-lambda"
"((s_0)(begin 'namespace-syntax-introduce(namespace-syntax-introduce_0 s_0 unsafe-undefined)))"
"((s_0 ns1_0)(namespace-syntax-introduce_0 s_0 ns1_0)))))"
"(define-values"
"(namespace-datum-introduce)"
"(lambda(s_0)(begin(1/namespace-syntax-introduce(1/datum->syntax #f s_0)))))"
"(define-values"
"(1/namespace-module-identifier)"
"(let-values(((namespace-module-identifier_0)"
"(lambda(where3_0)"
"(begin"
" 'namespace-module-identifier"
"(let-values(((where_0)(if(eq? where3_0 unsafe-undefined)(1/current-namespace) where3_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(let-values(((or-part_0)(1/namespace? where_0)))"
"(if or-part_0 or-part_0(phase? where_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-module-identifier"
"                                   (string-append \"(or/c namespace? \" phase?-string \")\")"
" where_0)))"
"(1/datum->syntax"
"(1/syntax-shift-phase-level"
" core-stx"
"(if(1/namespace? where_0)(namespace-phase where_0) where_0))"
" 'module))))))))))"
"(case-lambda"
"(()(begin 'namespace-module-identifier(namespace-module-identifier_0 unsafe-undefined)))"
"((where3_0)(namespace-module-identifier_0 where3_0)))))"
"(define-values"
"(1/namespace-symbol->identifier)"
"(lambda(sym_0)"
"(begin"
" 'namespace-symbol->identifier"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym_0)"
"(void)"
"              (let-values () (raise-argument-error 'namespace-symbol->identifier \"symbol?\" sym_0)))"
"(1/namespace-syntax-introduce(1/datum->syntax #f sym_0))))))))"
"(define-values"
"(do-namespace-require.1)"
"(lambda(copy-variable-as-constant?7_0"
" copy-variable-phase-level6_0"
" run?4_0"
" skip-variable-phase-level8_0"
" visit?5_0"
" who14_0"
" req15_0"
" ns16_0)"
"(begin"
" 'do-namespace-require"
"(let-values(((run?_0) run?4_0))"
"(let-values(((visit?_0) visit?5_0))"
"(let-values(((who_0) who14_0))"
"(let-values(((req_0) req15_0))"
"(let-values(((ns_0) ns16_0))"
"(let-values(((copy-variable-phase-level_0) copy-variable-phase-level6_0))"
"(let-values(((copy-variable-as-constant?_0) copy-variable-as-constant?7_0))"
"(let-values(((skip-variable-phase-level_0) skip-variable-phase-level8_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"                                          (let-values () (raise-argument-error who_0 \"namespace?\" ns_0)))"
"(values))))"
"(let-values(((ctx-stx_0)"
"(add-scopes"
" empty-syntax"
"(root-expand-context-module-scopes(namespace-get-root-expand-ctx ns_0)))))"
"(if(let-values(((or-part_0)(1/module-path-index? req_0)))"
"(if or-part_0 or-part_0(1/module-path? req_0)))"
"(let-values()"
"(let-values(((temp46_0)"
"(if(1/module-path-index? req_0)"
" req_0"
"(module-path-index-join* req_0 #f)))"
"((temp47_0) #f)"
"((temp48_0) #f)"
"((ctx-stx49_0) ctx-stx_0)"
"((ns50_0) ns_0)"
"((run?51_0) run?_0)"
"((visit?52_0) visit?_0)"
"((temp53_0)(namespace-phase ns_0))"
"((temp54_0)(namespace-phase ns_0))"
"((copy-variable-phase-level55_0) copy-variable-phase-level_0)"
"((copy-variable-as-constant?56_0) copy-variable-as-constant?_0)"
"((skip-variable-phase-level57_0) skip-variable-phase-level_0)"
"((who58_0) who_0))"
"(perform-require!.1"
" #f"
" #t"
" #f"
" copy-variable-as-constant?56_0"
" copy-variable-phase-level55_0"
" #f"
" 'all"
" #t"
" temp53_0"
" #f"
" temp54_0"
" run?51_0"
" skip-variable-phase-level57_0"
" unsafe-undefined"
" visit?52_0"
" who58_0"
" temp46_0"
" temp47_0"
" temp48_0"
" ctx-stx49_0"
" ns50_0)))"
"(let-values()"
"(let-values(((run?59_0) run?_0)"
"((visit?60_0) visit?_0)"
"((temp61_0)(list(1/datum->syntax ctx-stx_0 req_0)))"
"((temp62_0) #f)"
"((ns63_0) ns_0)"
"((temp64_0)(namespace-phase ns_0))"
"((temp65_0)"
"(let-values(((temp70_0) #f))"
"(make-requires+provides.1 #f unsafe-undefined temp70_0)))"
"((copy-variable-phase-level66_0) copy-variable-phase-level_0)"
"((copy-variable-as-constant?67_0) copy-variable-as-constant?_0)"
"((skip-variable-phase-level68_0) skip-variable-phase-level_0)"
"((who69_0) who_0))"
"(parse-and-perform-requires!.1"
" #f"
" #f"
" copy-variable-as-constant?67_0"
" copy-variable-phase-level66_0"
" '#hasheq()"
" #f"
" unsafe-undefined"
" run?59_0"
" #f"
" skip-variable-phase-level68_0"
" visit?60_0"
" who69_0"
" temp61_0"
" temp62_0"
" ns63_0"
" temp64_0"
" temp65_0))))))))))))))))))"
"(define-values"
"(1/namespace-require)"
"(let-values(((namespace-require_0)"
"(lambda(req19_0 ns18_0)"
"(begin"
" 'namespace-require"
"(let-values(((req_0) req19_0))"
"(let-values(((ns_0)(if(eq? ns18_0 unsafe-undefined)(1/current-namespace) ns18_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who72_0) 'namespace-require)((req73_0) req_0)((ns74_0) ns_0))"
"(do-namespace-require.1 #f #f #t #f #f who72_0 req73_0 ns74_0)))))))))))"
"(case-lambda"
"((req_0)(begin 'namespace-require(namespace-require_0 req_0 unsafe-undefined)))"
"((req_0 ns18_0)(namespace-require_0 req_0 ns18_0)))))"
"(define-values"
"(1/namespace-require/expansion-time)"
"(let-values(((namespace-require/expansion-time_0)"
"(lambda(req21_0 ns20_0)"
"(begin"
" 'namespace-require/expansion-time"
"(let-values(((req_0) req21_0))"
"(let-values(((ns_0)(if(eq? ns20_0 unsafe-undefined)(1/current-namespace) ns20_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((temp76_0) #f)"
"((temp77_0) #t)"
"((who78_0) 'namespace-require/expansion-time)"
"((req79_0) req_0)"
"((ns80_0) ns_0))"
"(do-namespace-require.1 #f #f temp76_0 #f temp77_0 who78_0 req79_0 ns80_0)))))))))))"
"(case-lambda"
"((req_0)(begin 'namespace-require/expansion-time(namespace-require/expansion-time_0 req_0 unsafe-undefined)))"
"((req_0 ns20_0)(namespace-require/expansion-time_0 req_0 ns20_0)))))"
"(define-values"
"(1/namespace-require/constant)"
"(let-values(((namespace-require/constant_0)"
"(lambda(req23_0 ns22_0)"
"(begin"
" 'namespace-require/constant"
"(let-values(((req_0) req23_0))"
"(let-values(((ns_0)(if(eq? ns22_0 unsafe-undefined)(1/current-namespace) ns22_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who82_0) 'namespace-require/constant)"
"((req83_0) req_0)"
"((ns84_0) ns_0)"
"((temp85_0) 0)"
"((temp86_0) #t))"
"(do-namespace-require.1 temp86_0 temp85_0 #t #f #f who82_0 req83_0 ns84_0)))))))))))"
"(case-lambda"
"((req_0)(begin 'namespace-require/constant(namespace-require/constant_0 req_0 unsafe-undefined)))"
"((req_0 ns22_0)(namespace-require/constant_0 req_0 ns22_0)))))"
"(define-values"
"(1/namespace-require/copy)"
"(let-values(((namespace-require/copy_0)"
"(lambda(req25_0 ns24_0)"
"(begin"
" 'namespace-require/copy"
"(let-values(((req_0) req25_0))"
"(let-values(((ns_0)(if(eq? ns24_0 unsafe-undefined)(1/current-namespace) ns24_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who88_0) 'namespace-require/copy)"
"((req89_0) req_0)"
"((ns90_0) ns_0)"
"((temp91_0) 0)"
"((temp92_0) 0))"
"(do-namespace-require.1 #f temp91_0 #t temp92_0 #f who88_0 req89_0 ns90_0)))))))))))"
"(case-lambda"
"((req_0)(begin 'namespace-require/copy(namespace-require/copy_0 req_0 unsafe-undefined)))"
"((req_0 ns24_0)(namespace-require/copy_0 req_0 ns24_0)))))"
"(define-values"
"(1/namespace-variable-value)"
"(let-values(((namespace-variable-value_0)"
"(lambda(sym29_0 use-mapping?26_0 failure-thunk27_0 ns28_0)"
"(begin"
" 'namespace-variable-value"
"(let-values(((sym_0) sym29_0))"
"(let-values(((use-mapping?_0) use-mapping?26_0))"
"(let-values(((failure-thunk_0) failure-thunk27_0))"
"(let-values(((ns_0)(if(eq? ns28_0 unsafe-undefined)(1/current-namespace) ns28_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'namespace-variable-value \"symbol?\" sym_0)))"
"(if(let-values(((or-part_0)(not failure-thunk_0)))"
"(if or-part_0"
" or-part_0"
"(if(procedure? failure-thunk_0)"
"(procedure-arity-includes? failure-thunk_0 0)"
" #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-variable-value"
"                                         \"(or/c #f (procedure-arity-includes/c 0))\""
" failure-thunk_0)))"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"                                        (raise-argument-error 'namespace-variable-value \"namespace?\" ns_0)))"
"((call/ec"
"(lambda(escape_0)"
"(let-values(((var-ns_0 var-phase-level_0 var-sym_0)"
"(if use-mapping?_0"
"(let-values()"
"(let-values(((id_0)(1/datum->syntax #f sym_0)))"
"(let-values(((b_0)"
"(resolve+shift/extra-inspector"
"(1/namespace-syntax-introduce id_0 ns_0)"
"(namespace-phase ns_0)"
" ns_0)))"
"(let-values((()"
"(begin"
"(if b_0"
"(let-values()"
"(namespace-visit-available-modules!"
" ns_0))"
"(void))"
"(values))))"
"(let-values(((v_0"
" primitive?_0"
" extra-inspector_0"
" protected?_0)"
"(if b_0"
"(let-values(((b94_0) b_0)"
"((empty-env95_0) empty-env)"
"((null96_0) null)"
"((ns97_0) ns_0)"
"((temp98_0)"
"(namespace-phase ns_0))"
"((id99_0) id_0))"
"(binding-lookup.1"
" #t"
" #f"
" #f"
" b94_0"
" empty-env95_0"
" null96_0"
" ns97_0"
" temp98_0"
" id99_0))"
"(values variable #f #f #f))))"
"(begin"
"(if(variable? v_0)"
"(void)"
"(let-values()"
"(escape_0"
"(let-values(((or-part_0) failure-thunk_0))"
"(if or-part_0"
" or-part_0"
"(lambda()"
"(raise"
"(make-exn:fail:syntax$1"
"(format"
"(string-append"
"                                                                                   \"namespace-variable-value: bound to syntax\\n\""
"                                                                                   \"  in: ~s\")"
" sym_0)"
"(current-continuation-marks)"
" null))))))))"
"(if(module-binding? b_0)"
"(values"
"(if(top-level-module-path-index?"
"(module-binding-module b_0))"
" ns_0"
"(module-instance-namespace"
"(binding->module-instance"
" b_0"
" ns_0"
"(namespace-phase ns_0)"
" id_0)))"
"(module-binding-phase b_0)"
"(module-binding-sym b_0))"
"(values ns_0(namespace-phase ns_0) sym_0))))))))"
"(let-values()(values ns_0(namespace-phase ns_0) sym_0)))))"
"(let-values(((val_0)"
"(namespace-get-variable"
" var-ns_0"
" var-phase-level_0"
" var-sym_0"
"(lambda()"
"(escape_0"
"(let-values(((or-part_0) failure-thunk_0))"
"(if or-part_0"
" or-part_0"
"(raise"
"(exn:fail:contract:variable"
"(format"
"(string-append"
"                                                                    \"namespace-variable-value: given name is not defined\\n\""
"                                                                    \"  name: ~s\")"
" sym_0)"
"(current-continuation-marks)"
" sym_0)))))))))"
"(lambda() val_0))))))))))))))))))"
"(case-lambda"
"((sym_0)(begin 'namespace-variable-value(namespace-variable-value_0 sym_0 #t #f unsafe-undefined)))"
"((sym_0 use-mapping?_0 failure-thunk_0 ns28_0)"
"(namespace-variable-value_0 sym_0 use-mapping?_0 failure-thunk_0 ns28_0))"
"((sym_0 use-mapping?_0 failure-thunk27_0)"
"(namespace-variable-value_0 sym_0 use-mapping?_0 failure-thunk27_0 unsafe-undefined))"
"((sym_0 use-mapping?26_0)(namespace-variable-value_0 sym_0 use-mapping?26_0 #f unsafe-undefined)))))"
"(define-values"
"(1/namespace-set-variable-value!)"
"(let-values(((namespace-set-variable-value!_0)"
"(lambda(sym33_0 val34_0 map?30_0 ns31_0 as-constant?32_0)"
"(begin"
" 'namespace-set-variable-value!"
"(let-values(((sym_0) sym33_0))"
"(let-values(((val_0) val34_0))"
"(let-values(((map?_0) map?30_0))"
"(let-values(((ns_0)(if(eq? ns31_0 unsafe-undefined)(1/current-namespace) ns31_0)))"
"(let-values(((as-constant?_0) as-constant?32_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'namespace-set-variable-value! \"symbol?\" sym_0)))"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'namespace-set-variable-value! \"namespace?\" ns_0)))"
"(namespace-set-variable! ns_0(namespace-phase ns_0) sym_0 val_0 as-constant?_0)"
"(if map?_0"
"(let-values()"
"(let-values((()"
"(begin"
"(namespace-unset-transformer!"
" ns_0"
"(namespace-phase ns_0)"
" sym_0)"
"(values))))"
"(let-values(((id_0)(1/datum->syntax #f sym_0)))"
"(let-values(((temp101_0)(1/namespace-syntax-introduce id_0 ns_0))"
"((temp102_0)"
"(let-values(((temp104_0)(namespace-mpi ns_0))"
"((temp105_0)(namespace-phase ns_0))"
"((sym106_0) sym_0))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" temp104_0"
" temp105_0"
" sym106_0)))"
"((temp103_0)(namespace-phase ns_0)))"
"(add-binding!.1 #f #f temp101_0 temp102_0 temp103_0)))))"
"(void)))))))))))))))"
"(case-lambda"
"((sym_0 val_0)"
"(begin 'namespace-set-variable-value!(namespace-set-variable-value!_0 sym_0 val_0 #f unsafe-undefined #f)))"
"((sym_0 val_0 map?_0 ns_0 as-constant?32_0)"
"(namespace-set-variable-value!_0 sym_0 val_0 map?_0 ns_0 as-constant?32_0))"
"((sym_0 val_0 map?_0 ns31_0)(namespace-set-variable-value!_0 sym_0 val_0 map?_0 ns31_0 #f))"
"((sym_0 val_0 map?30_0)(namespace-set-variable-value!_0 sym_0 val_0 map?30_0 unsafe-undefined #f)))))"
"(define-values"
"(1/namespace-undefine-variable!)"
"(let-values(((namespace-undefine-variable!_0)"
"(lambda(sym36_0 ns35_0)"
"(begin"
" 'namespace-undefine-variable!"
"(let-values(((sym_0) sym36_0))"
"(let-values(((ns_0)(if(eq? ns35_0 unsafe-undefined)(1/current-namespace) ns35_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'namespace-undefine-variable! \"symbol?\" sym_0)))"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'namespace-undefine-variable! \"namespace?\" ns_0)))"
"(namespace-unset-variable! ns_0(namespace-phase ns_0) sym_0)))))))))))"
"(case-lambda"
"((sym_0)(begin 'namespace-undefine-variable!(namespace-undefine-variable!_0 sym_0 unsafe-undefined)))"
"((sym_0 ns35_0)(namespace-undefine-variable!_0 sym_0 ns35_0)))))"
"(define-values"
"(1/namespace-mapped-symbols)"
"(let-values(((namespace-mapped-symbols_0)"
"(lambda(ns37_0)"
"(begin"
" 'namespace-mapped-symbols"
"(let-values(((ns_0)(if(eq? ns37_0 unsafe-undefined)(1/current-namespace) ns37_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"                                (let-values () (raise-argument-error 'namespace-mapped-symbols \"namespace?\" ns_0)))"
"(set->list"
"(set-union"
"(let-values(((temp109_0)"
"(root-expand-context-all-scopes-stx(namespace-get-root-expand-ctx ns_0)))"
"((temp110_0)(namespace-phase ns_0)))"
"(syntax-mapped-names.1 #f #f temp109_0 temp110_0))"
"(list->set(1/instance-variable-names(namespace->instance ns_0 0))))))))))))))"
"(case-lambda"
"(()(begin 'namespace-mapped-symbols(namespace-mapped-symbols_0 unsafe-undefined)))"
"((ns37_0)(namespace-mapped-symbols_0 ns37_0)))))"
"(define-values"
"(1/namespace-base-phase)"
"(let-values(((namespace-base-phase_0)"
"(lambda(ns38_0)"
"(begin"
" 'namespace-base-phase"
"(let-values(((ns_0)(if(eq? ns38_0 unsafe-undefined)(1/current-namespace) ns38_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"                                (let-values () (raise-argument-error 'namespace-base-phase \"namespace?\" ns_0)))"
"(namespace-phase ns_0))))))))))"
"(case-lambda"
"(()(begin 'namespace-base-phase(namespace-base-phase_0 unsafe-undefined)))"
"((ns38_0)(namespace-base-phase_0 ns38_0)))))"
"(define-values"
"(1/namespace-call-with-registry-lock)"
"(lambda(ns_0 thunk_0)"
"(begin"
" 'namespace-call-with-registry-lock"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"              (let-values () (raise-argument-error 'namespace-call-with-registry-lock \"namespace?\" ns_0)))"
"(if((lambda(p_0)(if(procedure? p_0)(procedure-arity-includes? p_0 0) #f)) thunk_0)"
"(void)"
"(let-values()"
"                (raise-argument-error 'namespace-call-with-registry-lock \"(procedure-arity-includes/c 0)\" thunk_0)))"
"(registry-call-with-lock(namespace-module-registry$1 ns_0) thunk_0)))))))"
"(define-values"
"(as-expand-time-top-level-bindings)"
"(lambda(ids_0 s_0 ctx_0)"
"(begin"
"(let-values(((top-level-bind-scope_0)(root-expand-context-top-level-bind-scope ctx_0)))"
"(let-values(((tl-ids_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(remove-use-site-scopes"
" id_0"
" ctx_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values((()"
"(begin"
"(let-values(((tl-ids1_0) tl-ids_0)((temp2_0)(expand-context-phase ctx_0))((s3_0) s_0))"
"(check-no-duplicate-ids.1 unsafe-undefined tl-ids1_0 temp2_0 s3_0 unsafe-undefined))"
"(values))))"
"(let-values(((tmp-bind-ids_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) tl-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" top-level-bind-scope_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(values tl-ids_0(select-defined-syms-and-bind!/ctx tmp-bind-ids_0 ctx_0)))))))))"
"(define-values"
"(make-top-add-defined-portal)"
"(lambda(ns_0 ctx_0 generated-syms_0)"
"(begin"
"(lambda(id_0 phase_0 portal-stx_0 orig-s_0)"
"(let-values(((ids_0 syms_0)(as-expand-time-top-level-bindings(list id_0) orig-s_0 ctx_0)))"
"(let-values(((sym_0)(car syms_0)))"
"(begin"
"(if phase_0"
"(let-values()"
"(let-values(((t_0)(portal-syntax1.1 portal-stx_0 #f)))"
"(namespace-set-transformer! ns_0 phase_0 sym_0 t_0)))"
"(void))"
"(set-box! generated-syms_0(cons sym_0(unbox generated-syms_0)))"
" sym_0)))))))"
"(define-values"
"(1/eval)"
"(let-values(((eval_0)"
"(lambda(s3_0 ns1_0 compile2_0)"
"(begin"
" 'eval"
"(let-values(((s_0) s3_0))"
"(let-values(((ns_0)(if(eq? ns1_0 unsafe-undefined)(1/current-namespace) ns1_0)))"
"(let-values(((compile_0)"
"(if(eq? compile2_0 unsafe-undefined)"
"(lambda(s_1 ns_1)(begin 'compile(1/compile s_1 ns_1 #f)))"
" compile2_0)))"
"(let-values()"
"(if(let-values(((or-part_0)(compiled-in-memory? s_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(linklet-directory?$1 s_0)))"
"(if or-part_1 or-part_1(1/linklet-bundle? s_0)))))"
"(let-values()(eval-compiled s_0 ns_0))"
"(if(if(syntax?$1 s_0)"
"(let-values(((or-part_0)(compiled-in-memory?(1/syntax-e s_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(linklet-directory?$1(1/syntax-e s_0))))"
"(if or-part_1 or-part_1(1/linklet-bundle?(1/syntax-e s_0))))))"
" #f)"
"(let-values()(eval-compiled(1/syntax->datum s_0) ns_0))"
"(let-values()"
"(let-values(((s63_0) s_0)"
"((ns64_0) ns_0)"
"((temp65_0)"
"(lambda(s_1 ns_1 tail?_0)"
"(eval-compiled(compile_0 s_1 ns_1) ns_1 tail?_0)))"
"((temp66_0) #f))"
"(per-top-level.1 #f #f temp66_0 #t #f temp65_0 #f s63_0 ns64_0)))))))))))))"
"(case-lambda"
"((s_0)(begin 'eval(eval_0 s_0 unsafe-undefined unsafe-undefined)))"
"((s_0 ns_0 compile2_0)(eval_0 s_0 ns_0 compile2_0))"
"((s_0 ns1_0)(eval_0 s_0 ns1_0 unsafe-undefined)))))"
"(define-values"
"(eval-compiled)"
"(let-values(((eval-compiled_0)"
"(lambda(c5_0 ns6_0 as-tail?4_0)"
"(begin"
" 'eval-compiled"
"(let-values(((c_0) c5_0))"
"(let-values(((ns_0) ns6_0))"
"(let-values(((as-tail?_0) as-tail?4_0))"
"(let-values()"
"(if(1/compiled-module-expression? c_0)"
"(let-values()"
"(let-values(((c67_0) c_0)((ns68_0) ns_0))(eval-module.1 ns68_0 #f #t c67_0)))"
"(let-values()(eval-top c_0 ns_0 eval-compiled as-tail?_0)))))))))))"
"(case-lambda"
"((c_0 ns_0)(begin(eval-compiled_0 c_0 ns_0 #t)))"
"((c_0 ns_0 as-tail?4_0)(eval-compiled_0 c_0 ns_0 as-tail?4_0)))))"
"(define-values"
"(1/compile)"
"(let-values(((compile_0)"
"(lambda(s10_0 ns7_0 serializable?8_0 expand9_0)"
"(begin"
" 'compile"
"(let-values(((s_0) s10_0))"
"(let-values(((ns_0)(if(eq? ns7_0 unsafe-undefined)(1/current-namespace) ns7_0)))"
"(let-values(((serializable?_0) serializable?8_0))"
"(let-values(((expand_0)(if(eq? expand9_0 unsafe-undefined) expand$1 expand9_0)))"
"(let-values()"
"(let-values(((to-correlated-linklet?_0)"
"(if serializable?_0(not(current-compile-target-machine)) #f)))"
"(let-values(((cs_0)"
"(if(1/compiled-expression? s_0)"
"(let-values()(list s_0))"
"(if(if(syntax?$1 s_0)(1/compiled-expression?(1/syntax-e s_0)) #f)"
"(let-values()(list(1/syntax-e s_0)))"
"(let-values()"
"(let-values(((s69_0) s_0)"
"((ns70_0) ns_0)"
"((temp71_0)"
"(lambda(s_1 ns_1 as-tail?_0)"
"(list"
"(let-values(((s74_0) s_1)"
"((ns75_0) ns_1)"
"((expand76_0) expand_0)"
"((serializable?77_0) serializable?_0)"
"((to-correlated-linklet?78_0)"
" to-correlated-linklet?_0))"
"(compile-single.1"
" serializable?77_0"
" to-correlated-linklet?78_0"
" s74_0"
" ns75_0"
" expand76_0)))))"
"((append72_0) append)"
"((temp73_0) #f))"
"(per-top-level.1"
" append72_0"
" #f"
" temp73_0"
" #t"
" #f"
" temp71_0"
" #f"
" s69_0"
" ns70_0)))))))"
"(if(if(= 1(length cs_0))(not(compiled-multiple-top?(car cs_0))) #f)"
"(car cs_0)"
"(let-values(((cs79_0) cs_0)"
"((to-correlated-linklet?80_0) to-correlated-linklet?_0)"
"((serializable?81_0) serializable?_0)"
"((ns82_0) ns_0))"
"(compiled-tops->compiled-top.1"
" serializable?81_0"
" ns82_0"
" to-correlated-linklet?80_0"
" cs79_0))))))))))))))"
"(case-lambda"
"((s_0)(begin 'compile(compile_0 s_0 unsafe-undefined #t unsafe-undefined)))"
"((s_0 ns_0 serializable?_0 expand9_0)(compile_0 s_0 ns_0 serializable?_0 expand9_0))"
"((s_0 ns_0 serializable?8_0)(compile_0 s_0 ns_0 serializable?8_0 unsafe-undefined))"
"((s_0 ns7_0)(compile_0 s_0 ns7_0 #t unsafe-undefined)))))"
"(define-values"
"(struct:lifted-parsed-begin"
" lifted-parsed-begin11.1"
" lifted-parsed-begin?"
" lifted-parsed-begin-seq"
" lifted-parsed-begin-last)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'lifted-parsed-begin"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'lifted-parsed-begin)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'seq)"
"(make-struct-field-accessor -ref_0 1 'last))))"
"(define-values"
"(compile-single.1)"
"(lambda(serializable?12_0 to-correlated-linklet?13_0 s16_0 ns17_0 expand18_0)"
"(begin"
" 'compile-single"
"(let-values(((s_0) s16_0))"
"(let-values(((ns_0) ns17_0))"
"(let-values(((expand_0) expand18_0))"
"(let-values(((serializable?_0) serializable?12_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?13_0))"
"(let-values()"
"(let-values(((exp-s_0)(expand_0 s_0 ns_0 #f #t serializable?_0 to-correlated-linklet?_0)))"
"((letrec-values(((loop_0)"
"(lambda(exp-s_1)"
"(begin"
" 'loop"
"(if(parsed-bundle? exp-s_1)"
"(let-values()"
"(1/compiled-expression-recompile(parsed-bundle-bundle exp-s_1)))"
"(if(parsed-module? exp-s_1)"
"(let-values()"
"(let-values(((exp-s84_0) exp-s_1)"
"((temp85_0)"
"(let-values(((ns88_0) ns_0))"
"(make-compile-context.1"
" #f"
" unsafe-undefined"
" #f"
" ns88_0"
" unsafe-undefined"
" unsafe-undefined)))"
"((serializable?86_0) serializable?_0)"
"((to-correlated-linklet?87_0) to-correlated-linklet?_0))"
"(compile-module.1"
" #f"
" unsafe-undefined"
" #t"
" serializable?86_0"
" to-correlated-linklet?87_0"
" exp-s84_0"
" temp85_0)))"
"(if(lifted-parsed-begin? exp-s_1)"
"(let-values()"
"(let-values(((to-correlated-linklet?89_0) to-correlated-linklet?_0)"
"((temp90_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0)"
"(append"
"(lifted-parsed-begin-seq exp-s_1)"
"(list"
"(lifted-parsed-begin-last"
" exp-s_1)))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0"
" e_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(compiled-tops->compiled-top.1"
" #f"
" #f"
" to-correlated-linklet?89_0"
" temp90_0)))"
"(let-values()"
"(let-values(((exp-s91_0) exp-s_1)"
"((temp92_0)"
"(let-values(((ns95_0) ns_0))"
"(make-compile-context.1"
" #f"
" unsafe-undefined"
" #f"
" ns95_0"
" unsafe-undefined"
" unsafe-undefined)))"
"((serializable?93_0) serializable?_0)"
"((to-correlated-linklet?94_0) to-correlated-linklet?_0))"
"(compile-top.1"
" serializable?93_0"
" #f"
" to-correlated-linklet?94_0"
" exp-s91_0"
" temp92_0))))))))))"
" loop_0)"
" exp-s_0)))))))))))"
"(define-values"
"(expand$1)"
"(let-values(((expand_0)"
"(lambda(s25_0 ns20_0 observable?21_0 to-parsed?22_0 serializable?23_0 to-correlated-linklet?24_0)"
"(begin"
" 'expand"
"(let-values(((s_0) s25_0))"
"(let-values(((ns_0)(if(eq? ns20_0 unsafe-undefined)(1/current-namespace) ns20_0)))"
"(let-values(((observable?_0) observable?21_0))"
"(let-values(((to-parsed?_0) to-parsed?22_0))"
"(let-values(((serializable?_0) serializable?23_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?24_0))"
"(let-values()"
"(let-values(((observer_0)(if observable?_0(current-expand-observe) #f)))"
"(begin"
"(if observer_0(let-values()(call-expand-observe observer_0 'start-top))(void))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-expand-observe"
" #f)"
"(let-values()"
"(let-values(((s96_0) s_0)"
"((ns97_0) ns_0)"
"((temp98_0)"
"(lambda(s_1 ns_1 as-tail?_0)"
"(let-values(((s102_0) s_1)"
"((ns103_0) ns_1)"
"((observer104_0) observer_0)"
"((to-parsed?105_0) to-parsed?_0)"
"((serializable?106_0) serializable?_0)"
"((to-correlated-linklet?107_0)"
" to-correlated-linklet?_0))"
"(expand-single.1"
" serializable?106_0"
" to-correlated-linklet?107_0"
" s102_0"
" ns103_0"
" observer104_0"
" to-parsed?105_0))))"
"((cons99_0) cons)"
"((re-pair100_0) re-pair)"
"((observer101_0) observer_0))"
"(per-top-level.1"
" cons99_0"
" #f"
" observer101_0"
" #t"
" #f"
" temp98_0"
" re-pair100_0"
" s96_0"
" ns97_0)))))))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand(expand_0 s_0 unsafe-undefined #f #f #f #f)))"
"((s_0 ns_0 observable?_0 to-parsed?_0 serializable?_0 to-correlated-linklet?24_0)"
"(expand_0 s_0 ns_0 observable?_0 to-parsed?_0 serializable?_0 to-correlated-linklet?24_0))"
"((s_0 ns_0 observable?_0 to-parsed?_0 serializable?23_0)"
"(expand_0 s_0 ns_0 observable?_0 to-parsed?_0 serializable?23_0 #f))"
"((s_0 ns_0 observable?_0 to-parsed?22_0)(expand_0 s_0 ns_0 observable?_0 to-parsed?22_0 #f #f))"
"((s_0 ns_0 observable?21_0)(expand_0 s_0 ns_0 observable?21_0 #f #f #f))"
"((s_0 ns20_0)(expand_0 s_0 ns20_0 #f #f #f #f)))))"
"(define-values"
"(expand-single.1)"
"(lambda(serializable?26_0 to-correlated-linklet?27_0 s30_0 ns31_0 observer32_0 to-parsed?33_0)"
"(begin"
" 'expand-single"
"(let-values(((s_0) s30_0))"
"(let-values(((ns_0) ns31_0))"
"(let-values(((observer_0) observer32_0))"
"(let-values(((to-parsed?_0) to-parsed?33_0))"
"(let-values(((serializable?_0) serializable?26_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?27_0))"
"(let-values()"
"(let-values(((rebuild-s_0)(keep-properties-only s_0)))"
"(let-values(((ctx_0)"
"(let-values(((ns108_0) ns_0)"
"((to-parsed?109_0) to-parsed?_0)"
"((serializable?110_0) serializable?_0)"
"((to-correlated-linklet?111_0) to-correlated-linklet?_0)"
"((observer112_0) observer_0))"
"(make-expand-context.1"
" serializable?110_0"
" observer112_0"
" #f"
" to-correlated-linklet?111_0"
" to-parsed?109_0"
" ns108_0))))"
"(let-values(((require-lifts_0 lifts_0 exp-s_0)(expand-capturing-lifts s_0 ctx_0)))"
"(if(if(null? require-lifts_0)(null? lifts_0) #f)"
"(let-values() exp-s_0)"
"(if to-parsed?_0"
"(let-values()"
"(let-values(((require-lifts113_0) require-lifts_0)"
"((lifts114_0) lifts_0)"
"((exp-s115_0) exp-s_0)"
"((rebuild-s116_0) rebuild-s_0)"
"((temp117_0)"
"(lambda(form_0)"
"(let-values(((form118_0) form_0)"
"((ns119_0) ns_0)"
"((observer120_0) observer_0)"
"((to-parsed?121_0) to-parsed?_0)"
"((serializable?122_0) serializable?_0))"
"(expand-single.1"
" serializable?122_0"
" #f"
" form118_0"
" ns119_0"
" observer120_0"
" to-parsed?121_0)))))"
"(wrap-lifts-as-lifted-parsed-begin.1"
" temp117_0"
" require-lifts113_0"
" lifts114_0"
" exp-s115_0"
" rebuild-s116_0)))"
"(let-values()"
"(let-values(((new-s_0)"
"(let-values(((temp128_0)"
"(append(map2 parsed-s require-lifts_0) lifts_0))"
"((exp-s129_0) exp-s_0)"
"((temp130_0)(namespace-phase ns_0)))"
"(wrap-lifts-as-begin.1"
" unsafe-undefined"
" unsafe-undefined"
" temp128_0"
" exp-s129_0"
" temp130_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'lift-loop new-s_0)))"
"(void)))"
"(let-values(((new-s123_0) new-s_0)"
"((ns124_0) ns_0)"
"((observer125_0) observer_0)"
"((to-parsed?126_0) to-parsed?_0)"
"((serializable?127_0) serializable?_0))"
"(expand-single.1"
" serializable?127_0"
" #f"
" new-s123_0"
" ns124_0"
" observer125_0"
" to-parsed?126_0))))))))))))))))))))"
"(define-values"
"(expand-once$1)"
"(let-values(((expand-once_0)"
"(lambda(s36_0 ns35_0)"
"(begin"
" 'expand-once"
"(let-values(((s_0) s36_0))"
"(let-values(((ns_0)(if(eq? ns35_0 unsafe-undefined)(1/current-namespace) ns35_0)))"
"(let-values()"
"(let-values(((s131_0) s_0)"
"((ns132_0) ns_0)"
"((temp133_0)(lambda(s_1 ns_1 as-tail?_0)(expand-single-once s_1 ns_1)))"
"((cons134_0) cons)"
"((re-pair135_0) re-pair)"
"((temp136_0) #t)"
"((temp137_0) #f))"
"(per-top-level.1"
" cons134_0"
" temp136_0"
" temp137_0"
" #t"
" #f"
" temp133_0"
" re-pair135_0"
" s131_0"
" ns132_0)))))))))"
"(case-lambda"
"((s_0)(begin 'expand-once(expand-once_0 s_0 unsafe-undefined)))"
"((s_0 ns35_0)(expand-once_0 s_0 ns35_0)))))"
"(define-values"
"(expand-single-once)"
"(lambda(s_0 ns_0)"
"(begin"
"(let-values(((require-lifts_0 lifts_0 exp-s_0)"
"(expand-capturing-lifts"
" s_0"
"(let-values(((v_0)"
"(let-values(((ns138_0) ns_0))(make-expand-context.1 #f #f #f #f #f ns138_0))))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner139_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((just-once?140_0) #t))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
"(expand-context/inner-to-parsed? the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
" just-once?140_0"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-parsing-expanded? the-struct_1)"
"(expand-context/inner-skip-visit-available? the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                              \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner139_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"                           (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))"
"(if(if(null? require-lifts_0)(null? lifts_0) #f)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((temp141_0)(append(map2 parsed-s require-lifts_0) lifts_0))"
"((exp-s142_0) exp-s_0)"
"((temp143_0)(namespace-phase ns_0)))"
"(wrap-lifts-as-begin.1 unsafe-undefined unsafe-undefined temp141_0 exp-s142_0 temp143_0))))))))"
"(define-values"
"(expand-to-top-form$1)"
"(let-values(((expand-to-top-form_0)"
"(lambda(s38_0 ns37_0)"
"(begin"
" 'expand-to-top-form"
"(let-values(((s_0) s38_0))"
"(let-values(((ns_0)(if(eq? ns37_0 unsafe-undefined)(1/current-namespace) ns37_0)))"
"(let-values()"
"(let-values(((observer_0)(current-expand-observe)))"
"(begin"
"(if observer_0(let-values()(call-expand-observe observer_0 'start-top))(void))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-expand-observe"
" #f)"
"(let-values()"
"(let-values(((s144_0) s_0)"
"((ns145_0) ns_0)"
"((temp146_0) #f)"
"((temp147_0) #f)"
"((observer148_0) observer_0))"
"(per-top-level.1"
" #f"
" #f"
" observer148_0"
" temp147_0"
" #f"
" temp146_0"
" #f"
" s144_0"
" ns145_0)))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand-to-top-form(expand-to-top-form_0 s_0 unsafe-undefined)))"
"((s_0 ns37_0)(expand-to-top-form_0 s_0 ns37_0)))))"
"(define-values"
"(per-top-level.1)"
"(lambda(combine40_0"
" just-once?42_0"
" observer45_0"
" quick-immediate?43_0"
" serializable?44_0"
" single39_0"
" wrap41_0"
" given-s53_0"
" ns54_0)"
"(begin"
" 'per-top-level"
"(let-values(((given-s_0) given-s53_0))"
"(let-values(((ns_0) ns54_0))"
"(let-values(((single_0) single39_0))"
"(let-values(((combine_0) combine40_0))"
"(let-values(((wrap_0) wrap41_0))"
"(let-values(((just-once?_0) just-once?42_0))"
"(let-values(((quick-immediate?_0) quick-immediate?43_0))"
"(let-values(((serializable?_0) serializable?44_0))"
"(let-values(((observer_0) observer45_0))"
"(let-values()"
"(let-values(((s_0)(maybe-intro given-s_0 ns_0)))"
"(let-values(((ctx_0)"
"(let-values(((ns149_0) ns_0)((observer150_0) observer_0))"
"(make-expand-context.1 #f observer150_0 #f #f #f ns149_0))))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"((letrec-values(((loop_0)"
"(lambda(s_1 phase_1 ns_1 as-tail?_0)"
"(begin"
" 'loop"
"(let-values(((tl-ctx_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner151_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((phase152_0)"
" phase_1)"
"((namespace153_0)"
" ns_1)"
"((just-once?154_0)"
" just-once?_0)"
"((for-serializable?155_0)"
" serializable?_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase152_0"
" namespace153_0"
" just-once?154_0"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
" for-serializable?155_0"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                             \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner151_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                           \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((wb-s_0)(if just-once?_0 s_1 #f)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'visit"
" s_1)))"
"(void)))"
"(values))))"
"(let-values(((require-lifts_0 lifts_0 exp-s_0)"
"(expand-capturing-lifts"
" s_1"
"(let-values(((v_0) tl-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((only-immediate?156_0)"
" #t)"
"((inner157_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((phase158_0)"
" phase_1)"
"((namespace159_0)"
" ns_1))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase158_0"
" namespace159_0"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                    \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner157_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
" only-immediate?156_0"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                  \"expand-context/outer?\""
" the-struct_0)))))))"
"(if(let-values(((or-part_0)(pair? require-lifts_0)))"
"(if or-part_0 or-part_0(pair? lifts_0)))"
"(let-values()"
"(let-values(((new-s_0)"
"(let-values(((temp160_0)"
"(append"
"(map2"
" parsed-s"
" require-lifts_0)"
" lifts_0))"
"((exp-s161_0) exp-s_0)"
"((phase162_0) phase_1))"
"(wrap-lifts-as-begin.1"
" unsafe-undefined"
" unsafe-undefined"
" temp160_0"
" exp-s161_0"
" phase162_0))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'lift-loop"
" new-s_0)))"
"(void)))"
"(if just-once?_0"
" new-s_0"
"(loop_0 new-s_0 phase_1 ns_1 as-tail?_0)))))"
"(if(not single_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'return"
" exp-s_0)))"
"(void)))"
" exp-s_0))"
"(if(if just-once?_0(not(eq? exp-s_0 wb-s_0)) #f)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((tmp_0)"
"(core-form-sym exp-s_0 phase_1)))"
"(if(equal? tmp_0 'begin)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-begin"
" exp-s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 begin163_0 e164_0)"
"(let-values(((s_2)"
" exp-s_0))"
"(let-values(((orig-s_0)"
" s_2))"
"(let-values(((begin163_0"
" e164_0)"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((begin165_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((e166_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                           \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin165_0"
" e166_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                   \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin163_0"
" e164_0))))))"
"(letrec-values(((begin-loop_0)"
"(lambda(es_0)"
"(begin"
" 'begin-loop"
"(if(null? es_0)"
"(let-values()"
"(if combine_0"
" null"
"(void)))"
"(if(if(not"
" combine_0)"
"(null?"
"(cdr"
" es_0))"
" #f)"
"(let-values()"
"(loop_0"
"(car es_0)"
" phase_1"
" ns_1"
" as-tail?_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((a_0)"
"(if combine_0"
"(loop_0"
"(car"
" es_0)"
" phase_1"
" ns_1"
" #f)"
"(begin"
"(loop_0"
"(car"
" es_0)"
" phase_1"
" ns_1"
" #f)"
"(void)))))"
"(if combine_0"
"(combine_0"
" a_0"
"(begin-loop_0"
"(cdr"
" es_0)))"
"(begin-loop_0"
"(cdr"
" es_0))))))))))))"
"(if wrap_0"
"(let-values()"
"(let-values(((new-s_0)"
"(wrap_0"
" begin163_0"
" exp-s_0"
"(begin-loop_0"
" e164_0))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'return"
" new-s_0)))"
"(void)))"
" new-s_0)))"
"(let-values()"
"(begin-loop_0 e164_0)))))))"
"(if(equal? tmp_0 'begin-for-syntax)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-begin-for-syntax"
" exp-s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" begin-for-syntax167_0"
" e168_0)"
"(let-values(((s_2)"
" exp-s_0))"
"(let-values(((orig-s_0)"
" s_2))"
"(let-values(((begin-for-syntax167_0"
" e168_0)"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((begin-for-syntax169_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((e170_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                             \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin-for-syntax169_0"
" e170_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                     \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin-for-syntax167_0"
" e168_0))))))"
"(let-values(((next-phase_0)"
"(add1 phase_1)))"
"(let-values(((next-ns_0)"
"(namespace->namespace-at-phase"
" ns_1"
" next-phase_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if quick-immediate?_0"
"(let-values()"
"(namespace-visit-available-modules!"
" ns_1))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(namespace-visit-available-modules!"
" next-ns_0)"
"(values))))"
"(let-values(((l_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" e168_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(loop_0"
" s_2"
" next-phase_0"
" next-ns_0"
" #f)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(if wrap_0"
"(let-values()"
"(let-values(((new-s_0)"
"(wrap_0"
" begin-for-syntax167_0"
" exp-s_0"
" l_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'return"
" new-s_0)))"
"(void)))"
" new-s_0)))"
"(if combine_0"
"(let-values()"
"(apply append l_0))"
"(let-values()"
"(void)))))))))))))"
"(let-values()"
"(single_0"
" exp-s_0"
" ns_1"
" as-tail?_0)))))))))))))))))"
" loop_0)"
" s_0"
" phase_0"
" ns_0"
" #t)))))))))))))))))"
"(define-values"
"(maybe-intro)"
"(lambda(s_0 ns_0)(begin(if(syntax?$1 s_0) s_0(1/namespace-syntax-introduce(1/datum->syntax #f s_0) ns_0)))))"
"(define-values(re-pair)(lambda(form-id_0 s_0 r_0)(begin(1/datum->syntax s_0(cons form-id_0 r_0) s_0 s_0))))"
"(define-values"
"(expand-capturing-lifts)"
"(lambda(s_0 ctx_0)"
"(begin"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand 'top))(void))"
"(begin0"
"(let-values()"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"(let-values((()(begin(namespace-visit-available-modules! ns_0)(values))))"
"(let-values(((lift-ctx_0)"
"(let-values(((temp171_0)(make-top-level-lift ctx_0)))"
"(make-lift-context.1 #f temp171_0))))"
"(let-values(((require-lift-ctx_0)"
"(make-require-lift-context"
"(namespace-phase ns_0)"
"(make-parse-top-lifted-require ns_0 ctx_0))))"
"(let-values(((exp-s_0)"
"(let-values(((s172_0) s_0)"
"((temp173_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner174_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((lifts175_0) lift-ctx_0)"
"((module-lifts176_0) lift-ctx_0)"
"((require-lifts177_0)"
" require-lift-ctx_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
" lifts175_0"
"(expand-context/inner-lift-envs the-struct_1)"
" module-lifts176_0"
" require-lifts177_0"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                         \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner174_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                       \"expand-context/outer?\""
" the-struct_0))))))"
"(expand.1 #f #f s172_0 temp173_0))))"
"(values"
"(get-and-clear-require-lifts! require-lift-ctx_0)"
"(get-and-clear-lifts! lift-ctx_0)"
" exp-s_0)))))))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))"
"(define-values"
"(make-parse-top-lifted-require)"
"(lambda(ns_0 ctx_0)"
"(begin"
"(lambda(s_0 phase_0)"
"(let-values(((ok?_0 #%require178_0 req179_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%require178_0 req179_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%require180_0)(let-values(((s_3)(car s_2))) s_3))"
"((req181_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((req182_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values req182_0))"
"                                                                (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values #%require180_0 req181_0))"
"                                            (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%require178_0 req179_0))))))"
"(let-values(((syms_0)(box null)))"
"(begin"
"(let-values(((temp183_0)(list req179_0))"
"((s184_0) s_0)"
"((ns185_0) ns_0)"
"((phase186_0) phase_0)"
"((phase187_0) phase_0)"
"((temp188_0)"
"(let-values(((temp191_0) #f))(make-requires+provides.1 #f unsafe-undefined temp191_0)))"
"((temp189_0)(make-top-add-defined-portal ns_0 ctx_0 syms_0))"
"((temp190_0) 'require))"
"(parse-and-perform-requires!.1"
" temp189_0"
" #f"
" #f"
" #f"
" '#hasheq()"
" #f"
" phase187_0"
" #f"
" #f"
" #f"
" #t"
" temp190_0"
" temp183_0"
" s184_0"
" ns185_0"
" phase186_0"
" temp188_0))"
"(parsed-require23.1 s_0(reverse$1(unbox syms_0))))))))))"
"(define-values"
"(wrap-lifts-as-lifted-parsed-begin.1)"
"(lambda(adjust-form56_0 require-lifts58_0 lifts59_0 exp-s60_0 rebuild-s61_0)"
"(begin"
" 'wrap-lifts-as-lifted-parsed-begin"
"(let-values(((require-lifts_0) require-lifts58_0))"
"(let-values(((lifts_0) lifts59_0))"
"(let-values(((exp-s_0) exp-s60_0))"
"(let-values(((rebuild-s_0) rebuild-s61_0))"
"(let-values(((adjust-form_0) adjust-form56_0))"
"(let-values()"
"(lifted-parsed-begin11.1"
"(append"
" require-lifts_0"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(get-lifts-as-lists lifts_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((ids+syms+rhs_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((exp-rhs_0)"
"(adjust-form_0"
"(caddr"
" ids+syms+rhs_0))))"
"(let-values(((just-rhs_0)"
"(if(lifted-parsed-begin?"
" exp-rhs_0)"
"(lifted-parsed-begin-last"
" exp-rhs_0)"
" exp-rhs_0)))"
"(let-values(((dv_0)"
"(parsed-define-values19.1"
" rebuild-s_0"
"(car"
" ids+syms+rhs_0)"
"(cadr"
" ids+syms+rhs_0)"
" just-rhs_0)))"
"(if(lifted-parsed-begin?"
" exp-rhs_0)"
"(let-values(((the-struct_0)"
" exp-rhs_0))"
"(if(lifted-parsed-begin?"
" the-struct_0)"
"(let-values(((last192_0)"
" dv_0))"
"(lifted-parsed-begin11.1"
"(lifted-parsed-begin-seq"
" the-struct_0)"
" last192_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                     \"lifted-parsed-begin?\""
" the-struct_0)))"
" dv_0)))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
" exp-s_0))))))))))"
" (define-values (replace-me) (lambda (who_0) (begin (lambda args_0 (error who_0 \"this stub must be replaced\")))))"
"(define-values"
"(1/current-eval)"
"(let-values()"
"(let-values()"
"(make-parameter"
"(replace-me 'current-eval)"
"(lambda(p_0)"
"(begin"
"(if((lambda(p_1)(if(procedure? p_1)(procedure-arity-includes? p_1 1) #f)) p_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-eval \"(procedure-arity-includes/c 1)\" p_0)))"
" p_0))"
" 'current-eval))))"
"(define-values"
"(1/current-compile)"
"(let-values()"
"(let-values()"
"(make-parameter"
"(replace-me 'current-compile)"
"(lambda(p_0)"
"(begin"
"(if((lambda(p_1)(if(procedure? p_1)(procedure-arity-includes? p_1 2) #f)) p_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-compile \"(procedure-arity-includes/c 2)\" p_0)))"
" p_0))"
" 'current-compile))))"
"(define-values"
"(1/current-load)"
"(let-values()"
"(let-values()"
"(make-parameter"
"(replace-me 'current-load)"
"(lambda(p_0)"
"(begin"
"(if((lambda(p_1)(if(procedure? p_1)(procedure-arity-includes? p_1 2) #f)) p_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-load \"(procedure-arity-includes/c 2)\" p_0)))"
" p_0))"
" 'current-load))))"
"(define-values"
"(1/current-load/use-compiled)"
"(let-values()"
"(let-values()"
"(make-parameter"
"(replace-me 'current-load/use-compiled)"
"(lambda(p_0)"
"(begin"
"(if((lambda(p_1)(if(procedure? p_1)(procedure-arity-includes? p_1 2) #f)) p_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-load/use-compiled \"(procedure-arity-includes/c 2)\" p_0)))"
" p_0))"
" 'current-load/use-compiled))))"
"(define-values"
"(1/current-library-collection-paths)"
"(let-values()"
"(let-values()"
"(make-parameter"
" null"
"(lambda(l_0)"
"(begin"
"(if((lambda(l_1)(if(list? l_1)(andmap2 complete-path-string? l_1) #f)) l_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'current-library-collection-paths"
"                \"(listof (and/c path-string? complete-path?))\""
" l_0)))"
"(map2 to-path l_0)))"
" 'current-library-collection-paths))))"
"(define-values"
"(1/current-library-collection-links)"
"(let-values()"
"(let-values()"
"(make-parameter"
" null"
"(lambda(l_0)"
"(begin"
"(if((lambda(l_1)"
"(if(list? l_1)"
"(andmap2"
"(lambda(p_0)"
"(let-values(((or-part_0)(not p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(complete-path-string? p_0)))"
"(if or-part_1"
" or-part_1"
"(if(hash? p_0)"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((ht_0) p_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(let-values(((or-part_2)"
"(not"
" k_0)))"
"(if or-part_2"
" or-part_2"
"(if(symbol?"
" k_0)"
"(1/module-path?"
" k_0)"
" #f)))"
"(if(list? v_0)"
"(andmap2"
" complete-path-string?"
" v_0)"
" #f)"
" #f)))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) k_0 v_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" result_2"
"(hash-iterate-next ht_0 i_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
"(hash-iterate-first ht_0)))))"
" #f))))))"
" l_1)"
" #f))"
" l_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'current-library-collection-links"
"(string-append"
"                 \"(listof (or/c #f\\n\""
"                 \"              (and/c path-string? complete-path?)\\n\""
"                 \"              (hash/c (or/c (and/c symbol? module-path?) #f)\\n\""
"                 \"                      (listof (and/c path-string? complete-path?)))))\")"
" l_0)))"
"(map2"
"(lambda(p_0)"
"(if(not p_0)"
"(let-values() #f)"
"(if(path? p_0)"
"(let-values() p_0)"
"(if(string? p_0)"
"(let-values()(string->path p_0))"
"(let-values()"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0) p_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" k_0"
"(to-path v_0)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0))))))))))"
" l_0)))"
" 'current-library-collection-links))))"
"(define-values"
"(1/use-compiled-file-paths)"
"(let-values()"
"(let-values()"
"(make-parameter"
"       (list (string->path \"compiled\"))"
"(lambda(l_0)"
"(begin"
"(if((lambda(l_1)(if(list? l_1)(andmap2 relative-path-string?$1 l_1) #f)) l_0)"
"(void)"
"(let-values()"
"               (raise-argument-error 'use-compiled-file-paths \"(listof (and/c path-string? relative-path?))\" l_0)))"
"(map2 to-path l_0)))"
" 'use-compiled-file-paths))))"
"(define-values"
"(1/current-compiled-file-roots)"
"(let-values()"
"(let-values()"
"(make-parameter"
" '(same)"
"(lambda(l_0)"
"(begin"
"(if((lambda(l_1)"
"(if(list? l_1)"
"(andmap2"
"(lambda(p_0)"
"(let-values(((or-part_0)(path-string? p_0)))(if or-part_0 or-part_0(eq? p_0 'same))))"
" l_1)"
" #f))"
" l_0)"
"(void)"
"(let-values()"
"               (raise-argument-error 'current-compiled-file-roots \"(listof (or/c path-string? 'same))\" l_0)))"
"(map2 to-path l_0)))"
" 'current-compiled-file-roots))))"
"(define-values"
"(1/use-compiled-file-check)"
"(let-values()"
"(let-values()"
"(make-parameter"
" 'modify-seconds"
"(lambda(v_0)"
"(begin"
"(if((lambda(v_1)"
"(let-values(((or-part_0)(eq? v_1 'modify-seconds)))(if or-part_0 or-part_0(eq? v_1 'exists))))"
" v_0)"
"(void)"
"             (let-values () (raise-argument-error 'use-compiled-file-check \"(or/c 'modify-seconds 'exists)\" v_0)))"
" v_0))"
" 'use-compiled-file-check))))"
"(define-values"
"(1/use-collection-link-paths)"
"(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'use-collection-link-paths))"
"(define-values"
"(1/use-user-specific-search-paths)"
"(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'use-user-specific-search-paths))"
"(define-values(complete-path-string?)(lambda(p_0)(begin(if(path-string? p_0)(complete-path? p_0) #f))))"
"(define-values"
"(relative-path-string?$1)"
"(lambda(p_0)(begin 'relative-path-string?(if(path-string? p_0)(relative-path? p_0) #f))))"
"(define-values(to-path)(lambda(p_0)(begin(if(string? p_0)(string->path p_0) p_0))))"
"(define-values"
"(eval$1)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((s_0)(begin 'eval((1/current-eval)(intro s_0))))"
"((s_0 ns_0)"
"(begin"
"          (if (1/namespace? ns_0) (void) (let-values () (raise-argument-error 'eval \"namespace?\" ns_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace ns_0)"
"(let-values()((1/current-eval)(intro s_0 ns_0))))))))))"
"(define-values"
"(1/eval-syntax)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((s_0)"
"(begin"
" 'eval-syntax"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'eval-syntax \"syntax?\" s_0)))"
"((1/current-eval) s_0))))"
"((s_0 ns_0)"
"(begin"
"          (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'eval-syntax \"syntax?\" s_0)))"
"          (if (1/namespace? ns_0) (void) (let-values () (raise-argument-error 'eval-syntax \"namespace?\" ns_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace ns_0)"
"(let-values()((1/current-eval) s_0)))))))))"
"(define-values(compile$1)(lambda(s_0)(begin 'compile((1/current-compile)(intro s_0) #f))))"
"(define-values"
"(1/compile-syntax)"
"(lambda(s_0)"
"(begin"
" 'compile-syntax"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'compile-syntax \"syntax?\" s_0)))"
"((1/current-compile) s_0 #f)))))))"
"(define-values"
"(1/expand)"
"(let-values(((expand_0)"
"(lambda(s2_0 insp1_0)"
"(begin"
" 'expand"
"(let-values(((s_0) s2_0))"
"(let-values(((insp_0)(if(eq? insp1_0 unsafe-undefined)(current-code-inspector) insp1_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(inspector? insp_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand \"inspector?\" insp_0)))"
"(maybe-taint-expanded insp_0(expand$1(intro s_0)(1/current-namespace) #t))))))))))))"
"(case-lambda((s_0)(begin 'expand(expand_0 s_0 unsafe-undefined)))((s_0 insp1_0)(expand_0 s_0 insp1_0)))))"
"(define-values"
"(1/expand-syntax)"
"(let-values(((expand-syntax_0)"
"(lambda(s4_0 insp3_0)"
"(begin"
" 'expand-syntax"
"(let-values(((s_0) s4_0))"
"(let-values(((insp_0)(if(eq? insp3_0 unsafe-undefined)(current-code-inspector) insp3_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand-syntax \"syntax?\" s_0)))"
"(if(inspector? insp_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand-syntax \"inspector?\" insp_0)))"
"(maybe-taint-expanded insp_0(expand$1 s_0(1/current-namespace) #t))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand-syntax(expand-syntax_0 s_0 unsafe-undefined)))"
"((s_0 insp3_0)(expand-syntax_0 s_0 insp3_0)))))"
"(define-values"
"(1/expand-once)"
"(let-values(((expand-once_0)"
"(lambda(s6_0 insp5_0)"
"(begin"
" 'expand-once"
"(let-values(((s_0) s6_0))"
"(let-values(((insp_0)(if(eq? insp5_0 unsafe-undefined)(current-code-inspector) insp5_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(inspector? insp_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand-once \"inspector?\" insp_0)))"
"(maybe-taint-expanded insp_0(expand-once$1(intro s_0)))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand-once(expand-once_0 s_0 unsafe-undefined)))"
"((s_0 insp5_0)(expand-once_0 s_0 insp5_0)))))"
"(define-values"
"(1/expand-syntax-once)"
"(let-values(((expand-syntax-once_0)"
"(lambda(s8_0 insp7_0)"
"(begin"
" 'expand-syntax-once"
"(let-values(((s_0) s8_0))"
"(let-values(((insp_0)(if(eq? insp7_0 unsafe-undefined)(current-code-inspector) insp7_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand-syntax-once \"syntax?\" s_0)))"
"(if(inspector? insp_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand-syntax-once \"inspector?\" insp_0)))"
"(maybe-taint-expanded insp_0(expand-once$1 s_0))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand-syntax-once(expand-syntax-once_0 s_0 unsafe-undefined)))"
"((s_0 insp7_0)(expand-syntax-once_0 s_0 insp7_0)))))"
"(define-values"
"(1/expand-to-top-form)"
"(let-values(((expand-to-top-form_0)"
"(lambda(s10_0 insp9_0)"
"(begin"
" 'expand-to-top-form"
"(let-values(((s_0) s10_0))"
"(let-values(((insp_0)(if(eq? insp9_0 unsafe-undefined)(current-code-inspector) insp9_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(inspector? insp_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand-to-top-form \"inspector?\" insp_0)))"
"(maybe-taint-expanded insp_0(expand-to-top-form$1(intro s_0)))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand-to-top-form(expand-to-top-form_0 s_0 unsafe-undefined)))"
"((s_0 insp9_0)(expand-to-top-form_0 s_0 insp9_0)))))"
"(define-values"
"(1/expand-syntax-to-top-form)"
"(let-values(((expand-syntax-to-top-form_0)"
"(lambda(s12_0 insp11_0)"
"(begin"
" 'expand-syntax-to-top-form"
"(let-values(((s_0) s12_0))"
"(let-values(((insp_0)(if(eq? insp11_0 unsafe-undefined)(current-code-inspector) insp11_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand-syntax-to-top-form \"syntax?\" s_0)))"
"(if(inspector? insp_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'expand-syntax-to-top-form \"inspector?\" insp_0)))"
"(maybe-taint-expanded insp_0(expand-to-top-form$1 s_0))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand-syntax-to-top-form(expand-syntax-to-top-form_0 s_0 unsafe-undefined)))"
"((s_0 insp11_0)(expand-syntax-to-top-form_0 s_0 insp11_0)))))"
"(define-values"
"(intro)"
"(let-values(((intro_0)"
"(lambda(given-s14_0 ns13_0)"
"(begin"
" 'intro"
"(let-values(((given-s_0) given-s14_0))"
"(let-values(((ns_0)(if(eq? ns13_0 unsafe-undefined)(1/current-namespace) ns13_0)))"
"(let-values()"
"(let-values(((s_0)(if(syntax?$1 given-s_0) given-s_0(1/datum->syntax #f given-s_0))))"
"(1/namespace-syntax-introduce s_0 ns_0)))))))))"
"(case-lambda"
"((given-s_0)(begin(intro_0 given-s_0 unsafe-undefined)))"
"((given-s_0 ns13_0)(intro_0 given-s_0 ns13_0)))))"
"(define-values"
"(maybe-taint-expanded)"
"(lambda(insp_0 s_0)(begin(if(eq? insp_0 initial-code-inspector) s_0(syntax-taint$1 s_0)))))"
"(define-values"
"(do-dynamic-require)"
"(let-values(((do-dynamic-require_0)"
"(lambda(who3_0 mod-path4_0 sym5_0 fail-k1_0 syntax-k2_0)"
"(begin"
" 'do-dynamic-require"
"(let-values(((who_0) who3_0))"
"(let-values(((mod-path_0) mod-path4_0))"
"(let-values(((sym_0) sym5_0))"
"(let-values(((fail-k_0) fail-k1_0))"
"(let-values(((syntax-k_0) syntax-k2_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(1/module-path? mod-path_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/module-path-index? mod-path_0)))"
"(if or-part_1"
" or-part_1"
"(1/resolved-module-path? mod-path_0)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                     \"(or/c module-path? module-path-index? resolved-module-path?)\""
" mod-path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(symbol? sym_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(not sym_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(equal? sym_0 0)))"
"(if or-part_2 or-part_2(void? sym_0)))))))"
"(void)"
"(let-values()"
"                                                      (raise-argument-error who_0 \"(or/c symbol? #f 0 void?)\" sym_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(eq? fail-k_0 'error)))"
"(if or-part_0"
" or-part_0"
"(if(procedure? fail-k_0)"
"(procedure-arity-includes? fail-k_0 0)"
" #f)))"
"(void)"
"(let-values()"
"                                                        (raise-argument-error who_0 \"(or/c 'error (-> any))\" fail-k_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(eq? syntax-k_0 'eval)))"
"(if or-part_0"
" or-part_0"
"(if(procedure? syntax-k_0)"
"(procedure-arity-includes? syntax-k_0 0)"
" #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                           \"(or/c 'eval (-> any))\""
" syntax-k_0)))"
"(values))))"
"(let-values(((ns_0)(1/current-namespace)))"
"(let-values(((mpi_0)"
"(if(1/module-path? mod-path_0)"
"(let-values()(1/module-path-index-join mod-path_0 #f))"
"(if(1/module-path-index? mod-path_0)"
"(let-values() mod-path_0)"
"(let-values()"
"(1/module-path-index-join"
"(resolved-module-path->module-path mod-path_0)"
" #f))))))"
"(let-values(((mod-name_0)(1/module-path-index-resolve mpi_0 #t)))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"(if(not sym_0)"
"(let-values()"
"(let-values(((ns14_0) ns_0)"
"((mpi15_0) mpi_0)"
"((phase16_0) phase_0)"
"((phase17_0) phase_0)"
"((temp18_0) #f))"
"(namespace-module-instantiate!.1"
" #f"
" temp18_0"
" #t"
" phase17_0"
" '#hasheq()"
" null"
" #f"
" #f"
" ns14_0"
" mpi15_0"
" phase16_0)))"
"(if(equal? sym_0 0)"
"(let-values()"
"(let-values(((ns19_0) ns_0)"
"((mpi20_0) mpi_0)"
"((phase21_0) phase_0)"
"((phase22_0) phase_0))"
"(namespace-module-instantiate!.1"
" #f"
" #t"
" #t"
" phase22_0"
" '#hasheq()"
" null"
" #f"
" #f"
" ns19_0"
" mpi20_0"
" phase21_0)))"
"(if(void? sym_0)"
"(let-values()"
"(begin"
"(namespace-visit-available-modules! ns_0 phase_0)"
"(let-values(((ns23_0) ns_0)"
"((mpi24_0) mpi_0)"
"((phase25_0) phase_0)"
"((phase26_0) phase_0))"
"(namespace-module-visit!.1"
" #f"
" phase26_0"
" ns23_0"
" mpi24_0"
" phase25_0))))"
"(let-values()"
"(let-values(((m_0)(namespace->module ns_0 mod-name_0)))"
"(let-values((()"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-unknown-module-error"
" 'dynamic-require"
" mod-name_0)))"
"(values))))"
"(let-values(((binding/p_0)"
"(hash-ref"
"(hash-ref(module-provides m_0) 0 '#hasheq())"
" sym_0"
" #f)))"
"(if(not binding/p_0)"
"(let-values()"
"(if(eq? fail-k_0 'error)"
"(raise-arguments-error"
" 'dynamic-require"
"                                                                     \"name is not provided\""
"                                                                     \"name\""
" sym_0"
"                                                                     \"module\""
" mod-name_0)"
"(fail-k_0)))"
"(let-values()"
"(let-values(((binding_0)"
"(provided-as-binding binding/p_0)))"
"(let-values(((ex-sym_0)"
"(module-binding-sym binding_0)))"
"(let-values(((ex-phase_0)"
"(module-binding-phase binding_0)))"
"(let-values((()"
"(begin"
"(let-values(((ns27_0) ns_0)"
"((mpi28_0) mpi_0)"
"((phase29_0)"
" phase_0)"
"((phase30_0)"
" phase_0)"
"((temp31_0) #f))"
"(namespace-module-instantiate!.1"
" #f"
" temp31_0"
" #t"
" phase30_0"
" '#hasheq()"
" null"
" #f"
" #f"
" ns27_0"
" mpi28_0"
" phase29_0))"
"(values))))"
"(let-values(((ex-mod-name_0)"
"(1/module-path-index-resolve"
"(module-path-index-shift"
"(module-binding-module"
" binding_0)"
"(module-self m_0)"
" mpi_0))))"
"(let-values(((m-ns_0)"
"(let-values(((ns32_0) ns_0)"
"((ex-mod-name33_0)"
" ex-mod-name_0)"
"((temp34_0)"
"(phase-"
" phase_0"
" ex-phase_0))"
"((temp35_0) #t))"
"(namespace->module-namespace.1"
" #f"
" temp35_0"
" void"
" ns32_0"
" ex-mod-name33_0"
" temp34_0))))"
"(let-values(((ex-m_0)"
"(namespace->module"
" ns_0"
" ex-mod-name_0)))"
"(let-values(((access_0)"
"(let-values(((or-part_0)"
"(module-access"
" ex-m_0)))"
"(if or-part_0"
" or-part_0"
"(module-compute-access!"
" ex-m_0)))))"
"(let-values((()"
"(begin"
"(if(if(not"
"(eq?"
" 'provided"
"(hash-ref"
"(hash-ref"
" access_0"
" ex-phase_0"
" '#hasheq())"
" ex-sym_0"
" #f)))"
"(if(not"
"(inspector-superior?"
"(current-code-inspector)"
"(namespace-inspector"
" m-ns_0)))"
"(not"
"(if(module-binding-extra-inspector"
" binding_0)"
"(inspector-superior?"
"(module-binding-extra-inspector"
" binding_0)"
"(namespace-inspector"
" m-ns_0))"
" #f))"
" #f)"
" #f)"
"(let-values()"
"(raise-arguments-error"
" 'dynamic-require"
"                                                                                                       \"name is protected\""
"                                                                                                       \"name\""
" sym_0"
"                                                                                                       \"module\""
" mod-name_0))"
"(void))"
"(values))))"
"(let-values(((fail_0)"
"(lambda()"
"(begin"
" 'fail"
"(if(eq?"
" fail-k_0"
" 'error)"
"(raise-arguments-error"
" 'dynamic-require"
"                                                                                                         \"name's binding is missing\""
"                                                                                                         \"name\""
" sym_0"
"                                                                                                         \"module\""
" mod-name_0)"
"(fail-k_0))))))"
"(if(not"
"(provided-as-transformer?"
" binding/p_0))"
"(let-values()"
"(namespace-get-variable"
" m-ns_0"
" ex-phase_0"
" ex-sym_0"
" fail_0))"
"(if(not(eq? syntax-k_0 'eval))"
"(let-values()(syntax-k_0))"
"(let-values()"
"(let-values(((missing_0)"
"(gensym"
" 'missing)))"
"(let-values((()"
"(begin"
"(let-values(((ns36_0)"
" ns_0)"
"((mpi37_0)"
" mpi_0)"
"((phase38_0)"
" phase_0)"
"((phase39_0)"
" phase_0))"
"(namespace-module-visit!.1"
" #f"
" phase39_0"
" ns36_0"
" mpi37_0"
" phase38_0))"
"(values))))"
"(let-values(((t_0)"
"(namespace-get-transformer"
" m-ns_0"
" ex-phase_0"
" ex-sym_0"
" missing_0)))"
"(if(eq?"
" t_0"
" missing_0)"
"(let-values()"
"(fail_0))"
"(let-values()"
"(let-values(((tmp-ns_0)"
"(let-values(((ns40_0)"
" ns_0))"
"(new-namespace.1"
" #t"
" unsafe-undefined"
" ns40_0))))"
"(let-values(((mod-path_1)"
"(resolved-module-path->module-path"
" mod-name_0)))"
"(begin"
"(1/namespace-require"
" mod-path_1"
" tmp-ns_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" tmp-ns_0)"
"(let-values()"
"(1/eval"
" sym_0"
" tmp-ns_0)))))))))))))))))))))))))))))))))))))))))))))))))))"
"(case-lambda"
"((who_0 mod-path_0 sym_0)(begin(do-dynamic-require_0 who_0 mod-path_0 sym_0 'error 'eval)))"
"((who_0 mod-path_0 sym_0 fail-k_0 syntax-k2_0)(do-dynamic-require_0 who_0 mod-path_0 sym_0 fail-k_0 syntax-k2_0))"
"((who_0 mod-path_0 sym_0 fail-k1_0)(do-dynamic-require_0 who_0 mod-path_0 sym_0 fail-k1_0 'eval)))))"
"(define-values"
"(1/dynamic-require)"
"(let-values(((dynamic-require_0)"
"(lambda(mod-path8_0 sym9_0 fail-k6_0 syntax-k7_0)"
"(begin"
" 'dynamic-require"
"(let-values(((mod-path_0) mod-path8_0))"
"(let-values(((sym_0) sym9_0))"
"(let-values(((fail-k_0) fail-k6_0))"
"(let-values(((syntax-k_0) syntax-k7_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(do-dynamic-require 'dynamic-require mod-path_0 sym_0 fail-k_0 syntax-k_0))))))))))))"
"(case-lambda"
"((mod-path_0 sym_0)(begin 'dynamic-require(dynamic-require_0 mod-path_0 sym_0 'error 'eval)))"
"((mod-path_0 sym_0 fail-k_0 syntax-k7_0)(dynamic-require_0 mod-path_0 sym_0 fail-k_0 syntax-k7_0))"
"((mod-path_0 sym_0 fail-k6_0)(dynamic-require_0 mod-path_0 sym_0 fail-k6_0 'eval)))))"
"(define-values"
"(1/dynamic-require-for-syntax)"
"(let-values(((dynamic-require-for-syntax_0)"
"(lambda(mod-path12_0 sym13_0 fail-k10_0 syntax-k11_0)"
"(begin"
" 'dynamic-require-for-syntax"
"(let-values(((mod-path_0) mod-path12_0))"
"(let-values(((sym_0) sym13_0))"
"(let-values(((fail-k_0) fail-k10_0))"
"(let-values(((syntax-k_0) syntax-k11_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
"(let-values(((ns_0)(1/current-namespace)))"
"(namespace->namespace-at-phase ns_0(add1(namespace-phase ns_0)))))"
"(let-values()"
"(do-dynamic-require"
" 'dynamic-require-for-syntax"
" mod-path_0"
" sym_0"
" fail-k_0"
" syntax-k_0))))))))))))))"
"(case-lambda"
"((mod-path_0 sym_0)"
"(begin 'dynamic-require-for-syntax(dynamic-require-for-syntax_0 mod-path_0 sym_0 'error 'eval)))"
"((mod-path_0 sym_0 fail-k_0 syntax-k11_0)(dynamic-require-for-syntax_0 mod-path_0 sym_0 fail-k_0 syntax-k11_0))"
"((mod-path_0 sym_0 fail-k10_0)(dynamic-require-for-syntax_0 mod-path_0 sym_0 fail-k10_0 'eval)))))"
"(define-values"
"(1/load)"
"(lambda(s_0)"
"(begin"
" 'load"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"                          (if (path-string? s_0) (void) (let-values () (raise-argument-error 'load \"path-string?\" s_0)))"
"(values))))"
"(let-values(((p_0)(->path s_0)))"
"(call-with-current-load-relative-directory p_0(lambda()((1/current-load) p_0 #f))))))))))"
"(define-values"
"(1/load-extension)"
"(lambda(s_0)"
"(begin"
" 'load-extension"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(path-string? s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'load-extension \"path-string?\" s_0)))"
"(values))))"
"(let-values(((p_0)(->path s_0)))"
"(call-with-current-load-relative-directory p_0(lambda()((current-load-extension) p_0 #f))))))))))"
"(define-values"
"(call-with-current-load-relative-directory)"
"(lambda(p_0 thunk_0)"
"(begin"
"(let-values(((base_0 name_0 dir?_0)(split-path p_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-load-relative-directory"
"(if(eq? base_0 'relative)(current-directory)(path->complete-path base_0)))"
"(let-values()(thunk_0)))))))"
"(define-values"
"(1/load/use-compiled)"
"(lambda(f_0)"
"(begin"
" 'load/use-compiled"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(path-string? f_0)"
"(void)"
"                            (let-values () (raise-argument-error 'load/use-compiled \"path-string?\" f_0)))"
"(values))))"
"(let-values(((p_0)(->path f_0)))((1/current-load/use-compiled) p_0 #f))))))))"
"(define-values"
"(embedded-load)"
"(let-values(((embedded-load_0)"
"(lambda(start2_0 end3_0 bstr4_0 as-predefined?5_0 in-path1_0)"
"(begin"
" 'embedded-load"
"(let-values(((start_0) start2_0))"
"(let-values(((end_0) end3_0))"
"(let-values(((bstr_0) bstr4_0))"
"(let-values(((as-predefined?_0) as-predefined?5_0))"
"(let-values(((in-path_0) in-path1_0))"
"(let-values()"
"(let-values(((s_0)"
"(if bstr_0"
" bstr_0"
"(let-values(((path_0)"
"(if(bytes? in-path_0)"
"(let-values()(bytes->path in-path_0))"
"(if(string? in-path_0)"
"(let-values() in-path_0)"
"(let-values()"
"(find-executable-path"
"(find-system-path 'exec-file)"
" #f))))))"
"(let-values(((start_1)"
"(if(string? start_0)"
"(let-values(((or-part_0)(1/string->number start_0)))"
"(if or-part_0 or-part_0 0))"
" start_0)))"
"(let-values(((end_1)"
"(if(string? end_0)"
"(let-values(((or-part_0)(1/string->number end_0)))"
"(if or-part_0 or-part_0 0))"
"(let-values(((or-part_0) end_0))"
"(if or-part_0 or-part_0(file-size path_0))))))"
"(let-values(((path9_0) path_0)"
"((temp10_0)"
"(lambda()"
"(begin"
"(file-position(current-input-port) start_1)"
"(read-bytes(max 0(- end_1 start_1)))))))"
"(with-input-from-file.1 'binary path9_0 temp10_0))))))))"
"(let-values(((p_0)(open-input-bytes s_0)))"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((e_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/read-accept-compiled"
" #t"
" 1/read-accept-reader"
" #t"
" 1/read-accept-lang"
" #t"
" read-on-demand-source"
" #t)"
"(let-values()(1/read p_0)))))"
"(if(eof-object? e_0)"
"(void)"
"(let-values()"
"(begin"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" current-module-declare-as-predefined"
" as-predefined?_0)"
"(let-values()((1/current-eval) e_0)))"
"(loop_0)))))))))"
" loop_0))))))))))))))"
"(case-lambda"
"((start_0 end_0 bstr_0 as-predefined?_0)(begin(embedded-load_0 start_0 end_0 bstr_0 as-predefined?_0 #f)))"
"((start_0 end_0 bstr_0 as-predefined?_0 in-path1_0)"
"(embedded-load_0 start_0 end_0 bstr_0 as-predefined?_0 in-path1_0)))))"
"(define-values(->path)(lambda(s_0)(begin(if(string? s_0)(string->path s_0) s_0))))"
"(define-values"
"(find-main-collects)"
"(lambda()"
"(begin(cache-configuration 0(lambda()(exe-relative-path->complete-path(find-system-path 'collects-dir)))))))"
"(define-values"
"(find-main-config)"
"(lambda()"
"(begin(cache-configuration 1(lambda()(exe-relative-path->complete-path(find-system-path 'config-dir)))))))"
"(define-values"
"(exe-relative-path->complete-path)"
"(lambda(collects-path_0)"
"(begin"
"(if(complete-path? collects-path_0)"
"(let-values()(simplify-path collects-path_0))"
"(if(absolute-path? collects-path_0)"
"(let-values()"
"(let-values(((exec_0)"
"(call-in-original-directory"
"(lambda()"
"(path->complete-path"
"(find-executable-path(find-system-path 'exec-file))"
"(find-system-path 'orig-dir))))))"
"(let-values(((base_0 name_0 dir?_0)(split-path exec_0)))"
"(simplify-path(path->complete-path collects-path_0 base_0)))))"
"(let-values()"
"(let-values(((p_0)"
"(call-in-original-directory"
"(lambda()(find-executable-path(find-system-path 'exec-file) collects-path_0 #t)))))"
"(if p_0(simplify-path p_0) #f))))))))"
"(define-values"
"(call-in-original-directory)"
"(lambda(thunk_0)"
"(begin"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-directory"
"(find-system-path 'orig-dir))"
"(thunk_0)))))"
"(define-values"
"(encoded-link-path?)"
"(lambda(p_0)"
"(begin"
"(let-values(((or-part_0)(path-string? p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(path-bytes? p_0)))"
"(if or-part_1"
" or-part_1"
"(if(pair? p_0)(if(list? p_0)(andmap2 path-element-bytes/same/up? p_0) #f) #f))))))))"
"(define-values"
"(path-bytes?)"
"(lambda(p_0)"
"(begin"
"(if(bytes? p_0)"
"(if(positive?(bytes-length p_0))"
"(let-values(((result_0)(let-values(((result_0) #t)) result_0)))"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0) p_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-bytes vec_0)))"
"(values vec_0(unsafe-bytes-length vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((c_0)(unsafe-bytes-ref vec_0 pos_0)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()(not(eqv? c_0 0))))))"
"(values result_2))))"
"(if(if(not((lambda x_0(not result_2)) c_0))(not #f) #f)"
"(for-loop_0 result_2(unsafe-fx+ 1 pos_0))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" 0)))"
" #f)"
" #f))))"
"(define-values"
"(path-element-bytes/same/up?)"
"(lambda(p_0)"
"(begin"
"(let-values(((or-part_0)(eq? p_0 'up)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? p_0 'same)))"
"(if or-part_1"
" or-part_1"
"(if(path-bytes? p_0)"
"(let-values(((p_1)(bytes->path-element p_0(system-path-convention-type) #t)))"
"(if p_1(relative-path? p_1) #f))"
" #f))))))))"
"(define-values"
"(decode-link-path)"
"(lambda(p_0)"
"(begin"
"(if(path-string? p_0)"
"(let-values() p_0)"
"(if(bytes? p_0)"
"(let-values()(bytes->path p_0))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(path_0 p_1)"
"(begin"
" 'loop"
"(if(null? p_1)"
"(let-values() path_0)"
"(let-values()"
"(let-values(((elem_0)"
"(if(bytes?(car p_1))(bytes->path-element(car p_1))(car p_1))))"
"(loop_0(if path_0(build-path path_0 elem_0) elem_0)(cdr p_1)))))))))"
" loop_0)"
" #f"
" p_0)))))))"
"(define-values"
"(struct:shadow-directory shadow-directory1.1 shadow-directory? shadow-directory-evt shadow-directory-table)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'shadow-directory"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'shadow-directory)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'evt)"
"(make-struct-field-accessor -ref_0 1 'table))))"
"(define-values"
"(use-shadow-directory?)"
"(let-values(((v_0)(system-type 'fs-change)))"
"(if(eq? 'scalable(vector-ref v_0 1))(eq? 'low-latency(vector-ref v_0 2)) #f)))"
"(define-values(make-cache)(lambda()(begin(if use-shadow-directory?(make-weak-hash) #f))))"
"(define-values(cell.1$2)(unsafe-make-place-local(make-cache)))"
"(define-values(shadow-directory-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$2(make-cache)))))"
"(define-values"
"(lookup-shadow-directory)"
"(lambda(orig_0)"
"(begin"
"(let-values(((sd_0)(call-as-atomic(lambda()(hash-ref(unsafe-place-local-ref cell.1$2) orig_0 #f)))))"
"(if sd_0"
"(let-values()"
"(if(sync/timeout 0(shadow-directory-evt sd_0))"
"(let-values()"
"(begin"
"(call-as-atomic(lambda()(hash-remove!(unsafe-place-local-ref cell.1$2) orig_0)))"
"(lookup-shadow-directory orig_0)))"
"(let-values() sd_0)))"
"(let-values()"
"(let-values(((evt_0)(filesystem-change-evt orig_0(lambda() #f))))"
"(if evt_0"
"(let-values()"
"(let-values(((table_0)"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((lst_0)(directory-list orig_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((p_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(if(directory-exists?"
"(build-path orig_0 p_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(normal-case-path"
" p_0)"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))"
" table_1)))"
"(if(not #f)(for-loop_0 table_2 rest_0) table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0))))))"
"(let-values(((sd_1)(shadow-directory1.1 evt_0 table_0)))"
"(begin"
"(call-as-atomic(lambda()(hash-set!(unsafe-place-local-ref cell.1$2) orig_0 sd_1)))"
" sd_1))))"
"(let-values() #f)))))))))"
"(define-values"
"(directory-exists?/shadow-filesystem)"
"(lambda(p_0 orig_0 subpath_0)"
"(begin"
"(if(not(unsafe-place-local-ref cell.1$2))"
"(let-values()(directory-exists? p_0))"
"(let-values()"
"(let-values(((sd_0)(lookup-shadow-directory orig_0)))"
"(if(not sd_0)"
"(let-values()(directory-exists? p_0))"
"(if sd_0"
"(let-values()"
"(let-values(((ht_0)(shadow-directory-table sd_0)))(hash-ref ht_0(normal-case-path subpath_0) #f)))"
"(void)))))))))"
"(define-values(relative-path-string?)(lambda(s_0)(begin(if(path-string? s_0)(relative-path? s_0) #f))))"
"(define-values"
"(check-collection)"
"(lambda(who_0 s_0 l_0)"
"(begin"
"(begin"
"(if(relative-path-string? s_0)"
"(void)"
"          (let-values () (raise-argument-error who_0 \"(and/c path-string? relative-path?)\" s_0)))"
"(if((lambda(l_1)(if(list? l_1)(andmap2 relative-path-string? l_1) #f)) l_0)"
"(void)"
"          (let-values () (raise-argument-error who_0 \"(listof (and/c path-string? relative-path?))\" l_0)))))))"
"(define-values"
"(check-fail)"
"(lambda(who_0 fail_0)"
"(begin"
"(if((lambda(p_0)(if(procedure? p_0)(procedure-arity-includes? p_0 1) #f)) fail_0)"
"(void)"
"        (let-values () (raise-argument-error who_0 \"(procedure-arity-includes/c 1)\" fail_0))))))"
"(define-values"
"(1/collection-path)"
"(lambda(fail_0 collection_0 collection-path_0)"
"(begin"
" 'collection-path"
"(let-values()"
"(let-values()"
"(begin"
"(check-collection 'collection-path collection_0 collection-path_0)"
"(check-fail 'collection-path fail_0)"
"(find-col-file fail_0 collection_0 collection-path_0 #f #f)))))))"
"(define-values"
"(1/collection-file-path)"
"(lambda(fail_0 check-compiled?_0 file-name_0 collection_0 collection-path_0)"
"(begin"
" 'collection-file-path"
"(let-values()"
"(let-values()"
"(begin"
"(if(relative-path-string? file-name_0)"
"(void)"
"(let-values()"
"                (raise-argument-error 'collection-file-path \"(and/c path-string? relative-path?)\" file-name_0)))"
"(check-collection 'collection-file-path collection_0 collection-path_0)"
"(check-fail 'collection-file-path fail_0)"
"(find-col-file fail_0 collection_0 collection-path_0 file-name_0 check-compiled?_0)))))))"
"(define-values"
"(1/read-installation-configuration-table)"
"(lambda()"
"(begin"
" 'read-installation-configuration-table"
"(let-values(((d_0)(find-main-config)))"
"        (let-values (((p_0) (if d_0 (build-path d_0 \"config.rktd\") #f)))"
"(let-values(((or-part_0)"
"(if p_0"
"(if(file-exists? p_0)"
"(let-values(((with-handlers-predicate11_0) exn:fail?)"
"((with-handlers-handler12_0)"
"(lambda(exn_0)(begin 'with-handlers-handler12 '#hash()))))"
"(let-values(((bpz_0)(continuation-mark-set-first #f break-enabled-key)))"
"(call-handled-body"
" bpz_0"
"(lambda(e_0)"
"(select-handler/no-breaks"
" e_0"
" bpz_0"
"(list(cons with-handlers-predicate11_0 with-handlers-handler12_0))))"
"(lambda()"
"(let-values(((p13_0) p_0)"
"((temp14_0)"
"(lambda()"
"(let-values(((v_0)"
"(call-with-default-reading-parameterization 1/read)))"
"(if(hash? v_0) v_0 #f)))))"
"(with-input-from-file.1 'binary p13_0 temp14_0))))))"
" #f)"
" #f)))"
"(if or-part_0 or-part_0 '#hash())))))))"
"(define-values"
"(get-installation-name)"
"(let-values(((get-installation-name_0)"
"(lambda(config-table1_0)"
"(begin"
" 'get-installation-name"
"(let-values(((config-table_0)"
"(if(eq? config-table1_0 unsafe-undefined)"
"(1/read-installation-configuration-table)"
" config-table1_0)))"
"(let-values()"
"(begin"
"(if(hash? config-table_0)"
"(void)"
"                            (let-values () (raise-argument-error 'get-installation-name \"hash?\" config-table_0)))"
"(let-values(((base-name_0)(hash-ref config-table_0 'installation-name(version))))"
"(if(not(1/use-user-specific-search-paths))"
"(let-values() base-name_0)"
"(let-values()"
"(let-values(((addon-dir_0)(find-system-path 'addon-dir)))"
"                                  (let-values (((other-version-name_0) \"other-version\"))"
"(if(directory-exists?(build-path addon-dir_0 base-name_0))"
"(let-values() base-name_0)"
"(if(directory-exists?(build-path addon-dir_0 other-version-name_0))"
"(let-values() other-version-name_0)"
"(let-values() base-name_0)))))))))))))))"
"(case-lambda"
"(()(begin(get-installation-name_0 unsafe-undefined)))"
"((config-table1_0)(get-installation-name_0 config-table1_0)))))"
"(define-values"
"(coerce-to-relative-path)"
"(lambda(p_0)"
"(begin"
"(if(string? p_0)"
"(let-values()(string->path p_0))"
"(if(bytes? p_0)(let-values()(bytes->path p_0))(let-values() p_0))))))"
"(define-values"
"(coerce-to-path)"
"(lambda(p_0)"
"(begin"
"(if(string? p_0)"
"(let-values()(collects-relative-path->complete-path(string->path p_0)))"
"(if(bytes? p_0)"
"(let-values()(collects-relative-path->complete-path(bytes->path p_0)))"
"(if(path? p_0)(let-values()(collects-relative-path->complete-path p_0))(let-values() p_0)))))))"
"(define-values"
"(collects-relative-path->complete-path)"
"(lambda(p_0)"
"(begin"
"(if(complete-path? p_0)"
"(let-values() p_0)"
"(let-values()"
"(path->complete-path"
" p_0"
"(let-values(((or-part_0)(find-main-collects)))(if or-part_0 or-part_0(current-directory)))))))))"
"(define-values"
"(add-config-search)"
"(lambda(ht_0 key_0 orig-l_0)"
"(begin"
"(let-values(((l_0)(hash-ref ht_0 key_0 #f)))"
"(if l_0"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values() null)"
"(if(not(car l_1))"
"(let-values()(append orig-l_0(loop_0(cdr l_1))))"
"(let-values()(cons(coerce-to-path(car l_1))(loop_0(cdr l_1))))))))))"
" loop_0)"
" l_0)"
" orig-l_0)))))"
"(define-values"
"(1/find-library-collection-links)"
"(let-values(((find-library-collection-links_0)"
"(lambda(config-table2_0 installation-name3_0)"
"(begin"
" 'find-library-collection-links"
"(let-values(((config-table_0)"
"(if(eq? config-table2_0 unsafe-undefined)"
"(1/read-installation-configuration-table)"
" config-table2_0)))"
"(let-values(((installation-name_0)"
"(if(eq? installation-name3_0 unsafe-undefined)"
"(if(hash? config-table_0)(get-installation-name config-table_0) #f)"
" installation-name3_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(hash? config-table_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'find-library-collection-links"
"                                               \"hash?\""
" config-table_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(string? installation-name_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'find-library-collection-links"
"                                                 \"string?\""
" installation-name_0)))"
"(values))))"
"(let-values(((lf_0)"
"(coerce-to-path"
"(let-values(((or-part_0)(hash-ref config-table_0 'links-file #f)))"
"(if or-part_0"
" or-part_0"
"(build-path"
"(let-values(((or-part_1)(hash-ref config-table_0 'share-dir #f)))"
"                                                    (if or-part_1 or-part_1 (build-path 'up \"share\")))"
"                                                  \"links.rktd\"))))))"
"(append"
"(list #f)"
"(if(if(1/use-user-specific-search-paths)(1/use-collection-link-paths) #f)"
"                                   (list (build-path (find-system-path 'addon-dir) installation-name_0 \"links.rktd\"))"
" null)"
"(if(1/use-collection-link-paths)"
"(add-config-search config-table_0 'links-search-files(list lf_0))"
" null))))))))))))"
"(case-lambda"
"(()(begin 'find-library-collection-links(find-library-collection-links_0 unsafe-undefined unsafe-undefined)))"
"((config-table_0 installation-name3_0)(find-library-collection-links_0 config-table_0 installation-name3_0))"
"((config-table2_0)(find-library-collection-links_0 config-table2_0 unsafe-undefined)))))"
"(define-values(cell.1$1)(unsafe-make-place-local(make-weak-hash)))"
"(define-values(collection-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$1(make-weak-hash)))))"
"(define-values(stamp-prompt-tag)(make-continuation-prompt-tag 'stamp))"
"(define-values"
"(file->stamp)"
"(lambda(path_0 old-stamp_0)"
"(begin"
"(if(if old-stamp_0(if(cdr old-stamp_0)(not(sync/timeout 0(cdr old-stamp_0))) #f) #f)"
"(let-values() old-stamp_0)"
"(let-values()"
"(call-with-continuation-prompt"
"(lambda()"
"(call-with-exception-handler"
"(lambda(exn_0)"
"(abort-current-continuation"
" stamp-prompt-tag"
"(if(exn:fail:filesystem? exn_0)(lambda() #f)(lambda()(raise exn_0)))))"
"(lambda()"
"(let-values(((dir-evt_0)"
"(if(vector-ref(system-type 'fs-change) 2)"
"((letrec-values(((loop_0)"
"(lambda(path_1)"
"(begin"
" 'loop"
"(let-values(((base_0 name_0 dir?_0)(split-path path_1)))"
"(if(path? base_0)"
"(if(directory-exists? base_0)"
"(filesystem-change-evt base_0(lambda() #f))"
"(loop_0 base_0))"
" #f))))))"
" loop_0)"
" path_0)"
" #f)))"
"(if(not(file-exists? path_0))"
"(let-values()(cons #f dir-evt_0))"
"(let-values()"
"(let-values(((evt_0)"
"(if(vector-ref(system-type 'fs-change) 2)"
"(filesystem-change-evt path_0(lambda() #f))"
" #f)))"
"(begin"
"(if dir-evt_0(let-values()(filesystem-change-evt-cancel dir-evt_0))(void))"
"(cons(file->bytes path_0) evt_0)))))))))"
" stamp-prompt-tag))))))"
"(define-values"
"(file->bytes)"
"(lambda(path_0)"
"(begin"
"(let-values(((path15_0) path_0)"
"((temp16_0)"
"(lambda(p_0)"
"(let-values(((bstr_0)(read-bytes 8192 p_0)))"
"(if(if(bytes? bstr_0)(>=(bytes-length bstr_0) 8192) #f)"
"(apply"
" bytes-append"
"(cons"
" bstr_0"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((bstr_1)(read-bytes 8192 p_0)))"
"(if(eof-object? bstr_1) null(cons bstr_1(loop_0))))))))"
" loop_0))))"
" bstr_0)))))"
"(call-with-input-file*.1 'binary path15_0 temp16_0)))))"
"(define-values"
"(no-file-stamp?)"
"(lambda(a_0)(begin(let-values(((or-part_0)(not a_0)))(if or-part_0 or-part_0(not(car a_0)))))))"
"(define-values"
"(get-linked-collections)"
"(lambda(links-path_0)"
"(begin"
"(call/ec"
"(lambda(esc_0)"
"(let-values(((make-handler_0)"
"(lambda(ts_0)"
"(begin"
" 'make-handler"
"(lambda(exn_0)"
"(begin"
"(if(exn:fail? exn_0)"
"(let-values(((l_0)(current-logger)))"
"(if(log-level? l_0 'error)"
"(let-values()"
"(log-message"
" l_0"
" 'error"
"(format"
"                                         \"error reading collection links file ~s: ~a\""
" links-path_0"
"(exn-message exn_0))"
"(current-continuation-marks)))"
"(void)))"
"(void))"
"(if ts_0"
"(let-values()"
"(call-as-atomic"
"(lambda()"
"(hash-set!"
"(unsafe-place-local-ref cell.1$1)"
" links-path_0"
"(cons ts_0 '#hasheq())))))"
"(void))"
"(if(exn:fail? exn_0)(esc_0(make-hasheq)) exn_0)))))))"
"(call-with-exception-handler"
"(make-handler_0 #f)"
"(lambda()"
"(let-values(((links-stamp+cache_0)"
"(call-as-atomic"
"(lambda()(hash-ref(unsafe-place-local-ref cell.1$1) links-path_0 '(#f . #hasheq()))))))"
"(let-values(((a-links-stamp_0)(car links-stamp+cache_0)))"
"(let-values(((ts_0)(file->stamp links-path_0 a-links-stamp_0)))"
"(if(equal? ts_0 a-links-stamp_0)"
"(let-values()(cdr links-stamp+cache_0))"
"(let-values()"
"(call-with-exception-handler"
"(make-handler_0 ts_0)"
"(lambda()"
"(call-with-default-reading-parameterization"
"(lambda()"
"(let-values(((v_0)"
"(if(no-file-stamp? ts_0)"
" null"
"(let-values(((links-path17_0) links-path_0)"
"((temp18_0)"
"(lambda(p_0)"
"(begin0"
"(1/read p_0)"
"(if(eof-object?(1/read p_0))"
"(void)"
"(let-values()"
"                                                                    (error \"expected a single S-expression\")))))))"
"(call-with-input-file*.1 'binary links-path17_0 temp18_0)))))"
"(let-values((()"
"(begin"
"(if(if(list? v_0)"
"(andmap2"
"(lambda(p_0)"
"(if(list? p_0)"
"(if(let-values(((or-part_0)(= 2(length p_0))))"
"(if or-part_0 or-part_0(= 3(length p_0))))"
"(if(let-values(((or-part_0)(string?(car p_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? 'root(car p_0))))"
"(if or-part_1"
" or-part_1"
"(eq? 'static-root(car p_0))))))"
"(if(encoded-link-path?(cadr p_0))"
"(let-values(((or-part_0)(null?(cddr p_0))))"
"(if or-part_0 or-part_0(regexp?(caddr p_0))))"
" #f)"
" #f)"
" #f)"
" #f))"
" v_0)"
" #f)"
"(void)"
"                                                  (let-values () (error \"ill-formed content\")))"
"(values))))"
"(let-values(((ht_0)(make-hasheq)))"
"(let-values(((dir_0)"
"(let-values(((base_0 name_0 dir?_0)(split-path links-path_0)))"
" base_0)))"
"(begin"
"(for-each2"
"(lambda(p_0)"
"(if(let-values(((or-part_0)(null?(cddr p_0))))"
"(if or-part_0 or-part_0(regexp-match?(caddr p_0)(version))))"
"(let-values()"
"(let-values(((dir_1)"
"(simplify-path"
"(path->complete-path"
"(decode-link-path(cadr p_0))"
" dir_0))))"
"(if(eq?(car p_0) 'static-root)"
"(let-values()"
"(for-each2"
"(lambda(sub_0)"
"(if(directory-exists?(build-path dir_1 sub_0))"
"(let-values()"
"(let-values(((k_0)(string->symbol(path->string sub_0))))"
"(hash-set!"
" ht_0"
" k_0"
"(cons dir_1(hash-ref ht_0 k_0 null)))))"
"(void)))"
"(directory-list dir_1)))"
"(if(eq?(car p_0) 'root)"
"(let-values()"
"(begin"
"(if(hash-ref ht_0 #f #f)"
"(void)"
"(let-values()(hash-set! ht_0 #f null)))"
"(hash-for-each"
" ht_0"
"(lambda(k_0 v_1)(hash-set! ht_0 k_0(cons dir_1 v_1))))))"
"(let-values()"
"(let-values(((s_0)(string->symbol(car p_0))))"
"(hash-set!"
" ht_0"
" s_0"
"(cons(box dir_1)(hash-ref ht_0 s_0 null)))))))))"
"(void)))"
" v_0)"
"(hash-for-each ht_0(lambda(k_0 v_1)(hash-set! ht_0 k_0(reverse$1 v_1))))"
"(call-as-atomic"
"(lambda()"
"(hash-set!(unsafe-place-local-ref cell.1$1) links-path_0(cons ts_0 ht_0))))"
" ht_0))))))))))))))))))))))"
"(define-values"
"(normalize-collection-reference)"
"(lambda(collection_0 collection-path_0)"
"(begin"
"(if(string? collection_0)"
"(let-values()"
"          (let-values (((m_0) (regexp-match-positions '#rx\"/+\" collection_0)))"
"(if m_0"
"(if(=(caar m_0)(sub1(string-length collection_0)))"
"(let-values()(values(substring collection_0 0(caar m_0)) collection-path_0))"
"(let-values()"
"(values"
"(substring collection_0 0(caar m_0))"
"(cons(substring collection_0(cdar m_0)) collection-path_0))))"
"(values collection_0 collection-path_0))))"
"(let-values()"
"(let-values(((base_0 name_0 dir?_0)(split-path collection_0)))"
"(if(eq? base_0 'relative)"
"(values name_0 collection-path_0)"
"(normalize-collection-reference base_0(cons name_0 collection-path_0)))))))))"
"(define-values"
"(find-col-file)"
"(lambda(fail_0 collection-in_0 collection-path-in_0 file-name_0 check-compiled?_0)"
"(begin"
"(let-values(((collection_0 collection-path_0)"
"(normalize-collection-reference collection-in_0 collection-path-in_0)))"
"(let-values(((all-paths_0)"
"(let-values(((sym_0)"
"(string->symbol"
"(if(path? collection_0)(path->string collection_0) collection_0))))"
"((letrec-values(((loop_0)"
"(lambda(l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
"(let-values() null)"
"(if(not(car l_0))"
"(let-values()"
"(append(1/current-library-collection-paths)(loop_0(cdr l_0))))"
"(if(hash?(car l_0))"
"(let-values()"
"(append"
"(map2 box(hash-ref(car l_0) sym_0 null))"
"(hash-ref(car l_0) #f null)"
"(loop_0(cdr l_0))))"
"(let-values()"
"(let-values(((ht_0)(get-linked-collections(car l_0))))"
"(append"
"(hash-ref ht_0 sym_0 null)"
"(hash-ref ht_0 #f null)"
"(loop_0(cdr l_0))))))))))))"
" loop_0)"
"(1/current-library-collection-links)))))"
"(let-values(((done_0)(lambda(p_0)(begin 'done(if file-name_0(build-path p_0 file-name_0) p_0)))))"
"(let-values(((*build-path-rep_0)"
"(lambda(p_0 c_0)"
"(begin '*build-path-rep(if(path? p_0)(build-path p_0 c_0)(unbox p_0))))))"
"(let-values(((*directory-exists?_0)"
"(lambda(orig_0 collection_1 p_0)"
"(begin"
" '*directory-exists?"
"(if(path? orig_0)(directory-exists?/shadow-filesystem p_0 orig_0 collection_1) #t)))))"
"(let-values(((to-string_0)(lambda(p_0)(begin 'to-string(if(path? p_0)(path->string p_0) p_0)))))"
"((letrec-values(((cloop_0)"
"(lambda(paths_0 found-col_0)"
"(begin"
" 'cloop"
"(if(null? paths_0)"
"(if found-col_0"
"(done_0 found-col_0)"
"(let-values(((rest-coll_0)"
"(if(null? collection-path_0)"
"                                                            \"\""
"(apply"
" string-append"
"((letrec-values(((loop_0)"
"(lambda(cp_0)"
"(begin"
" 'loop"
"(if(null?(cdr cp_0))"
"(list(to-string_0(car cp_0)))"
"(list*"
"(to-string_0(car cp_0))"
"                                                                                      \"/\""
"(loop_0(cdr cp_0))))))))"
" loop_0)"
" collection-path_0)))))"
"(letrec-values(((filter_0)"
"(lambda(f_0 l_0)"
"(begin"
" 'filter"
"(if(null? l_0)"
" null"
"(if(f_0(car l_0))"
"(cons(car l_0)(filter_0 f_0(cdr l_0)))"
"(filter_0 f_0(cdr l_0))))))))"
"(fail_0"
"(format"
"                                                  \"collection not found\\n  collection: ~s\\n  in collection directories:~a~a\""
"(if(null? collection-path_0)"
"(to-string_0 collection_0)"
"                                                    (string-append (to-string_0 collection_0) \"/\" rest-coll_0))"
"(apply"
" string-append"
"(map2"
"                                                    (lambda (p_0) (format \"\\n ~a ~a\" \" \" p_0))"
"(let-values(((len_0)(length all-paths_0))"
"((clen_0)"
"(length(1/current-library-collection-paths))))"
"(if(<(- len_0 clen_0) 5)"
" all-paths_0"
"(append"
"(1/current-library-collection-paths)"
"(list"
"(format"
"                                                           \"... [~a additional linked and package directories]\""
"(- len_0 clen_0))))))))"
"(if(ormap2 box? all-paths_0)"
"(format"
"                                                     \"\\n   sub-collection: ~s\\n  in parent directories:~a\""
" rest-coll_0"
"(apply"
" string-append"
"(map2"
"                                                       (lambda (p_0) (format \"\\n   ~a\" (unbox p_0)))"
"(filter_0 box? all-paths_0))))"
"                                                    \"\"))))))"
"(let-values(((dir_0)(*build-path-rep_0(car paths_0) collection_0)))"
"(if(*directory-exists?_0(car paths_0) collection_0 dir_0)"
"(let-values(((cpath_0)(apply build-path dir_0 collection-path_0)))"
"(if(if(null? collection-path_0) #t(directory-exists? cpath_0))"
"(if file-name_0"
"(if(let-values(((or-part_0)"
"(file-exists?/maybe-compiled"
" cpath_0"
" file-name_0"
" check-compiled?_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((alt-file-name_0)"
"(let-values(((file-name_1)"
"(if(path? file-name_0)"
"(path->string file-name_0)"
" file-name_0)))"
"(let-values(((len_0)"
"(string-length file-name_1)))"
"(if(>= len_0 4)"
"(if(string=?"
"                                                                                     \".rkt\""
"(substring"
" file-name_1"
"(- len_0 4)))"
"(string-append"
"(substring file-name_1 0(- len_0 4))"
"                                                                                   \".ss\")"
" #f)"
" #f)))))"
"(if alt-file-name_0"
"(file-exists?/maybe-compiled"
" cpath_0"
" alt-file-name_0"
" check-compiled?_0)"
" #f))))"
"(done_0 cpath_0)"
"(cloop_0"
"(cdr paths_0)"
"(let-values(((or-part_0) found-col_0))"
"(if or-part_0 or-part_0 cpath_0))))"
"(done_0 cpath_0))"
"(cloop_0(cdr paths_0) found-col_0)))"
"(cloop_0(cdr paths_0) found-col_0))))))))"
" cloop_0)"
" all-paths_0"
" #f))))))))))"
"(define-values"
"(file-exists?/maybe-compiled)"
"(lambda(dir_0 path_0 check-compiled?_0)"
"(begin"
"(let-values(((or-part_0)(file-exists?(build-path dir_0 path_0))))"
"(if or-part_0"
" or-part_0"
"(if check-compiled?_0"
"            (let-values (((try-path_0) (path-add-extension path_0 #\".zo\"))"
"((modes_0)(1/use-compiled-file-paths))"
"((roots_0)(1/current-compiled-file-roots)))"
"(ormap2"
"(lambda(d_0)"
"(ormap2"
"(lambda(mode_0)"
"(file-exists?"
"(let-values(((dir_1)"
"(if(eq? d_0 'same)"
"(let-values() dir_0)"
"(if(relative-path? d_0)"
"(let-values()(build-path dir_0 d_0))"
"(let-values()(reroot-path dir_0 d_0))))))"
"(build-path dir_1 mode_0 try-path_0))))"
" modes_0))"
" roots_0))"
" #f))))))"
"(define-values"
"(1/find-library-collection-paths)"
"(let-values(((find-library-collection-paths_0)"
"(lambda(extra-collects-dirs4_0 post-collects-dirs5_0 config-table6_0 installation-name7_0)"
"(begin"
" 'find-library-collection-paths"
"(let-values(((extra-collects-dirs_0) extra-collects-dirs4_0))"
"(let-values(((post-collects-dirs_0) post-collects-dirs5_0))"
"(let-values(((config-table_0)"
"(if(eq? config-table6_0 unsafe-undefined)"
"(1/read-installation-configuration-table)"
" config-table6_0)))"
"(let-values(((installation-name_0)"
"(if(eq? installation-name7_0 unsafe-undefined)"
"(if(hash? config-table_0)(get-installation-name config-table_0) #f)"
" installation-name7_0)))"
"(let-values()"
"(begin"
"(if(if(list? extra-collects-dirs_0)(andmap2 path-string? extra-collects-dirs_0) #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'find-library-collection-paths"
"                                     \"(listof path-string?)\""
" extra-collects-dirs_0)))"
"(if(if(list? post-collects-dirs_0)(andmap2 path-string? post-collects-dirs_0) #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'find-library-collection-paths"
"                                     \"(listof path-string?)\""
" post-collects-dirs_0)))"
"(if(hash? config-table_0)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'find-library-collection-paths \"hash?\" config-table_0)))"
"(if(string? installation-name_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'find-library-collection-paths"
"                                     \"string?\""
" installation-name_0)))"
"(let-values(((user-too?_0)(1/use-user-specific-search-paths))"
"((cons-if_0)"
"(lambda(f_0 r_0)(begin 'cons-if(if f_0(cons f_0 r_0) r_0)))))"
"(path-list-string->path-list"
"(if user-too?_0"
"(let-values(((c_0)"
"(environment-variables-ref"
"(current-environment-variables)"
"                                                    #\"PLTCOLLECTS\")))"
"                                       (if c_0 (bytes->string/locale c_0 '#\\?) \"\"))"
"                                     \"\")"
"(add-config-search"
" config-table_0"
" 'collects-search-dirs"
"(cons-if_0"
"(if user-too?_0"
"                                       (build-path (find-system-path 'addon-dir) installation-name_0 \"collects\")"
" #f)"
"((letrec-values(((loop_0)"
"(lambda(l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
" null"
"(let-values(((collects-path_0)(car l_0)))"
"(let-values(((v_0)"
"(exe-relative-path->complete-path"
" collects-path_0)))"
"(if v_0"
"(cons"
"(simplify-path"
"(path->complete-path v_0(current-directory)))"
"(loop_0(cdr l_0)))"
"(loop_0(cdr l_0))))))))))"
" loop_0)"
"(append"
" extra-collects-dirs_0"
"(list(find-system-path 'collects-dir))"
" post-collects-dirs_0))))))))))))))))"
"(case-lambda"
"(()"
"(begin"
" 'find-library-collection-paths"
"(find-library-collection-paths_0 null null unsafe-undefined unsafe-undefined)))"
"((extra-collects-dirs_0 post-collects-dirs_0 config-table_0 installation-name7_0)"
"(find-library-collection-paths_0 extra-collects-dirs_0 post-collects-dirs_0 config-table_0 installation-name7_0))"
"((extra-collects-dirs_0 post-collects-dirs_0 config-table6_0)"
"(find-library-collection-paths_0 extra-collects-dirs_0 post-collects-dirs_0 config-table6_0 unsafe-undefined))"
"((extra-collects-dirs_0 post-collects-dirs5_0)"
"(find-library-collection-paths_0 extra-collects-dirs_0 post-collects-dirs5_0 unsafe-undefined unsafe-undefined))"
"((extra-collects-dirs4_0)"
"(find-library-collection-paths_0 extra-collects-dirs4_0 null unsafe-undefined unsafe-undefined)))))"
"(define-values"
"(1/find-compiled-file-roots)"
"(let-values(((find-compiled-file-roots_0)"
"(lambda(ht8_0)"
"(begin"
" 'find-compiled-file-roots"
"(let-values(((ht_0)"
"(if(eq? ht8_0 unsafe-undefined)(1/read-installation-configuration-table) ht8_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(hash? ht_0)"
"(void)"
"                                          (let-values () (raise-argument-error 'find-compiled-file-roots \"hash?\" ht_0)))"
"(values))))"
"(let-values(((paths_0)(hash-ref ht_0 'compiled-file-roots #f)))"
"(let-values(((or-part_0)(if(list? paths_0)(map2 coerce-to-relative-path paths_0) #f)))"
"(if or-part_0 or-part_0(list 'same)))))))))))"
"(case-lambda"
"(()(begin 'find-compiled-file-roots(find-compiled-file-roots_0 unsafe-undefined)))"
"((ht8_0)(find-compiled-file-roots_0 ht8_0)))))"
"(define-values(prop:readtable prop:readtable? prop:readtable-ref)(make-struct-type-property 'readtable))"
"(define-values"
"(1/current-readtable)"
"(let-values()"
"(let-values()"
"(make-parameter"
" #f"
"(lambda(v_0)"
"(begin"
"(if((lambda(x_0)(let-values(((or-part_0)(not x_0)))(if or-part_0 or-part_0(prop:readtable? x_0))))"
" v_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-readtable \"(or/c prop:readtable? #f)\" v_0)))"
" v_0))"
" 'current-readtable))))"
"(define-values"
"(struct:read-config/outer"
" read-config/outer1.1"
" read-config/outer?"
" read-config/outer-inner"
" read-config/outer-wrap"
" read-config/outer-line"
" read-config/outer-col"
" read-config/outer-pos"
" read-config/outer-indentations"
" read-config/outer-keep-comment?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'read-config"
" #f"
" 7"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'read-config/outer)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'inner)"
"(make-struct-field-accessor -ref_0 1 'wrap)"
"(make-struct-field-accessor -ref_0 2 'line)"
"(make-struct-field-accessor -ref_0 3 'col)"
"(make-struct-field-accessor -ref_0 4 'pos)"
"(make-struct-field-accessor -ref_0 5 'indentations)"
"(make-struct-field-accessor -ref_0 6 'keep-comment?))))"
"(define-values"
"(struct:read-config/inner"
" read-config/inner2.1"
" read-config/inner?"
" read-config/inner-readtable"
" read-config/inner-next-readtable"
" read-config/inner-for-syntax?"
" read-config/inner-source"
" read-config/inner-read-compiled"
" read-config/inner-call-with-root-namespace"
" read-config/inner-dynamic-require"
" read-config/inner-module-declared?"
" read-config/inner-coerce"
" read-config/inner-coerce-key"
" read-config/inner-parameter-override"
" read-config/inner-parameter-cache"
" read-config/inner-st)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'read-config/inner"
" #f"
" 13"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12)"
" #f"
" 'read-config/inner)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'readtable)"
"(make-struct-field-accessor -ref_0 1 'next-readtable)"
"(make-struct-field-accessor -ref_0 2 'for-syntax?)"
"(make-struct-field-accessor -ref_0 3 'source)"
"(make-struct-field-accessor -ref_0 4 'read-compiled)"
"(make-struct-field-accessor -ref_0 5 'call-with-root-namespace)"
"(make-struct-field-accessor -ref_0 6 'dynamic-require)"
"(make-struct-field-accessor -ref_0 7 'module-declared?)"
"(make-struct-field-accessor -ref_0 8 'coerce)"
"(make-struct-field-accessor -ref_0 9 'coerce-key)"
"(make-struct-field-accessor -ref_0 10 'parameter-override)"
"(make-struct-field-accessor -ref_0 11 'parameter-cache)"
"(make-struct-field-accessor -ref_0 12 'st))))"
"(define-values"
"(read-config/make)"
"(lambda(readtable_0"
" next-readtable_0"
" for-syntax?_0"
" source_0"
" wrap_0"
" read-compiled_0"
" call-with-root-namespace_0"
" dynamic-require_0"
" module-declared?_0"
" coerce_0"
" coerce-key_0"
" line_0"
" col_0"
" pos_0"
" indentations_0"
" keep-comment?_0"
" parameter-override_0"
" parameter-cache_0"
" st_0)"
"(begin"
"(read-config/outer1.1"
"(read-config/inner2.1"
" readtable_0"
" next-readtable_0"
" for-syntax?_0"
" source_0"
" read-compiled_0"
" call-with-root-namespace_0"
" dynamic-require_0"
" module-declared?_0"
" coerce_0"
" coerce-key_0"
" parameter-override_0"
" parameter-cache_0"
" st_0)"
" wrap_0"
" line_0"
" col_0"
" pos_0"
" indentations_0"
" keep-comment?_0))))"
"(define-values(read-config-wrap)(lambda(v_0)(begin(read-config/outer-wrap v_0))))"
"(define-values(read-config-line)(lambda(v_0)(begin(read-config/outer-line v_0))))"
"(define-values(read-config-col)(lambda(v_0)(begin(read-config/outer-col v_0))))"
"(define-values(read-config-pos)(lambda(v_0)(begin(read-config/outer-pos v_0))))"
"(define-values(read-config-indentations)(lambda(v_0)(begin(read-config/outer-indentations v_0))))"
"(define-values(read-config-keep-comment?)(lambda(v_0)(begin(read-config/outer-keep-comment? v_0))))"
"(define-values"
"(read-config-readtable)"
"(lambda(v_0)(begin(read-config/inner-readtable(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-next-readtable)"
"(lambda(v_0)(begin(read-config/inner-next-readtable(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-for-syntax?)"
"(lambda(v_0)(begin(read-config/inner-for-syntax?(read-config/outer-inner v_0)))))"
"(define-values(read-config-source)(lambda(v_0)(begin(read-config/inner-source(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-read-compiled)"
"(lambda(v_0)(begin(read-config/inner-read-compiled(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-call-with-root-namespace)"
"(lambda(v_0)(begin(read-config/inner-call-with-root-namespace(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-dynamic-require)"
"(lambda(v_0)(begin(read-config/inner-dynamic-require(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-module-declared?)"
"(lambda(v_0)(begin(read-config/inner-module-declared?(read-config/outer-inner v_0)))))"
"(define-values(read-config-coerce)(lambda(v_0)(begin(read-config/inner-coerce(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-coerce-key)"
"(lambda(v_0)(begin(read-config/inner-coerce-key(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-parameter-override)"
"(lambda(v_0)(begin(read-config/inner-parameter-override(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-parameter-cache)"
"(lambda(v_0)(begin(read-config/inner-parameter-cache(read-config/outer-inner v_0)))))"
"(define-values(read-config-st)(lambda(v_0)(begin(read-config/inner-st(read-config/outer-inner v_0)))))"
"(define-values"
"(struct:read-config-state"
" read-config-state3.1"
" read-config-state?"
" read-config-state-accum-str"
" read-config-state-graph"
" set-read-config-state-accum-str!"
" set-read-config-state-graph!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'read-config-state"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'read-config-state)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'accum-str)"
"(make-struct-field-accessor -ref_0 1 'graph)"
"(make-struct-field-mutator -set!_0 0 'accum-str)"
"(make-struct-field-mutator -set!_0 1 'graph))))"
"(define-values(default-val.1) #f)"
"(define-values"
"(current-read-config)"
"(lambda()(begin(continuation-mark-set-first #f current-read-config default-val.1 root-tag))))"
"(define-values"
"(make-read-config.1)"
"(lambda(call-with-root-namespace10_0"
" coerce13_0"
" coerce-key14_0"
" dynamic-require11_0"
" for-syntax?5_0"
" keep-comment?15_0"
" module-declared?12_0"
" next-readtable7_0"
" read-compiled9_0"
" readtable6_0"
" source4_0"
" wrap8_0)"
"(begin"
" 'make-read-config"
"(let-values(((source_0) source4_0))"
"(let-values(((for-syntax?_0) for-syntax?5_0))"
"(let-values(((readtable_0)(if(eq? readtable6_0 unsafe-undefined)(1/current-readtable) readtable6_0)))"
"(let-values(((next-readtable_0)"
"(if(eq? next-readtable7_0 unsafe-undefined) readtable_0 next-readtable7_0)))"
"(let-values(((wrap_0) wrap8_0))"
"(let-values(((read-compiled_0) read-compiled9_0))"
"(let-values(((call-with-root-namespace_0) call-with-root-namespace10_0))"
"(let-values(((dynamic-require_0) dynamic-require11_0))"
"(let-values(((module-declared?_0) module-declared?12_0))"
"(let-values(((coerce_0) coerce13_0))"
"(let-values(((coerce-key_0) coerce-key14_0))"
"(let-values(((keep-comment?_0) keep-comment?15_0))"
"(let-values()"
"(read-config/make"
" readtable_0"
" next-readtable_0"
" for-syntax?_0"
" source_0"
" wrap_0"
"(let-values(((or-part_0) read-compiled_0))"
"                                   (if or-part_0 or-part_0 (lambda (in_0) (error 'read \"no `read-compiled` provided\"))))"
"(let-values(((or-part_0) call-with-root-namespace_0))"
"(if or-part_0"
" or-part_0"
"                                     (lambda (thunk_0) (error 'read \"no `call-with-root-namespace` provided\"))))"
"(let-values(((or-part_0) dynamic-require_0))"
"(if or-part_0"
" or-part_0"
"(lambda(mod-path_0 sym_0 failure-k_0)"
"                                       (error 'read \"no `dynamic-require` provided\"))))"
"(let-values(((or-part_0) module-declared?_0))"
"(if or-part_0"
" or-part_0"
"                                     (lambda (mod-path_0) (error 'read \"no `module-declare?` provided\"))))"
"(let-values(((or-part_0) coerce_0))"
"(if or-part_0 or-part_0(lambda(for-syntax?_1 v_0 srcloc_0) v_0)))"
"(let-values(((or-part_0) coerce-key_0))"
"(if or-part_0 or-part_0(lambda(for-syntax?_1 v_0) v_0)))"
" #f"
" #f"
" #f"
" null"
" keep-comment?_0"
" '#hasheq()"
"(make-hasheq)"
"(read-config-state3.1 #f #f))))))))))))))))))"
"(define-values"
"(read-config-update.1)"
"(lambda(for-syntax?29_0 keep-comment?34_0 next-readtable32_0 readtable31_0 reset-graph?33_0 wrap30_0 config41_0)"
"(begin"
" 'read-config-update"
"(let-values(((config_0) config41_0))"
"(let-values(((for-syntax?_0) for-syntax?29_0))"
"(let-values(((wrap_0) wrap30_0))"
"(let-values(((readtable_0) readtable31_0))"
"(let-values(((next-readtable_0)"
"(if(eq? next-readtable32_0 unsafe-undefined)"
"(read-config-readtable config_0)"
" next-readtable32_0)))"
"(let-values(((local-graph?_0) reset-graph?33_0))"
"(let-values(((keep-comment?_0) keep-comment?34_0))"
"(let-values()"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((wrap51_0) wrap_0)"
"((keep-comment?52_0) keep-comment?_0)"
"((inner53_0)"
"(let-values(((the-struct_1)(read-config/outer-inner v_0)))"
"(if(read-config/inner? the-struct_1)"
"(let-values(((for-syntax?54_0) for-syntax?_0)"
"((readtable55_0) readtable_0)"
"((next-readtable56_0) next-readtable_0)"
"((st57_0)"
"(if local-graph?_0"
"(read-config-state3.1 #f #f)"
"(read-config-st config_0)))"
"((parameter-override58_0) '#hasheq())"
"((parameter-cache59_0)(make-hasheq)))"
"(read-config/inner2.1"
" readtable55_0"
" next-readtable56_0"
" for-syntax?54_0"
"(read-config/inner-source the-struct_1)"
"(read-config/inner-read-compiled the-struct_1)"
"(read-config/inner-call-with-root-namespace the-struct_1)"
"(read-config/inner-dynamic-require the-struct_1)"
"(read-config/inner-module-declared? the-struct_1)"
"(read-config/inner-coerce the-struct_1)"
"(read-config/inner-coerce-key the-struct_1)"
" parameter-override58_0"
" parameter-cache59_0"
" st57_0))"
"                                              (raise-argument-error 'struct-copy \"read-config/inner?\" the-struct_1)))))"
"(read-config/outer1.1"
" inner53_0"
" wrap51_0"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
" keep-comment?52_0))"
"                            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))))))))))"
"(define-values"
"(port+config->srcloc.1)"
"(lambda(end-pos43_0 in45_0 config46_0)"
"(begin"
" 'port+config->srcloc"
"(let-values(((in_0) in45_0))"
"(let-values(((config_0) config46_0))"
"(let-values(((given-end-pos_0) end-pos43_0))"
"(let-values()"
"(let-values(((end-pos_0)"
"(let-values(((or-part_0) given-end-pos_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((end-line_0 end-col_0 end-pos_0)(port-next-location in_0)))"
" end-pos_0)))))"
"(srcloc"
"(let-values(((or-part_0)(read-config-source config_0)))"
"(if or-part_0"
" or-part_0"
"                     (let-values (((or-part_1) (object-name in_0))) (if or-part_1 or-part_1 \"UNKNOWN\"))))"
"(read-config-line config_0)"
"(read-config-col config_0)"
"(read-config-pos config_0)"
"(if(read-config-pos config_0)"
"(if end-pos_0(max 0(- end-pos_0(read-config-pos config_0))) #f)"
" #f))))))))))"
"(define-values"
"(reading-at)"
"(lambda(config_0 line_0 col_0 pos_0)"
"(begin"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((line60_0) line_0)"
"((col61_0) col_0)"
"((pos62_0) pos_0)"
"((inner63_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner63_0"
"(read-config/outer-wrap the-struct_0)"
" line60_0"
" col61_0"
" pos62_0"
"(read-config/outer-indentations the-struct_0)"
"(read-config/outer-keep-comment? the-struct_0)))"
"            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))"
"(define-values"
"(disable-wrapping)"
"(lambda(config_0)"
"(begin"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((wrap64_0) #f)((inner65_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner65_0"
" wrap64_0"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
"(read-config/outer-keep-comment? the-struct_0)))"
"            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))"
"(define-values"
"(keep-comment)"
"(lambda(config_0)"
"(begin"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((keep-comment?66_0) #t)((inner67_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner67_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
" keep-comment?66_0))"
"            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))"
"(define-values"
"(discard-comment)"
"(lambda(config_0)"
"(begin"
"(if(not(read-config-keep-comment? config_0))"
"(let-values() config_0)"
"(let-values()"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((keep-comment?68_0) #f)((inner69_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner69_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
" keep-comment?68_0))"
"                (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))))"
"(define-values"
"(next-readtable)"
"(lambda(config_0)"
"(begin"
"(if(eq?(read-config-readtable config_0)(read-config-next-readtable config_0))"
"(let-values() config_0)"
"(let-values()"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((inner70_0)"
"(let-values(((the-struct_1)(read-config/outer-inner v_0)))"
"(if(read-config/inner? the-struct_1)"
"(let-values(((readtable71_0)(read-config-next-readtable config_0)))"
"(read-config/inner2.1"
" readtable71_0"
"(read-config/inner-next-readtable the-struct_1)"
"(read-config/inner-for-syntax? the-struct_1)"
"(read-config/inner-source the-struct_1)"
"(read-config/inner-read-compiled the-struct_1)"
"(read-config/inner-call-with-root-namespace the-struct_1)"
"(read-config/inner-dynamic-require the-struct_1)"
"(read-config/inner-module-declared? the-struct_1)"
"(read-config/inner-coerce the-struct_1)"
"(read-config/inner-coerce-key the-struct_1)"
"(read-config/inner-parameter-override the-struct_1)"
"(read-config/inner-parameter-cache the-struct_1)"
"(read-config/inner-st the-struct_1)))"
"                                  (raise-argument-error 'struct-copy \"read-config/inner?\" the-struct_1)))))"
"(read-config/outer1.1"
" inner70_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
"(read-config/outer-keep-comment? the-struct_0)))"
"                (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))))"
"(define-values"
"(coerce)"
"(lambda(val_0 in_0 config_0)"
"(begin"
"(let-values(((for-syntax?_0)(read-config-for-syntax? config_0)))"
"((read-config-coerce config_0)"
" for-syntax?_0"
" val_0"
"(if for-syntax?_0"
"(let-values(((in1_0) in_0)((config2_0) config_0))(port+config->srcloc.1 #f in1_0 config2_0))"
" #f))))))"
"(define-values(default-reader-guard$1)(lambda(v_0)(begin 'default-reader-guard v_0)))"
"(define-values"
"(1/current-reader-guard)"
"(make-parameter"
" default-reader-guard$1"
"(lambda(v_0)"
"(begin"
"(if(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)"
"(void)"
"         (let-values () (raise-argument-error 'current-reader-guard \"(procedure-arity-includes/c 1)\" v_0)))"
" v_0))"
" 'current-reader-guard))"
"(define-values"
"(1/read-square-bracket-as-paren)"
"(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-square-bracket-as-paren))"
"(define-values"
"(1/read-curly-brace-as-paren)"
"(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-curly-brace-as-paren))"
"(define-values"
"(1/read-square-bracket-with-tag)"
"(make-parameter #f(lambda(v_0)(if v_0 #t #f)) 'read-square-bracket-with-tag))"
"(define-values"
"(1/read-curly-brace-with-tag)"
"(make-parameter #f(lambda(v_0)(if v_0 #t #f)) 'read-curly-brace-with-tag))"
"(define-values(1/read-cdot)(make-parameter #f(lambda(v_0)(if v_0 #t #f)) 'read-cdot))"
"(define-values(1/read-accept-graph)(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-accept-graph))"
"(define-values"
"(1/read-syntax-accept-graph)"
"(make-parameter #f(lambda(v_0)(if v_0 #t #f)) 'read-syntax-accept-graph))"
"(define-values(1/read-accept-compiled)(make-parameter #f(lambda(v_0)(if v_0 #t #f)) 'read-accept-compiled))"
"(define-values(1/read-accept-box)(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-accept-box))"
"(define-values(1/read-single-flonum)(make-parameter #f(lambda(v_0)(if v_0 #t #f)) 'read-single-flonum))"
"(define-values(1/read-decimal-as-inexact)(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-decimal-as-inexact))"
"(define-values(1/read-accept-dot)(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-accept-dot))"
"(define-values(1/read-accept-infix-dot)(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-accept-infix-dot))"
"(define-values(1/read-accept-quasiquote)(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-accept-quasiquote))"
"(define-values(1/read-accept-reader)(make-parameter #f(lambda(v_0)(if v_0 #t #f)) 'read-accept-reader))"
"(define-values(1/read-accept-lang)(make-parameter #t(lambda(v_0)(if v_0 #t #f)) 'read-accept-lang))"
"(define-values(unknown)(gensym 'unknown))"
"(define-values"
"(check-parameter)"
"(lambda(param_0 config_0)"
"(begin"
"(let-values(((cache_0)(read-config-parameter-cache config_0)))"
"(let-values(((v_0)"
"(hash-ref(read-config-parameter-override config_0) param_0(hash-ref cache_0 param_0 unknown))))"
"(if(eq? v_0 unknown)"
"(let-values()(let-values(((v_1)(param_0)))(begin(hash-set! cache_0 param_0 v_1) v_1)))"
"(let-values() v_0)))))))"
"(define-values"
"(override-parameter)"
"(lambda(param_0 config_0 v_0)"
"(begin"
"(let-values(((v_1) config_0))"
"(let-values(((the-struct_0) v_1))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((inner1_0)"
"(let-values(((the-struct_1)(read-config/outer-inner v_1)))"
"(if(read-config/inner? the-struct_1)"
"(let-values(((parameter-override2_0)"
"(hash-set(read-config-parameter-override config_0) param_0 v_0)))"
"(read-config/inner2.1"
"(read-config/inner-readtable the-struct_1)"
"(read-config/inner-next-readtable the-struct_1)"
"(read-config/inner-for-syntax? the-struct_1)"
"(read-config/inner-source the-struct_1)"
"(read-config/inner-read-compiled the-struct_1)"
"(read-config/inner-call-with-root-namespace the-struct_1)"
"(read-config/inner-dynamic-require the-struct_1)"
"(read-config/inner-module-declared? the-struct_1)"
"(read-config/inner-coerce the-struct_1)"
"(read-config/inner-coerce-key the-struct_1)"
" parameter-override2_0"
"(read-config/inner-parameter-cache the-struct_1)"
"(read-config/inner-st the-struct_1)))"
"                              (raise-argument-error 'struct-copy \"read-config/inner?\" the-struct_1)))))"
"(read-config/outer1.1"
" inner1_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
"(read-config/outer-keep-comment? the-struct_0)))"
"            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))"
"(define-values"
"(force-parameters!)"
"(lambda(config_0)"
"(begin"
"(let-values(((cache_0)(read-config-parameter-cache config_0)))"
"(if(hash-ref cache_0 'all-forced #f)"
"(void)"
"(let-values()"
"(begin"
"(hash-set! cache_0 'all-forced #t)"
"(check-parameter read-case-sensitive config_0)"
"(check-parameter 1/read-square-bracket-as-paren config_0)"
"(check-parameter 1/read-curly-brace-as-paren config_0)"
"(check-parameter 1/read-square-bracket-with-tag config_0)"
"(check-parameter 1/read-curly-brace-with-tag config_0)"
"(check-parameter 1/read-cdot config_0)"
"(check-parameter 1/read-accept-graph config_0)"
"(check-parameter 1/read-syntax-accept-graph config_0)"
"(check-parameter 1/read-accept-compiled config_0)"
"(check-parameter 1/read-accept-box config_0)"
"(check-parameter read-accept-bar-quote config_0)"
"(check-parameter 1/read-decimal-as-inexact config_0)"
"(check-parameter 1/read-single-flonum config_0)"
"(check-parameter 1/read-accept-dot config_0)"
"(check-parameter 1/read-accept-infix-dot config_0)"
"(check-parameter 1/read-accept-quasiquote config_0)"
"(check-parameter 1/read-accept-reader config_0)"
"(check-parameter 1/read-accept-lang config_0))))))))"
"(define-values"
"(struct:special-comment 1/make-special-comment 1/special-comment? 1/special-comment-value)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'special-comment"
" #f"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'make-special-comment)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'value))))"
"(define-values"
"(struct:readtable"
" readtable1.1"
" 1/readtable?"
" readtable-symbol-parser"
" readtable-char-ht"
" readtable-dispatch-ht"
" readtable-delimiter-ht)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'readtable"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t)(cons prop:readtable #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'readtable)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'symbol-parser)"
"(make-struct-field-accessor -ref_0 1 'char-ht)"
"(make-struct-field-accessor -ref_0 2 'dispatch-ht)"
"(make-struct-field-accessor -ref_0 3 'delimiter-ht))))"
"(define-values"
"(1/make-readtable)"
"(lambda(rt_0 . args_0)"
"(begin"
" 'make-readtable"
"(begin"
"(if(let-values(((or-part_0)(not rt_0)))(if or-part_0 or-part_0(1/readtable? rt_0)))"
"(void)"
"          (let-values () (raise-argument-error 'make-readtable \"(or/c readtable? #f)\" rt_0)))"
"((letrec-values(((loop_0)"
"(lambda(args_1 symbol-parser_0 char-ht_0 dispatch-ht_0 delimiter-ht_0)"
"(begin"
" 'loop"
"(if(null? args_1)"
"(let-values()(readtable1.1 symbol-parser_0 char-ht_0 dispatch-ht_0 delimiter-ht_0))"
"(let-values()"
"(let-values(((key_0)(car args_1)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not key_0)))"
"(if or-part_0 or-part_0(char? key_0)))"
"(void)"
"(let-values()"
"                                                        (raise-argument-error 'make-readtable \"(or/c char? #f)\" key_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(null?(cdr args_1))"
"(let-values()"
"(if key_0"
"(let-values()"
"(raise-arguments-error"
" 'make-readtable"
"(string-append"
"                                                                \"expected 'terminating-macro, 'non-terminating-macro, 'dispatch-macro,\""
"                                                                \" or character argument after character argument\")"
"                                                               \"character\""
" key_0))"
"(let-values()"
"(raise-arguments-error"
" 'make-readtable"
"                                                               \"expected 'non-terminating-macro after #f\"))))"
"(void))"
"(values))))"
"(let-values(((mode_0)(cadr args_1)))"
"(let-values((()"
"(begin"
"(if key_0"
"(let-values()"
"(if(let-values(((or-part_0)"
"(eq? mode_0 'terminating-macro)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(eq?"
" mode_0"
" 'non-terminating-macro)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(eq? mode_0 'dispatch-macro)))"
"(if or-part_2 or-part_2(char? mode_0)))))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                                   \"(or/c 'terminating-macro 'non-terminating-macro 'dispatch-macro char?)\""
" mode_0))))"
"(let-values()"
"(if(eq? mode_0 'non-terminating-macro)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'make-readtable"
"                                                                   \"expected 'non-terminating-macro after #f\")))))"
"(values))))"
"(let-values((()"
"(begin"
"(if(null?(cddr args_1))"
"(let-values()"
"(raise-arguments-error"
" 'make-readtable"
"(if(char? mode_0)"
"                                                                   \"expected readtable or #f argument after character argument\""
"                                                                   \"expected procedure argument after symbol argument\")"
"                                                                 (if (char? mode_0) \"character\" \"symbol\")"
" mode_0))"
"(void))"
"(values))))"
"(let-values(((target_0)(caddr args_1)))"
"(let-values(((rest-args_0)(cdddr args_1)))"
"(if(not key_0)"
"(let-values()"
"(begin"
"(if(if(procedure? target_0)"
"(procedure-arity-includes? target_0 6)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                             \"(procedure-arity-includes/c 6)\""
" target_0)))"
"(loop_0"
" rest-args_0"
" target_0"
" char-ht_0"
" dispatch-ht_0"
" delimiter-ht_0)))"
"(if(eq? mode_0 'dispatch-macro)"
"(let-values()"
"(begin"
"(if(if(procedure? target_0)"
"(procedure-arity-includes? target_0 6)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                               \"(procedure-arity-includes/c 6)\""
" target_0)))"
"(loop_0"
" rest-args_0"
" symbol-parser_0"
" char-ht_0"
"(hash-set dispatch-ht_0 key_0 target_0)"
" delimiter-ht_0)))"
"(if(char? mode_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not target_0)))"
"(if or-part_0"
" or-part_0"
"(1/readtable? target_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                                               \"(or/c readtable? #f)\""
" target_0)))"
"(values))))"
"(let-values(((actual-target_0)"
"(let-values(((or-part_0)"
"(if target_0"
"(hash-ref"
"(readtable-char-ht target_0)"
" mode_0"
" #f)"
" #f)))"
"(if or-part_0 or-part_0 mode_0))))"
"(let-values(((new-char-ht_0)"
"(if actual-target_0"
"(hash-set char-ht_0 key_0 actual-target_0)"
"(hash-remove char-ht_0 key_0))))"
"(let-values(((new-delimiter-ht_0)"
"(hash-set"
" delimiter-ht_0"
" key_0"
"(if target_0"
"(hash-ref"
"(readtable-delimiter-ht target_0)"
" mode_0"
" mode_0)"
" mode_0))))"
"(loop_0"
" rest-args_0"
" symbol-parser_0"
" new-char-ht_0"
" dispatch-ht_0"
" new-delimiter-ht_0))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if(procedure? target_0)"
"(procedure-arity-includes? target_0 6)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                                               \"(procedure-arity-includes/c 6)\""
" target_0)))"
"(values))))"
"(let-values(((new-char-ht_0)"
"(hash-set char-ht_0 key_0 target_0)))"
"(let-values(((new-delimiter-ht_0)"
"(hash-set"
" delimiter-ht_0"
" key_0"
"(if(eq? mode_0 'terminating-macro)"
" 'delimit"
" 'no-delimit))))"
"(loop_0"
" rest-args_0"
" symbol-parser_0"
" new-char-ht_0"
" dispatch-ht_0"
" new-delimiter-ht_0))))))))))))))))))))))"
" loop_0)"
" args_0"
"(if rt_0(readtable-symbol-parser rt_0) #f)"
"(if rt_0(readtable-char-ht rt_0) '#hasheqv())"
"(if rt_0(readtable-dispatch-ht rt_0) '#hasheqv())"
"(if rt_0(readtable-delimiter-ht rt_0) '#hasheqv()))))))"
"(define-values"
"(*readtable-effective-char)"
"(lambda(rt_0 c_0 handler_0)"
"(begin"
"(let-values(((target_0)(hash-ref(readtable-char-ht rt_0) c_0 #f)))"
"(if(not target_0)"
"(let-values() c_0)"
"(if(char? target_0)(let-values() target_0)(let-values() handler_0)))))))"
"(define-values"
"(readtable-effective-char/#)"
"(lambda(rt_0 c_0)"
"(begin(if(if rt_0(hash-ref(readtable-dispatch-ht rt_0) c_0 #f) #f)(let-values() #f)(let-values() c_0)))))"
"(define-values"
"(effective-char)"
"(lambda(c_0 config_0)"
"(begin"
"(let-values(((rt_0)(read-config-readtable config_0))((c_1) c_0)((handler_0) '#\\x))"
"(if(let-values(((or-part_0)(not rt_0)))(if or-part_0 or-part_0(not(char? c_1))))"
"(let-values() c_1)"
"(let-values()(*readtable-effective-char rt_0 c_1 handler_0)))))))"
"(define-values"
"(readtable-handler)"
"(lambda(config_0 c_0)"
"(begin"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(if rt_0"
"(let-values(((target_0)(hash-ref(readtable-char-ht rt_0) c_0 #f)))"
"(if target_0(if(not(char? target_0)) target_0 #f) #f))"
" #f)))))"
"(define-values"
"(readtable-dispatch-handler)"
"(lambda(config_0 c_0)"
"(begin"
"(let-values((()(begin(force-parameters! config_0)(values))))"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(if rt_0(hash-ref(readtable-dispatch-ht rt_0) c_0 #f) #f))))))"
"(define-values"
"(readtable-apply)"
"(lambda(handler_0 c_0 in_0 config_0 line_0 col_0 pos_0)"
"(begin"
"(let-values(((for-syntax?_0)(read-config-for-syntax? config_0)))"
"(let-values(((v_0)"
"(if(not for-syntax?_0)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()"
"(if(procedure-arity-includes? handler_0 2)"
"(handler_0 c_0 in_0)"
"(handler_0 c_0 in_0 #f line_0 col_0 pos_0)))))"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()(handler_0 c_0 in_0(read-config-source config_0) line_0 col_0 pos_0)))))))"
"(if(1/special-comment? v_0) v_0(coerce v_0 in_0 config_0)))))))"
"(define-values"
"(1/readtable-mapping)"
"(lambda(rt_0 c_0)"
"(begin"
" 'readtable-mapping"
"(let-values((()"
"(begin"
"(if(1/readtable? rt_0)"
"(void)"
"                        (let-values () (raise-argument-error 'readtable-mapping \"readtable?\" rt_0)))"
"(values))))"
"(let-values((()"
"(begin"
"                        (if (char? c_0) (void) (let-values () (raise-argument-error 'readtable-mapping \"char?\" c_0)))"
"(values))))"
"(let-values(((handler_0)(hash-ref(readtable-char-ht rt_0) c_0 #f)))"
"(values"
"(let-values(((or-part_0)"
"(if handler_0"
"(if(char? handler_0)"
"(let-values() handler_0)"
"(if(eq? 'delimit(hash-ref(readtable-delimiter-ht rt_0) c_0 #f))"
"(let-values() 'terminating-macro)"
"(let-values() 'non-terminating-macro)))"
" #f)))"
"(if or-part_0 or-part_0 c_0))"
"(if(char? handler_0) #f handler_0)"
"(hash-ref(readtable-dispatch-ht rt_0) c_0 #f))))))))"
"(define-values"
"(readtable-equivalent-chars)"
"(lambda(rt_0 c_0)"
"(begin"
"(let-values(((ht_0)(readtable-char-ht rt_0)))"
"(append"
"(if(hash-ref ht_0 c_0 #f) null(list c_0))"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_1 i_0)))"
"(let-values(((fold-var_2)"
"(if(eqv? v_0 c_0)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons(let-values() k_0) fold-var_1))))"
"(values fold-var_2))"
" fold-var_1)))"
"(if(not #f)"
"(for-loop_0 fold-var_2(hash-iterate-next ht_1 i_0))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
"(hash-iterate-first ht_1)))))))))))"
"(define-values"
"(struct:special special1.1 special? special-value)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'special #f 1 0 #f null(current-inspector) #f '(0) #f 'special)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'value))))"
"(define-values"
"(wrap)"
"(lambda(s-exp_0 in_0 config_0 rep_0)"
"(begin"
"(let-values(((wrap_0)(read-config-wrap config_0)))"
"(if wrap_0"
"(wrap_0"
" s-exp_0"
"(let-values(((in1_0) in_0)((config2_0) config_0))(port+config->srcloc.1 #f in1_0 config2_0))"
" rep_0)"
" s-exp_0)))))"
"(define-values(consume-char)(lambda(in_0 c_0)(begin(begin(read-char in_0)(void)))))"
"(define-values"
"(consume-char/special)"
"(lambda(in_0 config_0 c_0)"
"(begin(begin(read-char-or-special in_0 special1.1(read-config-source config_0))(void)))))"
"(define-values"
"(reader-error.1)"
"(lambda(continuation-marks1_0 due-to2_0 end-pos4_0 who3_0 in9_0 config10_0 str11_0 new-rest_0)"
"(begin"
" 'reader-error"
"(let-values(((in_0) in9_0))"
"(let-values(((config_0) config10_0))"
"(let-values(((continuation-marks_0)"
"(if(eq? continuation-marks1_0 unsafe-undefined)"
"(current-continuation-marks)"
" continuation-marks1_0)))"
"(let-values(((due-to_0) due-to2_0))"
"(let-values(((who_0)"
"(if(eq? who3_0 unsafe-undefined)"
"(if(read-config-for-syntax? config_0) 'read-syntax 'read)"
" who3_0)))"
"(let-values(((end-pos_0) end-pos4_0))"
"(let-values(((str_0) str11_0))"
"(let-values(((args_0) new-rest_0))"
"                      (let-values (((msg_0) (format \"~a: ~a\" who_0 (apply format str_0 args_0))))"
"(let-values(((srcloc_0)"
"(if in_0"
"(let-values(((in19_0) in_0)((config20_0) config_0)((end-pos21_0) end-pos_0))"
"(port+config->srcloc.1 end-pos21_0 in19_0 config20_0))"
" #f)))"
"(raise"
"((if(eof-object? due-to_0)"
"(let-values() exn:fail:read:eof)"
"(if(not(char? due-to_0))"
"(let-values() exn:fail:read:non-char)"
"(let-values() exn:fail:read)))"
"(let-values(((s_0)"
"(if(error-print-source-location)"
"(if srcloc_0(srcloc->string srcloc_0) #f)"
" #f)))"
"                              (if s_0 (string-append s_0 \": \" msg_0) msg_0))"
" continuation-marks_0"
"(if srcloc_0(list srcloc_0) null))))))))))))))))"
"(define-values"
"(bad-syntax-error.1)"
"(lambda(due-to13_0 in15_0 config16_0 str17_0)"
"(begin"
" 'bad-syntax-error"
"(let-values(((in_0) in15_0))"
"(let-values(((config_0) config16_0))"
"(let-values(((str_0) str17_0))"
"(let-values(((due-to_0) due-to13_0))"
"(let-values()"
"(let-values(((in22_0) in_0)"
"((config23_0) config_0)"
"((due-to24_0) due-to_0)"
"                             ((temp25_0) \"bad syntax `~a`\")"
"((str26_0) str_0))"
"(reader-error.1"
" unsafe-undefined"
" due-to24_0"
" #f"
" unsafe-undefined"
" in22_0"
" config23_0"
" temp25_0"
"(list str26_0)))))))))))"
"(define-values"
"(catch-and-reraise-as-reader/proc)"
"(lambda(in_0 config_0 thunk_0)"
"(begin"
"(let-values(((with-handlers-predicate27_0) exn:fail?)"
"((with-handlers-handler28_0)"
"(lambda(exn_0)"
"(begin"
" 'with-handlers-handler28"
"(let-values(((in29_0) in_0)"
"((config30_0) config_0)"
"                                     ((temp31_0) \"~a\")"
"((temp32_0)"
"                                      (let-values (((s_0) (exn-message exn_0))) (regexp-replace \"^[a-z-]*: \" s_0 \"\")))"
"((temp33_0)(exn-continuation-marks exn_0)))"
"(reader-error.1"
" temp33_0"
" '#\\x"
" #f"
" unsafe-undefined"
" in29_0"
" config30_0"
" temp31_0"
"(list temp32_0)))))))"
"(let-values(((bpz_0)(continuation-mark-set-first #f break-enabled-key)))"
"(call-handled-body"
" bpz_0"
"(lambda(e_0)"
"(select-handler/no-breaks e_0 bpz_0(list(cons with-handlers-predicate27_0 with-handlers-handler28_0))))"
"(lambda()(thunk_0))))))))"
"(define-values"
"(port-next-location*)"
"(lambda(in_0 init-c_0)"
"(begin"
"(if(not init-c_0)"
"(let-values()(port-next-location in_0))"
"(let-values()"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(let-values(((delta_0)"
"(if(port-counts-lines? in_0)"
"(let-values() 1)"
"(if(char? init-c_0)(let-values()(char-utf-8-length init-c_0))(let-values() 1)))))"
"(values line_0(if col_0(max 0(- col_0 delta_0)) #f)(if pos_0(max 1(- pos_0 delta_0)) #f)))))))))"
"(define-values"
"(read-char/skip-whitespace-and-comments)"
"(lambda(init-c_0 read-one_0 in_0 config_0)"
"(begin"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(let-values(((source_0)(read-config-source config_0)))"
"((letrec-values(((skip-loop_0)"
"(lambda(init-c_1)"
"(begin"
" 'skip-loop"
"(let-values(((c_0)"
"(let-values(((or-part_0) init-c_1))"
"(if or-part_0"
" or-part_0"
"(let-values(((in_1) in_0)((source_1) source_0))"
"(read-char-or-special in_1 special1.1 source_1))))))"
"(let-values(((ec_0)"
"(let-values(((rt_1) rt_0)((c_1) c_0)((handler_0) '#\\x))"
"(if(let-values(((or-part_0)(not rt_1)))"
"(if or-part_0 or-part_0(not(char? c_1))))"
"(let-values() c_1)"
"(let-values()(*readtable-effective-char rt_1 c_1 handler_0))))))"
"(if(eof-object? ec_0)"
"(let-values() c_0)"
"(if(not(char? ec_0))"
"(let-values()"
"(let-values(((v_0)(special-value c_0)))"
"(if(if(1/special-comment? v_0)"
"(not(read-config-keep-comment? config_0))"
" #f)"
"(let-values()(skip-loop_0 #f))"
"(let-values() c_0))))"
"(if(let-values(((or-part_0)(char-whitespace? ec_0)))"
"(if or-part_0 or-part_0(eqv? '#\\uFEFF ec_0)))"
"(let-values()(skip-loop_0 #f))"
"(if(char=? '#\\; ec_0)"
"(let-values()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((c_1)"
"(let-values(((in_1) in_0)"
"((source_1) source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(if(let-values(((or-part_0)"
"(eof-object? c_1)))"
"(if or-part_0"
" or-part_0"
"(eqv?"
" '#\\newline"
"(effective-char c_1 config_0))))"
"(void)"
"(let-values()(loop_0))))))))"
" loop_0))"
"(if(read-config-keep-comment? config_0)"
"(result-special-comment)"
"(skip-loop_0 #f))))"
"(if(if(char=? '#\\# ec_0)"
"(eqv?"
" '#\\|"
"(readtable-effective-char/#"
" rt_0"
"(let-values(((in_1) in_0)((skip-count_0) 0)((source_1) source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
" #f)"
"(let-values()"
"(begin"
"(skip-pipe-comment! c_0 in_0 config_0)"
"(if(read-config-keep-comment? config_0)"
"(result-special-comment)"
"(skip-loop_0 #f))))"
"(if(if(char=? '#\\# ec_0)"
"(if(eqv?"
" '#\\!"
"(readtable-effective-char/#"
" rt_0"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_1) source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(let-values(((c3_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 1)"
"((source_1) source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq? c_1 'special)"
"(special1.1 'special)"
" c_1)))))"
"(let-values(((or-part_0)(eqv? '#\\space c3_0)))"
"(if or-part_0 or-part_0(eqv? '#\\/ c3_0))))"
" #f)"
" #f)"
"(let-values()"
"(begin"
"(skip-unix-line-comment! in_0 config_0)"
"(if(read-config-keep-comment? config_0)"
"(result-special-comment)"
"(skip-loop_0 #f))))"
"(if(if(char=? '#\\# ec_0)"
"(eqv?"
" '#\\;"
"(readtable-effective-char/#"
" rt_0"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_1) source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
" #f)"
"(let-values()"
"(let-values((()(begin(consume-char in_0 '#\\;)(values))))"
"(let-values(((v_0)(read-one_0 #f in_0 config_0)))"
"(begin"
"(if(eof-object? v_0)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((v3_0) v_0)"
"((temp4_0)"
"                                                                            \"expected a commented-out element for `~a;`, but found end-of-file\")"
"((ec5_0) ec_0))"
"(reader-error.1"
" unsafe-undefined"
" v3_0"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp4_0"
"(list ec5_0))))"
"(void))"
"(if(read-config-keep-comment? config_0)"
"(result-special-comment)"
"(skip-loop_0 #f))))))"
"(let-values() c_0))))))))))))))"
" skip-loop_0)"
" init-c_0))))))"
"(define-values(result-special-comment)(lambda()(begin(special1.1(1/make-special-comment #f)))))"
"(define-values"
"(skip-pipe-comment!)"
"(lambda(init-c_0 in_0 config_0)"
"(begin"
"(let-values(((source_0)(read-config-source config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(begin"
"(consume-char in_0 '#\\|)"
"((letrec-values(((loop_0)"
"(lambda(prev-c_0 depth_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_1) source_0))"
"(read-char-or-special in_1 special1.1 source_1))))"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in6_0) in_0)"
"((temp7_0)(reading-at config_0 line_0 col_0 pos_0))"
"((c8_0) c_0)"
"                                                     ((temp9_0) \"end of file in `#|` comment\"))"
"(reader-error.1"
" unsafe-undefined"
" c8_0"
" #f"
" unsafe-undefined"
" in6_0"
" temp7_0"
" temp9_0"
"(list))))"
"(if(not(char? c_0))"
"(let-values()(loop_0 #f depth_0))"
"(if(if(char=? '#\\| c_0)(eqv? prev-c_0 '#\\#) #f)"
"(let-values()(loop_0 #f(add1 depth_0)))"
"(if(if(char=? '#\\# c_0)(eqv? prev-c_0 '#\\|) #f)"
"(let-values()"
"(if(positive? depth_0)"
"(let-values()(loop_0 #f(sub1 depth_0)))"
"(void)))"
"(let-values()(loop_0 c_0 depth_0)))))))))))"
" loop_0)"
" #f"
" 0)))))))"
"(define-values"
"(skip-unix-line-comment!)"
"(lambda(in_0 config_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(backslash?_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(if(eof-object? c_0)"
"(let-values()(void))"
"(if(not(char? c_0))"
"(let-values()(loop_0 #f))"
"(if(char=? c_0 '#\\newline)"
"(let-values()(if backslash?_0(let-values()(loop_0 #f))(void)))"
"(if(char=? c_0 '#\\\\)"
"(let-values()(loop_0 #t))"
"(let-values()(loop_0 #f)))))))))))"
" loop_0)"
" #f))))"
"(define-values"
"(special-comment-via-readtable?)"
"(lambda(c_0 read-one_0 in_0 config_0)"
"(begin"
"(let-values(((v_0)"
"(if(if(char? c_0)"
"(let-values(((ec_0)"
"(let-values(((rt_0)(read-config-readtable config_0))"
"((c_1) c_0)"
"((handler_0) #f))"
"(if(let-values(((or-part_0)(not rt_0)))"
"(if or-part_0 or-part_0(not(char? c_1))))"
"(let-values() c_1)"
"(let-values()(*readtable-effective-char rt_0 c_1 handler_0))))))"
"(let-values(((or-part_0)(not ec_0)))"
"(if or-part_0"
" or-part_0"
"(if(char=? ec_0 '#\\#)"
"(let-values(((c2_0)(peek-char in_0)))"
"(if(char? c2_0)"
"(not(readtable-effective-char/#(read-config-readtable config_0) c2_0))"
" #f))"
" #f))))"
" #f)"
"(let-values()(read-one_0 c_0 in_0(keep-comment config_0)))"
"(let-values() c_0))))"
"(if(1/special-comment? v_0) v_0 #f)))))"
"(define-values"
"(readtable-char-delimiter?)"
"(lambda(rt_0 c_0 config_0)"
"(begin"
"(let-values(((dc_0)"
"(let-values(((or-part_0)(if rt_0(hash-ref(readtable-delimiter-ht rt_0) c_0 #f) #f)))"
"(if or-part_0 or-part_0 c_0))))"
"(if(eq? dc_0 'no-delimit)"
"(let-values() #f)"
"(if(not(char? dc_0))"
"(let-values() #t)"
"(let-values()"
"(let-values(((or-part_0)(char-whitespace? dc_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char=? dc_0 '#\\()))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(char=? dc_0 '#\\))))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(char=? dc_0 '#\\[)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(char=? dc_0 '#\\])))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(char=? dc_0 '#\\{)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(char=? dc_0 '#\\})))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(char=? dc_0 '#\\')))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(char=? dc_0 '#\\`)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(char=? dc_0 '#\\,)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(char=? dc_0 '#\\;)))"
"(if or-part_10"
" or-part_10"
"                                                          (let-values (((or-part_11) (char=? dc_0 '#\\\")))"
"(if or-part_11"
" or-part_11"
"(let-values(((or-part_12)(char=? dc_0 '#\\uFEFF)))"
"(if or-part_12"
" or-part_12"
"(if(char=? dc_0 '#\\.)"
"(check-parameter 1/read-cdot config_0)"
" #f))))))))))))))))))))))))))))))))))"
"(define-values"
"(char-delimiter?)"
"(lambda(c_0 config_0)(begin(readtable-char-delimiter?(read-config-readtable config_0) c_0 config_0))))"
"(define-values"
"(char-closer?)"
"(lambda(ec_0 config_0)"
"(begin"
"(if(not(eof-object? ec_0))"
"(let-values(((or-part_0)(char=? ec_0 '#\\))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char=? ec_0 '#\\])))(if or-part_1 or-part_1(char=? ec_0 '#\\})))))"
" #f))))"
" (define-values (closer-name) (lambda (c_0 config_0) (begin (effective-char-names c_0 config_0 \"closer\"))))"
" (define-values (opener-name) (lambda (c_0 config_0) (begin (effective-char-names c_0 config_0 \"opener\"))))"
"(define-values"
"(effective-char-names)"
"(lambda(c_0 config_0 fallback-str_0)"
"(begin"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(if(not rt_0)"
"          (let-values () (format \"`~a`\" c_0))"
"(let-values()"
"(let-values(((cs_0)(readtable-equivalent-chars rt_0 c_0)))"
"(if(null? cs_0)"
"(let-values() fallback-str_0)"
"(if(null?(cdr cs_0))"
"                  (let-values () (format \"`~a`\" (car cs_0)))"
"(if(null?(cddr cs_0))"
"                    (let-values () (format \"`~a` or `~a`\" (car cs_0) (cadr cs_0)))"
"(let-values()"
"(apply"
" string-append"
"((letrec-values(((loop_0)"
"(lambda(cs_1)"
"(begin"
" 'loop"
"(if(null?(cdr cs_1))"
"                                               (let-values () (list (format \"or `~a`\" (car cs_1))))"
"(let-values()"
"                                                 (cons (format \"`~a`, \" (car cs_1)) (loop_0 (cdr cs_1)))))))))"
" loop_0)"
" cs_0)))))))))))))"
"(define-values"
"(closer->opener)"
"(lambda(c_0)"
"(begin"
"(let-values(((tmp_0) c_0))"
"(if(equal? tmp_0 '#\\))"
"(let-values() '#\\()"
"(if(equal? tmp_0 '#\\])"
"(let-values() '#\\[)"
"(if(equal? tmp_0 '#\\})(let-values() '#\\{)(let-values() c_0))))))))"
" (define-values (dot-name) (lambda (config_0) (begin \"`.`\")))"
"(define-values"
"(all-openers-str)"
"(lambda(config_0)"
"(begin"
"(let-values(((p_0)(opener-name '#\\( config_0)))"
"(let-values(((s_0)"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)(opener-name '#\\[ config_0) #f)))"
"(let-values(((c_0)"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)(opener-name '#\\{ config_0) #f)))"
"(if(if s_0 c_0 #f)"
"              (let-values () (format \"~a, ~a, or ~a\" p_0 s_0 c_0))"
"(if(let-values(((or-part_0) s_0))(if or-part_0 or-part_0 c_0))"
"                (let-values () (format \"~a or ~a\" p_0 (let-values (((or-part_0) s_0)) (if or-part_0 or-part_0 c_0))))"
"(let-values() p_0)))))))))"
"(define-values"
"(struct:accum-string"
" accum-string1.1"
" accum-string?"
" accum-string-pos"
" accum-string-str"
" set-accum-string-pos!"
" set-accum-string-str!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'accum-string"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'accum-string)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'pos)"
"(make-struct-field-accessor -ref_0 1 'str)"
"(make-struct-field-mutator -set!_0 0 'pos)"
"(make-struct-field-mutator -set!_0 1 'str))))"
"(define-values"
"(accum-string-init!)"
"(lambda(config_0)"
"(begin"
"(let-values(((st_0)(read-config-st config_0)))"
"(let-values(((a_0)(read-config-state-accum-str st_0)))"
"(if a_0"
"(let-values()(begin(set-read-config-state-accum-str! st_0 #f)(set-accum-string-pos! a_0 0) a_0))"
"(let-values()(accum-string1.1 0(make-string 32)))))))))"
"(define-values"
"(accum-string-add!)"
"(lambda(a_0 c_0)"
"(begin"
"(let-values(((pos_0)(accum-string-pos a_0)))"
"(let-values(((str_0)(accum-string-str a_0)))"
"(let-values(((str2_0)"
"(if(fx< pos_0(string-length str_0))"
"(let-values() str_0)"
"(let-values()"
"(let-values(((str2_0)(make-string(fx*(string-length str_0) 2))))"
"(begin(string-copy! str2_0 0 str_0)(set-accum-string-str! a_0 str2_0) str2_0))))))"
"(begin(string-set! str2_0 pos_0 c_0)(set-accum-string-pos! a_0(fx+ 1 pos_0)))))))))"
"(define-values(accum-string-count)(lambda(a_0)(begin(accum-string-pos a_0))))"
"(define-values(set-accum-string-count!)(lambda(a_0 pos_0)(begin(set-accum-string-pos! a_0 pos_0))))"
"(define-values"
"(accum-string-convert!)"
"(lambda(a_0 convert_0 start-pos_0)"
"(begin"
"(let-values(((str_0)(accum-string-str a_0)))"
"(let-values(((s_0)(convert_0(substring str_0 start-pos_0(accum-string-pos a_0)))))"
"(let-values(((len_0)(string-length s_0)))"
"(begin"
"(if(fx<(fx+ len_0 start-pos_0)(string-length str_0))"
"(void)"
"(let-values()"
"(let-values(((str2_0)(make-string(fx+ start-pos_0 len_0))))"
"(begin(string-copy! str2_0 0 str_0 0 start-pos_0)(set-accum-string-str! a_0 str2_0)))))"
"(string-copy!(accum-string-str a_0) start-pos_0 s_0)"
"(set-accum-string-pos! a_0(fx+ start-pos_0 len_0)))))))))"
"(define-values"
"(accum-string-get!.1)"
"(lambda(start-pos2_0 a4_0 config5_0)"
"(begin"
" 'accum-string-get!"
"(let-values(((a_0) a4_0))"
"(let-values(((config_0) config5_0))"
"(let-values(((start-pos_0) start-pos2_0))"
"(let-values()"
"(let-values(((s_0)(substring(accum-string-str a_0) start-pos_0(accum-string-pos a_0))))"
"(begin(accum-string-abandon! a_0 config_0) s_0)))))))))"
"(define-values"
"(accum-string-get-bytes!.1)"
"(lambda(start-pos7_0 a9_0 config10_0)"
"(begin"
" 'accum-string-get-bytes!"
"(let-values(((a_0) a9_0))"
"(let-values(((config_0) config10_0))"
"(let-values(((start-pos_0) start-pos7_0))"
"(let-values()"
"(let-values(((bstr_0)"
"(string->bytes/latin-1(accum-string-str a_0) #f start-pos_0(accum-string-pos a_0))))"
"(begin(accum-string-abandon! a_0 config_0) bstr_0)))))))))"
"(define-values"
"(accum-string-abandon!)"
"(lambda(a_0 config_0)(begin(set-read-config-state-accum-str!(read-config-st config_0) a_0))))"
"(define-values"
"(struct:indentation"
" indentation1.1"
" indentation?"
" indentation-closer"
" indentation-suspicious-closer"
" indentation-multiline?"
" indentation-start-line"
" indentation-last-line"
" indentation-suspicious-line"
" indentation-max-indent"
" indentation-suspicious-quote"
" set-indentation-suspicious-closer!"
" set-indentation-multiline?!"
" set-indentation-last-line!"
" set-indentation-suspicious-line!"
" set-indentation-max-indent!"
" set-indentation-suspicious-quote!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'indentation #f 8 0 #f null(current-inspector) #f '(0 3) #f 'indentation)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'closer)"
"(make-struct-field-accessor -ref_0 1 'suspicious-closer)"
"(make-struct-field-accessor -ref_0 2 'multiline?)"
"(make-struct-field-accessor -ref_0 3 'start-line)"
"(make-struct-field-accessor -ref_0 4 'last-line)"
"(make-struct-field-accessor -ref_0 5 'suspicious-line)"
"(make-struct-field-accessor -ref_0 6 'max-indent)"
"(make-struct-field-accessor -ref_0 7 'suspicious-quote)"
"(make-struct-field-mutator -set!_0 1 'suspicious-closer)"
"(make-struct-field-mutator -set!_0 2 'multiline?)"
"(make-struct-field-mutator -set!_0 4 'last-line)"
"(make-struct-field-mutator -set!_0 5 'suspicious-line)"
"(make-struct-field-mutator -set!_0 6 'max-indent)"
"(make-struct-field-mutator -set!_0 7 'suspicious-quote))))"
"(define-values"
"(make-indentation)"
"(lambda(closer_0 in_0 config_0)"
"(begin"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(indentation1.1 closer_0 #f #f line_0 line_0 #f(if col_0(add1 col_0) #f) #f)))))"
"(define-values"
"(track-indentation!)"
"(lambda(config_0 line_0 col_0)"
"(begin"
"(let-values(((indts_0)(read-config-indentations config_0)))"
"(let-values(((indt_0)(if(pair? indts_0)(car indts_0) #f)))"
"(if(if indt_0"
"(if line_0(if(indentation-last-line indt_0)(> line_0(indentation-last-line indt_0)) #f) #f)"
" #f)"
"(let-values()"
"(begin"
"(set-indentation-last-line! indt_0 line_0)"
"(set-indentation-multiline?! indt_0 #t)"
"(if(>= col_0(indentation-max-indent indt_0))"
"(let-values()(set-indentation-max-indent! indt_0 col_0))"
"(let-values()"
"(if(indentation-suspicious-line indt_0)"
"(void)"
"(let-values()"
"(begin"
"(set-indentation-suspicious-closer! indt_0(indentation-closer indt_0))"
"(set-indentation-suspicious-line! indt_0 line_0))))))))"
"(void)))))))"
"(define-values"
"(indentation-possible-cause)"
"(lambda(config_0)"
"(begin"
"(let-values(((indt_0)(car(read-config-indentations config_0))))"
"(if(indentation-suspicious-line indt_0)"
"(let-values()"
"(format"
"             \"\\n  possible cause: indentation suggests a missing ~a before line ~a\""
"(closer-name(indentation-suspicious-closer indt_0) config_0)"
"(indentation-suspicious-line indt_0)))"
"          (let-values () \"\"))))))"
"(define-values"
"(indentation-unexpected-closer-message)"
"(lambda(ec_0 c_0 config_0)"
"(begin"
"(let-values(((indts_0)(read-config-indentations config_0)))"
"(if(null? indts_0)"
"          (let-values () (format \"unexpected `~a`\" c_0))"
"(let-values()"
"(let-values(((indt_0)(car indts_0)))"
"(string-append"
"(if(char=? ec_0(indentation-closer indt_0))"
"                 (let-values () (format \"unexpected `~a`\" c_0))"
"(let-values()"
"(let-values(((missing_0)"
"(let-values(((or-part_0)"
"(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((lst_0)(cdr indts_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((indt_1)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(char=?"
" ec_0"
"(indentation-closer"
" indt_1))"
"                                                                                                                   \"missing\""
" #f)))))"
"(values result_2))))"
"(if(if(not"
"((lambda x_0 result_2)"
" indt_1))"
"(not #f)"
" #f)"
"(for-loop_0 result_2 rest_0)"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" lst_0))))))"
"                                   (if or-part_0 or-part_0 \"expected\"))))"
"(let-values(((opener-str_0)(opener-name(closer->opener(indentation-closer indt_0)) config_0)))"
"(format"
"                        \"~a ~a to close ~a, found instead `~a`\""
" missing_0"
"(closer-name(indentation-closer indt_0) config_0)"
"(if(indentation-multiline? indt_0)"
"                          (let-values () (format \"~a on line ~a\" opener-str_0 (indentation-start-line indt_0)))"
"                          (let-values () (format \"preceding ~a\" opener-str_0)))"
" c_0)))))"
"(indentation-possible-cause config_0)))))))))"
"(define-values"
"(read-unwrapped-sequence.1)"
"(lambda(dot-mode2_0"
" elem-config1_0"
" first-read-one5_0"
" shape-tag?3_0"
" whitespace-read-one4_0"
" read-one11_0"
" opener-c12_0"
" opener13_0"
" closer14_0"
" in15_0"
" seq-config16_0)"
"(begin"
" 'read-unwrapped-sequence"
"(let-values(((read-one_0) read-one11_0))"
"(let-values(((opener-c_0) opener-c12_0))"
"(let-values(((opener_0) opener13_0))"
"(let-values(((closer_0) closer14_0))"
"(let-values(((in_0) in15_0))"
"(let-values(((seq-config_0) seq-config16_0))"
"(let-values(((elem-config_0)"
"(if(eq? elem-config1_0 unsafe-undefined)"
"(next-readtable seq-config_0)"
" elem-config1_0)))"
"(let-values(((dot-mode_0) dot-mode2_0))"
"(let-values(((shape-tag?_0) shape-tag?3_0))"
"(let-values(((whitespace-read-one_0)"
"(if(eq? whitespace-read-one4_0 unsafe-undefined)"
" read-one_0"
" whitespace-read-one4_0)))"
"(let-values(((first-read-one_0)"
"(if(eq? first-read-one5_0 unsafe-undefined) read-one_0 first-read-one5_0)))"
"(let-values()"
"(let-values(((head_0) #f))"
"(let-values(((indentation_0)(make-indentation closer_0 in_0 seq-config_0)))"
"(let-values(((config_0)"
"(let-values(((v_0) elem-config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((indentations18_0)"
"(cons"
" indentation_0"
"(read-config-indentations seq-config_0)))"
"((inner19_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner19_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
" indentations18_0"
"(read-config/outer-keep-comment? the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                       \"read-config/outer?\""
" the-struct_0))))))"
"(let-values(((open-end-line_0 open-end-col_0 open-end-pos_0)"
"(port-next-location in_0)))"
"(let-values(((config/keep-comment_0)(keep-comment config_0)))"
"(let-values(((read-one/not-eof_0)"
"(lambda(init-c_0 read-one_1 config_1)"
"(begin"
" 'read-one/not-eof"
"(let-values(((e_0)(read-one_1 init-c_0 in_0 config_1)))"
"(begin"
"(if(eof-object? e_0)"
"(let-values()"
"(let-values(((in20_0) in_0)"
"((seq-config21_0) seq-config_0)"
"((e22_0) e_0)"
"((open-end-pos23_0) open-end-pos_0)"
"((temp24_0)"
"                                                                                \"expected a ~a to close `~a`~a\")"
"((temp25_0)"
"(closer-name closer_0 config_1))"
"((opener-c26_0) opener-c_0)"
"((temp27_0)"
"(indentation-possible-cause config_1)))"
"(reader-error.1"
" unsafe-undefined"
" e22_0"
" open-end-pos23_0"
" unsafe-undefined"
" in20_0"
" seq-config21_0"
" temp24_0"
"(list temp25_0 opener-c26_0 temp27_0))))"
"(void))"
" e_0))))))"
"(let-values(((seq_0)"
"((letrec-values(((loop_0)"
"(lambda(depth_0"
" accum_0"
" init-c_0"
" first?_0"
" first-read-one_1"
" closing_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(read-char/skip-whitespace-and-comments"
" init-c_0"
" whitespace-read-one_0"
" in_0"
" seq-config_0)))"
"(let-values(((ec_0)"
"(effective-char"
" c_0"
" seq-config_0)))"
"(if(eqv? ec_0 closer_0)"
"(let-values()"
"(begin"
"(closing_0)"
"(if(null? accum_0)"
" null"
"(reverse$1 accum_0))))"
"(if(if(not first?_0)"
"(if(eqv? ec_0 '#\\.)"
"(if(check-parameter"
" 1/read-accept-dot"
" config_0)"
"(char-delimiter?"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_0)"
"(read-config-source"
" config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq?"
" c_1"
" 'special)"
"(special1.1"
" 'special)"
" c_1)))"
" seq-config_0)"
" #f)"
" #f)"
" #f)"
"(let-values()"
"(let-values(((dot-line_0"
" dot-col_0"
" dot-pos_0)"
"(port-next-location*"
" in_0"
" c_0)))"
"(let-values((()"
"(begin"
"(track-indentation!"
" config_0"
" dot-line_0"
" dot-col_0)"
"(values))))"
"(let-values((()"
"(begin"
"(if(if dot-mode_0"
"(not"
" head_0)"
" #f)"
"(void)"
"(let-values()"
"(let-values(((in28_0)"
" in_0)"
"((temp29_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0))"
"((temp30_0)"
"                                                                                                                              \"illegal use of `.`\"))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in28_0"
" temp29_0"
" temp30_0"
"(list)))))"
"(values))))"
"(let-values(((v_0)"
"(read-one/not-eof_0"
" #f"
" first-read-one_1"
" config_0)))"
"((letrec-values(((post-dot-loop_0)"
"(lambda()"
"(begin"
" 'post-dot-loop"
"(let-values(((rest-c_0)"
"(read-char/skip-whitespace-and-comments"
" #f"
" whitespace-read-one_0"
" in_0"
" seq-config_0)))"
"(let-values(((rest-ec_0)"
"(effective-char"
" rest-c_0"
" seq-config_0)))"
"(if(eqv?"
" rest-ec_0"
" closer_0)"
"(let-values()"
"(if(null?"
" accum_0)"
" v_0"
"(append"
"(reverse$1"
" accum_0)"
" v_0)))"
"(if(if(eqv?"
" rest-ec_0"
" '#\\.)"
"(if(check-parameter"
" 1/read-accept-dot"
" config_0)"
"(if(check-parameter"
" 1/read-accept-infix-dot"
" config_0)"
"(char-delimiter?"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_0)"
"(read-config-source"
" config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq?"
" c_1"
" 'special)"
"(special1.1"
" 'special)"
" c_1)))"
" seq-config_0)"
" #f)"
" #f)"
" #f)"
"(let-values()"
"(let-values((()"
"(begin"
"(set! head_0"
"(box"
" v_0))"
"(values))))"
"(let-values(((dot2-line_0"
" dot2-col_0"
" dot2-pos_0)"
"(port-next-location"
" in_0)))"
"(let-values((()"
"(begin"
"(track-indentation!"
" config_0"
" dot2-line_0"
" dot2-col_0)"
"(values))))"
"(let-values(((post-c_0)"
"(read-char/skip-whitespace-and-comments"
" #f"
" whitespace-read-one_0"
" in_0"
" seq-config_0)))"
"(let-values(((post-ec_0)"
"(effective-char"
" post-c_0"
" seq-config_0)))"
"(let-values(((closing-after-dot_0)"
"(lambda()"
"(begin"
" 'closing-after-dot"
"(let-values(((in31_0)"
" in_0)"
"((temp32_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0))"
"((post-ec33_0)"
" post-ec_0)"
"((temp34_0)"
"                                                                                                                                                                          \"illegal use of `.`\"))"
"(reader-error.1"
" unsafe-undefined"
" post-ec33_0"
" #f"
" unsafe-undefined"
" in31_0"
" temp32_0"
" temp34_0"
"(list)))))))"
"(loop_0"
" depth_0"
" accum_0"
" post-c_0"
" #f"
" read-one_0"
" closing-after-dot_0))))))))"
"(if(special-comment-via-readtable?"
" rest-c_0"
" read-one_0"
" in_0"
" seq-config_0)"
"(let-values()"
"(post-dot-loop_0))"
"(let-values()"
"(let-values(((in35_0)"
" in_0)"
"((temp36_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0))"
"((rest-c37_0)"
" rest-c_0)"
"((temp38_0)"
"                                                                                                                                                \"illegal use of `.`\"))"
"(reader-error.1"
" unsafe-undefined"
" rest-c37_0"
" #f"
" unsafe-undefined"
" in35_0"
" temp36_0"
" temp38_0"
"(list)))))))))))))"
" post-dot-loop_0)))))))"
"(let-values()"
"(let-values(((v_0)"
"(read-one/not-eof_0"
" c_0"
" first-read-one_1"
" config/keep-comment_0)))"
"(if(1/special-comment? v_0)"
"(let-values()"
"(loop_0"
" depth_0"
" accum_0"
" #f"
" #f"
" read-one_0"
" closing_0))"
"(if(> depth_0 1024)"
"(let-values()"
"(loop_0"
" depth_0"
"(cons v_0 accum_0)"
" #f"
" #f"
" read-one_0"
" void))"
"(let-values()"
"(cons"
" v_0"
"(loop_0"
"(add1 depth_0)"
" null"
" #f"
" #f"
" read-one_0"
" void)))))))))))))))"
" loop_0)"
" 0"
" null"
" #f"
" #t"
" first-read-one_0"
" void)))"
"(let-values(((full-seq_0)(if head_0(cons(unbox head_0) seq_0) seq_0)))"
"(if shape-tag?_0"
"(add-shape-tag opener_0 in_0 config_0 full-seq_0)"
" full-seq_0))))))))))))))))))))))))"
"(define-values"
"(add-shape-tag)"
"(lambda(opener_0 in_0 config_0 seq_0)"
"(begin"
"(let-values(((tag_0)"
"(let-values(((tmp_0) opener_0))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()(if(check-parameter 1/read-square-bracket-with-tag config_0) '#%brackets #f))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()(if(check-parameter 1/read-curly-brace-with-tag config_0) '#%braces #f))"
"(let-values() #f))))))"
"(if tag_0(cons(wrap tag_0 in_0 config_0 #f) seq_0) seq_0)))))"
"(define-values"
"(read-digits.1)"
"(lambda(base1_0 init3_0 max-count2_0 zero-digits-result4_0 in10_0 config11_0 accum-str9_0)"
"(begin"
" 'read-digits"
"(let-values(((in_0) in10_0))"
"(let-values(((config_0) config11_0))"
"(let-values(((accum-str_0) accum-str9_0))"
"(let-values(((base_0) base1_0))"
"(let-values(((max-count_0) max-count2_0))"
"(let-values(((init-v_0) init3_0))"
"(let-values(((zero-digits-result_0) zero-digits-result4_0))"
"(let-values()"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_0)(peek-char-or-special in_1 skip-count_0 'special source_0)))"
"(if(eq? c_0 'special)(special1.1 'special) c_0)))))"
"(if(digit? c_0 base_0)"
"(let-values()"
"(begin"
"(consume-char in_0 c_0)"
"(if accum-str_0(let-values()(accum-string-add! accum-str_0 c_0))(void))"
"((letrec-values(((loop_0)"
"(lambda(v_0 max-count_1)"
"(begin"
" 'loop"
"(if(zero? max-count_1)"
"(let-values() v_0)"
"(let-values()"
"(let-values(((c_1)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)"
"(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)"
"(special1.1 'special)"
" c_1)))))"
"(if(digit? c_1 base_0)"
"(let-values()"
"(begin"
"(consume-char in_0 c_1)"
"(if accum-str_0"
"(let-values()(accum-string-add! accum-str_0 c_1))"
"(void))"
"(loop_0"
"(+(digit->number c_1)(* v_0 base_0))"
"(sub1 max-count_1))))"
"(let-values() v_0)))))))))"
" loop_0)"
"(+(digit->number c_0)(* init-v_0 base_0))"
"(sub1 max-count_0))))"
"(if zero-digits-result_0"
"(let-values() zero-digits-result_0)"
"(let-values() c_0)))))))))))))))"
"(define-values"
"(digit?)"
"(lambda(c_0 base_0)"
"(begin"
"(if(not(char? c_0))"
"(let-values() #f)"
"(if(= base_0 8)"
"(let-values()(octal-digit? c_0))"
"(if(= base_0 16)(let-values()(hex-digit? c_0))(let-values()(decimal-digit? c_0))))))))"
"(define-values(decimal-digit?)(lambda(c_0)(begin(if(char>=? c_0 '#\\0)(char<=? c_0 '#\\9) #f))))"
"(define-values(octal-digit?)(lambda(c_0)(begin(if(char>=? c_0 '#\\0)(char<=? c_0 '#\\7) #f))))"
"(define-values"
"(hex-digit?)"
"(lambda(c_0)"
"(begin"
"(let-values(((or-part_0)(if(char>=? c_0 '#\\0)(char<=? c_0 '#\\9) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(char>=? c_0 '#\\A)(char<=? c_0 '#\\F) #f)))"
"(if or-part_1 or-part_1(if(char>=? c_0 '#\\a)(char<=? c_0 '#\\f) #f))))))))"
"(define-values"
"(digit->number)"
"(lambda(c_0)"
"(begin"
"(if(if(char>=? c_0 '#\\0)(char<=? c_0 '#\\9) #f)"
"(let-values()(-(char->integer c_0)(char->integer '#\\0)))"
"(if(if(char>=? c_0 '#\\A)(char<=? c_0 '#\\F) #f)"
"(let-values()(-(char->integer c_0)(-(char->integer '#\\A) 10)))"
"(let-values()(-(char->integer c_0)(-(char->integer '#\\a) 10))))))))"
"(define-values"
"(maybe-digit)"
"(lambda(c_0 radix_0)"
"(begin"
"(let-values(((v_0)(char->integer c_0)))"
"(if(fx< v_0(char->integer '#\\0))"
"(let-values() c_0)"
"(if(fx< v_0(fx+(fxmin radix_0 10)(char->integer '#\\0)))"
"(let-values()(fx- v_0(char->integer '#\\0)))"
"(if(fx<= radix_0 10)"
"(let-values() c_0)"
"(if(fx< v_0(char->integer '#\\A))"
"(let-values() c_0)"
"(if(fx< v_0(+ radix_0(-(char->integer '#\\A) 10)))"
"(let-values()(fx- v_0(-(char->integer '#\\A) 10)))"
"(if(fx< v_0(char->integer '#\\a))"
"(let-values() c_0)"
"(if(fx< v_0(+ radix_0(-(char->integer '#\\a) 10)))"
"(let-values()(fx- v_0(-(char->integer '#\\a) 10)))"
"(let-values() c_0))))))))))))"
"(define-values(string->number$1) string->number)"
"(define-values"
"(1/string->number)"
"(let-values(((string->number_0)"
"(lambda(s5_0 radix1_0 convert-mode2_0 decimal-mode3_0 single-mode4_0)"
"(begin"
" 'string->number"
"(let-values(((s_0) s5_0))"
"(let-values(((radix_0) radix1_0))"
"(let-values(((convert-mode_0) convert-mode2_0))"
"(let-values(((decimal-mode_0)"
"(if(eq? decimal-mode3_0 unsafe-undefined)"
"(if(1/read-decimal-as-inexact) 'decimal-as-inexact 'decimal-as-exact)"
" decimal-mode3_0)))"
"(let-values(((single-mode_0)"
"(if(eq? single-mode4_0 unsafe-undefined)"
"(if(1/read-single-flonum) 'single 'double)"
" single-mode4_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(string? s_0)"
"(void)"
"                                        (let-values () (raise-argument-error 'string->number \"string?\" s_0)))"
"(if((lambda(p_0)(if(exact-integer? radix_0)(<= 2 radix_0 16) #f)) radix_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'string->number \"(integer-in 2 16)\" radix_0)))"
"(if((lambda(p_0)"
"(let-values(((or-part_0)(eq? p_0 'number-or-false)))"
"(if or-part_0 or-part_0(eq? p_0 'read))))"
" convert-mode_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'string->number"
"                                           \"(or/c 'number-or-false 'read)\""
" convert-mode_0)))"
"(if((lambda(p_0)"
"(let-values(((or-part_0)(eq? p_0 'decimal-as-inexact)))"
"(if or-part_0 or-part_0(eq? p_0 'decimal-as-exact))))"
" decimal-mode_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'string->number"
"                                           \"(or/c 'decimal-as-inexact 'decimal-as-exact)\""
" decimal-mode_0)))"
"(if((lambda(p_0)"
"(let-values(((or-part_0)(eq? p_0 'single)))"
"(if or-part_0 or-part_0(eq? p_0 'double))))"
" single-mode_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'string->number"
"                                           \"(or/c 'single 'double)\""
" single-mode_0)))"
"(unchecked-string->number"
" s_0"
" radix_0"
" convert-mode_0"
" decimal-mode_0"
" single-mode_0))))))))))))))"
"(case-lambda"
"((s_0)(begin 'string->number(string->number_0 s_0 10 'number-or-false unsafe-undefined unsafe-undefined)))"
"((s_0 radix_0 convert-mode_0 decimal-mode_0 single-mode4_0)"
"(string->number_0 s_0 radix_0 convert-mode_0 decimal-mode_0 single-mode4_0))"
"((s_0 radix_0 convert-mode_0 decimal-mode3_0)"
"(string->number_0 s_0 radix_0 convert-mode_0 decimal-mode3_0 unsafe-undefined))"
"((s_0 radix_0 convert-mode2_0)(string->number_0 s_0 radix_0 convert-mode2_0 unsafe-undefined unsafe-undefined))"
"((s_0 radix1_0)(string->number_0 s_0 radix1_0 'number-or-false unsafe-undefined unsafe-undefined)))))"
"(define-values"
"(unchecked-string->number)"
"(lambda(s_0 radix_0 convert-mode_0 decimal-mode_0 single-mode_0)"
"(begin"
"(let-values(((s44_0) s_0)"
"((temp45_0) 0)"
"((temp46_0)(string-length s_0))"
"((radix47_0) radix_0)"
"((temp48_0) #f)"
"((decimal-mode49_0) decimal-mode_0)"
"((convert-mode50_0) convert-mode_0)"
"((single-mode51_0) single-mode_0))"
"(do-string->number.1"
" temp48_0"
" s44_0"
" temp45_0"
" temp46_0"
" radix47_0"
" decimal-mode49_0"
" convert-mode50_0"
" single-mode51_0)))))"
"(define-values"
"(struct:parse-state"
" parse-state6.1"
" parse-state?"
" parse-state-exactness"
" parse-state-convert-mode"
" parse-state-can-single?"
" parse-state-fst"
" parse-state-other-exactness)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parse-state"
" #f"
" 5"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4)"
" #f"
" 'parse-state)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'exactness)"
"(make-struct-field-accessor -ref_0 1 'convert-mode)"
"(make-struct-field-accessor -ref_0 2 'can-single?)"
"(make-struct-field-accessor -ref_0 3 'fst)"
"(make-struct-field-accessor -ref_0 4 'other-exactness))))"
"(define-values"
"(struct:rect-prefix rect-prefix7.1 rect-prefix? rect-prefix-sgn/z rect-prefix-n rect-prefix-start)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'rect-prefix"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'rect-prefix)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'sgn/z)"
"(make-struct-field-accessor -ref_0 1 'n)"
"(make-struct-field-accessor -ref_0 2 'start))))"
"(define-values"
"(struct:polar-prefix polar-prefix8.1 polar-prefix? polar-prefix-sgn/z polar-prefix-n polar-prefix-start)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'polar-prefix"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'polar-prefix)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'sgn/z)"
"(make-struct-field-accessor -ref_0 1 'n)"
"(make-struct-field-accessor -ref_0 2 'start))))"
"(define-values"
"(init-state)"
"(lambda(exactness_0 convert-mode_0 single-mode_0 fst_0)"
"(begin(parse-state6.1 exactness_0 convert-mode_0(eq? single-mode_0 'single) fst_0 exactness_0))))"
"(define-values"
"(state-has-first-half?)"
"(lambda(state_0)(begin(let-values(((fst_0)(parse-state-fst state_0)))(if fst_0(not(eq? fst_0 '+/-)) #f)))))"
"(define-values"
"(state-set-first-half)"
"(lambda(state_0 fst_0)"
"(begin"
"(let-values(((the-struct_0) state_0))"
"(if(parse-state? the-struct_0)"
"(let-values(((fst55_0) fst_0)"
"((exactness56_0)(parse-state-other-exactness state_0))"
"((other-exactness57_0)(parse-state-exactness state_0)))"
"(parse-state6.1"
" exactness56_0"
"(parse-state-convert-mode the-struct_0)"
"(parse-state-can-single? the-struct_0)"
" fst55_0"
" other-exactness57_0))"
"          (raise-argument-error 'struct-copy \"parse-state?\" the-struct_0))))))"
"(define-values"
"(state-first-half)"
"(lambda(state_0)"
"(begin"
"(init-state"
"(parse-state-other-exactness state_0)"
"(parse-state-convert-mode state_0)"
"(if(parse-state-can-single? state_0) 'single 'double)"
" #f))))"
"(define-values"
"(state-second-half)"
"(lambda(state_0)"
"(begin"
"(init-state"
"(parse-state-exactness state_0)"
"(parse-state-convert-mode state_0)"
"(if(parse-state-can-single? state_0) 'single 'double)"
" #f))))"
"(define-values"
"(state->convert-mode)"
"(lambda(state_0)(begin(if(parse-state? state_0)(parse-state-convert-mode state_0) state_0))))"
"(define-values"
"(state->dbz-convert-mode)"
"(lambda(state_0)"
"(begin"
"(let-values(((convert-mode_0)(parse-state-convert-mode state_0)))"
"(if(eq? convert-mode_0 'read) 'must-read convert-mode_0)))))"
"(define-values"
"(bad-digit)"
"(lambda(c_0 s_0 state_0)"
"(begin"
"(if(char=? c_0 '#\\nul)"
"(let-values()"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"            (let-values () (format \"nul character in `~.a`\" s_0))"
"(let-values() #f)))"
"(let-values()"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"            (let-values () (format \"bad digit `~a`\" c_0))"
"(let-values() #f)))))))"
"(define-values"
"(bad-mixed-decimal-fraction)"
"(lambda(s_0 state_0)"
"(begin"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"        (let-values () (format \"decimal points and fractions cannot be mixed in `~.a`\" s_0))"
"(let-values() #f)))))"
"(define-values"
"(bad-misplaced)"
"(lambda(what_0 s_0 state_0)"
"(begin"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"        (let-values () (format \"misplaced `~a` in `~.a`\" what_0 s_0))"
"(let-values() #f)))))"
"(define-values"
"(bad-no-digits)"
"(lambda(after_0 s_0 state_0)"
"(begin"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"        (let-values () (format \"missing digits after `~a` in `~.a`\" after_0 s_0))"
"(let-values() #f)))))"
"(define-values"
"(bad-extflonum-for-complex)"
"(lambda(i_0 s_0 state_0)"
"(begin"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"        (let-values () (format \"cannot combine extflonum `~a` into a complex number\" i_0))"
"(let-values() #f)))))"
"(define-values"
"(struct:lazy-expt lazy-expt9.1 lazy-expt? lazy-expt-n lazy-expt-radix lazy-expt-exp)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'lazy-expt"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'lazy-expt)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'n)"
"(make-struct-field-accessor -ref_0 1 'radix)"
"(make-struct-field-accessor -ref_0 2 'exp))))"
"(define-values"
"(struct:lazy-rational lazy-rational10.1 lazy-rational? lazy-rational-n lazy-rational-d)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'lazy-rational"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'lazy-rational)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'n)(make-struct-field-accessor -ref_0 1 'd))))"
"(define-values"
"(lazy-number)"
"(lambda(n_0 radix_0 exp_0)"
"(begin"
"(if(eq? n_0 'dbz)"
"(let-values() n_0)"
"(if(eq? n_0 'dbz!)"
"(let-values() n_0)"
"(let-values()"
"(if(if(< exp_0 30)(> exp_0 -30) #f)(* n_0(expt radix_0 exp_0))(lazy-expt9.1 n_0 radix_0 exp_0))))))))"
"(define-values"
"(lazy-divide)"
"(lambda(n_0 d_0 d-exactness_0)"
"(begin"
"(if(eqv? d_0 0)"
"(let-values()(if(eq? d-exactness_0 'exact) 'dbz! 'dbz))"
"(if(let-values(((or-part_0)(lazy-expt? n_0)))(if or-part_0 or-part_0(lazy-expt? d_0)))"
"(let-values()(lazy-rational10.1 n_0 d_0))"
"(let-values()(/ n_0 d_0)))))))"
"(define-values"
"(simplify-lazy-divide)"
"(lambda(n0_0)"
"(begin"
"(if(lazy-rational? n0_0)"
"(let-values()"
"(let-values(((n_0)(lazy-rational-n n0_0)))"
"(let-values(((d_0)(lazy-rational-d n0_0)))"
"(let-values(((n-n_0)(if(lazy-expt? n_0)(lazy-expt-n n_0) n_0)))"
"(let-values(((n-exp_0)(if(lazy-expt? n_0)(lazy-expt-exp n_0) 0)))"
"(let-values(((d-n_0)(if(lazy-expt? d_0)(lazy-expt-n d_0) d_0)))"
"(let-values(((d-exp_0)(if(lazy-expt? d_0)(lazy-expt-exp d_0) 0)))"
"(let-values(((radix_0)(if(lazy-expt? n_0)(lazy-expt-radix n_0)(lazy-expt-radix d_0))))"
"(lazy-number(/ n-n_0 d-n_0) radix_0(- n-exp_0 d-exp_0))))))))))"
"(let-values() n0_0)))))"
"(define-values"
"(force-lazy-exact)"
"(lambda(n0_0 state_0 s_0)"
"(begin"
"(let-values(((n_0)(simplify-lazy-divide n0_0)))"
"(if(let-values(((or-part_0)(eq? n_0 'dbz)))(if or-part_0 or-part_0(eq? n_0 'dbz!)))"
"(let-values()"
"(if(eq?(state->convert-mode(state->dbz-convert-mode state_0)) 'must-read)"
"              (let-values () (format \"division by zero in `~.a`\" s_0))"
"(let-values() #f)))"
"(if(lazy-expt? n_0)"
"(let-values()(*(lazy-expt-n n_0)(expt(lazy-expt-radix n_0)(lazy-expt-exp n_0))))"
"(let-values() n_0)))))))"
"(define-values"
"(force-lazy-inexact)"
"(let-values(((force-lazy-inexact_0)"
"(lambda(sgn/z12_0 n013_0 state14_0 s15_0 precision11_0)"
"(begin"
" 'force-lazy-inexact"
"(let-values(((sgn/z_0) sgn/z12_0))"
"(let-values(((n0_0) n013_0))"
"(let-values(((state_0) state14_0))"
"(let-values(((s_0) s15_0))"
"(let-values(((precision_0) precision11_0))"
"(let-values()"
"(let-values(((n1_0)(simplify-lazy-divide n0_0)))"
"(if(eq? n0_0 'dbz)"
"(let-values()(if(fx= sgn/z_0 -1) -inf.0 +inf.0))"
"(if(eq? n0_0 'dbz!)"
"(let-values()"
"(if(eq?(state->convert-mode(state->dbz-convert-mode state_0)) 'must-read)"
"                                          (let-values () (format \"division by zero in `~.a`\" s_0))"
"(let-values() #f)))"
"(if(lazy-expt? n1_0)"
"(let-values()"
"(let-values(((n_0)(lazy-expt-n n1_0)))"
"(let-values(((exp_0)(lazy-expt-exp n1_0)))"
"(let-values(((radix_0)(lazy-expt-radix n1_0)))"
"(let-values(((approx-expt_0)"
"(+"
"(/"
"(if(integer? n_0)"
"(integer-length n_0)"
"(-"
"(integer-length(numerator n_0))"
"(integer-length(denominator n_0))))"
"(log radix_0 2))"
" exp_0)))"
"(if(eqv? n_0 0)"
"(let-values()(if(fx= sgn/z_0 -1)(- 0.0) 0.0))"
"(if(> approx-expt_0 precision_0)"
"(let-values()(if(fx= sgn/z_0 -1) -inf.0 +inf.0))"
"(if(< approx-expt_0(- precision_0))"
"(let-values()(if(fx= sgn/z_0 -1)(- 0.0) 0.0))"
"(let-values()(* n_0(expt radix_0 exp_0)))))))))))"
"(if(eqv? n1_0 0)"
"(let-values()(if(fx= sgn/z_0 -1)(- 0.0) 0.0))"
"(let-values() n1_0))))))))))))))))"
"(case-lambda"
"((sgn/z_0 n0_0 state_0 s_0)(begin(force-lazy-inexact_0 sgn/z_0 n0_0 state_0 s_0 2048)))"
"((sgn/z_0 n0_0 state_0 s_0 precision11_0)(force-lazy-inexact_0 sgn/z_0 n0_0 state_0 s_0 precision11_0)))))"
"(define-values"
"(fast-inexact)"
"(lambda(state_0 sgn_0 n_0 radix_0 exp_0 sgn2_0 exp2_0)"
"(begin"
"(let-values(((tmp_0)(parse-state-exactness state_0)))"
"(if(if(equal? tmp_0 'double) #t(equal? tmp_0 'approx))"
"(let-values()"
"(if(state-has-first-half? state_0)"
"(let-values() #f)"
"(if(eqv? n_0 0)"
"(let-values()(if(fx= sgn_0 1) 0.0(- 0.0)))"
"(if(if(fixnum? n_0)(if(< n_0(expt 2 50))(> n_0(-(expt 2 50))) #f) #f)"
"(let-values()"
"(let-values(((exp_1)(+ exp_0(* sgn2_0 exp2_0))))"
"(if(if(fixnum? exp_1)"
"(if(fx<= radix_0 10)"
"(let-values()(fx<= -15 exp_1 15))"
"(let-values()(fx<= -12 exp_1 12)))"
" #f)"
"(let-values()"
"(let-values(((m_0)(fx->fl(if(fx= sgn_0 -1)(fx- 0 n_0) n_0))))"
"(if(eqv? exp_1 0)"
"(let-values() m_0)"
"(if(not(fixnum? exp_1))"
"(let-values() #f)"
"(let-values()"
"(let-values(((fradix_0)(if(fx= radix_0 10) 10.0(fx->fl radix_0))))"
"(if(fx< exp_1 0)"
"(let-values()(/ m_0(expt fradix_0(fx- 0 exp_1))))"
"(let-values()(* m_0(expt fradix_0 exp_1))))))))))"
"(let-values() #f))))"
"(let-values() #f)))))"
"(let-values() #f))))))"
"(define-values"
"(finish.1)"
"(lambda(range16_0 sgn/z18_0 n19_0 s20_0 state21_0)"
"(begin"
" 'finish"
"(let-values(((sgn/z_0) sgn/z18_0))"
"(let-values(((n_0) n19_0))"
"(let-values(((s_0) s20_0))"
"(let-values(((state_0) state21_0))"
"(let-values(((range_0) range16_0))"
"(let-values()"
"(let-values(((fst_0)(parse-state-fst state_0)))"
"(if(let-values(((or-part_0)(not fst_0)))(if or-part_0 or-part_0(eq? fst_0 '+/-)))"
"(let-values()"
"(let-values(((tmp_0)(parse-state-exactness state_0)))"
"(if(equal? tmp_0 'single)"
"(let-values()"
"(let-values(((v_0)(force-lazy-inexact sgn/z_0 n_0 state_0 s_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(r_0)"
"(if(parse-state-can-single? state_0)"
"(if(single-flonum-available?)"
"(real->single-flonum r_0)"
"(raise"
"(exn:fail:unsupported"
"(string-append"
"                                            \"read: single-flonums are not supported on this platform\\n\""
"                                            \"  conversion from: \""
"(number->string r_0))"
"(current-continuation-marks))))"
"(exact->inexact r_0)))"
" v_0))))"
"(if(equal? tmp_0 'exact)"
"(let-values()"
"(let-values(((tmp_1) n_0))"
"(if(if(equal? tmp_1 +inf.0) #t(if(equal? tmp_1 -inf.0) #t(equal? tmp_1 +nan.0)))"
"(let-values()"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"                                        (let-values () (format \"no exact representation for ~a\" n_0))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((v_0)(force-lazy-exact n_0 state_0 s_0)))"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(r_0)(inexact->exact r_0)) v_0)))))))"
"(if(equal? tmp_0 'extended)"
"(let-values()"
"(if(eq?(parse-state-convert-mode state_0) 'number-or-false)"
"(let-values() #f)"
"(if(extflonum-available?)"
"(let-values()"
"(let-values(((v_0)(force-lazy-inexact sgn/z_0 n_0 state_0 s_0 32768)))"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(r_0)(real->extfl r_0)) v_0))))"
"(let-values()"
"(let-values(((trim-s_0)"
"(trim-number"
" s_0"
"(if range_0(car range_0) 0)"
"(if range_0(cdr range_0)(string-length s_0)))))"
"(string->number$1 trim-s_0 10 'read))))))"
"(if(if(equal? tmp_0 'double)"
" #t"
"(if(equal? tmp_0 'inexact) #t(equal? tmp_0 'approx)))"
"(let-values()"
"(let-values(((v_0)(force-lazy-inexact sgn/z_0 n_0 state_0 s_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(r0_0)(exact->inexact r0_0)) v_0))))"
"(if(equal? tmp_0 'extflonum->inexact)"
"(let-values()"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"                                        (let-values () (format \"cannot convert extflonum to inexact in `~a`\" s_0))"
"(let-values() #f)))"
"(if(equal? tmp_0 'extflonum->exact)"
"(let-values()"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"                                          (let-values () (format \"cannot convert extflonum to exact in `~a`\" s_0))"
"(let-values() #f)))"
"(let-values()(force-lazy-exact n_0 state_0 s_0))))))))))"
"(if(polar-prefix? fst_0)"
"(let-values()"
"(let-values(((pos_0)(polar-prefix-start fst_0)))"
"(let-values(((m_0)"
"(let-values(((temp60_0)(polar-prefix-sgn/z fst_0))"
"((temp61_0)(polar-prefix-n fst_0))"
"((s62_0) s_0)"
"((temp63_0)(state-first-half state_0))"
"((temp64_0)(cons 0 pos_0)))"
"(finish.1 temp64_0 temp60_0 temp61_0 s62_0 temp63_0))))"
"(let-values(((a_0)"
"(let-values(((sgn/z65_0) sgn/z_0)"
"((n66_0) n_0)"
"((s67_0) s_0)"
"((temp68_0)(state-second-half state_0))"
"((temp69_0)(cons pos_0(string-length s_0))))"
"(finish.1 temp69_0 sgn/z65_0 n66_0 s67_0 temp68_0))))"
"(if(extflonum? m_0)"
"(let-values()(bad-extflonum-for-complex m_0 s_0 state_0))"
"(if(extflonum? a_0)"
"(let-values()(bad-extflonum-for-complex a_0 s_0 state_0))"
"(let-values()"
"(let-values(((v_0) m_0))"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(m_1)"
"(let-values(((v_1) a_0))"
"(if(let-values(((or-part_0)(not v_1)))"
"(if or-part_0 or-part_0(string? v_1)))"
" v_1"
"((lambda(a_1)"
"(let-values(((cn_0)(make-polar m_1 a_1)))"
"(let-values(((tmp_0)(parse-state-exactness state_0)))"
"(if(equal? tmp_0 'exact)"
"(let-values()(inexact->exact cn_0))"
"(let-values() cn_0)))))"
" v_1))))"
" v_0))))))))))"
"(if fst_0"
"(let-values()"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"                              (let-values () (format \"missing `i` for complex number in `~.a`\" s_0))"
"(let-values() #f)))"
"(void))))))))))))))"
"(define-values"
"(finish-imaginary)"
"(lambda(sgn/z_0 n_0 s_0 start_0 end_0 state_0)"
"(begin"
"(let-values(((fst_0)(parse-state-fst state_0)))"
"(if(if(eq? fst_0 '+/-)(fx= start_0 end_0) #f)"
"(let-values()"
"(let-values(((v_0)"
"(let-values(((sgn/z70_0) sgn/z_0)((n71_0) n_0)((s72_0) s_0)((state73_0) state_0))"
"(finish.1 #f sgn/z70_0 n71_0 s72_0 state73_0))))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(i_0)"
"(if(extflonum? i_0)"
"(let-values()(bad-extflonum-for-complex i_0 s_0 state_0))"
"(let-values()"
"(let-values(((zero_0)"
"(let-values(((tmp_0)(parse-state-other-exactness state_0)))"
"(if(equal? tmp_0 'inexact)(let-values() 0.0)(let-values() 0)))))"
"(make-rectangular zero_0 i_0)))))"
" v_0))))"
"(if(if(rect-prefix? fst_0)(fx= start_0 end_0) #f)"
"(let-values()"
"(let-values(((pos_0)(rect-prefix-start fst_0)))"
"(let-values(((r_0)"
"(let-values(((temp74_0)(rect-prefix-sgn/z fst_0))"
"((temp75_0)(rect-prefix-n fst_0))"
"((s76_0) s_0)"
"((temp77_0)(state-first-half state_0))"
"((temp78_0)(cons 0 pos_0)))"
"(finish.1 temp78_0 temp74_0 temp75_0 s76_0 temp77_0))))"
"(let-values(((i_0)"
"(let-values(((sgn/z79_0) sgn/z_0)"
"((n80_0) n_0)"
"((s81_0) s_0)"
"((temp82_0)(state-second-half state_0))"
"((temp83_0)(cons pos_0(string-length s_0))))"
"(finish.1 temp83_0 sgn/z79_0 n80_0 s81_0 temp82_0))))"
"(if(extflonum? r_0)"
"(let-values()(bad-extflonum-for-complex r_0 s_0 state_0))"
"(if(extflonum? i_0)"
"(let-values()(bad-extflonum-for-complex r_0 i_0 state_0))"
"(let-values()"
"(let-values(((v_0) r_0))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(r_1)"
"(let-values(((v_1) i_0))"
"(if(let-values(((or-part_0)(not v_1)))(if or-part_0 or-part_0(string? v_1)))"
" v_1"
"((lambda(i_1)(make-rectangular r_1 i_1)) v_1))))"
" v_0))))))))))"
"            (let-values () (bad-misplaced \"i\" s_0 state_0))))))))"
"(define-values"
"(set-exactness.1)"
"(lambda(override?23_0 state25_0 new-exactness26_0)"
"(begin"
" 'set-exactness"
"(let-values(((state_0) state25_0))"
"(let-values(((new-exactness_0) new-exactness26_0))"
"(let-values(((override?_0) override?23_0))"
"(let-values()"
"(let-values(((exactness_0)(parse-state-exactness state_0)))"
"(let-values(((result-exactness_0)"
"(let-values(((tmp_0) new-exactness_0))"
"(if(if(equal? tmp_0 'single) #t(equal? tmp_0 'double))"
"(let-values()"
"(let-values(((tmp_1) exactness_0))"
"(if(equal? tmp_1 'exact)"
"(let-values() 'exact)"
"(if(equal? tmp_1 'decimal-as-exact)"
"(let-values()(if override?_0 new-exactness_0 'decimal-as-exact))"
"(let-values() new-exactness_0)))))"
"(if(equal? tmp_0 'approx)"
"(let-values()"
"(let-values(((tmp_1) exactness_0))"
"(if(if(equal? tmp_1 'exact)"
" #t"
"(if(equal? tmp_1 'inexact) #t(equal? tmp_1 'decimal-as-exact)))"
"(let-values() exactness_0)"
"(let-values() new-exactness_0))))"
"(if(equal? tmp_0 'extended)"
"(let-values()"
"(let-values(((tmp_1) exactness_0))"
"(if(equal? tmp_1 'inexact)"
"(let-values() 'extflonum->inexact)"
"(if(equal? tmp_1 'exact)"
"(let-values() 'extflonum->exact)"
"(let-values() 'extended)))))"
"(let-values() new-exactness_0)))))))"
"(if(eq? exactness_0 result-exactness_0)"
" state_0"
"(let-values(((the-struct_0) state_0))"
"(if(parse-state? the-struct_0)"
"(let-values(((exactness84_0) result-exactness_0))"
"(parse-state6.1"
" exactness84_0"
"(parse-state-convert-mode the-struct_0)"
"(parse-state-can-single? the-struct_0)"
"(parse-state-fst the-struct_0)"
"(parse-state-other-exactness the-struct_0)))"
"                        (raise-argument-error 'struct-copy \"parse-state?\" the-struct_0)))))))))))))"
"(define-values"
"(set-exactness-by-char.1)"
"(lambda(override?28_0 state30_0 c31_0)"
"(begin"
" 'set-exactness-by-char"
"(let-values(((state_0) state30_0))"
"(let-values(((c_0) c31_0))"
"(let-values(((override?_0) override?28_0))"
"(let-values()"
"(let-values(((state85_0) state_0)"
"((temp86_0)"
"(let-values(((tmp_0) c_0))"
"(let-values(((index_0)"
"(if(char? tmp_0)"
"(let-values(((codepoint_0)(char->integer tmp_0)))"
"(if(if(unsafe-fx>= codepoint_0 48)(unsafe-fx< codepoint_0 117) #f)"
"(let-values(((tbl_0)"
" '#(1"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 1"
" 1"
" 2"
" 0"
" 0"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 2"
" 3"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 1"
" 1"
" 2"
" 0"
" 0"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 2"
" 3)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 48)))"
" 0))"
" 0)))"
"(if(unsafe-fx< index_0 1)"
"(let-values()(void))"
"(if(unsafe-fx< index_0 2)"
"(let-values() 'double)"
"(if(unsafe-fx< index_0 3)(let-values() 'single)(let-values() 'extended)))))))"
"((override?87_0) override?_0))"
"(set-exactness.1 override?87_0 state85_0 temp86_0)))))))))"
"(define-values"
"(trim-number)"
"(lambda(s_0 start_0 end_0)"
"(begin"
"(if(eqv?(string-ref s_0 start_0) '#\\#)"
"(let-values()(trim-number s_0(fx+ 2 start_0) end_0))"
"(if(let-values(((c_0)(string-ref s_0(fx- end_0 1))))"
"(let-values(((or-part_0)(eqv? c_0 '#\\i)))(if or-part_0 or-part_0(eqv? c_0 '#\\I))))"
"(let-values()(trim-number s_0 start_0(fx- end_0 1)))"
"(let-values()(substring s_0 start_0 end_0)))))))"
"(define-values"
"(add-digit)"
"(lambda(d_0 c_0 radix_0)"
"(begin"
"(if(pair? d_0)"
"(let-values()"
"(let-values(((p_0)(car d_0)))"
"(let-values(((digits_0)(add-digit(car p_0) c_0 radix_0)))"
"(if(pair? digits_0)"
"(list*(car digits_0)(cons(cdr digits_0)(cdr p_0))(cdr d_0))"
"(cons(cons digits_0(fx+ 1(cdr p_0)))(cdr d_0))))))"
"(if(eqv? d_0 0)"
"(let-values() c_0)"
"(if(< d_0(expt 2 100))(let-values()(+(* d_0 radix_0) c_0))(let-values()(cons(cons c_0 1) d_0))))))))"
"(define-values"
"(digits->integer)"
"(lambda(d_0 radix_0)"
"(begin"
"(if(pair? d_0)"
"(let-values()"
"(let-values(((len_0)"
"((letrec-values(((loop_0)"
"(lambda(d_1)(begin 'loop(if(pair? d_1)(fx+ 1(loop_0(cdr d_1))) 1)))))"
" loop_0)"
" d_0)))"
"((letrec-values(((loop_0)"
"(lambda(d_1 len_1)"
"(begin"
" 'loop"
"(if(fx= len_1 1)"
"(let-values()(if(pair? d_1)(caar d_1) d_1))"
"(let-values()"
"(let-values(((hi-len_0)(fxrshift len_1 1)))"
"(let-values(((lo-len_0)(fx- len_1 hi-len_0)))"
"(let-values(((hi_0)(loop_0 d_1 hi-len_0)))"
"((letrec-values(((split-loop_0)"
"(lambda(shift_0 hi-len_1 d_2)"
"(begin"
" 'split-loop"
"(if(fx= hi-len_1 0)"
"(+"
" hi_0"
"(*(expt radix_0 shift_0)(loop_0 d_2 lo-len_0)))"
"(split-loop_0"
"(fx+ shift_0(cdar d_2))"
"(fx- hi-len_1 1)"
"(cdr d_2)))))))"
" split-loop_0)"
" 0"
" hi-len_0"
" d_1))))))))))"
" loop_0)"
" d_0"
" len_0)))"
"(let-values() d_0)))))"
"(define-values"
"(do-string->number.1)"
"(lambda(radix-set?33_0 s35_0 start36_0 end37_0 radix38_0 exactness39_0 convert-mode40_0 single-mode41_0)"
"(begin"
" 'do-string->number"
"(let-values(((s_0) s35_0))"
"(let-values(((start_0) start36_0))"
"(let-values(((end_0) end37_0))"
"(let-values(((radix_0) radix38_0))"
"(let-values(((radix-set?_0) radix-set?33_0))"
"(let-values(((exactness_0) exactness39_0))"
"(let-values(((convert-mode_0) convert-mode40_0))"
"(let-values(((single-mode_0) single-mode41_0))"
"(let-values()"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(if(eq?(state->convert-mode convert-mode_0) 'must-read)"
"                                (let-values () (format \"no digits\"))"
"(let-values() #f)))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-integer"
" 1"
" c_0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(init-state exactness_0 convert-mode_0 single-mode_0 #f)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\#)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((next_0)(fx+ 1 start_0)))"
"(let-values(((i_0)"
"(if(fx= next_0 end_0)"
" 'eof"
"(let-values(((c_1)(string-ref s_0 next_0)))"
"(maybe-digit c_1 10)))))"
"(if(let-values(((or-part_0)(eqv? i_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(if(eq?(state->convert-mode convert-mode_0) 'must-read)"
"                                            (let-values () (format \"no character after `#` indicator in `~.a`\" s_0))"
"(let-values() #f)))"
"(if(let-values(((or-part_0)(eqv? i_0 '#\\e)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? i_0 '#\\E)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? i_0 '#\\i)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? i_0 '#\\I)))"
"(if or-part_3 or-part_3 #f))))))))"
"(let-values()"
"(if(let-values(((or-part_0)(eq? exactness_0 'exact)))"
"(if or-part_0 or-part_0(eq? exactness_0 'inexact)))"
"(let-values()"
"(if(eq?(state->convert-mode convert-mode_0) 'must-read)"
"(let-values()"
"(format"
"                                                     \"misplaced exactness specification at `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((s88_0) s_0)"
"((temp89_0)(fx+ 1 next_0))"
"((end90_0) end_0)"
"((radix91_0) radix_0)"
"((radix-set?92_0) radix-set?_0)"
"((temp93_0)"
"(if(let-values(((or-part_0)(char=? i_0 '#\\e)))"
"(if or-part_0 or-part_0(char=? i_0 '#\\E)))"
" 'exact"
" 'inexact))"
"((temp94_0)"
"(if(eq? convert-mode_0 'read) 'must-read convert-mode_0))"
"((single-mode95_0) single-mode_0))"
"(do-string->number.1"
" radix-set?92_0"
" s88_0"
" temp89_0"
" end90_0"
" radix91_0"
" temp93_0"
" temp94_0"
" single-mode95_0)))))"
"(if(let-values(((or-part_0)(eqv? i_0 '#\\b)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? i_0 '#\\B)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? i_0 '#\\o)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? i_0 '#\\O)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(eqv? i_0 '#\\d)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(eqv? i_0 '#\\D)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(eqv? i_0 '#\\x)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(eqv? i_0 '#\\X)))"
"(if or-part_7 or-part_7 #f))))))))))))))))"
"(let-values()"
"(if radix-set?_0"
"(let-values()"
"(if(eq?(state->convert-mode convert-mode_0) 'must-read)"
"(let-values()"
"(format"
"                                                       \"misplaced radix specification at `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((radix_1)"
"(let-values(((tmp_0) i_0))"
"(if(if(equal? tmp_0 '#\\b) #t(equal? tmp_0 '#\\B))"
"(let-values() 2)"
"(if(if(equal? tmp_0 '#\\o) #t(equal? tmp_0 '#\\O))"
"(let-values() 8)"
"(if(if(equal? tmp_0 '#\\d)"
" #t"
"(equal? tmp_0 '#\\D))"
"(let-values() 10)"
"(let-values() 16)))))))"
"(let-values(((s96_0) s_0)"
"((temp97_0)(fx+ 1 next_0))"
"((end98_0) end_0)"
"((radix99_0) radix_1)"
"((temp100_0) #t)"
"((exactness101_0) exactness_0)"
"((temp102_0)"
"(if(eq? convert-mode_0 'read)"
" 'must-read"
" convert-mode_0))"
"((single-mode103_0) single-mode_0))"
"(do-string->number.1"
" temp100_0"
" s96_0"
" temp97_0"
" end98_0"
" radix99_0"
" exactness101_0"
" temp102_0"
" single-mode103_0))))))"
"(let-values()"
"(if(eq?"
"(state->convert-mode"
"(if(eq? convert-mode_0 'read) 'must-read convert-mode_0))"
" 'must-read)"
"(let-values()"
"(format"
"                                                   \"bad `#` indicator `~a` at `~.a`\""
" i_0"
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))))))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-signed"
" 1"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(init-state exactness_0 convert-mode_0 single-mode_0 '+/-)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\-)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-signed"
" -1"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(init-state exactness_0 convert-mode_0 single-mode_0 '+/-)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-decimal"
" 1"
" #f"
" 0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((temp104_0)"
"(init-state exactness_0 convert-mode_0 single-mode_0 #f))"
"((temp105_0) 'approx))"
"(set-exactness.1 #f temp104_0 temp105_0))))"
"(let-values()(bad-digit c_0 s_0 convert-mode_0)))))))))))))))))))))"
"(define-values"
"(read-signed)"
"(lambda(sgn_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"              (let-values () (format \"no digits in `~.a`\" s_0))"
"(let-values() #f)))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"(let-values()(read-integer sgn_0 c_0 s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-decimal"
" sgn_0"
" #f"
" 0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state106_0) state_0)((temp107_0) 'approx))(set-exactness.1 #f state106_0 temp107_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\i)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(eqv? c_0 '#\\I)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(let-values(((c2_0)"
"(if(fx=(fx+ 1 start_0) end_0)"
" 'eof"
"(let-values(((c_1)(string-ref s_0(fx+ 1 start_0))))(maybe-digit c_1 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c2_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()(finish-imaginary sgn_0 sgn_0 s_0(fx+ 1 start_0) end_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c2_0 '#\\n)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c2_0 '#\\N)))(if or-part_1 or-part_1 #f))))"
"(let-values()(read-infinity sgn_0 c_0 s_0(fx+ 2 start_0) end_0 radix_0 state_0))"
"(let-values()(bad-digit c_0 s_0 state_0))))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\n)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(eqv? c_0 '#\\N)))(if or-part_1 or-part_1 #f))))"
"(let-values()(read-nan c_0 s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(let-values()(bad-digit c_0 s_0 state_0)))))))))))"
"(define-values"
"(read-integer)"
"(lambda(sgn_0 n_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((get-n_0)(lambda()(begin 'get-n(* sgn_0(digits->integer n_0 radix_0))))))"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((sgn108_0) sgn_0)((temp109_0)(get-n_0))((s110_0) s_0)((state111_0) state_0))"
"(finish.1 #f sgn108_0 temp109_0 s110_0 state111_0)))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"(let-values()(read-integer sgn_0(add-digit n_0 c_0 radix_0) s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-decimal"
" sgn_0"
"(digits->integer n_0 radix_0)"
" 0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state112_0) state_0)((temp113_0) 'approx))"
"(set-exactness.1 #f state112_0 temp113_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\e)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\E)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? c_0 '#\\d)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? c_0 '#\\D)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(eqv? c_0 '#\\l)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(eqv? c_0 '#\\L)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(eqv? c_0 '#\\f)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(eqv? c_0 '#\\F)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(eqv? c_0 '#\\s)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(eqv? c_0 '#\\S)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(eqv? c_0 '#\\t)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(eqv? c_0 '#\\T)))"
"(if or-part_11 or-part_11 #f))))))))))))))))))))))))"
"(let-values()"
"(read-exponent"
" sgn_0"
"(get-n_0)"
" 0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state114_0) state_0)((c115_0) c_0))"
"(set-exactness-by-char.1 #f state114_0 c115_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\/)))(if or-part_0 or-part_0 #f))"
"(let-values()(read-rational sgn_0(get-n_0) #f s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\#)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-approx"
" sgn_0"
"(digits->integer n_0 radix_0)"
" 1"
" #f"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state116_0) state_0)((temp117_0) 'approx))"
"(set-exactness.1 #f state116_0 temp117_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\-)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(read-imag"
" c_0"
" sgn_0"
"(get-n_0)"
"(if(eqv? c_0 '#\\+) 1 -1)"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\@)))(if or-part_0 or-part_0 #f))"
"(let-values()(read-polar sgn_0(get-n_0) s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\i)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\I)))(if or-part_1 or-part_1 #f))))"
"(let-values()(finish-imaginary sgn_0(get-n_0) s_0(fx+ 1 start_0) end_0 state_0))"
"(let-values()(bad-digit c_0 s_0 state_0))))))))))))))))"
"(define-values"
"(read-decimal)"
"(lambda(sgn_0 n_0 exp_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((get-n_0)"
"(lambda()"
"(begin"
" 'get-n"
"(if n_0"
"(lazy-number(* sgn_0(digits->integer n_0 radix_0)) radix_0(- exp_0))"
"                          (bad-no-digits \".\" s_0 state_0))))))"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((or-part_0)"
"(if n_0(fast-inexact state_0 sgn_0(digits->integer n_0 radix_0) radix_0 0 -1 exp_0) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_1)(not v_0)))(if or-part_1 or-part_1(string? v_0)))"
" v_0"
"((lambda(n_1)"
"(let-values(((sgn118_0) sgn_0)((n119_0) n_1)((s120_0) s_0)((state121_0) state_0))"
"(finish.1 #f sgn118_0 n119_0 s120_0 state121_0)))"
" v_0))))))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((next_0)(fx+ 1 start_0)))"
"(if(if(eqv? c_0 '#\\0)(fx= next_0 end_0) #f)"
"(let-values()"
"(read-decimal"
" sgn_0"
"(let-values(((or-part_0) n_0))(if or-part_0 or-part_0 0))"
" exp_0"
" s_0"
" next_0"
" end_0"
" radix_0"
" state_0))"
"(let-values()"
"(read-decimal"
" sgn_0"
"(add-digit(let-values(((or-part_0) n_0))(if or-part_0 or-part_0 0)) c_0 radix_0)"
"(fx+ 1 exp_0)"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))(if or-part_0 or-part_0 #f))"
"                (let-values () (bad-misplaced \".\" s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\e)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\E)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? c_0 '#\\d)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? c_0 '#\\D)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(eqv? c_0 '#\\l)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(eqv? c_0 '#\\L)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(eqv? c_0 '#\\f)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(eqv? c_0 '#\\F)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(eqv? c_0 '#\\s)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(eqv? c_0 '#\\S)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(eqv? c_0 '#\\t)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(eqv? c_0 '#\\T)))"
"(if or-part_11 or-part_11 #f))))))))))))))))))))))))"
"(let-values()"
"(if n_0"
"(read-exponent"
" sgn_0"
"(* sgn_0(digits->integer n_0 radix_0))"
"(- exp_0)"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state122_0) state_0)((c123_0) c_0))"
"(set-exactness-by-char.1 #f state122_0 c123_0)))"
"                      (bad-no-digits \".\" s_0 state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\/)))(if or-part_0 or-part_0 #f))"
"(let-values()(bad-mixed-decimal-fraction s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\#)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(if n_0"
"(read-approx"
" sgn_0"
"(digits->integer n_0 radix_0)"
"(fx- 0 exp_0)"
" #t"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0)"
"                          (bad-misplaced \"#\" s_0 state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\-)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(if n_0"
"(read-imag"
" c_0"
" sgn_0"
"(get-n_0)"
"(if(eqv? c_0 '#\\+) 1 -1)"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0)"
"                            (bad-no-digits \".\" s_0 state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\@)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_1)(read-polar sgn_0 n_1 s_0(fx+ 1 start_0) end_0 radix_0 state_0)) v_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\i)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\I)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_1)(finish-imaginary sgn_0 n_1 s_0(fx+ 1 start_0) end_0 state_0)) v_0))))"
"(let-values()(bad-digit c_0 s_0 state_0))))))))))))))))"
"(define-values"
"(read-approx)"
"(lambda(sgn_0 n_0 exp_0 saw-.?_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((get-n_0)(lambda()(begin 'get-n(lazy-number(* sgn_0 n_0) radix_0 exp_0)))))"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((sgn124_0) sgn_0)((temp125_0)(get-n_0))((s126_0) s_0)((state127_0) state_0))"
"(finish.1 #f sgn124_0 temp125_0 s126_0 state127_0)))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"              (let-values () (bad-misplaced \"#\" s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(if saw-.?_0"
"                    (bad-misplaced \".\" s_0 state_0)"
"(read-approx sgn_0 n_0 exp_0 #t s_0(fx+ 1 start_0) end_0 radix_0 state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\#)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-approx"
" sgn_0"
" n_0"
"(if saw-.?_0 exp_0(fx+ 1 exp_0))"
" saw-.?_0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\e)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\E)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? c_0 '#\\d)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? c_0 '#\\D)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(eqv? c_0 '#\\l)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(eqv? c_0 '#\\L)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(eqv? c_0 '#\\f)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(eqv? c_0 '#\\F)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(eqv? c_0 '#\\s)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(eqv? c_0 '#\\S)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(eqv? c_0 '#\\t)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(eqv? c_0 '#\\T)))"
"(if or-part_11 or-part_11 #f))))))))))))))))))))))))"
"(let-values()"
"(read-exponent"
" sgn_0"
"(* sgn_0 n_0)"
" exp_0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state128_0) state_0)((c129_0) c_0))"
"(set-exactness-by-char.1 #f state128_0 c129_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\/)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(if saw-.?_0"
"(bad-mixed-decimal-fraction s_0 state_0)"
"(read-rational sgn_0(get-n_0) #f s_0(fx+ 1 start_0) end_0 radix_0 state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\-)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(read-imag"
" c_0"
" sgn_0"
"(get-n_0)"
"(if(eqv? c_0 '#\\+) 1 -1)"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\@)))(if or-part_0 or-part_0 #f))"
"(let-values()(read-polar sgn_0(get-n_0) s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\i)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\I)))(if or-part_1 or-part_1 #f))))"
"(let-values()(finish-imaginary sgn_0(get-n_0) s_0(fx+ 1 start_0) end_0 state_0))"
"(let-values()(bad-digit c_0 s_0 state_0))))))))))))))))"
"(define-values"
"(read-exponent)"
"(lambda(sgn_0 sgn-n_0 exp_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(eqv? c_0 '#\\@)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"              (let-values () (format \"empty exponent `~.a`\" s_0))"
"(let-values() #f)))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"(let-values()(read-signed-exponent sgn_0 sgn-n_0 exp_0 1 c_0 s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(eqv? c_0 '#\\-)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(let-values(((sgn2_0)(if(eqv? c_0 '#\\+) 1 -1)))"
"(read-signed-exponent sgn_0 sgn-n_0 exp_0 sgn2_0 #f s_0(fx+ 1 start_0) end_0 radix_0 state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\#)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? c_0 '#\\/)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? c_0 '#\\e)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(eqv? c_0 '#\\E)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(eqv? c_0 '#\\d)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(eqv? c_0 '#\\D)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(eqv? c_0 '#\\l)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(eqv? c_0 '#\\L)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(eqv? c_0 '#\\f)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(eqv? c_0 '#\\F)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(eqv? c_0 '#\\s)))"
"(if or-part_11"
" or-part_11"
"(let-values(((or-part_12)(eqv? c_0 '#\\S)))"
"(if or-part_12"
" or-part_12"
"(let-values(((or-part_13)(eqv? c_0 '#\\t)))"
"(if or-part_13"
" or-part_13"
"(let-values(((or-part_14)(eqv? c_0 '#\\T)))"
"(if or-part_14"
" or-part_14"
" #f))))))))))))))))))))))))))))))"
"(let-values()(bad-misplaced c_0 s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\i)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(eqv? c_0 '#\\I)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(if(state-has-first-half? state_0)"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"                        (let-values () (format \"empty exponent `~.a`\" s_0))"
"(let-values() #f))"
"                      (bad-misplaced \"i\" s_0 state_0)))"
"(let-values()(bad-digit c_0 s_0 state_0)))))))))))"
"(define-values"
"(read-signed-exponent)"
"(lambda(sgn_0 sgn-n_0 exp_0 sgn2_0 exp2_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((get-n_0)"
"(lambda()"
"(begin"
" 'get-n"
"(if exp2_0"
"(lazy-number sgn-n_0 radix_0(+ exp_0(* sgn2_0(digits->integer exp2_0 radix_0))))"
"(if(eq?(state->convert-mode state_0) 'must-read)"
"                            (let-values () (format \"empty exponent `~.a`\" s_0))"
"(let-values() #f)))))))"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((or-part_0)"
"(if exp2_0"
"(if(number? sgn-n_0)"
"(fast-inexact"
" state_0"
"(if(eqv? sgn-n_0 0) sgn_0 1)"
" sgn-n_0"
" radix_0"
" exp_0"
" sgn2_0"
"(digits->integer exp2_0 radix_0))"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_1)(not v_0)))(if or-part_1 or-part_1(string? v_0)))"
" v_0"
"((lambda(n_0)"
"(let-values(((sgn130_0) sgn_0)((n131_0) n_0)((s132_0) s_0)((state133_0) state_0))"
"(finish.1 #f sgn130_0 n131_0 s132_0 state133_0)))"
" v_0))))))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((new-exp2_0)"
"(add-digit(let-values(((or-part_0) exp2_0))(if or-part_0 or-part_0 0)) c_0 radix_0)))"
"(read-signed-exponent"
" sgn_0"
" sgn-n_0"
" exp_0"
" sgn2_0"
" new-exp2_0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(eqv? c_0 '#\\-)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_0)"
"(read-imag c_0 sgn_0 n_0(if(eqv? c_0 '#\\+) 1 -1) s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
" v_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\#)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? c_0 '#\\/)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? c_0 '#\\e)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(eqv? c_0 '#\\E)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(eqv? c_0 '#\\d)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(eqv? c_0 '#\\D)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(eqv? c_0 '#\\l)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(eqv? c_0 '#\\L)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(eqv? c_0 '#\\f)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(eqv? c_0 '#\\F)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(eqv? c_0 '#\\s)))"
"(if or-part_11"
" or-part_11"
"(let-values(((or-part_12)(eqv? c_0 '#\\S)))"
"(if or-part_12"
" or-part_12"
"(let-values(((or-part_13)(eqv? c_0 '#\\t)))"
"(if or-part_13"
" or-part_13"
"(let-values(((or-part_14)(eqv? c_0 '#\\T)))"
"(if or-part_14"
" or-part_14"
" #f))))))))))))))))))))))))))))))"
"(let-values()(bad-misplaced c_0 s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\@)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_0)(read-polar sgn_0 n_0 s_0(fx+ 1 start_0) end_0 radix_0 state_0)) v_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\i)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\I)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_0)(finish-imaginary sgn_0 n_0 s_0(fx+ 1 start_0) end_0 state_0)) v_0))))"
"(let-values()(bad-digit c_0 s_0 state_0)))))))))))))"
"(define-values"
"(read-infinity)"
"(lambda(sgn_0 c_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((fail_0)(lambda()(begin 'fail(bad-digit c_0 s_0 state_0)))))"
"(let-values(((start+n_0)(fx+ start_0 0)))"
"(let-values(((var_0)(if(fx= start+n_0 end_0) 'eof(string-ref s_0 start+n_0))))"
"(let-values(((tmp_0) var_0))"
"(if(if(equal? tmp_0 '#\\f) #t(equal? tmp_0 '#\\F))"
"(let-values()"
"(let-values(((fail_1)(lambda()(begin 'fail(fail_0)))))"
"(let-values(((start+n_1)(fx+ start_0(+ 0 1))))"
"(let-values(((var_1)(if(fx= start+n_1 end_0) 'eof(string-ref s_0 start+n_1))))"
"(let-values(((tmp_1) var_1))"
"(if(equal? tmp_1 '#\\.)"
"(let-values()"
"(let-values(((fail_2)(lambda()(begin 'fail(fail_1)))))"
"(let-values(((start+n_2)(fx+ start_0(+(+ 0 1) 1))))"
"(let-values(((var_2)(if(fx= start+n_2 end_0) 'eof(string-ref s_0 start+n_2))))"
"(let-values(((tmp_2) var_2))"
"(if(if(equal? tmp_2 '#\\0)"
" #t"
"(if(equal? tmp_2 '#\\f)"
" #t"
"(if(equal? tmp_2 '#\\t)"
" #t"
"(if(equal? tmp_2 '#\\F) #t(equal? tmp_2 '#\\T)))))"
"(let-values()"
"(let-values()"
"(let-values(((n_0)(if(negative? sgn_0) -inf.0 +inf.0)))"
"(let-values(((new-state_0)"
"(let-values(((state134_0) state_0)"
"((temp135_0)(string-ref s_0(fx+ start_0 2)))"
"((temp136_0) #t))"
"(set-exactness-by-char.1"
" temp136_0"
" state134_0"
" temp135_0))))"
"(let-values(((c2_0)"
"(if(fx=(fx+ 3 start_0) end_0)"
" 'eof"
"(let-values(((c_1)(string-ref s_0(fx+ 3 start_0))))"
"(maybe-digit c_1 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c2_0 'eof)))"
"(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((sgn137_0) sgn_0)"
"((n138_0) n_0)"
"((s139_0) s_0)"
"((new-state140_0) new-state_0))"
"(finish.1 #f sgn137_0 n138_0 s139_0 new-state140_0)))"
"(if(let-values(((or-part_0)(eqv? c2_0 '#\\+)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c2_0 '#\\-)))"
"(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(read-imag"
" c2_0"
" sgn_0"
" n_0"
"(if(eqv? c2_0 '#\\+) 1 -1)"
" s_0"
"(fx+ 4 start_0)"
" end_0"
" radix_0"
" new-state_0))"
"(if(let-values(((or-part_0)(eqv? c2_0 '#\\@)))"
"(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-polar"
" sgn_0"
" n_0"
" s_0"
"(fx+ 4 start_0)"
" end_0"
" radix_0"
" new-state_0))"
"(if(let-values(((or-part_0)(eqv? c2_0 '#\\i)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c2_0 '#\\I)))"
"(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(finish-imaginary"
" sgn_0"
" n_0"
" s_0"
"(fx+ 4 start_0)"
" end_0"
" new-state_0))"
"(let-values()(bad-digit c_0 s_0 state_0)))))))))))"
"(let-values()(fail_2))))))))"
"(let-values()(fail_1))))))))"
"(let-values()(fail_0))))))))))"
"(define-values"
"(read-nan)"
"(lambda(c_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((fail_0)(lambda()(begin 'fail(bad-digit c_0 s_0 state_0)))))"
"(let-values(((start+n_0)(fx+ start_0 0)))"
"(let-values(((var_0)(if(fx= start+n_0 end_0) 'eof(string-ref s_0 start+n_0))))"
"(let-values(((tmp_0) var_0))"
"(if(if(equal? tmp_0 '#\\a) #t(equal? tmp_0 '#\\A))"
"(let-values()"
"(let-values(((fail_1)(lambda()(begin 'fail(fail_0)))))"
"(let-values(((start+n_1)(fx+ start_0(+ 0 1))))"
"(let-values(((var_1)(if(fx= start+n_1 end_0) 'eof(string-ref s_0 start+n_1))))"
"(let-values(((tmp_1) var_1))"
"(if(if(equal? tmp_1 '#\\n) #t(equal? tmp_1 '#\\N))"
"(let-values()"
"(let-values(((fail_2)(lambda()(begin 'fail(fail_1)))))"
"(let-values(((start+n_2)(fx+ start_0(+(+ 0 1) 1))))"
"(let-values(((var_2)(if(fx= start+n_2 end_0) 'eof(string-ref s_0 start+n_2))))"
"(let-values(((tmp_2) var_2))"
"(if(equal? tmp_2 '#\\.)"
"(let-values()"
"(let-values(((fail_3)(lambda()(begin 'fail(fail_2)))))"
"(let-values(((start+n_3)(fx+ start_0(+(+(+ 0 1) 1) 1))))"
"(let-values(((var_3)"
"(if(fx= start+n_3 end_0) 'eof(string-ref s_0 start+n_3))))"
"(let-values(((tmp_3) var_3))"
"(if(if(equal? tmp_3 '#\\0)"
" #t"
"(if(equal? tmp_3 '#\\f)"
" #t"
"(if(equal? tmp_3 '#\\t)"
" #t"
"(if(equal? tmp_3 '#\\F) #t(equal? tmp_3 '#\\T)))))"
"(let-values()"
"(let-values()"
"(let-values(((n_0) +nan.0))"
"(let-values(((new-state_0)"
"(let-values(((state141_0) state_0)"
"((temp142_0)"
"(string-ref s_0(fx+ start_0 3)))"
"((temp143_0) #t))"
"(set-exactness-by-char.1"
" temp143_0"
" state141_0"
" temp142_0))))"
"(let-values(((c2_0)"
"(if(fx=(fx+ 4 start_0) end_0)"
" 'eof"
"(let-values(((c_1)"
"(string-ref"
" s_0"
"(fx+ 4 start_0))))"
"(maybe-digit c_1 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c2_0 'eof)))"
"(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((temp144_0) 1)"
"((n145_0) n_0)"
"((s146_0) s_0)"
"((new-state147_0) new-state_0))"
"(finish.1"
" #f"
" temp144_0"
" n145_0"
" s146_0"
" new-state147_0)))"
"(if(let-values(((or-part_0)(eqv? c2_0 '#\\+)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c2_0 '#\\-)))"
"(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(read-imag"
" c2_0"
" 1"
" n_0"
"(if(eqv? c2_0 '#\\+) 1 -1)"
" s_0"
"(fx+ 5 start_0)"
" end_0"
" radix_0"
" new-state_0))"
"(if(let-values(((or-part_0)(eqv? c2_0 '#\\@)))"
"(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-polar"
" 1"
" n_0"
" s_0"
"(fx+ 5 start_0)"
" end_0"
" radix_0"
" new-state_0))"
"(if(let-values(((or-part_0)(eqv? c2_0 '#\\i)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c2_0 '#\\I)))"
"(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(finish-imaginary"
" 1"
" n_0"
" s_0"
"(fx+ 5 start_0)"
" end_0"
" new-state_0))"
"(let-values()"
"(bad-digit c_0 s_0 state_0)))))))))))"
"(let-values()(fail_3))))))))"
"(let-values()(fail_2))))))))"
"(let-values()(fail_1))))))))"
"(let-values()(fail_0))))))))))"
"(define-values"
"(read-rational)"
"(lambda(sgn_0 sgn-n_0 d_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((get-n_0)"
"(lambda()"
"(begin"
" 'get-n"
"(if d_0"
"(lazy-divide sgn-n_0(digits->integer d_0 radix_0) 'exact)"
"                          (bad-no-digits \"/\" s_0 state_0))))))"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_0)"
"(let-values(((sgn148_0) sgn_0)((n149_0) n_0)((s150_0) s_0)((state151_0) state_0))"
"(finish.1 #f sgn148_0 n149_0 s150_0 state151_0)))"
" v_0))))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-rational"
" sgn_0"
" sgn-n_0"
"(add-digit(let-values(((or-part_0) d_0))(if or-part_0 or-part_0 0)) c_0 radix_0)"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))(if or-part_0 or-part_0 #f))"
"(let-values()(bad-mixed-decimal-fraction s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\#)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(if d_0"
"(read-denom-approx"
" sgn_0"
" sgn-n_0"
"(digits->integer d_0 radix_0)"
" 1"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state152_0) state_0)((temp153_0) 'approx))"
"(set-exactness.1 #f state152_0 temp153_0)))"
"                      (bad-misplaced \"#\" s_0 state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\e)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\E)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? c_0 '#\\d)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? c_0 '#\\D)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(eqv? c_0 '#\\l)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(eqv? c_0 '#\\L)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(eqv? c_0 '#\\f)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(eqv? c_0 '#\\F)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(eqv? c_0 '#\\s)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(eqv? c_0 '#\\S)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(eqv? c_0 '#\\t)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(eqv? c_0 '#\\T)))"
"(if or-part_11 or-part_11 #f))))))))))))))))))))))))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(sgn-n_1)"
"(read-exponent"
" sgn_0"
" sgn-n_1"
" 0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state154_0) state_0)((c155_0) c_0))"
"(set-exactness-by-char.1 #f state154_0 c155_0))))"
" v_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\/)))(if or-part_0 or-part_0 #f))"
"                      (let-values () (bad-misplaced \"/\" s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\-)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_0)"
"(read-imag"
" c_0"
" sgn_0"
" n_0"
"(if(eqv? c_0 '#\\+) 1 -1)"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0))"
" v_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\@)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_0)(read-polar sgn_0 n_0 s_0(fx+ 1 start_0) end_0 radix_0 state_0)) v_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\i)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\I)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(let-values(((v_0)(get-n_0)))"
"(if(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(string? v_0)))"
" v_0"
"((lambda(n_0)(finish-imaginary sgn_0 n_0 s_0(fx+ 1 start_0) end_0 state_0)) v_0))))"
"(let-values()(bad-digit c_0 s_0 state_0))))))))))))))))"
"(define-values"
"(read-denom-approx)"
"(lambda(sgn_0 sgn-n_0 d_0 exp_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(let-values(((get-n_0)(lambda()(begin 'get-n(lazy-divide sgn-n_0(lazy-number d_0 radix_0 exp_0) 'approx)))))"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((sgn156_0) sgn_0)((temp157_0)(get-n_0))((s158_0) s_0)((state159_0) state_0))"
"(finish.1 #f sgn156_0 temp157_0 s158_0 state159_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\#)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(read-denom-approx sgn_0 sgn-n_0 d_0(fx+ 1 exp_0) s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"                (let-values () (bad-misplaced \"#\" s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(eqv? c_0 '#\\/)))(if or-part_1 or-part_1 #f))))"
"(let-values()(bad-misplaced c_0 s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\e)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\E)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(eqv? c_0 '#\\d)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(eqv? c_0 '#\\D)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(eqv? c_0 '#\\l)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(eqv? c_0 '#\\L)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(eqv? c_0 '#\\f)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(eqv? c_0 '#\\F)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(eqv? c_0 '#\\s)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(eqv? c_0 '#\\S)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(eqv? c_0 '#\\t)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(eqv? c_0 '#\\T)))"
"(if or-part_11 or-part_11 #f))))))))))))))))))))))))"
"(let-values()"
"(read-exponent"
" sgn_0"
"(get-n_0)"
" 0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((state160_0) state_0)((c161_0) c_0))"
"(set-exactness-by-char.1 #f state160_0 c161_0))))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\-)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(read-imag"
" c_0"
" sgn_0"
"(get-n_0)"
"(if(eqv? c_0 '#\\+) 1 -1)"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
" state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\@)))(if or-part_0 or-part_0 #f))"
"(let-values()(read-polar sgn_0(get-n_0) s_0(fx+ 1 start_0) end_0 radix_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\i)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eqv? c_0 '#\\I)))(if or-part_1 or-part_1 #f))))"
"(let-values()(finish-imaginary sgn_0(get-n_0) s_0(fx+ 1 start_0) end_0 state_0))"
"(let-values()(bad-digit c_0 s_0 state_0)))))))))))))))"
"(define-values"
"(read-imag)"
"(lambda(c_0 real-sgn_0 real_0 sgn_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(if(let-values(((or-part_0)(state-has-first-half? state_0)))"
"(if or-part_0 or-part_0(eq? 'extended(parse-state-exactness state_0))))"
"(let-values()(bad-misplaced c_0 s_0 state_0))"
"(let-values()"
"(read-signed"
" sgn_0"
" s_0"
" start_0"
" end_0"
" radix_0"
"(state-set-first-half state_0(rect-prefix7.1 real-sgn_0 real_0(fx- start_0 1)))))))))"
"(define-values"
"(read-polar)"
"(lambda(real-sgn_0 real_0 s_0 start_0 end_0 radix_0 state_0)"
"(begin"
"(if(let-values(((or-part_0)(state-has-first-half? state_0)))"
"(if or-part_0 or-part_0(eq? 'extended(parse-state-exactness state_0))))"
"        (let-values () (bad-misplaced \"@\" s_0 state_0))"
"(let-values()"
"(let-values(((c_0)"
"(if(fx= start_0 end_0)"
" 'eof"
"(let-values(((c_0)(string-ref s_0 start_0)))(maybe-digit c_0 radix_0)))))"
"(if(let-values(((or-part_0)(eqv? c_0 'eof)))(if or-part_0 or-part_0 #f))"
"              (let-values () (bad-misplaced \"@\" s_0 state_0))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\+)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(eqv? c_0 '#\\-)))(if or-part_1 or-part_1 #f))))"
"(let-values()"
"(let-values(((new-state_0)"
"(state-set-first-half state_0(polar-prefix8.1 real-sgn_0 real_0 start_0))))"
"(read-signed(if(eq? c_0 '#\\+) 1 -1) s_0(fx+ 1 start_0) end_0 radix_0 new-state_0)))"
"(if(let-values(((or-part_0)(fixnum? c_0)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((new-state_0)"
"(state-set-first-half state_0(polar-prefix8.1 real-sgn_0 real_0 start_0))))"
"(read-integer 1 c_0 s_0(fx+ 1 start_0) end_0 radix_0 new-state_0)))"
"(if(let-values(((or-part_0)(eqv? c_0 '#\\.)))(if or-part_0 or-part_0 #f))"
"(let-values()"
"(let-values(((new-state_0)"
"(state-set-first-half state_0(polar-prefix8.1 real-sgn_0 real_0 start_0))))"
"(read-decimal"
" 1"
" #f"
" 0"
" s_0"
"(fx+ 1 start_0)"
" end_0"
" radix_0"
"(let-values(((new-state162_0) new-state_0)((temp163_0) 'approx))"
"(set-exactness.1 #f new-state162_0 temp163_0)))))"
"(let-values()(bad-digit c_0 s_0 state_0))))))))))))"
"(define-values"
"(read-symbol-or-number.1)"
"(lambda(extra-prefix2_0 mode1_0 init-c5_0 in6_0 orig-config7_0)"
"(begin"
" 'read-symbol-or-number"
"(let-values(((init-c_0) init-c5_0))"
"(let-values(((in_0) in6_0))"
"(let-values(((orig-config_0) orig-config7_0))"
"(let-values(((mode_0) mode1_0))"
"(let-values(((extra-prefix_0) extra-prefix2_0))"
"(let-values()"
"(let-values(((config_0)"
"(if(string? mode_0)(override-parameter 1/read-cdot orig-config_0 #f) orig-config_0)))"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(let-values(((c1_0)"
"(if rt_0"
"(if(let-values(((or-part_0)(eq? mode_0 'symbol-or-number)))"
"(if or-part_0 or-part_0(eq? mode_0 'symbol/indirect)))"
"(readtable-symbol-parser rt_0)"
" #f)"
" #f)))"
"(if c1_0"
"((lambda(handler_0)"
"(readtable-apply"
" handler_0"
" init-c_0"
" in_0"
" config_0"
"(read-config-line config_0)"
"(read-config-col config_0)"
"(read-config-pos config_0)))"
" c1_0)"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values(((quoted-ever?_0) #f))"
"(let-values(((case-sens?_0)(check-parameter read-case-sensitive config_0)))"
"(let-values((()"
"(begin"
"(if extra-prefix_0"
"(let-values()(accum-string-add! accum-str_0 extra-prefix_0))"
"(void))"
"(values))))"
"(let-values(((source_0)(read-config-source config_0)))"
"(let-values(((unexpected-quoted_0)"
"(lambda(c_0 after-c_0)"
"(begin"
" 'unexpected-quoted"
"(let-values(((in9_0) in_0)"
"((config10_0) config_0)"
"((c11_0) c_0)"
"                                                                     ((temp12_0) \"~a following `~a` in ~a\")"
"((temp13_0)"
"(if(eof-object? c_0)"
"                                                                        \"end-of-file\""
"                                                                        \"non-character\"))"
"((after-c14_0) after-c_0)"
"((temp15_0)"
"(if(eq? mode_0 'keyword)"
"                                                                        (let-values () \"keyword\")"
"(if(string? mode_0)"
"                                                                          (let-values () \"number\")"
"                                                                          (let-values () \"symbol\")))))"
"(reader-error.1"
" unsafe-undefined"
" c11_0"
" #f"
" unsafe-undefined"
" in9_0"
" config10_0"
" temp12_0"
"(list temp13_0 after-c14_0 temp15_0)))))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(init-c_1"
" pipe-quote-c_0"
" foldcase-from_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((or-part_0)"
" init-c_1))"
"(if or-part_0"
" or-part_0"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_1)"
" source_0))"
"(let-values(((c_0)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq?"
" c_0"
" 'special)"
"(special1.1"
" 'special)"
" c_0)))))))"
"(let-values(((ec_0)"
"(let-values(((rt_1) rt_0)"
"((c_1) c_0)"
"((handler_0)"
" '#\\x))"
"(if(let-values(((or-part_0)"
"(not"
" rt_1)))"
"(if or-part_0"
" or-part_0"
"(not"
"(char? c_1))))"
"(let-values() c_1)"
"(let-values()"
"(*readtable-effective-char"
" rt_1"
" c_1"
" handler_0))))))"
"(if(if pipe-quote-c_0"
"(not(char? ec_0))"
" #f)"
"(let-values()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char/special"
" in_0"
" config_0"
" c_0)))"
"(unexpected-quoted_0"
" c_0"
" pipe-quote-c_0)))"
"(if(if(not pipe-quote-c_0)"
"(readtable-char-delimiter?"
" rt_0"
" c_0"
" config_0)"
" #f)"
"(let-values()"
"(if case-sens?_0"
"(void)"
"(let-values()"
"(accum-string-convert!"
" accum-str_0"
" string-foldcase"
" foldcase-from_0))))"
"(if(if pipe-quote-c_0"
"(char=? c_0 pipe-quote-c_0)"
" #f)"
"(let-values()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char"
" in_0"
" c_0)))"
"(loop_0"
" #f"
" #f"
"(accum-string-count"
" accum-str_0))))"
"(if(if(char=? ec_0 '#\\|)"
"(check-parameter"
" read-accept-bar-quote"
" config_0)"
" #f)"
"(let-values()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char"
" in_0"
" c_0)))"
"(set! quoted-ever?_0 #t)"
"(if case-sens?_0"
"(void)"
"(let-values()"
"(accum-string-convert!"
" accum-str_0"
" string-foldcase"
" foldcase-from_0)))"
"(loop_0"
" #f"
" c_0"
"(accum-string-count"
" accum-str_0))))"
"(if(if(char=? ec_0 '#\\\\)"
"(not pipe-quote-c_0)"
" #f)"
"(let-values()"
"(let-values((()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char"
" in_0"
" c_0)))"
"(values))))"
"(let-values(((next-c_0)"
"(let-values(((in_1)"
" in_0)"
"((source_1)"
" source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(begin"
"(if(char? next-c_0)"
"(void)"
"(let-values()"
"(unexpected-quoted_0"
" next-c_0"
" c_0)))"
"(if(let-values(((or-part_0)"
" pipe-quote-c_0))"
"(if or-part_0"
" or-part_0"
" case-sens?_0))"
"(void)"
"(let-values()"
"(accum-string-convert!"
" accum-str_0"
" string-foldcase"
" foldcase-from_0)))"
"(accum-string-add!"
" accum-str_0"
" next-c_0)"
"(set! quoted-ever?_0"
" #t)"
"(loop_0"
" #f"
" #f"
"(accum-string-count"
" accum-str_0))))))"
"(let-values()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char"
" in_0"
" c_0)))"
"(accum-string-add!"
" accum-str_0"
" c_0)"
"(loop_0"
" #f"
" pipe-quote-c_0"
" foldcase-from_0))))))))))))))"
" loop_0)"
" init-c_0"
" #f"
" 0)"
"(values))))"
"(let-values(((str_0)"
"(let-values(((accum-str16_0) accum-str_0)"
"((config17_0) config_0))"
"(accum-string-get!.1 0 accum-str16_0 config17_0))))"
"(let-values((()"
"(begin"
"(if(if(= 1(string-length str_0))"
"(if(not quoted-ever?_0)"
"(char=?"
" '#\\."
"(effective-char(string-ref str_0 0) config_0))"
" #f)"
" #f)"
"(let-values()"
"(let-values(((in18_0) in_0)"
"((config19_0) config_0)"
"                                                                             ((temp20_0) \"illegal use of `.`\"))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in18_0"
" config19_0"
" temp20_0"
"(list))))"
"(void))"
"(values))))"
"(let-values(((num_0)"
"(if(let-values(((or-part_0)"
"(eq? mode_0 'symbol-or-number)))"
"(if or-part_0 or-part_0(string? mode_0)))"
"(if(not quoted-ever?_0)"
"(unchecked-string->number"
"(if(string? mode_0)"
"(string-append mode_0 str_0)"
" str_0)"
" 10"
" 'read"
"(if(check-parameter"
" 1/read-decimal-as-inexact"
" config_0)"
" 'decimal-as-inexact"
" 'decimal-as-exact)"
"(if(check-parameter 1/read-single-flonum config_0)"
" 'single"
" 'double))"
" #f)"
" #f)))"
"(begin"
"(if(string? num_0)"
"(let-values()"
"(let-values(((in21_0) in_0)"
"((config22_0) config_0)"
"                                                                   ((temp23_0) \"~a\")"
"((num24_0) num_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in21_0"
" config22_0"
" temp23_0"
"(list num24_0))))"
"(void))"
"(if(if(not num_0)(string? mode_0) #f)"
"(let-values()"
"(let-values(((in25_0) in_0)"
"((config26_0) config_0)"
"                                                                   ((temp27_0) \"bad number: `~a`\")"
"((temp28_0)(string-append mode_0 str_0)))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in25_0"
" config26_0"
" temp27_0"
"(list temp28_0))))"
"(void))"
"(wrap"
"(let-values(((or-part_0) num_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(eq? mode_0 'keyword)"
"(string->keyword str_0)"
" #f)))"
"(if or-part_1 or-part_1(string->symbol str_0)))))"
" in_0"
" config_0"
" str_0))))))))))))))))))))))))))"
"(define-values"
"(read-number-literal)"
"(lambda(read-one_0 init-c_0 in_0 config_0 mode_0 starts-num?_0 num?_0 num-str_0)"
"(begin"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments init-c_0 read-one_0 in_0 config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location* in_0 c_0)))"
"(let-values(((ec_0)"
"(let-values(((rt_0)(read-config-readtable config_0))((c_1) c_0)((handler_0) '#\\x))"
"(if(let-values(((or-part_0)(not rt_0)))(if or-part_0 or-part_0(not(char? c_1))))"
"(let-values() c_1)"
"(let-values()(*readtable-effective-char rt_0 c_1 handler_0))))))"
"(if(let-values(((or-part_0)(not(char? c_0))))(if or-part_0 or-part_0(starts-num?_0 ec_0)))"
"(let-values()"
"(let-values(((v_0)"
"(if(char? c_0)"
"(let-values(((c1_0) c_0)((in2_0) in_0)((config3_0) config_0)((mode4_0) mode_0))"
"(read-symbol-or-number.1 #f mode4_0 c1_0 in2_0 config3_0))"
" c_0)))"
"(if(num?_0 v_0)"
"(let-values() v_0)"
"(if(eof-object? v_0)"
"(let-values() v_0)"
"(if(if(1/special-comment? v_0)(read-config-keep-comment? v_0) #f)"
"(let-values() v_0)"
"(let-values()"
"(let-values(((in5_0) in_0)"
"((temp6_0)(reading-at config_0 line_0 col_0 pos_0))"
"                                       ((temp7_0) \"expected a ~a, found ~v\")"
"((num-str8_0) num-str_0)"
"((v9_0) v_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in5_0"
" temp6_0"
" temp7_0"
"(list num-str8_0 v9_0)))))))))"
"(let-values(((c1_0)(special-comment-via-readtable? c_0 read-one_0 in_0 config_0)))"
"(if c1_0"
"((lambda(v_0)"
"(if(read-config-keep-comment? config_0)"
" v_0"
"(read-number-literal read-one_0 #f in_0 config_0 mode_0 starts-num?_0 num?_0 num-str_0)))"
" c1_0)"
"(let-values()"
"(let-values(((in10_0) in_0)"
"((temp11_0)(reading-at config_0 line_0 col_0 pos_0))"
"                                 ((temp12_0) \"expected a ~a\")"
"((num-str13_0) num-str_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in10_0"
" temp11_0"
" temp12_0"
"(list num-str13_0)))))))))))))"
"(define-values"
"(starts-fixnum?)"
"(lambda(c_0)"
"(begin"
"(let-values(((or-part_0)(char<=? '#\\0 c_0 '#\\9)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char=? c_0 '#\\-)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(char=? c_0 '#\\+)))(if or-part_2 or-part_2(char=? c_0 '#\\#))))))))))"
"(define-values"
"(read-fixnum)"
"(lambda(read-one_0 init-c_0 in_0 config_0)"
"    (begin (read-number-literal read-one_0 init-c_0 in_0 config_0 \"#e\" starts-fixnum? fixnum? \"fixnum\"))))"
"(define-values"
"(starts-flonum?)"
"(lambda(c_0)(begin(let-values(((or-part_0)(starts-fixnum? c_0)))(if or-part_0 or-part_0(char=? c_0 '#\\.))))))"
"(define-values"
"(read-flonum)"
"(lambda(read-one_0 init-c_0 in_0 config_0)"
"    (begin (read-number-literal read-one_0 init-c_0 in_0 config_0 \"#i\" starts-flonum? flonum? \"flonum\"))))"
"(define-values"
"(read-vector.1)"
"(lambda(length2_0 mode1_0 read-one5_0 opener-c6_0 opener7_0 closer8_0 in9_0 config10_0)"
"(begin"
" 'read-vector"
"(let-values(((read-one_0) read-one5_0))"
"(let-values(((opener-c_0) opener-c6_0))"
"(let-values(((opener_0) opener7_0))"
"(let-values(((closer_0) closer8_0))"
"(let-values(((in_0) in9_0))"
"(let-values(((config_0) config10_0))"
"(let-values(((vector-mode_0) mode1_0))"
"(let-values(((expected-len_0) length2_0))"
"(let-values()"
"(let-values(((read-one-element_0)"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"(let-values() read-one_0)"
"(if(equal? tmp_0 'fixnum)"
"(let-values()"
"(lambda(init-c_0 in_1 config_1)"
"(begin"
" 'read-one-element"
"(read-fixnum read-one_0 init-c_0 in_1 config_1))))"
"(if(equal? tmp_0 'flonum)"
"(let-values()"
"(lambda(init-c_0 in_1 config_1)"
"(begin"
" 'read-one-element"
"(read-flonum read-one_0 init-c_0 in_1 config_1))))"
"(let-values()(void))))))))"
"(let-values(((seq_0)"
"(let-values(((read-one-element12_0) read-one-element_0)"
"((opener-c13_0) opener-c_0)"
"((opener14_0) opener_0)"
"((closer15_0) closer_0)"
"((in16_0) in_0)"
"((config17_0) config_0)"
"((read-one18_0) read-one_0)"
"((temp19_0) #f))"
"(read-unwrapped-sequence.1"
" temp19_0"
" unsafe-undefined"
" unsafe-undefined"
" #f"
" read-one18_0"
" read-one-element12_0"
" opener-c13_0"
" opener14_0"
" closer15_0"
" in16_0"
" config17_0))))"
"(let-values(((vec_0)"
"(if(not expected-len_0)"
"(let-values()"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"(let-values()(list->vector seq_0))"
"(if(equal? tmp_0 'fixnum)"
"(let-values()"
"(let-values(((len_0)(length seq_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/fxvector"
"                                                               \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((fill_0) 0))"
"(let-values(((v_0)(make-fxvector len_0 fill_0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((lst_0) seq_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((i_2)"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(let-values(((elem_0)"
"(let-values()"
" e_0)))"
"(if(fixnum?"
" elem_0)"
"(unsafe-fxvector-set!"
" v_0"
" i_1"
" elem_0)"
"(not-an-fX.1"
" 'for*/vector"
" elem_0)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values"
" i_2))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_2"
" len_0))"
" e_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_2"
" rest_0)"
" i_2)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" lst_0))))))"
" v_0))))))"
"(if(equal? tmp_0 'flonum)"
"(let-values()"
"(let-values(((len_0)(length seq_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/flvector"
"                                                                 \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((fill_0) 0.0))"
"(let-values(((v_0)(make-flvector len_0 fill_0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((lst_0) seq_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((i_2)"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(let-values(((elem_0)"
"(let-values()"
" e_0)))"
"(if(flonum?"
" elem_0)"
"(unsafe-flvector-set!"
" v_0"
" i_1"
" elem_0)"
"(not-an-fX.1$1"
" 'for*/vector"
" elem_0)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values"
" i_2))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_2"
" len_0))"
" e_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_2"
" rest_0)"
" i_2)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" lst_0))))))"
" v_0))))))"
"(let-values()(void)))))))"
"(let-values()"
"(let-values(((len_0)(length seq_0)))"
"(if(= expected-len_0 len_0)"
"(let-values()(list->vector seq_0))"
"(if(< expected-len_0 len_0)"
"(let-values()"
"(let-values(((in20_0) in_0)"
"((config21_0) config_0)"
"((temp22_0)"
"                                                                    \"~avector length ~a is too small, ~a values provided\")"
"((temp23_0)"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"                                                                        (let-values () \"\")"
"(if(equal? tmp_0 'fixnum)"
"                                                                          (let-values () \"fx\")"
"(if(equal? tmp_0 'flonum)"
"                                                                            (let-values () \"fl\")"
"(let-values()(void)))))))"
"((expected-len24_0) expected-len_0)"
"((len25_0) len_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in20_0"
" config21_0"
" temp22_0"
"(list temp23_0 expected-len24_0 len25_0))))"
"(let-values()"
"(let-values(((last-or_0)"
"(lambda(v_0)"
"(begin"
" 'last-or"
"(if(null? seq_0)"
"(wrap v_0 in_0 config_0 #f)"
"((letrec-values(((loop_0)"
"(lambda(seq_1)"
"(begin"
" 'loop"
"(if(null?(cdr seq_1))"
"(car seq_1)"
"(loop_0"
"(cdr seq_1)))))))"
" loop_0)"
" seq_0))))))"
"(let-values((()"
"(begin"
"(if(>=(integer-length expected-len_0) 48)"
"(let-values()"
"(raise"
"(exn:fail:out-of-memory"
"                                                                              \"out of memory\""
"(current-continuation-marks))))"
"(void))"
"(values))))"
"(let-values(((vec_0)"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"(let-values()"
"(make-vector"
" expected-len_0"
"(last-or_0 0)))"
"(if(equal? tmp_0 'fixnum)"
"(let-values()"
"(make-fxvector"
" expected-len_0"
"(last-or_0 0)))"
"(if(equal? tmp_0 'flonum)"
"(let-values()"
"(make-flvector"
" expected-len_0"
"(last-or_0 0.0)))"
"(let-values()(void))))))))"
"(begin"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0) seq_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1)"
" #t"
" #f)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(vector-set!"
" vec_0"
" i_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
" rest_0"
"(+ pos_0 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0))))"
"(void)))"
"(if(equal? tmp_0 'fixnum)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0) seq_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_1)"
" #t"
" #f)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(fxvector-set!"
" vec_0"
" i_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
" rest_0"
"(+"
" pos_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0))))"
"(void)))"
"(if(equal? tmp_0 'flonum)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0) seq_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_1)"
" #t"
" #f)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(flvector-set!"
" vec_0"
" i_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
" rest_0"
"(+"
" pos_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0))))"
"(void)))"
"(let-values()(void))))))"
" vec_0))))))))))))"
"(wrap"
"(if(read-config-for-syntax? config_0)(vector->immutable-vector vec_0) vec_0)"
" in_0"
" config_0"
" opener_0))))))))))))))))"
"(define-values"
"(read-fixnum-or-flonum-vector)"
"(lambda(read-one_0 dispatch-c_0 c_0 c2_0 in_0 config_0)"
"(begin"
"(let-values(((vector-mode_0)(if(char=? c2_0 '#\\x) 'fixnum 'flonum)))"
"(let-values((()(begin(consume-char in_0 c2_0)(values))))"
"(let-values((()"
"(begin"
"(if(read-config-for-syntax? config_0)"
"(let-values()"
"(let-values(((in26_0) in_0)"
"((config27_0) config_0)"
"                                           ((temp28_0) \"literal f~avectors not allowed\")"
"((c229_0) c2_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in26_0"
" config27_0"
" temp28_0"
"(list c229_0))))"
"(void))"
"(values))))"
"(let-values(((c3_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((vector-len_0 len-str_0 c4_0)"
"(if(decimal-digit? c3_0)"
"(let-values()(read-simple-number in_0 config_0 c3_0))"
"                              (let-values () (values #f \"\" c3_0)))))"
"(let-values(((tmp_0) c4_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values()"
"(let-values(((read-one30_0) read-one_0)"
"((temp31_0) '#\\()"
"((temp32_0) '#\\()"
"((temp33_0) '#\\))"
"((in34_0) in_0)"
"((config35_0) config_0)"
"((vector-mode36_0) vector-mode_0)"
"((vector-len37_0) vector-len_0))"
"(read-vector.1"
" vector-len37_0"
" vector-mode36_0"
" read-one30_0"
" temp31_0"
" temp32_0"
" temp33_0"
" in34_0"
" config35_0)))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)"
"(let-values()"
"(let-values(((read-one38_0) read-one_0)"
"((temp39_0) '#\\[)"
"((temp40_0) '#\\[)"
"((temp41_0) '#\\])"
"((in42_0) in_0)"
"((config43_0) config_0)"
"((vector-mode44_0) vector-mode_0)"
"((vector-len45_0) vector-len_0))"
"(read-vector.1"
" vector-len45_0"
" vector-mode44_0"
" read-one38_0"
" temp39_0"
" temp40_0"
" temp41_0"
" in42_0"
" config43_0)))"
"(let-values()"
"(let-values(((in46_0) in_0)"
"((config47_0) config_0)"
"                                         ((temp48_0) (format \"~a~a\" dispatch-c_0 (format \"~a~a\" c_0 c2_0))))"
"(bad-syntax-error.1 '#\\x in46_0 config47_0 temp48_0)))))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)"
"(let-values()"
"(let-values(((read-one49_0) read-one_0)"
"((temp50_0) '#\\{)"
"((temp51_0) '#\\{)"
"((temp52_0) '#\\})"
"((in53_0) in_0)"
"((config54_0) config_0)"
"((vector-mode55_0) vector-mode_0)"
"((vector-len56_0) vector-len_0))"
"(read-vector.1"
" vector-len56_0"
" vector-mode55_0"
" read-one49_0"
" temp50_0"
" temp51_0"
" temp52_0"
" in53_0"
" config54_0)))"
"(let-values()"
"(let-values(((in57_0) in_0)"
"((config58_0) config_0)"
"                                           ((temp59_0) (format \"~a~a\" dispatch-c_0 (format \"~a~a\" c_0 c2_0))))"
"(bad-syntax-error.1 '#\\x in57_0 config58_0 temp59_0)))))"
"(let-values()"
"(let-values(((in60_0) in_0)"
"((config61_0) config_0)"
"((c462_0) c4_0)"
"                                       ((temp63_0) \"expected `(`, `[`, or `{` after `#~a~a~a`\")"
"((c64_0) c_0)"
"((c265_0) c2_0)"
"((len-str66_0) len-str_0))"
"(reader-error.1"
" unsafe-undefined"
" c462_0"
" #f"
" unsafe-undefined"
" in60_0"
" config61_0"
" temp63_0"
"(list c64_0 c265_0 len-str66_0))))))))))))))))"
"(define-values"
"(read-simple-number)"
"(lambda(in_0 config_0 init-c_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 init-c_0)(values))))"
"(let-values(((init-v_0)(digit->number init-c_0)))"
"(let-values(((v_0)"
"(let-values(((in67_0) in_0)"
"((config68_0) config_0)"
"((accum-str69_0) accum-str_0)"
"((temp70_0) 10)"
"((temp71_0) +inf.0)"
"((init-v72_0) init-v_0)"
"((init-v73_0) init-v_0))"
"(read-digits.1 temp70_0 init-v72_0 temp71_0 init-v73_0 in67_0 config68_0 accum-str69_0))))"
"(values"
" v_0"
"(let-values(((accum-str74_0) accum-str_0)((config75_0) config_0))"
"(accum-string-get!.1 0 accum-str74_0 config75_0))"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))))))))"
"(define-values"
"(read-struct)"
"(lambda(read-one_0 dispatch-c_0 in_0 config_0)"
"(begin"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values(((seq_0)"
"(let-values(((tmp_0) ec_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values()(read-struct-sequence read-one_0 c_0 '#\\( '#\\) in_0 config_0))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)"
"(let-values()(read-struct-sequence read-one_0 c_0 '#\\[ '#\\] in_0 config_0))"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"                                                 ((temp3_0) (format \"~as~a\" dispatch-c_0 c_0)))"
"(bad-syntax-error.1 '#\\x in1_0 config2_0 temp3_0)))))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)"
"(let-values()(read-struct-sequence read-one_0 c_0 '#\\{ '#\\} in_0 config_0))"
"(let-values()"
"(let-values(((in4_0) in_0)"
"((config5_0) config_0)"
"                                                   ((temp6_0) (format \"~as~a\" dispatch-c_0 c_0)))"
"(bad-syntax-error.1 '#\\x in4_0 config5_0 temp6_0)))))"
"(let-values()"
"(let-values(((in7_0) in_0)"
"((config8_0) config_0)"
"                                               ((temp9_0) \"expected ~a after `~as`\")"
"((temp10_0)(all-openers-str config_0))"
"((dispatch-c11_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in7_0"
" config8_0"
" temp9_0"
"(list temp10_0 dispatch-c11_0))))))))))"
"(let-values((()"
"(begin"
"(if(null? seq_0)"
"(let-values()"
"(let-values(((in12_0) in_0)"
"((config13_0) config_0)"
"                                             ((temp14_0) \"missing structure description in `~as` form\")"
"((dispatch-c15_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in12_0"
" config13_0"
" temp14_0"
"(list dispatch-c15_0))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(prefab-key?(car seq_0))"
"(void)"
"(let-values()"
"(let-values(((in16_0) in_0)"
"((config17_0) config_0)"
"                                               ((temp18_0) \"invalid structure description in `~as` form\")"
"((dispatch-c19_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in16_0"
" config17_0"
" temp18_0"
"(list dispatch-c19_0)))))"
"(values))))"
"(let-values(((st_0)"
"(let-values(((with-handlers-predicate20_0) exn:fail?)"
"((with-handlers-handler21_0)"
"(lambda(exn_0)(begin 'with-handlers-handler21 #f))))"
"(let-values(((bpz_0)(continuation-mark-set-first #f break-enabled-key)))"
"(call-handled-body"
" bpz_0"
"(lambda(e_0)"
"(select-handler/no-breaks"
" e_0"
" bpz_0"
"(list(cons with-handlers-predicate20_0 with-handlers-handler21_0))))"
"(lambda()(prefab-key->struct-type(car seq_0)(length(cdr seq_0)))))))))"
"(begin"
"(if st_0"
"(void)"
"(let-values()"
"(let-values(((in22_0) in_0)"
"((config23_0) config_0)"
"((temp24_0)"
"(string-append"
"                                       \"mismatch between structure description\""
"                                       \" and number of provided field values in `~as` form\"))"
"((dispatch-c25_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in22_0"
" config23_0"
" temp24_0"
"(list dispatch-c25_0)))))"
"(if(read-config-for-syntax? config_0)"
"(let-values()"
"(if(all-fields-immutable?(car seq_0))"
"(void)"
"(let-values()"
"(let-values(((in26_0) in_0)"
"((config27_0) config_0)"
"                                         ((temp28_0) \"cannot read mutable `~as` form as syntax\")"
"((dispatch-c29_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in26_0"
" config27_0"
" temp28_0"
"(list dispatch-c29_0))))))"
"(void))"
"(wrap(apply make-prefab-struct seq_0) in_0 config_0 ec_0)))))))))))"
"(define-values"
"(read-struct-sequence)"
"(lambda(read-one_0 opener-c_0 opener_0 closer_0 in_0 config_0)"
"(begin"
"(let-values(((read-one30_0) read-one_0)"
"((opener-c31_0) opener-c_0)"
"((opener32_0) opener_0)"
"((closer33_0) closer_0)"
"((in34_0) in_0)"
"((config35_0) config_0)"
"((temp36_0)"
"(lambda(init-c_0 in_1 config_1)(read-one_0 init-c_0 in_1(disable-wrapping config_1)))))"
"(read-unwrapped-sequence.1"
" 'all"
" unsafe-undefined"
" temp36_0"
" #f"
" unsafe-undefined"
" read-one30_0"
" opener-c31_0"
" opener32_0"
" closer33_0"
" in34_0"
" config35_0)))))"
"(define-values"
"(read-vector-or-graph)"
"(lambda(read-one_0 dispatch-c_0 init-c_0 in_0 config_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 init-c_0)(values))))"
"(let-values(((init-v_0)(digit->number init-c_0)))"
"(let-values(((v_0)"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((accum-str3_0) accum-str_0)"
"((temp4_0) 10)"
"((temp5_0) +inf.0)"
"((init-v6_0) init-v_0)"
"((init-v7_0) init-v_0))"
"(read-digits.1 temp4_0 init-v6_0 temp5_0 init-v7_0 in1_0 config2_0 accum-str3_0))))"
"(let-values(((post-line_0 post-col_0 post-pos_0)(port-next-location in_0)))"
"(let-values(((get-accum_0)"
"(lambda(c_0)"
"(begin"
" 'get-accum"
"(format"
"                                   \"~a~a~a\""
" dispatch-c_0"
"(let-values(((accum-str8_0) accum-str_0)((config9_0) config_0))"
"(accum-string-get!.1 0 accum-str8_0 config9_0))"
" c_0)))))"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values(((tmp_0) ec_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values()"
"(begin"
"(accum-string-abandon! accum-str_0 config_0)"
"(let-values(((read-one10_0) read-one_0)"
"((c11_0) c_0)"
"((temp12_0) '#\\()"
"((temp13_0) '#\\))"
"((in14_0) in_0)"
"((config15_0) config_0)"
"((v16_0) v_0))"
"(read-vector.1 v16_0 'any read-one10_0 c11_0 temp12_0 temp13_0 in14_0 config15_0))))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(begin"
"(accum-string-abandon! accum-str_0 config_0)"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)"
"(let-values()"
"(let-values(((read-one17_0) read-one_0)"
"((c18_0) c_0)"
"((temp19_0) '#\\[)"
"((temp20_0) '#\\])"
"((in21_0) in_0)"
"((config22_0) config_0)"
"((v23_0) v_0))"
"(read-vector.1"
" v23_0"
" 'any"
" read-one17_0"
" c18_0"
" temp19_0"
" temp20_0"
" in21_0"
" config22_0)))"
"(let-values()"
"(let-values(((in24_0) in_0)"
"((config25_0) config_0)"
"((temp26_0)(get-accum_0(get-accum_0 c_0))))"
"(bad-syntax-error.1 '#\\x in24_0 config25_0 temp26_0))))))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(begin"
"(accum-string-abandon! accum-str_0 config_0)"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)"
"(let-values()"
"(let-values(((read-one27_0) read-one_0)"
"((c28_0) c_0)"
"((temp29_0) '#\\{)"
"((temp30_0) '#\\})"
"((in31_0) in_0)"
"((config32_0) config_0)"
"((v33_0) v_0))"
"(read-vector.1"
" v33_0"
" 'any"
" read-one27_0"
" c28_0"
" temp29_0"
" temp30_0"
" in31_0"
" config32_0)))"
"(let-values()"
"(let-values(((in34_0) in_0)"
"((config35_0) config_0)"
"((temp36_0)(get-accum_0(get-accum_0 c_0))))"
"(bad-syntax-error.1 '#\\x in34_0 config35_0 temp36_0))))))"
"(let-values()"
"(let-values(((tmp_1) c_0))"
"(if(if(equal? tmp_1 '#\\=) #t(equal? tmp_1 '#\\#))"
"(let-values()"
"(begin"
"(if(check-parameter"
"(if(read-config-for-syntax? config_0)"
" 1/read-syntax-accept-graph"
" 1/read-accept-graph)"
" config_0)"
"(void)"
"(let-values()"
"(let-values(((in37_0) in_0)"
"((config38_0) config_0)"
"                                                         ((temp39_0) \"`#...~a` forms not enabled for `~a` mode\")"
"((c40_0) c_0)"
"((temp41_0)"
"                                                          (if (read-config-for-syntax? config_0) \"read-syntax\" \"read\")))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in37_0"
" config38_0"
" temp39_0"
"(list c40_0 temp41_0)))))"
"(if(<=(accum-string-count accum-str_0) 8)"
"(void)"
"(let-values()"
"(let-values(((in42_0) in_0)"
"((config43_0) config_0)"
"                                                         ((temp44_0) \"graph ID too long in `~a~a~a`\")"
"((dispatch-c45_0) dispatch-c_0)"
"((temp46_0)"
"(let-values(((accum-str48_0) accum-str_0)"
"((config49_0) config_0))"
"(accum-string-get!.1 0 accum-str48_0 config49_0)))"
"((c47_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in42_0"
" config43_0"
" temp44_0"
"(list dispatch-c45_0 temp46_0 c47_0)))))"
"(let-values(((tmp_2) c_0))"
"(if(equal? tmp_2 '#\\=)"
"(let-values()"
"(let-values(((ph_0)(make-placeholder 'placeholder)))"
"(let-values(((ht_0)(get-graph-hash config_0)))"
"(let-values((()"
"(begin"
"(if(hash-ref ht_0 v_0 #f)"
"(let-values()"
"(let-values(((in50_0) in_0)"
"((config51_0) config_0)"
"                                                                                   ((temp52_0) \"multiple `~a~a~a` tags\")"
"((dispatch-c53_0) dispatch-c_0)"
"((temp54_0)"
"(let-values(((accum-str56_0)"
" accum-str_0)"
"((config57_0)"
" config_0))"
"(accum-string-get!.1"
" 0"
" accum-str56_0"
" config57_0)))"
"((c55_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in50_0"
" config51_0"
" temp52_0"
"(list dispatch-c53_0 temp54_0 c55_0))))"
"(void))"
"(values))))"
"(let-values((()(begin(hash-set! ht_0 v_0 ph_0)(values))))"
"(let-values(((result-v_0)"
"(read-one_0 #f in_0(next-readtable config_0))))"
"(begin"
"(if(eof-object? result-v_0)"
"(let-values()"
"(let-values(((in58_0) in_0)"
"((config59_0) config_0)"
"((result-v60_0) result-v_0)"
"((temp61_0)"
"                                                                            \"expected an element for graph after `~a~a~a`, found end-of-file\")"
"((dispatch-c62_0) dispatch-c_0)"
"((temp63_0)"
"(let-values(((accum-str65_0) accum-str_0)"
"((config66_0) config_0))"
"(accum-string-get!.1"
" 0"
" accum-str65_0"
" config66_0)))"
"((c64_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" result-v60_0"
" #f"
" unsafe-undefined"
" in58_0"
" config59_0"
" temp61_0"
"(list dispatch-c62_0 temp63_0 c64_0))))"
"(void))"
"(accum-string-abandon! accum-str_0 config_0)"
"(placeholder-set! ph_0 result-v_0)"
"(wrap ph_0 in_0 config_0 ph_0))))))))"
"(if(equal? tmp_2 '#\\#)"
"(let-values()"
"(let-values(((ph_0)"
"(hash-ref"
"(let-values(((or-part_0)"
"(read-config-state-graph"
"(read-config-st config_0))))"
"(if or-part_0 or-part_0 '#hash()))"
" v_0"
"(lambda()"
"(let-values(((in67_0) in_0)"
"((config68_0) config_0)"
"((temp69_0)"
"                                                                               \"no preceding `~a~a=` for `~a~a~a`\")"
"((dispatch-c70_0) dispatch-c_0)"
"((v71_0) v_0)"
"((dispatch-c72_0) dispatch-c_0)"
"((temp73_0)"
"(let-values(((accum-str75_0)"
" accum-str_0)"
"((config76_0) config_0))"
"(accum-string-get!.1"
" 0"
" accum-str75_0"
" config76_0)))"
"((c74_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in67_0"
" config68_0"
" temp69_0"
"(list"
" dispatch-c70_0"
" v71_0"
" dispatch-c72_0"
" temp73_0"
" c74_0)))))))"
"(begin"
"(accum-string-abandon! accum-str_0 config_0)"
"(wrap ph_0 in_0 config_0 ph_0))))"
"(let-values()(void)))))))"
"(let-values()"
"(let-values(((in77_0) in_0)"
"((config78_0) config_0)"
"((c79_0) c_0)"
"                                                   ((temp80_0) \"bad syntax `~a`\")"
"((temp81_0)(get-accum_0 c_0)))"
"(reader-error.1"
" unsafe-undefined"
" c79_0"
" #f"
" unsafe-undefined"
" in77_0"
" config78_0"
" temp80_0"
"(list temp81_0))))))))))))))))))))))"
"(define-values"
"(get-graph-hash)"
"(lambda(config_0)"
"(begin"
"(let-values(((st_0)(read-config-st config_0)))"
"(let-values(((or-part_0)(read-config-state-graph st_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheqv)))(begin(set-read-config-state-graph! st_0 ht_0) ht_0))))))))"
"(define-values"
"(coerce-key)"
"(lambda(key_0 config_0)"
"(begin"
"(let-values(((for-syntax?_0)(read-config-for-syntax? config_0)))"
"((read-config-coerce-key config_0) for-syntax?_0 key_0)))))"
"(define-values"
"(read-hash)"
"(lambda(read-one_0 dispatch-c_0 init-c_0 in_0 config_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 dispatch-c_0)(values))))"
"(let-values((()(begin(accum-string-add! accum-str_0 init-c_0)(values))))"
"(let-values(((get-next!_0)"
"(lambda(expect-c_0 expect-alt-c_0)"
"(begin"
" 'get-next!"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(let-values(((or-part_0)(eqv? c_0 expect-c_0)))"
"(if or-part_0 or-part_0(eqv? c_0 expect-alt-c_0)))"
"(void)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((c3_0) c_0)"
"                                                   ((temp4_0) \"expected `~a` after `~a`\")"
"((expect-c5_0) expect-c_0)"
"((temp6_0)"
"(let-values(((accum-str7_0) accum-str_0)((config8_0) config_0))"
"(accum-string-get!.1 0 accum-str7_0 config8_0))))"
"(reader-error.1"
" unsafe-undefined"
" c3_0"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp4_0"
"(list expect-c5_0 temp6_0)))))"
"(accum-string-add! accum-str_0 c_0)))))))"
"(let-values((()(begin(get-next!_0 '#\\a '#\\A)(values))))"
"(let-values((()(begin(get-next!_0 '#\\s '#\\S)(values))))"
"(let-values((()(begin(get-next!_0 '#\\h '#\\H)(values))))"
"(let-values(((content_0 opener_0 mode_0)"
"((letrec-values(((loop_0)"
"(lambda(mode_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((source_0)"
"(read-config-source config_0)))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_0))))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values(((tmp_0) ec_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values()"
"(let-values(((open-end-line_0"
" open-end-col_0"
" open-end-pos_0)"
"(port-next-location in_0)))"
"(let-values(((read-one-key+value_0)"
"(make-read-one-key+value"
" read-one_0"
" c_0"
" '#\\)"
" open-end-pos_0)))"
"(values"
"(let-values(((read-one-key+value9_0)"
" read-one-key+value_0)"
"((c10_0) c_0)"
"((temp11_0) '#\\()"
"((temp12_0) '#\\))"
"((in13_0) in_0)"
"((config14_0) config_0)"
"((config15_0) config_0)"
"((temp16_0) #f))"
"(read-unwrapped-sequence.1"
" temp16_0"
" config15_0"
" unsafe-undefined"
" #f"
" unsafe-undefined"
" read-one-key+value9_0"
" c10_0"
" temp11_0"
" temp12_0"
" in13_0"
" config14_0))"
" ec_0"
" mode_0))))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(if(check-parameter"
" 1/read-square-bracket-as-paren"
" config_0)"
"(let-values()"
"(let-values(((open-end-line_0"
" open-end-col_0"
" open-end-pos_0)"
"(port-next-location in_0)))"
"(let-values(((read-one-key+value_0)"
"(make-read-one-key+value"
" read-one_0"
" c_0"
" '#\\]"
" open-end-pos_0)))"
"(values"
"(let-values(((read-one-key+value17_0)"
" read-one-key+value_0)"
"((c18_0) c_0)"
"((temp19_0) '#\\[)"
"((temp20_0) '#\\])"
"((in21_0) in_0)"
"((config22_0) config_0)"
"((config23_0) config_0)"
"((temp24_0) #f))"
"(read-unwrapped-sequence.1"
" temp24_0"
" config23_0"
" unsafe-undefined"
" #f"
" unsafe-undefined"
" read-one-key+value17_0"
" c18_0"
" temp19_0"
" temp20_0"
" in21_0"
" config22_0))"
" ec_0"
" mode_0))))"
"(let-values()"
"(let-values(((in25_0) in_0)"
"((config26_0) config_0)"
"                                                                                     ((temp27_0) \"illegal use of `~a`\")"
"((c28_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in25_0"
" config26_0"
" temp27_0"
"(list c28_0))))))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(if(check-parameter"
" 1/read-curly-brace-as-paren"
" config_0)"
"(let-values()"
"(let-values(((open-end-line_0"
" open-end-col_0"
" open-end-pos_0)"
"(port-next-location in_0)))"
"(let-values(((read-one-key+value_0)"
"(make-read-one-key+value"
" read-one_0"
" c_0"
" '#\\}"
" open-end-pos_0)))"
"(values"
"(let-values(((read-one-key+value29_0)"
" read-one-key+value_0)"
"((c30_0) c_0)"
"((temp31_0) '#\\{)"
"((temp32_0) '#\\})"
"((in33_0) in_0)"
"((config34_0) config_0)"
"((config35_0) config_0)"
"((temp36_0) #f))"
"(read-unwrapped-sequence.1"
" temp36_0"
" config35_0"
" unsafe-undefined"
" #f"
" unsafe-undefined"
" read-one-key+value29_0"
" c30_0"
" temp31_0"
" temp32_0"
" in33_0"
" config34_0))"
" ec_0"
" mode_0))))"
"(let-values()"
"(let-values(((in37_0) in_0)"
"((config38_0) config_0)"
"((temp39_0)"
"                                                                                        \"illegal use of `~a`\")"
"((c40_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in37_0"
" config38_0"
" temp39_0"
"(list c40_0))))))"
"(if(if(equal? tmp_0 '#\\e) #t(equal? tmp_0 '#\\E))"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(get-next!_0 '#\\q '#\\Q)"
"(loop_0 'eq)))"
"(if(if(equal? tmp_0 '#\\v)"
" #t"
"(equal? tmp_0 '#\\V))"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(if(eq? mode_0 'eq)"
"(loop_0 'eqv)"
"(let-values(((in41_0) in_0)"
"((config42_0) config_0)"
"((temp43_0)"
"                                                                                            \"bad syntax `~a`\")"
"((temp44_0)"
"(let-values(((accum-str45_0)"
" accum-str_0)"
"((config46_0)"
" config_0))"
"(accum-string-get!.1"
" 0"
" accum-str45_0"
" config46_0))))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in41_0"
" config42_0"
" temp43_0"
"(list temp44_0))))))"
"(if(if(equal? tmp_0 '#\\a)"
" #t"
"(equal? tmp_0 '#\\A))"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(get-next!_0 '#\\l '#\\L)"
"(get-next!_0 '#\\w '#\\W)"
"(if(eq? mode_0 'equal)"
"(loop_0 'equal-always)"
"(let-values(((in47_0) in_0)"
"((config48_0) config_0)"
"((temp49_0)"
"                                                                                              \"bad syntax `~a`\")"
"((temp50_0)"
"(let-values(((accum-str51_0)"
" accum-str_0)"
"((config52_0)"
" config_0))"
"(accum-string-get!.1"
" 0"
" accum-str51_0"
" config52_0))))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in47_0"
" config48_0"
" temp49_0"
"(list temp50_0))))))"
"(let-values()"
"(begin"
"(if(char? c_0)"
"(let-values()"
"(accum-string-add! accum-str_0 c_0))"
"(void))"
"(let-values(((in53_0) in_0)"
"((config54_0) config_0)"
"((c55_0) c_0)"
"((temp56_0)"
"                                                                                            \"bad syntax `~a`\")"
"((temp57_0)"
"(let-values(((accum-str58_0)"
" accum-str_0)"
"((config59_0)"
" config_0))"
"(accum-string-get!.1"
" 0"
" accum-str58_0"
" config59_0))))"
"(reader-error.1"
" unsafe-undefined"
" c55_0"
" #f"
" unsafe-undefined"
" in53_0"
" config54_0"
" temp56_0"
"(list temp57_0))))))))))))))))))"
" loop_0)"
" 'equal)))"
"(let-values(((graph?_0)(if(read-config-state-graph(read-config-st config_0)) #t #f)))"
"(wrap"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'equal)"
"(let-values()"
"(if graph?_0(make-hash-placeholder content_0)(make-immutable-hash content_0)))"
"(if(equal? tmp_0 'eq)"
"(let-values()"
"(if graph?_0(make-hasheq-placeholder content_0)(make-immutable-hasheq content_0)))"
"(if(equal? tmp_0 'eqv)"
"(let-values()"
"(if graph?_0"
"(make-hasheqv-placeholder content_0)"
"(make-immutable-hasheqv content_0)))"
"(if(equal? tmp_0 'equal-always)"
"(let-values()"
"(if graph?_0"
"(make-hashalw-placeholder content_0)"
"(make-immutable-hashalw content_0)))"
"(let-values()(void)))))))"
" in_0"
" config_0"
" opener_0)))))))))))))"
"(define-values"
"(make-read-one-key+value)"
"(lambda(read-one_0 overall-opener-c_0 overall-closer-ec_0 prefix-end-pos_0)"
"(begin"
"(lambda(init-c_0 in_0 config/maybe-keep-comment_0)"
"(let-values(((config_0)(discard-comment config/maybe-keep-comment_0)))"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments init-c_0 read-one_0 in_0 config_0)))"
"(let-values(((open-line_0 open-col_0 open-pos_0)(port-next-location* in_0 c_0)))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values(((elem-config_0)(next-readtable config_0)))"
"(let-values(((closer_0)"
"(let-values(((tmp_0) ec_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values() '#\\))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(if(check-parameter 1/read-square-bracket-as-paren config_0) '#\\] #f))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(if(check-parameter 1/read-curly-brace-as-paren config_0) '#\\} #f))"
"(let-values() #f)))))))"
"(if(not closer_0)"
"(let-values()"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in60_0) in_0)"
"((config61_0) config_0)"
"((c62_0) c_0)"
"((prefix-end-pos63_0) prefix-end-pos_0)"
"                                         ((temp64_0) \"expected ~a to close `~a`\")"
"((temp65_0)(closer-name overall-closer-ec_0 config_0))"
"((overall-opener-c66_0) overall-opener-c_0))"
"(reader-error.1"
" unsafe-undefined"
" c62_0"
" prefix-end-pos63_0"
" unsafe-undefined"
" in60_0"
" config61_0"
" temp64_0"
"(list temp65_0 overall-opener-c66_0))))"
"(if(char-closer? ec_0 config_0)"
"(let-values()"
"(let-values(((in67_0) in_0)"
"((temp68_0)(reading-at config_0 open-line_0 open-col_0 open-pos_0))"
"                                           ((temp69_0) \"~a\")"
"((temp70_0)(indentation-unexpected-closer-message ec_0 c_0 config_0)))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in67_0"
" temp68_0"
" temp69_0"
"(list temp70_0))))"
"(let-values(((c1_0)(special-comment-via-readtable? c_0 read-one_0 in_0 elem-config_0)))"
"(if c1_0"
"((lambda(v_0)"
"(if(read-config-keep-comment? config/maybe-keep-comment_0)"
" v_0"
"((make-read-one-key+value"
" read-one_0"
" overall-opener-c_0"
" overall-closer-ec_0"
" prefix-end-pos_0)"
" #f"
" in_0"
" config_0)))"
" c1_0)"
"(let-values()"
"(let-values(((in71_0) in_0)"
"((temp72_0)(reading-at config_0 open-line_0 open-col_0 open-pos_0))"
"                                               ((temp73_0) \"expected ~a to start a hash pair\")"
"((temp74_0)(all-openers-str config_0)))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in71_0"
" temp72_0"
" temp73_0"
"(list temp74_0)))))))))"
"(let-values()"
"(let-values(((k_0)(read-one_0 #f in_0(disable-wrapping elem-config_0))))"
"((letrec-values(((dot-loop_0)"
"(lambda()"
"(begin"
" 'dot-loop"
"(let-values(((dot-c_0)"
"(read-char/skip-whitespace-and-comments"
" #f"
" read-one_0"
" in_0"
" config_0)))"
"(let-values(((dot-line_0 dot-col_0 dot-pos_0)"
"(port-next-location* in_0 dot-c_0)))"
"(let-values(((dot-ec_0)(effective-char dot-c_0 config_0)))"
"(if(if(eqv? dot-ec_0 '#\\.)"
"(char-delimiter?"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))"
" config_0)"
" #f)"
"(let-values()"
"(let-values(((v_0)(read-one_0 #f in_0 elem-config_0)))"
"((letrec-values(((closer-loop_0)"
"(lambda()"
"(begin"
" 'closer-loop"
"(let-values(((closer-c_0)"
"(read-char/skip-whitespace-and-comments"
" #f"
" read-one_0"
" in_0"
" config_0)))"
"(let-values(((closer-line_0"
" closer-col_0"
" closer-pos_0)"
"(port-next-location*"
" in_0"
" closer-c_0)))"
"(let-values(((closer-ec_0)"
"(effective-char"
" closer-c_0"
" config_0)))"
"(if(eqv? closer-ec_0 closer_0)"
"(let-values()"
"(cons"
"(coerce-key"
" k_0"
" elem-config_0)"
" v_0))"
"(if(special-comment-via-readtable?"
" closer-c_0"
" read-one_0"
" in_0"
" config_0)"
"(let-values()"
"(closer-loop_0))"
"(let-values()"
"(let-values(((in75_0)"
" in_0)"
"((temp76_0)"
"(reading-at"
" config_0"
" closer-line_0"
" closer-col_0"
" closer-pos_0))"
"((closer-c77_0)"
" closer-c_0)"
"((temp78_0)"
"                                                                                                            \"expected ~a after value within a hash\")"
"((temp79_0)"
"(closer-name"
" closer_0"
" config_0)))"
"(reader-error.1"
" unsafe-undefined"
" closer-c77_0"
" #f"
" unsafe-undefined"
" in75_0"
" temp76_0"
" temp78_0"
"(list"
" temp79_0)))))))))))))"
" closer-loop_0))))"
"(if(special-comment-via-readtable?"
" dot-c_0"
" read-one_0"
" in_0"
" config_0)"
"(let-values()(dot-loop_0))"
"(let-values()"
"(let-values(((in80_0) in_0)"
"((temp81_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0))"
"((dot-c82_0) dot-c_0)"
"                                                                         ((temp83_0) \"expected ~a and value for hash\")"
"((temp84_0)(dot-name config_0)))"
"(reader-error.1"
" unsafe-undefined"
" dot-c82_0"
" #f"
" unsafe-undefined"
" in80_0"
" temp81_0"
" temp83_0"
"(list temp84_0)))))))))))))"
" dot-loop_0)))))))))))))))"
"(define-values"
"(read-string.1)"
"(lambda(mode1_0 in3_0 config4_0)"
"(begin"
" 'read-string"
"(let-values(((in_0) in3_0))"
"(let-values(((config_0) config4_0))"
"(let-values(((mode_0) mode1_0))"
"(let-values()"
"(let-values(((source_0)(read-config-source config_0)))"
"(let-values(((open-end-line_0 open-end-col_0 open-end-pos_0)(port-next-location in_0)))"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values(((bad-end_0)"
"(lambda(c_0)"
"(begin"
" 'bad-end"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in6_0) in_0)"
"((config7_0) config_0)"
"((c8_0) c_0)"
"((open-end-pos9_0) open-end-pos_0)"
"                                                       ((temp10_0) \"expected a closing `\\\"`\"))"
"(reader-error.1"
" unsafe-undefined"
" c8_0"
" open-end-pos9_0"
" unsafe-undefined"
" in6_0"
" config7_0"
" temp10_0"
"(list))))"
"(let-values()"
"(let-values(((in11_0) in_0)"
"((config12_0) config_0)"
"((c13_0) c_0)"
"                                                       ((temp14_0) \"found non-character while reading a ~a\")"
"((mode15_0) mode_0))"
"(reader-error.1"
" unsafe-undefined"
" c13_0"
" #f"
" unsafe-undefined"
" in11_0"
" config12_0"
" temp14_0"
"(list mode15_0)))))))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((source_1) source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(if(not(char? c_0))"
"(let-values()(bad-end_0 c_0))"
"(if(char=? '#\\\\ c_0)"
"(let-values()"
"(let-values(((escaping-c_0) c_0))"
"(let-values(((escaped-c_0)"
"(let-values(((in_1) in_0)"
"((source_1) source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(let-values((()"
"(begin"
"(if(not(char? escaped-c_0))"
"(let-values()"
"(bad-end_0 escaped-c_0))"
"(void))"
"(values))))"
"(let-values(((unknown-error_0)"
"(lambda()"
"(begin"
" 'unknown-error"
"(let-values(((in16_0) in_0)"
"((config17_0)"
" config_0)"
"((temp18_0)"
"                                                                                                          \"unknown escape sequence `~a~a` in ~a\")"
"((escaping-c19_0)"
" escaping-c_0)"
"((escaped-c20_0)"
" escaped-c_0)"
"((mode21_0)"
" mode_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in16_0"
" config17_0"
" temp18_0"
"(list"
" escaping-c19_0"
" escaped-c20_0"
" mode21_0)))))))"
"(begin"
"(let-values(((tmp_0) escaped-c_0))"
"(let-values(((index_0)"
"(if(char? tmp_0)"
"(let-values(((codepoint_0)"
"(char->integer"
" tmp_0)))"
"(if(if(unsafe-fx>="
" codepoint_0"
" 10)"
"(unsafe-fx<"
" codepoint_0"
" 121)"
" #f)"
"(let-values(((tbl_0)"
" '#(10"
" 0"
" 0"
" 11"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 12"
" 12"
" 12"
" 12"
" 12"
" 12"
" 12"
" 12"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 15"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 2"
" 3"
" 0"
" 0"
" 9"
" 7"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 5"
" 0"
" 0"
" 0"
" 8"
" 0"
" 4"
" 14"
" 6"
" 0"
" 13)))"
"(unsafe-vector*-ref"
" tbl_0"
"(unsafe-fx-"
" codepoint_0"
" 10)))"
" 0))"
" 0)))"
"(if(unsafe-fx< index_0 7)"
"(if(unsafe-fx< index_0 3)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(unknown-error_0))"
"(if(unsafe-fx< index_0 2)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" escaped-c_0))"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\u0007))))"
"(if(unsafe-fx< index_0 4)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\backspace))"
"(if(unsafe-fx< index_0 5)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\tab))"
"(if(unsafe-fx< index_0 6)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\newline))"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\vtab))))))"
"(if(unsafe-fx< index_0 11)"
"(if(unsafe-fx< index_0 8)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\page))"
"(if(unsafe-fx< index_0 9)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\return))"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\u001B))"
"(let-values()(void)))))"
"(if(unsafe-fx< index_0 13)"
"(if(unsafe-fx< index_0 12)"
"(let-values()"
"(let-values(((maybe-newline-c_0)"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_1)"
" source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq?"
" c_1"
" 'special)"
"(special1.1"
" 'special)"
" c_1)))))"
"(begin"
"(if(eqv?"
" maybe-newline-c_0"
" '#\\newline)"
"(let-values()"
"(consume-char"
" in_0"
" maybe-newline-c_0))"
"(void))"
"(void))))"
"(let-values()"
"(let-values(((pos_0)"
"(accum-string-count"
" accum-str_0)))"
"(let-values((()"
"(begin"
"(accum-string-add!"
" accum-str_0"
" escaped-c_0)"
"(values))))"
"(let-values(((init-v_0)"
"(digit->number"
" escaped-c_0)))"
"(let-values(((v_0)"
"(let-values(((in22_0)"
" in_0)"
"((config23_0)"
" config_0)"
"((accum-str24_0)"
" accum-str_0)"
"((temp25_0)"
" 8)"
"((temp26_0)"
" 2)"
"((init-v27_0)"
" init-v_0)"
"((init-v28_0)"
" init-v_0))"
"(read-digits.1"
" temp25_0"
" init-v27_0"
" temp26_0"
" init-v28_0"
" in22_0"
" config23_0"
" accum-str24_0))))"
"(begin"
"(if(<= v_0 255)"
"(void)"
"(let-values()"
"(let-values(((in29_0)"
" in_0)"
"((config30_0)"
" config_0)"
"((temp31_0)"
"                                                                                                                        \"escape sequence `~a~a` is out of range in ~a\")"
"((escaping-c32_0)"
" escaping-c_0)"
"((temp33_0)"
"(let-values(((accum-str35_0)"
" accum-str_0)"
"((config36_0)"
" config_0)"
"((pos37_0)"
" pos_0))"
"(accum-string-get!.1"
" pos37_0"
" accum-str35_0"
" config36_0)))"
"((mode34_0)"
" mode_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in29_0"
" config30_0"
" temp31_0"
"(list"
" escaping-c32_0"
" temp33_0"
" mode34_0)))))"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" v_0)))))))))"
"(if(unsafe-fx< index_0 14)"
"(let-values()"
"(let-values(((pos_0)"
"(accum-string-count"
" accum-str_0)))"
"(let-values(((v_0)"
"(let-values(((in38_0)"
" in_0)"
"((config39_0)"
" config_0)"
"((accum-str40_0)"
" accum-str_0)"
"((temp41_0)"
" 16)"
"((temp42_0)"
" 2))"
"(read-digits.1"
" temp41_0"
" 0"
" temp42_0"
" #f"
" in38_0"
" config39_0"
" accum-str40_0))))"
"(begin"
"(if(integer? v_0)"
"(void)"
"(let-values()"
"(no-hex-digits"
" in_0"
" config_0"
" v_0"
" escaping-c_0"
" escaped-c_0)))"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" v_0))))))"
"(if(unsafe-fx< index_0 15)"
"(let-values()"
"(let-values((()"
"(begin"
"(if(eq?"
" mode_0"
" 'string)"
"(void)"
"(let-values()"
"(unknown-error_0)))"
"(values))))"
"(let-values(((pos_0)"
"(accum-string-count"
" accum-str_0)))"
"(let-values(((v_0)"
"(let-values(((in43_0)"
" in_0)"
"((config44_0)"
" config_0)"
"((accum-str45_0)"
" accum-str_0)"
"((temp46_0)"
" 16)"
"((temp47_0)"
" 4))"
"(read-digits.1"
" temp46_0"
" 0"
" temp47_0"
" #f"
" in43_0"
" config44_0"
" accum-str45_0))))"
"(begin"
"(if(integer? v_0)"
"(void)"
"(let-values()"
"(no-hex-digits"
" in_0"
" config_0"
" v_0"
" escaping-c_0"
" escaped-c_0)))"
"(if(let-values(((or-part_0)"
"(<"
" v_0"
" 55296)))"
"(if or-part_0"
" or-part_0"
"(>"
" v_0"
" 57343)))"
"(let-values()"
"(begin"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" v_0))))"
"(let-values()"
"(let-values(((next!_0)"
"(lambda()"
"(begin"
" 'next!"
"(let-values(((next-c_0)"
"(let-values(((in_1)"
" in_0)"
"((source_1)"
" source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(begin"
"(if(char?"
" next-c_0)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" next-c_0))"
"(void))"
" next-c_0))))))"
"(let-values(((v2_0)"
"(let-values(((next-c_0)"
"(next!_0)))"
"(if(char=?"
" next-c_0"
" '#\\\\)"
"(let-values()"
"(let-values(((next-c_1)"
"(next!_0)))"
"(if(char=?"
" next-c_1"
" '#\\u)"
"(let-values()"
"(let-values(((v2_0)"
"(let-values(((in48_0)"
" in_0)"
"((config49_0)"
" config_0)"
"((accum-str50_0)"
" accum-str_0)"
"((temp51_0)"
" 16)"
"((temp52_0)"
" 4))"
"(read-digits.1"
" temp51_0"
" 0"
" temp52_0"
" #f"
" in48_0"
" config49_0"
" accum-str50_0))))"
"(if(integer?"
" v2_0)"
"(let-values()"
"(if(>="
" v2_0"
" 56320)"
"(if(<="
" v2_0"
" 57343)"
" v2_0"
" #f)"
" #f))"
"(let-values()"
" v2_0))))"
"(let-values()"
" next-c_1))))"
"(let-values()"
" next-c_0)))))"
"(if(integer?"
" v2_0)"
"(let-values()"
"(let-values(((combined-v_0)"
"(+"
"(arithmetic-shift"
"(-"
" v_0"
" 55296)"
" 10)"
"(-"
" v2_0"
" 56320)"
" 65536)))"
"(if(>"
" combined-v_0"
" 1114111)"
"(let-values()"
"(let-values(((in53_0)"
" in_0)"
"((config54_0)"
" config_0)"
"((temp55_0)"
"                                                                                                                                      \"escape sequence `~au~a` is out of range in string\")"
"((escaping-c56_0)"
" escaping-c_0)"
"((temp57_0)"
"(let-values(((accum-str58_0)"
" accum-str_0)"
"((config59_0)"
" config_0)"
"((pos60_0)"
" pos_0))"
"(accum-string-get!.1"
" pos60_0"
" accum-str58_0"
" config59_0))))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in53_0"
" config54_0"
" temp55_0"
"(list"
" escaping-c56_0"
" temp57_0))))"
"(let-values()"
"(begin"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" combined-v_0)))))))"
"(let-values()"
"(let-values(((in61_0)"
" in_0)"
"((config62_0)"
" config_0)"
"((v263_0)"
" v2_0)"
"((temp64_0)"
"                                                                                                                                \"bad or incomplete surrogate-style encoding at `~au~a`\")"
"((escaping-c65_0)"
" escaping-c_0)"
"((temp66_0)"
"(let-values(((accum-str67_0)"
" accum-str_0)"
"((config68_0)"
" config_0)"
"((pos69_0)"
" pos_0))"
"(accum-string-get!.1"
" pos69_0"
" accum-str67_0"
" config68_0))))"
"(reader-error.1"
" unsafe-undefined"
" v263_0"
" #f"
" unsafe-undefined"
" in61_0"
" config62_0"
" temp64_0"
"(list"
" escaping-c65_0"
" temp66_0))))))))))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(eq?"
" mode_0"
" 'string)"
"(void)"
"(let-values()"
"(unknown-error_0)))"
"(values))))"
"(let-values(((pos_0)"
"(accum-string-count"
" accum-str_0)))"
"(let-values(((v_0)"
"(let-values(((in70_0)"
" in_0)"
"((config71_0)"
" config_0)"
"((accum-str72_0)"
" accum-str_0)"
"((temp73_0)"
" 16)"
"((temp74_0)"
" 8))"
"(read-digits.1"
" temp73_0"
" 0"
" temp74_0"
" #f"
" in70_0"
" config71_0"
" accum-str72_0))))"
"(begin"
"(if(integer? v_0)"
"(void)"
"(let-values()"
"(no-hex-digits"
" in_0"
" config_0"
" v_0"
" escaping-c_0"
" escaped-c_0)))"
"(if(if(let-values(((or-part_0)"
"(<"
" v_0"
" 55296)))"
"(if or-part_0"
" or-part_0"
"(>"
" v_0"
" 57343)))"
"(<="
" v_0"
" 1114111)"
" #f)"
"(let-values()"
"(begin"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" v_0))))"
"(let-values()"
"(let-values(((in75_0)"
" in_0)"
"((config76_0)"
" config_0)"
"((temp77_0)"
"                                                                                                                        \"escape sequence `~aU~a` is out of range in string\")"
"((escaping-c78_0)"
" escaping-c_0)"
"((temp79_0)"
"(let-values(((accum-str80_0)"
" accum-str_0)"
"((config81_0)"
" config_0)"
"((pos82_0)"
" pos_0))"
"(accum-string-get!.1"
" pos82_0"
" accum-str80_0"
" config81_0))))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in75_0"
" config76_0"
" temp77_0"
"(list"
" escaping-c78_0"
" temp79_0)))))))))))))))))"
"(loop_0)))))))"
"                                                                  (if (char=? '#\\\" c_0)"
"(let-values() null)"
"(let-values()"
"(begin"
"(if(eq? mode_0 '|byte string|)"
"(let-values()"
"(if(byte?(char->integer c_0))"
"(void)"
"(let-values()"
"(let-values(((in83_0) in_0)"
"((config84_0) config_0)"
"((temp85_0)"
"                                                                                              \"character `~a` is out of range in byte string\")"
"((c86_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in83_0"
" config84_0"
" temp85_0"
"(list c86_0))))))"
"(void))"
"(accum-string-add! accum-str_0 c_0)"
"(loop_0)))))))))))"
" loop_0))"
"(values))))"
"(let-values(((str_0)"
"(if(eq? mode_0 '|byte string|)"
"(let-values(((accum-str87_0) accum-str_0)((config88_0) config_0))"
"(accum-string-get-bytes!.1 0 accum-str87_0 config88_0))"
"(let-values(((accum-str89_0) accum-str_0)((config90_0) config_0))"
"(accum-string-get!.1 0 accum-str89_0 config90_0)))))"
"(wrap str_0 in_0 config_0 str_0))))))))))))))"
"(define-values"
"(read-here-string)"
"(lambda(in_0 config_0)"
"(begin"
"(let-values(((source_0)(read-config-source config_0)))"
"(let-values(((open-end-line_0 open-end-col_0 open-end-pos_0)(port-next-location in_0)))"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values(((full-terminator_0)"
"(cons"
" '#\\newline"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_1) source_0))"
"(read-char-or-special in_1 special1.1 source_1))))"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in91_0) in_0)"
"((config92_0) config_0)"
"((c93_0) c_0)"
"((temp94_0)"
"                                                                     \"found end-of-file after `#<<` and before a newline\"))"
"(reader-error.1"
" unsafe-undefined"
" c93_0"
" #f"
" unsafe-undefined"
" in91_0"
" config92_0"
" temp94_0"
"(list))))"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((in95_0) in_0)"
"((config96_0) config_0)"
"((c97_0) c_0)"
"((temp98_0)"
"                                                                       \"found non-character while reading `#<<`\"))"
"(reader-error.1"
" unsafe-undefined"
" c97_0"
" #f"
" unsafe-undefined"
" in95_0"
" config96_0"
" temp98_0"
"(list))))"
"(if(char=? c_0 '#\\newline)"
"(let-values() null)"
"(let-values()(cons c_0(loop_0)))))))))))"
" loop_0)))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(terminator_0 terminator-accum_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_1) source_0))"
"(read-char-or-special in_1 special1.1 source_1))))"
"(if(eof-object? c_0)"
"(let-values()"
"(if(null? terminator_0)"
"(void)"
"(let-values()"
"(let-values(((in99_0) in_0)"
"((config100_0) config_0)"
"((c101_0) c_0)"
"((open-end-pos102_0) open-end-pos_0)"
"((temp103_0)"
"                                                                            \"found end-of-file before terminating `~a`\")"
"((temp104_0)"
"(list->string(cdr full-terminator_0))))"
"(reader-error.1"
" unsafe-undefined"
" c101_0"
" open-end-pos102_0"
" unsafe-undefined"
" in99_0"
" config100_0"
" temp103_0"
"(list temp104_0))))))"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((in105_0) in_0)"
"((config106_0) config_0)"
"((c107_0) c_0)"
"((temp108_0)"
"                                                                          \"found non-character while reading `#<<`\"))"
"(reader-error.1"
" unsafe-undefined"
" c107_0"
" #f"
" unsafe-undefined"
" in105_0"
" config106_0"
" temp108_0"
"(list))))"
"(if(if(pair? terminator_0)"
"(char=? c_0(car terminator_0))"
" #f)"
"(let-values()"
"(loop_0"
"(cdr terminator_0)"
"(cons(car terminator_0) terminator-accum_0)))"
"(if(if(null? terminator_0)(char=? c_0 '#\\newline) #f)"
"(let-values()(void))"
"(let-values()"
"(begin"
"(if(null? terminator-accum_0)"
"(void)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
"(reverse$1 terminator-accum_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((c_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" c_1))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))))"
"(if(char=? c_0 '#\\newline)"
"(let-values()"
"(loop_0"
"(cdr full-terminator_0)"
"(list '#\\newline)))"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(loop_0 full-terminator_0 null)))))))))))))))"
" loop_0)"
"(cdr full-terminator_0)"
" null)"
"(values))))"
"(let-values(((str_0)"
"(let-values(((accum-str109_0) accum-str_0)((config110_0) config_0))"
"(accum-string-get!.1 0 accum-str109_0 config110_0))))"
"(wrap str_0 in_0 config_0 str_0))))))))))"
"(define-values"
"(no-hex-digits)"
"(lambda(in_0 config_0 c_0 escaping-c_0 escaped-c_0)"
"(begin"
"(let-values(((in111_0) in_0)"
"((config112_0) config_0)"
"((c113_0) c_0)"
"                   ((temp114_0) \"no hex digit following `~a~a`\")"
"((escaping-c115_0) escaping-c_0)"
"((escaped-c116_0) escaped-c_0))"
"(reader-error.1"
" unsafe-undefined"
" c113_0"
" #f"
" unsafe-undefined"
" in111_0"
" config112_0"
" temp114_0"
"(list escaping-c115_0 escaped-c116_0))))))"
"(define-values"
"(read-character)"
"(lambda(in_0 config_0)"
"(begin"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((char_0)"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((c3_0) c_0)"
"                                       ((temp4_0) \"expected a character after `#\\\\`\"))"
"(reader-error.1 unsafe-undefined c3_0 #f unsafe-undefined in1_0 config2_0 temp4_0(list))))"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((in5_0) in_0)"
"((config6_0) config_0)"
"((c7_0) c_0)"
"                                         ((temp8_0) \"found non-character after `#\\\\`\"))"
"(reader-error.1"
" unsafe-undefined"
" c7_0"
" #f"
" unsafe-undefined"
" in5_0"
" config6_0"
" temp8_0"
"(list))))"
"(if(octal-digit? c_0)"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special in_1 skip-count_0 'special source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(if(char? c2_0)(octal-digit? c2_0) #f)"
"(let-values()"
"(let-values((()(begin(consume-char in_0 c2_0)(values))))"
"(let-values(((c3_0)"
"(let-values(((in_1) in_0)"
"((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((v_0)"
"(if(if(char? c3_0)(octal-digit? c3_0) #f)"
"(let-values()"
"(+"
"(arithmetic-shift(digit->number c_0) 6)"
"(arithmetic-shift(digit->number c2_0) 3)"
"(digit->number c3_0)))"
"(let-values() #f))))"
"(begin"
"(if(if v_0(<= v_0 255) #f)"
"(void)"
"(let-values()"
"(let-values(((in9_0) in_0)"
"((config10_0) config_0)"
"((c311_0) c3_0)"
"                                                             ((temp12_0) \"bad character constant `#\\\\~a~a~a`\")"
"((c13_0) c_0)"
"((c214_0) c2_0)"
"                                                             ((temp15_0) (if (char? c3_0) c3_0 \"\")))"
"(reader-error.1"
" unsafe-undefined"
" c311_0"
" #f"
" unsafe-undefined"
" in9_0"
" config10_0"
" temp12_0"
"(list c13_0 c214_0 temp15_0)))))"
"(integer->char v_0))))))"
"(let-values() c_0))))"
"(if(let-values(((or-part_0)(char=? c_0 '#\\u)))"
"(if or-part_0 or-part_0(char=? c_0 '#\\U)))"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values(((v_0)"
"(let-values(((in16_0) in_0)"
"((config17_0) config_0)"
"((accum-str18_0) accum-str_0)"
"((temp19_0) 16)"
"((temp20_0)(if(char=? c_0 '#\\u) 4 8)))"
"(read-digits.1"
" temp19_0"
" 0"
" temp20_0"
" #f"
" in16_0"
" config17_0"
" accum-str18_0))))"
"(if(integer? v_0)"
"(let-values()"
"(if(if(let-values(((or-part_0)(< v_0 55296)))"
"(if or-part_0 or-part_0(> v_0 57343)))"
"(<= v_0 1114111)"
" #f)"
"(let-values()"
"(begin(accum-string-abandon! accum-str_0 config_0)(integer->char v_0)))"
"(let-values()"
"(let-values(((in21_0) in_0)"
"((config22_0) config_0)"
"                                                         ((temp23_0) \"bad character constant `#\\\\u~a`\")"
"((temp24_0)"
"(let-values(((accum-str25_0) accum-str_0)"
"((config26_0) config_0))"
"(accum-string-get!.1 0 accum-str25_0 config26_0))))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in21_0"
" config22_0"
" temp23_0"
"(list temp24_0))))))"
"(let-values()(begin(accum-string-abandon! accum-str_0 config_0) c_0))))))"
"(if(char-alphabetic? c_0)"
"(let-values()"
"(let-values(((next-c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(if(char? next-c_0)(char-alphabetic? next-c_0) #f)"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 c_0)(values))))"
"(let-values((()(begin(accum-string-add! accum-str_0 next-c_0)(values))))"
"(let-values((()(begin(consume-char in_0 next-c_0)(values))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((next-c_1)"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_0)"
"(read-config-source"
" config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq?"
" c_1"
" 'special)"
"(special1.1"
" 'special)"
" c_1)))))"
"(if(if(char? next-c_1)"
"(char-alphabetic?"
" next-c_1)"
" #f)"
"(let-values()"
"(begin"
"(accum-string-add!"
" accum-str_0"
" next-c_1)"
"(consume-char"
" in_0"
" next-c_1)"
"(loop_0)))"
"(void)))))))"
" loop_0))"
"(values))))"
"(let-values(((name_0)"
"(string-foldcase"
"(let-values(((accum-str27_0) accum-str_0)"
"((config28_0) config_0))"
"(accum-string-get!.1 0 accum-str27_0 config28_0)))))"
"(let-values(((tmp_0) name_0))"
"                                                      (if (if (equal? tmp_0 \"nul\") #t (equal? tmp_0 \"null\"))"
"(let-values() '#\\nul)"
"                                                        (if (equal? tmp_0 \"backspace\")"
"(let-values() '#\\backspace)"
"                                                          (if (equal? tmp_0 \"tab\")"
"(let-values() '#\\tab)"
"                                                            (if (if (equal? tmp_0 \"newline\")"
" #t"
"                                                                  (equal? tmp_0 \"linefeed\"))"
"(let-values() '#\\newline)"
"                                                              (if (equal? tmp_0 \"vtab\")"
"(let-values() '#\\vtab)"
"                                                                (if (equal? tmp_0 \"page\")"
"(let-values() '#\\page)"
"                                                                  (if (equal? tmp_0 \"return\")"
"(let-values() '#\\return)"
"                                                                    (if (equal? tmp_0 \"space\")"
"(let-values() '#\\space)"
"                                                                      (if (equal? tmp_0 \"rubout\")"
"(let-values() '#\\rubout)"
"(let-values()"
"(let-values(((in29_0) in_0)"
"((config30_0) config_0)"
"((temp31_0)"
"                                                                                        \"bad character constant `#\\\\~a`\")"
"((name32_0) name_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in29_0"
" config30_0"
" temp31_0"
"(list name32_0)))))))))))))))))))))"
"(let-values() c_0))))"
"(let-values() c_0))))))))"
"(wrap char_0 in_0 config_0 char_0))))))"
"(define-values"
"(read-quote)"
"(lambda(read-one_0 sym_0 desc_0 c_0 in_0 config_0)"
"(begin"
"(let-values(((wrapped-sym_0)(wrap sym_0 in_0 config_0 c_0)))"
"(let-values(((end-line_0 end-col_0 end-pos_0)(port-next-location in_0)))"
"(let-values(((e_0)(read-one_0 #f in_0 config_0)))"
"(begin"
"(if(eof-object? e_0)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((e3_0) e_0)"
"((end-pos4_0) end-pos_0)"
"                               ((temp5_0) \"expected an element for ~a, found end-of-file\")"
"((desc6_0) desc_0))"
"(reader-error.1"
" unsafe-undefined"
" e3_0"
" end-pos4_0"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp5_0"
"(list desc6_0))))"
"(void))"
"(wrap(list wrapped-sym_0 e_0) in_0 config_0 #f))))))))"
"(define-values"
"(read-delimited-constant)"
"(lambda(init-c_0 can-match?_0 chars_0 val_0 in_0 config_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(begin"
"(accum-string-add! accum-str_0 init-c_0)"
"((letrec-values(((loop_0)"
"(lambda(chars_1)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_0)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_0 'special)(special1.1 'special) c_0)))))"
"(if(char-delimiter? c_0 config_0)"
"(let-values()"
"(if(null? chars_1)"
"(void)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((c3_0) c_0)"
"                                                       ((temp4_0) \"bad syntax `#~a`\")"
"((temp5_0)"
"(let-values(((accum-str6_0) accum-str_0)"
"((config7_0) config_0))"
"(accum-string-get!.1 0 accum-str6_0 config7_0))))"
"(reader-error.1"
" unsafe-undefined"
" c3_0"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp4_0"
"(list temp5_0))))))"
"(if(null? chars_1)"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(let-values(((in8_0) in_0)"
"((config9_0) config_0)"
"                                                       ((temp10_0) \"bad syntax `#~a`\")"
"((temp11_0)"
"(let-values(((accum-str12_0) accum-str_0)"
"((config13_0) config_0))"
"(accum-string-get!.1 0 accum-str12_0 config13_0))))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in8_0"
" config9_0"
" temp10_0"
"(list temp11_0)))))"
"(if(if can-match?_0(char=? c_0(car chars_1)) #f)"
"(let-values()"
"(begin"
"(consume-char in_0 c_0)"
"(accum-string-add! accum-str_0 c_0)"
"(loop_0(cdr chars_1))))"
"(let-values()"
"(begin"
"(consume-char/special in_0 config_0 c_0)"
"(accum-string-add! accum-str_0 c_0)"
"(let-values(((in14_0) in_0)"
"((config15_0) config_0)"
"                                                         ((temp16_0) \"bad syntax `#~a`\")"
"((temp17_0)"
"(let-values(((accum-str18_0) accum-str_0)"
"((config19_0) config_0))"
"(accum-string-get!.1 0 accum-str18_0 config19_0))))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in14_0"
" config15_0"
" temp16_0"
"(list temp17_0)))))))))))))"
" loop_0)"
" chars_0)"
"(wrap"
" val_0"
" in_0"
" config_0"
"(let-values(((accum-str20_0) accum-str_0)((config21_0) config_0))"
"(accum-string-get!.1 0 accum-str20_0 config21_0))))))))"
"(define-values"
"(read-box)"
"(lambda(read-one_0 dispatch-c_0 in_0 config_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(check-parameter 1/read-accept-box config_0)"
"(void)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"                                       ((temp3_0) \"`~a&` forms not enabled\")"
"((dispatch-c4_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp3_0"
"(list dispatch-c4_0)))))"
"(values))))"
"(let-values(((open-end-line_0 open-end-col_0 open-end-pos_0)(port-next-location in_0)))"
"(let-values(((e_0)(read-one_0 #f in_0(next-readtable config_0))))"
"(begin"
"(if(eof-object? e_0)"
"(let-values()"
"(let-values(((in5_0) in_0)"
"((config6_0) config_0)"
"((e7_0) e_0)"
"((open-end-pos8_0) open-end-pos_0)"
"                               ((temp9_0) \"expected an element for `~a&` box, found end-of-file\")"
"((dispatch-c10_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" e7_0"
" open-end-pos8_0"
" unsafe-undefined"
" in5_0"
" config6_0"
" temp9_0"
"(list dispatch-c10_0))))"
"(void))"
"(wrap(if(read-config-for-syntax? config_0)(box-immutable e_0)(box e_0)) in_0 config_0 #f))))))))"
"(define-values"
"(read-regexp)"
"(lambda(mode-c_0 accum-str_0 in_0 config_0)"
"(begin"
"(let-values(((c3_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((no-wrap-config_0)(disable-wrapping config_0)))"
"(let-values(((rx_0)"
"(let-values(((tmp_0) c3_0))"
"                          (if (equal? tmp_0 '#\\\")"
"(let-values()"
"(let-values((()(begin(accum-string-abandon! accum-str_0 config_0)(values))))"
"(let-values(((str_0)"
"(let-values(((in1_0) in_0)((no-wrap-config2_0) no-wrap-config_0))"
"(read-string.1 'string in1_0 no-wrap-config2_0))))"
"(catch-and-reraise-as-reader/proc"
" in_0"
" config_0"
"(lambda()((if(char=? mode-c_0 '#\\r) regexp pregexp) str_0))))))"
"(if(equal? tmp_0 '#\\#)"
"(let-values()"
"(let-values((()(begin(accum-string-add! accum-str_0 c3_0)(values))))"
"(let-values(((c4_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((tmp_1) c4_0))"
"                                      (if (equal? tmp_1 '#\\\")"
"(let-values()"
"(let-values((()"
"(begin(accum-string-abandon! accum-str_0 config_0)(values))))"
"(let-values(((bstr_0)"
"(let-values(((in3_0) in_0)"
"((no-wrap-config4_0) no-wrap-config_0)"
"((temp5_0) '|byte string|))"
"(read-string.1 temp5_0 in3_0 no-wrap-config4_0))))"
"(catch-and-reraise-as-reader/proc"
" in_0"
" config_0"
"(lambda()"
"((if(char=? mode-c_0 '#\\r) byte-regexp byte-pregexp) bstr_0))))))"
"(let-values()"
"(let-values(((in6_0) in_0)"
"((config7_0) config_0)"
"((c48_0) c4_0)"
"                                                       ((temp9_0) \"expected `\\\"` after `~a`\")"
"((temp10_0)"
"(let-values(((accum-str11_0) accum-str_0)"
"((config12_0) config_0))"
"(accum-string-get!.1 0 accum-str11_0 config12_0))))"
"(reader-error.1"
" unsafe-undefined"
" c48_0"
" #f"
" unsafe-undefined"
" in6_0"
" config7_0"
" temp9_0"
"(list temp10_0)))))))))"
"(let-values()"
"(let-values(((in13_0) in_0)"
"((config14_0) config_0)"
"((c315_0) c3_0)"
"                                             ((temp16_0) \"expected `\\\"` or `#` after `~a`\")"
"((temp17_0)"
"(let-values(((accum-str18_0) accum-str_0)((config19_0) config_0))"
"(accum-string-get!.1 0 accum-str18_0 config19_0))))"
"(reader-error.1"
" unsafe-undefined"
" c315_0"
" #f"
" unsafe-undefined"
" in13_0"
" config14_0"
" temp16_0"
"(list temp17_0)))))))))"
"(wrap rx_0 in_0 config_0 #f)))))))"
"(define-values"
"(read-extension-reader)"
"(lambda(read-one_0 read-recur_0 dispatch-c_0 in_0 config_0)"
"(begin"
"(let-values(((extend-str_0)"
"(read-extension-prefix(cons dispatch-c_0 '(#\\r #\\e)) '(#\\a #\\d #\\e #\\r) in_0 config_0)))"
"(let-values((()"
"(begin"
"(if(check-parameter 1/read-accept-reader config_0)"
"(void)"
"(let-values()"
"(let-values(((in46_0) in_0)"
"((config47_0) config_0)"
"                                         ((temp48_0) \"`~a` not enabled\")"
"((extend-str49_0) extend-str_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in46_0"
" config47_0"
" temp48_0"
"(list extend-str49_0)))))"
"(values))))"
"(let-values(((mod-path-wrapped_0)(read-one_0 #f in_0(next-readtable config_0))))"
"(begin"
"(if(eof-object? mod-path-wrapped_0)"
"(let-values()"
"(let-values(((in50_0) in_0)"
"((config51_0) config_0)"
"((mod-path-wrapped52_0) mod-path-wrapped_0)"
"                               ((temp53_0) \"expected a datum after `~a`, found end-of-file\")"
"((extend-str54_0) extend-str_0))"
"(reader-error.1"
" unsafe-undefined"
" mod-path-wrapped52_0"
" #f"
" unsafe-undefined"
" in50_0"
" config51_0"
" temp53_0"
"(list extend-str54_0))))"
"(void))"
"(let-values(((temp41_0)((read-config-coerce config_0) #f mod-path-wrapped_0 #f))"
"((read-recur42_0) read-recur_0)"
"((in43_0) in_0)"
"((config44_0) config_0)"
"((mod-path-wrapped45_0) mod-path-wrapped_0))"
"(read-extension.1"
" #f"
" mod-path-wrapped45_0"
" #f"
" '|#reader|"
" temp41_0"
" read-recur42_0"
" in43_0"
" config44_0)))))))))"
"(define-values"
"(read-extension-lang.1)"
"(lambda(get-info?1_0 read-recur3_0 dispatch-c4_0 in5_0 config6_0)"
"(begin"
" 'read-extension-lang"
"(let-values(((read-recur_0) read-recur3_0))"
"(let-values(((dispatch-c_0) dispatch-c4_0))"
"(let-values(((in_0) in5_0))"
"(let-values(((config_0) config6_0))"
"(let-values(((get-info?_0) get-info?1_0))"
"(let-values()"
"(let-values(((extend-str_0)"
"(read-extension-prefix(cons dispatch-c_0 '(#\\l)) '(#\\a #\\n #\\g) in_0 config_0)))"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(eqv? c_0 '#\\space)"
"(void)"
"(let-values()"
"(let-values(((in62_0) in_0)"
"((config63_0) config_0)"
"                                         ((temp64_0) \"expected a single space after `~a`\")"
"((extend-str65_0) extend-str_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in62_0"
" config63_0"
" temp64_0"
"(list extend-str65_0)))))"
"(let-values(((extend-str55_0) extend-str_0)"
"((read-recur56_0) read-recur_0)"
"((in57_0) in_0)"
"((config58_0) config_0)"
"((temp59_0) #t)"
"((temp60_0) '|#lang|)"
"((get-info?61_0) get-info?_0))"
"(read-lang.1"
" get-info?61_0"
" #f"
" temp59_0"
" temp60_0"
" extend-str55_0"
" read-recur56_0"
" in57_0"
" config58_0))))))))))))))"
"(define-values"
"(read-extension-#!.1)"
"(lambda(get-info?8_0 read-recur10_0 dispatch-c11_0 in12_0 config13_0)"
"(begin"
" 'read-extension-#!"
"(let-values(((read-recur_0) read-recur10_0))"
"(let-values(((dispatch-c_0) dispatch-c11_0))"
"(let-values(((in_0) in12_0))"
"(let-values(((config_0) config13_0))"
"(let-values(((get-info?_0) get-info?8_0))"
"(let-values()"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(if(char? c_0)(char-lang-nonsep? c_0) #f)"
"(void)"
"(let-values()"
"(let-values(((in73_0) in_0)"
"((config74_0) config_0)"
"((temp75_0)"
"(if(char? c_0)(string dispatch-c_0 '#\\! c_0)(string dispatch-c_0 '#\\!))))"
"(bad-syntax-error.1 '#\\x in73_0 config74_0 temp75_0))))"
"(let-values(((temp66_0)(string dispatch-c_0 '#\\!))"
"((read-recur67_0) read-recur_0)"
"((in68_0) in_0)"
"((config69_0) config_0)"
"((c70_0) c_0)"
"((temp71_0) '|#!|)"
"((get-info?72_0) get-info?_0))"
"(read-lang.1"
" get-info?72_0"
" c70_0"
" #f"
" temp71_0"
" temp66_0"
" read-recur67_0"
" in68_0"
" config69_0)))))))))))))"
"(define-values"
"(read-lang.1)"
"(lambda(get-info?17_0 init-c15_0 one-space?16_0 who18_0 extend-str23_0 read-recur24_0 in25_0 config26_0)"
"(begin"
" 'read-lang"
"(let-values(((extend-str_0) extend-str23_0))"
"(let-values(((read-recur_0) read-recur24_0))"
"(let-values(((in_0) in25_0))"
"(let-values(((config_0) config26_0))"
"(let-values(((init-c_0) init-c15_0))"
"(let-values(((one-space?_0) one-space?16_0))"
"(let-values(((get-info?_0) get-info?17_0))"
"(let-values(((who_0) who18_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if(check-parameter 1/read-accept-reader config_0)"
"(check-parameter 1/read-accept-lang config_0)"
" #f)"
"(void)"
"(let-values()"
"(let-values(((in83_0) in_0)"
"((config84_0) config_0)"
"                                                         ((temp85_0) \"`~a` not enabled\\n  possible reason: ~a\")"
"((extend-str86_0) extend-str_0)"
"((temp87_0)"
"(string-append"
"                                                           \"not allowed again inside a module that already starts `#lang`,\""
"                                                           \" or not enabled for interactive evaluation\")))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in83_0"
" config84_0"
" temp85_0"
"(list extend-str86_0 temp87_0)))))"
"(values))))"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()"
"(begin"
"(if init-c_0"
"(let-values()(accum-string-add! accum-str_0 init-c_0))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)"
"(read-config-source"
" config_0)))"
"(let-values(((c_0)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_0 'special)"
"(special1.1 'special)"
" c_0)))))"
"(if(eof-object? c_0)"
"(let-values()(void))"
"(if(not(char? c_0))"
"(let-values()"
"(begin"
"(consume-char/special in_0 config_0 c_0)"
"(let-values(((in88_0) in_0)"
"((config89_0) config_0)"
"((c90_0) c_0)"
"((temp91_0)"
"                                                                                              \"found non-character while reading `#~a`\")"
"((extend-str92_0)"
" extend-str_0))"
"(reader-error.1"
" unsafe-undefined"
" c90_0"
" #f"
" unsafe-undefined"
" in88_0"
" config89_0"
" temp91_0"
"(list extend-str92_0)))))"
"(if(if(char-whitespace? c_0)"
"(positive?"
"(accum-string-count accum-str_0))"
" #f)"
"(let-values()(void))"
"(if(if one-space?_0"
"(char=? c_0 '#\\space)"
" #f)"
"(let-values()"
"(let-values(((in93_0) in_0)"
"((config94_0) config_0)"
"((temp95_0)"
"                                                                                                \"expected a single space after `~a`\")"
"((extend-str96_0)"
" extend-str_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in93_0"
" config94_0"
" temp95_0"
"(list extend-str96_0))))"
"(if(let-values(((or-part_0)"
"(char-lang-nonsep?"
" c_0)))"
"(if or-part_0"
" or-part_0"
"(char=? '#\\/ c_0)))"
"(let-values()"
"(begin"
"(consume-char in_0 c_0)"
"(accum-string-add!"
" accum-str_0"
" c_0)"
"(loop_0)))"
"(let-values()"
"(begin"
"(consume-char in_0 c_0)"
"(let-values(((in97_0) in_0)"
"((config98_0)"
" config_0)"
"((temp99_0)"
"(string-append"
"                                                                                                     \"expected only alphanumeric, `-`, `+`, `_`, or `/`\""
"                                                                                                     \" characters for `~a`, found `~a`\"))"
"((extend-str100_0)"
" extend-str_0)"
"((c101_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in97_0"
" config98_0"
" temp99_0"
"(list"
" extend-str100_0"
" c101_0)))))))))))))))"
" loop_0))"
"(values))))"
"(let-values(((lang-str_0)"
"(let-values(((accum-str102_0) accum-str_0)((config103_0) config_0))"
"(accum-string-get!.1 0 accum-str102_0 config103_0))))"
"(let-values((()"
"(begin"
"                                                    (if (equal? lang-str_0 \"\")"
"(let-values()"
"(let-values(((in104_0) in_0)"
"((config105_0) config_0)"
"((temp106_0)"
"                                                                      \"expected a non-empty sequence of alphanumeric, `-`, `+`, `_`, or `/` after `~a~a`\")"
"((extend-str107_0) extend-str_0)"
"                                                                     ((temp108_0) (if one-space?_0 \" \" \"\")))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in104_0"
" config105_0"
" temp106_0"
"(list extend-str107_0 temp108_0))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(char=? '#\\/(string-ref lang-str_0 0))"
"(let-values()"
"(let-values(((in109_0) in_0)"
"((config110_0) config_0)"
"((temp111_0)"
"                                                                        \"expected a name that does not start `/` after `~a`\")"
"((extend-str112_0) extend-str_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in109_0"
" config110_0"
" temp111_0"
"(list extend-str112_0))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(char=?"
" '#\\/"
"(string-ref lang-str_0(sub1(string-length lang-str_0))))"
"(let-values()"
"(let-values(((in113_0) in_0)"
"((config114_0) config_0)"
"((temp115_0)"
"                                                                          \"expected a name that does not end `/` after `~a`\")"
"((extend-str116_0) extend-str_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in113_0"
" config114_0"
" temp115_0"
"(list extend-str116_0))))"
"(void))"
"(values))))"
"(let-values(((submod-path_0)"
"(list* 'submod(string->symbol lang-str_0) '(reader))))"
"(let-values(((reader-path_0)"
"                                                          (string->symbol (string-append lang-str_0 \"/lang/reader\"))))"
"(let-values(((submod-path76_0) submod-path_0)"
"((reader-path77_0) reader-path_0)"
"((read-recur78_0) read-recur_0)"
"((in79_0) in_0)"
"((temp80_0)(reading-at config_0 line_0 col_0 pos_0))"
"((get-info?81_0) get-info?_0)"
"((who82_0) who_0))"
"(read-extension.1"
" get-info?81_0"
" unsafe-undefined"
" submod-path76_0"
" who82_0"
" reader-path77_0"
" read-recur78_0"
" in79_0"
" temp80_0)))))))))))))))))))))))))"
"(define-values"
"(char-lang-nonsep?)"
"(lambda(c_0)"
"(begin"
"(if(<(char->integer c_0) 128)"
"(let-values(((or-part_0)(char-alphabetic? c_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char-numeric? c_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(char=? '#\\- c_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(char=? '#\\+ c_0)))(if or-part_3 or-part_3(char=? '#\\_ c_0)))))))))"
" #f))))"
"(define-values"
"(read-extension-prefix)"
"(lambda(already_0 wanted_0 in_0 config_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(begin"
"(let-values()"
"(let-values(((lst_0) already_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((c_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(accum-string-add! accum-str_0 c_0))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"((letrec-values(((loop_0)"
"(lambda(wanted_1)"
"(begin"
" 'loop"
"(if(null? wanted_1)"
"(void)"
"(let-values()"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(char? c_0)(let-values()(accum-string-add! accum-str_0 c_0))(void))"
"(if(eqv? c_0(car wanted_1))"
"(void)"
"(let-values()"
"(let-values(((in119_0) in_0)"
"((config120_0) config_0)"
"((temp121_0)"
"(let-values(((accum-str123_0) accum-str_0)"
"((config124_0) config_0))"
"(accum-string-get!.1 0 accum-str123_0 config124_0)))"
"((c122_0) c_0))"
"(bad-syntax-error.1 c122_0 in119_0 config120_0 temp121_0))))"
"(loop_0(cdr wanted_1))))))))))"
" loop_0)"
" wanted_0)"
"(let-values(((accum-str117_0) accum-str_0)((config118_0) config_0))"
"(accum-string-get!.1 0 accum-str117_0 config118_0)))))))"
"(define-values"
"(read-extension.1)"
"(lambda(get-info?30_0"
" mod-path-wrapped29_0"
" try-first-mod-path28_0"
" who31_0"
" mod-path-datum36_0"
" read-recur37_0"
" in38_0"
" config39_0)"
"(begin"
" 'read-extension"
"(let-values(((try-first-mod-path_0) try-first-mod-path28_0))"
"(let-values(((mod-path-datum_0) mod-path-datum36_0))"
"(let-values(((read-recur_0) read-recur37_0))"
"(let-values(((in_0) in38_0))"
"(let-values(((config_0) config39_0))"
"(let-values(((mod-path-wrapped_0)"
"(if(eq? mod-path-wrapped29_0 unsafe-undefined)"
"((read-config-coerce config_0)"
" #t"
" mod-path-datum_0"
"(let-values(((in125_0) in_0)((config126_0) config_0))"
"(port+config->srcloc.1 #f in125_0 config126_0)))"
" mod-path-wrapped29_0)))"
"(let-values(((get-info?_0) get-info?30_0))"
"(let-values(((who_0) who31_0))"
"(let-values()"
"(let-values((()(begin(force-parameters! config_0)(values))))"
"(let-values(((guard_0)(1/current-reader-guard)))"
"(let-values(((mod-path_0)"
"(let-values(((or-part_0)"
"(if try-first-mod-path_0"
"(let-values(((mod-path_0)(guard_0 try-first-mod-path_0)))"
"(if((read-config-module-declared? config_0)"
" try-first-mod-path_0)"
" mod-path_0"
" #f))"
" #f)))"
"(if or-part_0 or-part_0(guard_0 mod-path-datum_0)))))"
"((read-config-call-with-root-namespace config_0)"
"(lambda()"
"(let-values(((for-syntax?_0)(read-config-for-syntax? config_0)))"
"(let-values(((dynamic-require_0)(read-config-dynamic-require config_0)))"
"(let-values(((no-value_0)(gensym)))"
"(let-values(((extension_0)"
"(if get-info?_0"
"(let-values()"
"(dynamic-require_0"
" mod-path_0"
" 'get-info"
"(lambda() no-value_0)))"
"(let-values()"
"(dynamic-require_0"
" mod-path_0"
"(if for-syntax?_0 'read-syntax 'read))))))"
"(if(eq? extension_0 no-value_0)"
"(let-values() #f)"
"(let-values()"
"(let-values(((result-v_0)"
"(if(if for-syntax?_0(not get-info?_0) #f)"
"(let-values()"
"(if(procedure-arity-includes? extension_0 6)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()"
"(extension_0"
"(read-config-source config_0)"
" in_0"
" mod-path-wrapped_0"
"(read-config-line config_0)"
"(read-config-col config_0)"
"(read-config-pos config_0)))))"
"(if(procedure-arity-includes? extension_0 2)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()"
"(extension_0"
"(read-config-source config_0)"
" in_0))))"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                                      \"(or/c (procedure-arity-includes?/c 2) (procedure-arity-includes?/c 6))\""
" extension_0)))))"
"(let-values()"
"(if(procedure-arity-includes? extension_0 5)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()"
"(extension_0"
" in_0"
" mod-path-wrapped_0"
"(read-config-line config_0)"
"(read-config-col config_0)"
"(read-config-pos config_0)))))"
"(if get-info?_0"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                                      \"(procedure-arity-includes?/c 5)\""
" extension_0))"
"(if(procedure-arity-includes? extension_0 1)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()(extension_0 in_0))))"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                                        \"(or/c (procedure-arity-includes?/c 1) (procedure-arity-includes?/c 5))\""
" extension_0)))))))))"
"(if get-info?_0"
"(let-values()"
"(begin"
"(if(if(procedure? result-v_0)"
"(procedure-arity-includes? result-v_0 2)"
" #f)"
"(void)"
"(let-values()"
"(raise-result-error"
" 'read-language"
"                                                          \"(procedure-arity-includes?/c 2)\""
" result-v_0)))"
" result-v_0))"
"(if(1/special-comment? result-v_0)"
"(let-values()(read-recur_0 #f in_0 config_0))"
"(let-values()"
"(coerce result-v_0 in_0 config_0))))))))))))))))))))))))))))"
"(define-values"
"(read-language/get-info)"
"(lambda(read-one_0 in_0 config_0 fail-k_0)"
"(begin"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments #f read-one_0 in_0 config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location* in_0 c_0)))"
"(let-values(((l-config_0)"
"(override-parameter 1/read-accept-reader(reading-at config_0 line_0 col_0 pos_0) #t)))"
"(if(not(eqv? c_0 '#\\#))"
"(let-values()"
"(if(special-comment-via-readtable? c_0 read-one_0 in_0 config_0)"
"(let-values()(read-language/get-info read-one_0 in_0 config_0 fail-k_0))"
"                  (let-values () (if fail-k_0 (fail-k_0) (lang-error in_0 l-config_0 \"\" c_0)))))"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source l-config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(if(eqv? c2_0 '#\\l)"
"(let-values()"
"(let-values(((read-one1_0) read-one_0)"
"((c2_1) c_0)"
"((in3_0) in_0)"
"((l-config4_0) l-config_0)"
"((temp5_0) #t))"
"(read-extension-lang.1 temp5_0 read-one1_0 c2_1 in3_0 l-config4_0)))"
"(if(eqv? c2_0 '#\\!)"
"(let-values()"
"(let-values(((read-one6_0) read-one_0)"
"((c7_0) c_0)"
"((in8_0) in_0)"
"((l-config9_0) l-config_0)"
"((temp10_0) #t))"
"(read-extension-#!.1 temp10_0 read-one6_0 c7_0 in8_0 l-config9_0)))"
"(let-values()(if fail-k_0(fail-k_0)(lang-error in_0 l-config_0(string c_0) c2_0))))))))))))))"
"(define-values"
"(lang-error)"
"(lambda(in_0 config_0 prefix_0 c_0)"
"(begin"
"(let-values(((add-prefix_0)"
"(lambda(s_0)"
"                      (begin 'add-prefix (if (string=? prefix_0 \"\") (format \"`~a` followed by ~a\" prefix_0 s_0) s_0)))))"
"(let-values(((in11_0) in_0)"
"((config12_0) config_0)"
"((c13_0) c_0)"
"((temp14_0) 'read-language)"
"((temp15_0)"
"(string-append"
"                       \"expected (after whitespace and comments) `#lang ` or `#!` followed\""
"                       \" immediately by a language name, found ~a\"))"
"((temp16_0)"
"(if(eof-object? c_0)"
"                        (let-values () (add-prefix_0 \"end-of-file\"))"
"(if(not(char? c_0))"
"                          (let-values () (add-prefix_0 \"non-character\"))"
"                          (let-values () (format \"`~a~a`\" prefix_0 c_0))))))"
"(reader-error.1 unsafe-undefined c13_0 #f temp14_0 in11_0 config12_0 temp15_0(list temp16_0)))))))"
"(define-values"
"(read.1)"
"(lambda(call-with-root-namespace10_0"
" coerce13_0"
" coerce-key14_0"
" dynamic-require11_0"
" for-syntax?8_0"
" init-c2_0"
" keep-comment?15_0"
" local-graph?6_0"
" module-declared?12_0"
" next-readtable3_0"
" read-compiled9_0"
" readtable4_0"
" recursive?5_0"
" source7_0"
" wrap1_0"
" in31_0)"
"(begin"
" 'read"
"(let-values(((in_0) in31_0))"
"(let-values(((wrap_0) wrap1_0))"
"(let-values(((init-c_0) init-c2_0))"
"(let-values(((next-readtable_0)"
"(if(eq? next-readtable3_0 unsafe-undefined)(1/current-readtable) next-readtable3_0)))"
"(let-values(((readtable_0)(if(eq? readtable4_0 unsafe-undefined) next-readtable_0 readtable4_0)))"
"(let-values(((recursive?_0) recursive?5_0))"
"(let-values(((local-graph?_0) local-graph?6_0))"
"(let-values(((source_0) source7_0))"
"(let-values(((for-syntax?_0) for-syntax?8_0))"
"(let-values(((read-compiled_0) read-compiled9_0))"
"(let-values(((call-with-root-namespace_0) call-with-root-namespace10_0))"
"(let-values(((dynamic-require_0) dynamic-require11_0))"
"(let-values(((module-declared?_0) module-declared?12_0))"
"(let-values(((coerce_0) coerce13_0))"
"(let-values(((coerce-key_0) coerce-key14_0))"
"(let-values(((keep-comment?_0)"
"(if(eq? keep-comment?15_0 unsafe-undefined)"
" recursive?_0"
" keep-comment?15_0)))"
"(let-values()"
"(let-values(((config_0)"
"(let-values(((c1_0)(if recursive?_0(current-read-config) #f)))"
"(if c1_0"
"((lambda(config_0)"
"(let-values(((config52_0) config_0)"
"((for-syntax?53_0) for-syntax?_0)"
"((wrap54_0) wrap_0)"
"((readtable55_0) readtable_0)"
"((next-readtable56_0) next-readtable_0)"
"((local-graph?57_0) local-graph?_0)"
"((keep-comment?58_0) keep-comment?_0))"
"(read-config-update.1"
" for-syntax?53_0"
" keep-comment?58_0"
" next-readtable56_0"
" readtable55_0"
" local-graph?57_0"
" wrap54_0"
" config52_0)))"
" c1_0)"
"(let-values()"
"(let-values(((readtable59_0) readtable_0)"
"((next-readtable60_0) next-readtable_0)"
"((source61_0) source_0)"
"((for-syntax?62_0) for-syntax?_0)"
"((wrap63_0) wrap_0)"
"((read-compiled64_0) read-compiled_0)"
"((call-with-root-namespace65_0)"
" call-with-root-namespace_0)"
"((dynamic-require66_0) dynamic-require_0)"
"((module-declared?67_0) module-declared?_0)"
"((coerce68_0) coerce_0)"
"((coerce-key69_0) coerce-key_0)"
"((keep-comment?70_0) keep-comment?_0))"
"(make-read-config.1"
" call-with-root-namespace65_0"
" coerce68_0"
" coerce-key69_0"
" dynamic-require66_0"
" for-syntax?62_0"
" keep-comment?70_0"
" module-declared?67_0"
" next-readtable60_0"
" read-compiled64_0"
" readtable59_0"
" source61_0"
" wrap63_0)))))))"
"(let-values(((v_0)(read-one init-c_0 in_0 config_0)))"
"(if(if(let-values(((or-part_0)(not recursive?_0)))"
"(if or-part_0 or-part_0 local-graph?_0))"
"(read-config-state-graph(read-config-st config_0))"
" #f)"
"(let-values()"
"(catch-and-reraise-as-reader/proc"
" #f"
" config_0"
"(lambda()(make-reader-graph v_0))))"
"(if(if recursive?_0"
"(if(not local-graph?_0)"
"(if(not for-syntax?_0)"
"(if(not(eof-object? v_0))(not(1/special-comment? v_0)) #f)"
" #f)"
" #f)"
" #f)"
"(let-values()(begin(get-graph-hash config_0) v_0))"
"(let-values() v_0)))))))))))))))))))))))))"
"(define-values"
"(read-language.1)"
"(lambda(call-with-root-namespace37_0"
" coerce39_0"
" coerce-key40_0"
" dynamic-require36_0"
" for-syntax?33_0"
" module-declared?38_0"
" read-compiled35_0"
" wrap34_0"
" in49_0"
" fail-k50_0)"
"(begin"
" 'read-language"
"(let-values(((in_0) in49_0))"
"(let-values(((fail-k_0) fail-k50_0))"
"(let-values(((for-syntax?_0) for-syntax?33_0))"
"(let-values(((wrap_0) wrap34_0))"
"(let-values(((read-compiled_0) read-compiled35_0))"
"(let-values(((dynamic-require_0) dynamic-require36_0))"
"(let-values(((call-with-root-namespace_0) call-with-root-namespace37_0))"
"(let-values(((module-declared?_0) module-declared?38_0))"
"(let-values(((coerce_0) coerce39_0))"
"(let-values(((coerce-key_0) coerce-key40_0))"
"(let-values()"
"(let-values(((config_0)"
"(let-values(((temp71_0) #f)"
"((temp72_0) #f)"
"((for-syntax?73_0) for-syntax?_0)"
"((wrap74_0) wrap_0)"
"((read-compiled75_0) read-compiled_0)"
"((call-with-root-namespace76_0) call-with-root-namespace_0)"
"((dynamic-require77_0) dynamic-require_0)"
"((module-declared?78_0) module-declared?_0)"
"((coerce79_0) coerce_0)"
"((coerce-key80_0) coerce-key_0))"
"(make-read-config.1"
" call-with-root-namespace76_0"
" coerce79_0"
" coerce-key80_0"
" dynamic-require77_0"
" for-syntax?73_0"
" #f"
" module-declared?78_0"
" temp72_0"
" read-compiled75_0"
" temp71_0"
" #f"
" wrap74_0))))"
"(let-values(((l-config_0)(override-parameter 1/read-accept-reader config_0 #f)))"
"(read-language/get-info read-undotted in_0 config_0 fail-k_0)))))))))))))))))"
"(define-values"
"(read-one)"
"(lambda(init-c_0 in_0 config_0)"
"(begin"
"(if(not(check-parameter 1/read-cdot config_0))"
"(let-values()(read-undotted init-c_0 in_0 config_0))"
"(if(check-parameter 1/read-cdot config_0)"
"(let-values()"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(let-values(((v_0)(read-undotted init-c_0 in_0 config_0)))"
"(if(1/special-comment? v_0)"
"(let-values() v_0)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(v_1)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_0)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_0 'special)(special1.1 'special) c_0)))))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(if(not(char? ec_0))"
"(let-values() v_1)"
"(if(char-whitespace? ec_0)"
"(let-values()(begin(consume-char in_0 c_0)(loop_0 v_1)))"
"(if(char=? ec_0 '#\\.)"
"(let-values()"
"(let-values(((dot-line_0 dot-col_0 dot-pos_0)"
"(port-next-location in_0)))"
"(let-values((()(begin(consume-char in_0 c_0)(values))))"
"(let-values(((pos-config_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0)))"
"(let-values(((cdot_0)"
"(wrap '#%dot in_0 pos-config_0 '#\\.)))"
"(let-values(((post-v_0)"
"(read-undotted #f in_0 config_0)))"
"(begin"
"(if(eof-object? post-v_0)"
"(let-values()"
"(let-values(((in81_0) in_0)"
"((pos-config82_0) pos-config_0)"
"((eof83_0) eof)"
"((temp84_0)"
"                                                                                    \"expected a datum after cdot, found end-of-file\"))"
"(reader-error.1"
" unsafe-undefined"
" eof83_0"
" #f"
" unsafe-undefined"
" in81_0"
" pos-config82_0"
" temp84_0"
"(list))))"
"(void))"
"(loop_0"
"(wrap"
"(list cdot_0 v_1 post-v_0)"
" in_0"
"(reading-at config_0 line_0 col_0 pos_0)"
" '#\\.)))))))))"
"(let-values() v_1))))))))))"
" loop_0)"
" v_0))))))"
"(void))))))"
"(define-values"
"(read-undotted)"
"(lambda(init-c_0 in_0 config_0)"
"(begin"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments init-c_0 read-one in_0 config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location* in_0 c_0)))"
"(if(eof-object? c_0)"
"(let-values() eof)"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((v_0)(special-value c_0)))"
"(if(1/special-comment? v_0)"
"(let-values()(if(read-config-keep-comment? config_0) v_0(read-undotted #f in_0 config_0)))"
"(let-values()(coerce v_0 in_0(reading-at config_0 line_0 col_0 pos_0))))))"
"(let-values(((c2_0)(readtable-handler config_0 c_0)))"
"(if c2_0"
"((lambda(handler_0)"
"(let-values(((v_0)(readtable-apply handler_0 c_0 in_0 config_0 line_0 col_0 pos_0)))"
"(retry-special-comment v_0 in_0 config_0)))"
" c2_0)"
"(let-values()"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values((()"
"(begin"
"(if(not(char-closer? ec_0 config_0))"
"(let-values()(track-indentation! config_0 line_0 col_0))"
"(void))"
"(values))))"
"(let-values(((r-config_0)(reading-at(discard-comment config_0) line_0 col_0 pos_0)))"
"(let-values(((tmp_0) ec_0))"
"(let-values(((index_0)"
"(if(char? tmp_0)"
"(let-values(((codepoint_0)(char->integer tmp_0)))"
"(if(if(unsafe-fx>= codepoint_0 34)(unsafe-fx< codepoint_0 126) #f)"
"(if(unsafe-fx< codepoint_0 91)"
"(if(unsafe-fx< codepoint_0 40)"
"(let-values(((tbl_0) '#(11 1 0 0 0 2)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 34)))"
"(if(unsafe-fx< codepoint_0 42)"
"(let-values(((tbl_0) '#(5 6)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 40)))"
"(if(unsafe-fx< codepoint_0 44)"
" 0"
"(if(unsafe-fx< codepoint_0 45) 4 0))))"
"(let-values(((tbl_0)"
" '#(7"
" 0"
" 8"
" 0"
" 0"
" 3"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 9"
" 12"
" 10)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 91))))"
" 0))"
" 0)))"
"(if(unsafe-fx< index_0 6)"
"(if(unsafe-fx< index_0 2)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(let-values(((v_0)"
"(let-values(((c85_0) c_0)"
"((in86_0) in_0)"
"((r-config87_0) r-config_0)"
"((temp88_0)"
"(if(let-values(((or-part_0)(eq? c_0 ec_0)))"
"(if or-part_0"
" or-part_0"
"(if(<(char->integer ec_0) 128)"
"(char-numeric? ec_0)"
" #f)))"
" 'symbol-or-number"
" 'symbol/indirect)))"
"(read-symbol-or-number.1 #f temp88_0 c85_0 in86_0 r-config87_0))))"
"(retry-special-comment v_0 in_0 config_0)))"
"(let-values()(read-dispatch c_0 in_0 r-config_0 config_0)))"
"(if(unsafe-fx< index_0 3)"
"                                    (let-values () (read-quote read-one 'quote \"quoting \\\"'\\\"\" c_0 in_0 r-config_0))"
"(if(unsafe-fx< index_0 4)"
"(let-values()"
"(if(check-parameter 1/read-accept-quasiquote config_0)"
"(let-values()"
"                                            (read-quote read-one 'quasiquote \"quasiquoting \\\"`\\\"\" c_0 in_0 r-config_0))"
"(let-values()"
"(let-values(((in89_0) in_0)"
"((r-config90_0) r-config_0)"
"                                                         ((temp91_0) \"illegal use of `~a`\")"
"((c92_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in89_0"
" r-config90_0"
" temp91_0"
"(list c92_0))))))"
"(if(unsafe-fx< index_0 5)"
"(let-values()"
"(if(check-parameter 1/read-accept-quasiquote config_0)"
"(let-values()"
"(let-values(((c2_1)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(eqv? c2_1 '#\\@)"
"(begin"
"(consume-char in_0 c2_1)"
"(read-quote"
" read-one"
" 'unquote-splicing"
"                                                     \"unquoting `,@`\""
" c_0"
" in_0"
" r-config_0))"
"                                                  (read-quote read-one 'unquote \"unquoting `,`\" c_0 in_0 r-config_0))))"
"(let-values()"
"(let-values(((in93_0) in_0)"
"((r-config94_0) r-config_0)"
"                                                           ((temp95_0) \"illegal use of `~a`\")"
"((c96_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in93_0"
" r-config94_0"
" temp95_0"
"(list c96_0))))))"
"(let-values()"
"(wrap"
"(let-values(((read-one97_0) read-one)"
"((ec98_0) ec_0)"
"((temp99_0) '#\\()"
"((temp100_0) '#\\))"
"((in101_0) in_0)"
"((r-config102_0) r-config_0)"
"((temp103_0) #t))"
"(read-unwrapped-sequence.1"
" 'all"
" unsafe-undefined"
" unsafe-undefined"
" temp103_0"
" unsafe-undefined"
" read-one97_0"
" ec98_0"
" temp99_0"
" temp100_0"
" in101_0"
" r-config102_0))"
" in_0"
" r-config_0"
" ec_0))))))"
"(if(unsafe-fx< index_0 9)"
"(if(unsafe-fx< index_0 7)"
"(let-values()"
"(let-values(((in104_0) in_0)"
"((r-config105_0) r-config_0)"
"                                                   ((temp106_0) \"~a\")"
"((temp107_0)"
"(indentation-unexpected-closer-message ec_0 c_0 r-config_0)))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in104_0"
" r-config105_0"
" temp106_0"
"(list temp107_0))))"
"(if(unsafe-fx< index_0 8)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(check-parameter 1/read-square-bracket-as-paren config_0)))"
"(if or-part_0"
" or-part_0"
"(check-parameter 1/read-square-bracket-with-tag config_0)))"
"(let-values()"
"(wrap"
"(let-values(((read-one108_0) read-one)"
"((ec109_0) ec_0)"
"((temp110_0) '#\\[)"
"((temp111_0) '#\\])"
"((in112_0) in_0)"
"((r-config113_0) r-config_0)"
"((temp114_0) #t))"
"(read-unwrapped-sequence.1"
" 'all"
" unsafe-undefined"
" unsafe-undefined"
" temp114_0"
" unsafe-undefined"
" read-one108_0"
" ec109_0"
" temp110_0"
" temp111_0"
" in112_0"
" r-config113_0))"
" in_0"
" r-config_0"
" ec_0))"
"(let-values()"
"(let-values(((in115_0) in_0)"
"((r-config116_0) r-config_0)"
"                                                         ((temp117_0) \"illegal use of `~a`\")"
"((c118_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in115_0"
" r-config116_0"
" temp117_0"
"(list c118_0))))))"
"(let-values()"
"(if(let-values(((or-part_0)"
"(check-parameter 1/read-square-bracket-as-paren config_0)))"
"(if or-part_0"
" or-part_0"
"(check-parameter 1/read-square-bracket-with-tag config_0)))"
"(let-values()"
"(let-values(((in119_0) in_0)"
"((r-config120_0) r-config_0)"
"                                                         ((temp121_0) \"~a\")"
"((temp122_0)"
"(indentation-unexpected-closer-message ec_0 c_0 r-config_0)))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in119_0"
" r-config120_0"
" temp121_0"
"(list temp122_0))))"
"(let-values()"
"(let-values(((in123_0) in_0)"
"((r-config124_0) r-config_0)"
"                                                         ((temp125_0) \"illegal use of `~a`\")"
"((c126_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in123_0"
" r-config124_0"
" temp125_0"
"(list c126_0))))))))"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(check-parameter 1/read-curly-brace-as-paren config_0)))"
"(if or-part_0"
" or-part_0"
"(check-parameter 1/read-curly-brace-with-tag config_0)))"
"(let-values()"
"(wrap"
"(let-values(((read-one127_0) read-one)"
"((ec128_0) ec_0)"
"((temp129_0) '#\\{)"
"((temp130_0) '#\\})"
"((in131_0) in_0)"
"((r-config132_0) r-config_0)"
"((temp133_0) #t))"
"(read-unwrapped-sequence.1"
" 'all"
" unsafe-undefined"
" unsafe-undefined"
" temp133_0"
" unsafe-undefined"
" read-one127_0"
" ec128_0"
" temp129_0"
" temp130_0"
" in131_0"
" r-config132_0))"
" in_0"
" r-config_0"
" ec_0))"
"(let-values()"
"(let-values(((in134_0) in_0)"
"((r-config135_0) r-config_0)"
"                                                       ((temp136_0) \"illegal use of `~a`\")"
"((c137_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in134_0"
" r-config135_0"
" temp136_0"
"(list c137_0))))))"
"(if(unsafe-fx< index_0 11)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(check-parameter 1/read-curly-brace-as-paren config_0)))"
"(if or-part_0"
" or-part_0"
"(check-parameter 1/read-curly-brace-with-tag config_0)))"
"(let-values()"
"(let-values(((in138_0) in_0)"
"((r-config139_0) r-config_0)"
"                                                         ((temp140_0) \"~a\")"
"((temp141_0)"
"(indentation-unexpected-closer-message ec_0 c_0 r-config_0)))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in138_0"
" r-config139_0"
" temp140_0"
"(list temp141_0))))"
"(let-values()"
"(let-values(((in142_0) in_0)"
"((r-config143_0) r-config_0)"
"                                                         ((temp144_0) \"illegal use of `~a`\")"
"((c145_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in142_0"
" r-config143_0"
" temp144_0"
"(list c145_0))))))"
"(if(unsafe-fx< index_0 12)"
"(let-values()"
"(let-values(((in146_0) in_0)((r-config147_0) r-config_0))"
"(read-string.1 'string in146_0 r-config147_0)))"
"(let-values()"
"(let-values(((c148_0) c_0)"
"((in149_0) in_0)"
"((r-config150_0) r-config_0)"
"((temp151_0) 'symbol))"
"(read-symbol-or-number.1"
" #f"
" temp151_0"
" c148_0"
" in149_0"
" r-config150_0)))))))))))))))))))))))"
"(define-values"
"(read-dispatch)"
"(lambda(dispatch-c_0 in_0 config_0 orig-config_0)"
"(begin"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in152_0) in_0)"
"((config153_0) config_0)"
"((c154_0) c_0)"
"                         ((temp155_0) \"bad syntax `~a`\")"
"((dispatch-c156_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" c154_0"
" #f"
" unsafe-undefined"
" in152_0"
" config153_0"
" temp155_0"
"(list dispatch-c156_0))))"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((in157_0) in_0)"
"((config158_0) config_0)"
"((c159_0) c_0)"
"                           ((temp160_0) \"bad syntax `~a`\")"
"((dispatch-c161_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" c159_0"
" #f"
" unsafe-undefined"
" in157_0"
" config158_0"
" temp160_0"
"(list dispatch-c161_0))))"
"(let-values(((c3_0)(readtable-dispatch-handler orig-config_0 c_0)))"
"(if c3_0"
"((lambda(handler_0)"
"(let-values(((line_0)(read-config-line config_0)))"
"(let-values(((col_0)(read-config-col config_0)))"
"(let-values(((pos_0)(read-config-pos config_0)))"
"(let-values(((v_0)(readtable-apply handler_0 c_0 in_0 config_0 line_0 col_0 pos_0)))"
"(retry-special-comment v_0 in_0 orig-config_0))))))"
" c3_0)"
"(let-values()"
"(let-values()"
"(let-values(((tmp_0) c_0))"
"(let-values(((index_0)"
"(if(char? tmp_0)"
"(let-values(((codepoint_0)(char->integer tmp_0)))"
"(if(if(unsafe-fx>= codepoint_0 33)(unsafe-fx< codepoint_0 127) #f)"
"(let-values(((tbl_0)"
" '#(34"
" 11"
" 0"
" 0"
" 13"
" 6"
" 7"
" 2"
" 0"
" 0"
" 0"
" 9"
" 0"
" 0"
" 0"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 14"
" 0"
" 12"
" 0"
" 0"
" 0"
" 0"
" 0"
" 22"
" 29"
" 25"
" 18"
" 16"
" 0"
" 30"
" 20"
" 0"
" 0"
" 0"
" 0"
" 0"
" 24"
" 0"
" 0"
" 0"
" 0"
" 15"
" 0"
" 0"
" 0"
" 28"
" 0"
" 0"
" 3"
" 10"
" 0"
" 0"
" 0"
" 8"
" 0"
" 26"
" 29"
" 21"
" 17"
" 16"
" 0"
" 30"
" 19"
" 0"
" 0"
" 33"
" 0"
" 0"
" 23"
" 32"
" 0"
" 31"
" 5"
" 15"
" 0"
" 0"
" 0"
" 27"
" 0"
" 0"
" 4"
" 0"
" 0"
" 35)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 33)))"
" 0))"
" 0)))"
"(if(unsafe-fx< index_0 17)"
"(if(unsafe-fx< index_0 8)"
"(if(unsafe-fx< index_0 3)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(let-values(((in162_0) in_0)"
"((config163_0) config_0)"
"                                               ((temp164_0) \"bad syntax `~a~a`\")"
"((dispatch-c165_0) dispatch-c_0)"
"((c166_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in162_0"
" config163_0"
" temp164_0"
"(list dispatch-c165_0 c166_0))))"
"(if(unsafe-fx< index_0 2)"
"(let-values()(read-vector-or-graph read-one dispatch-c_0 c_0 in_0 config_0))"
"(let-values()"
"(let-values(((read-one167_0) read-one)"
"((temp168_0) '#\\()"
"((temp169_0) '#\\()"
"((temp170_0) '#\\))"
"((in171_0) in_0)"
"((config172_0) config_0))"
"(read-vector.1"
" #f"
" 'any"
" read-one167_0"
" temp168_0"
" temp169_0"
" temp170_0"
" in171_0"
" config172_0)))))"
"(if(unsafe-fx< index_0 5)"
"(if(unsafe-fx< index_0 4)"
"(let-values()"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)"
"(let-values()"
"(let-values(((read-one173_0) read-one)"
"((temp174_0) '#\\[)"
"((temp175_0) '#\\[)"
"((temp176_0) '#\\])"
"((in177_0) in_0)"
"((config178_0) config_0))"
"(read-vector.1"
" #f"
" 'any"
" read-one173_0"
" temp174_0"
" temp175_0"
" temp176_0"
" in177_0"
" config178_0)))"
"(let-values()"
"(let-values(((in179_0) in_0)"
"((config180_0) config_0)"
"                                                     ((temp181_0) (format \"~a~a\" dispatch-c_0 c_0)))"
"(bad-syntax-error.1 '#\\x in179_0 config180_0 temp181_0)))))"
"(let-values()"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)"
"(let-values()"
"(let-values(((read-one182_0) read-one)"
"((temp183_0) '#\\{)"
"((temp184_0) '#\\{)"
"((temp185_0) '#\\})"
"((in186_0) in_0)"
"((config187_0) config_0))"
"(read-vector.1"
" #f"
" 'any"
" read-one182_0"
" temp183_0"
" temp184_0"
" temp185_0"
" in186_0"
" config187_0)))"
"(let-values()"
"(let-values(((in188_0) in_0)"
"((config189_0) config_0)"
"                                                     ((temp190_0) (format \"~a~a\" dispatch-c_0 c_0)))"
"(bad-syntax-error.1 '#\\x in188_0 config189_0 temp190_0))))))"
"(if(unsafe-fx< index_0 6)"
"(let-values()(read-struct read-one dispatch-c_0 in_0 config_0))"
"(if(unsafe-fx< index_0 7)"
"(let-values()(read-box read-one dispatch-c_0 in_0 config_0))"
"                                    (let-values () (read-quote read-one 'syntax \"quoting #'\" c_0 in_0 config_0))))))"
"(if(unsafe-fx< index_0 12)"
"(if(unsafe-fx< index_0 9)"
"                                (let-values () (read-quote read-one 'quasisyntax \"quasiquoting #`\" c_0 in_0 config_0))"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(eqv? c2_0 '#\\@)"
"(begin"
"(consume-char in_0 c2_0)"
"                                          (read-quote read-one 'unsyntax-splicing \"unquoting #,@\" c_0 in_0 config_0))"
"                                        (read-quote read-one 'unsyntax \"unquoting #,\" c_0 in_0 config_0))))"
"(if(unsafe-fx< index_0 11)"
"(let-values()(read-character in_0 config_0))"
"(let-values()"
"(let-values(((in191_0) in_0)"
"((config192_0) config_0)"
"((temp193_0) '|byte string|))"
"(read-string.1 temp193_0 in191_0 config192_0))))))"
"(if(unsafe-fx< index_0 14)"
"(if(unsafe-fx< index_0 13)"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(eqv? '#\\< c2_0)"
"(let-values()"
"(begin(consume-char in_0 '#\\<)(read-here-string in_0 config_0)))"
"(let-values()"
"(let-values(((in194_0) in_0)"
"((config195_0) config_0)"
"((c2196_0) c2_0)"
"                                                       ((temp197_0) \"bad syntax `~a<`\")"
"((dispatch-c198_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" c2196_0"
" #f"
" unsafe-undefined"
" in194_0"
" config195_0"
" temp197_0"
"(list dispatch-c198_0)))))))"
"(let-values()"
"(let-values(((c199_0) c_0)"
"((in200_0) in_0)"
"((config201_0) config_0)"
"((dispatch-c202_0) dispatch-c_0)"
"((temp203_0) 'symbol))"
"(read-symbol-or-number.1 dispatch-c202_0 temp203_0 c199_0 in200_0 config201_0))))"
"(if(unsafe-fx< index_0 15)"
"(let-values()"
"(let-values(((temp204_0) #f)"
"((in205_0) in_0)"
"((config206_0) config_0)"
"((temp207_0) 'keyword))"
"(read-symbol-or-number.1 #f temp207_0 temp204_0 in205_0 config206_0)))"
"(if(unsafe-fx< index_0 16)"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(char-delimiter? c2_0 config_0)"
"(let-values()(wrap #t in_0 config_0 c_0))"
"(let-values()"
"(read-delimited-constant"
" c_0"
"(char=? c_0 '#\\t)"
" '(#\\r #\\u #\\e)"
" #t"
" in_0"
" config_0)))))"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(char-delimiter? c2_0 config_0)"
"(let-values()(wrap #f in_0 config_0 c_0))"
"(if(let-values(((or-part_0)(char=? c2_0 '#\\x)))"
"(if or-part_0 or-part_0(char=? c2_0 '#\\l)))"
"(let-values()"
"(read-fixnum-or-flonum-vector"
" read-one"
" dispatch-c_0"
" c_0"
" c2_0"
" in_0"
" config_0))"
"(let-values()"
"(read-delimited-constant"
" c_0"
"(char=? c_0 '#\\f)"
" '(#\\a #\\l #\\s #\\e)"
" #f"
" in_0"
" config_0)))))))))))"
"(if(unsafe-fx< index_0 26)"
"(if(unsafe-fx< index_0 21)"
"(if(unsafe-fx< index_0 18)"
"(let-values()"
"(let-values(((temp208_0) #f)"
"((in209_0) in_0)"
"((config210_0) config_0)"
"                                               ((temp211_0) \"#e\"))"
"(read-symbol-or-number.1 #f temp211_0 temp208_0 in209_0 config210_0)))"
"(if(unsafe-fx< index_0 19)"
"(let-values()"
"(let-values(((temp212_0) #f)"
"((in213_0) in_0)"
"((config214_0) config_0)"
"                                                 ((temp215_0) \"#E\"))"
"(read-symbol-or-number.1 #f temp215_0 temp212_0 in213_0 config214_0)))"
"(if(unsafe-fx< index_0 20)"
"(let-values()"
"(let-values(((temp216_0) #f)"
"((in217_0) in_0)"
"((config218_0) config_0)"
"                                                   ((temp219_0) \"#i\"))"
"(read-symbol-or-number.1 #f temp219_0 temp216_0 in217_0 config218_0)))"
"(let-values()"
"(let-values(((temp220_0) #f)"
"((in221_0) in_0)"
"((config222_0) config_0)"
"                                                   ((temp223_0) \"#I\"))"
"(read-symbol-or-number.1 #f temp223_0 temp220_0 in221_0 config222_0))))))"
"(if(unsafe-fx< index_0 23)"
"(if(unsafe-fx< index_0 22)"
"(let-values()"
"(let-values(((temp224_0) #f)"
"((in225_0) in_0)"
"((config226_0) config_0)"
"                                                 ((temp227_0) \"#d\"))"
"(read-symbol-or-number.1 #f temp227_0 temp224_0 in225_0 config226_0)))"
"(let-values()"
"(let-values(((temp228_0) #f)"
"((in229_0) in_0)"
"((config230_0) config_0)"
"                                                 ((temp231_0) \"#B\"))"
"(read-symbol-or-number.1 #f temp231_0 temp228_0 in229_0 config230_0))))"
"(if(unsafe-fx< index_0 24)"
"(let-values()"
"(let-values(((temp232_0) #f)"
"((in233_0) in_0)"
"((config234_0) config_0)"
"                                                 ((temp235_0) \"#o\"))"
"(read-symbol-or-number.1 #f temp235_0 temp232_0 in233_0 config234_0)))"
"(if(unsafe-fx< index_0 25)"
"(let-values()"
"(let-values(((temp236_0) #f)"
"((in237_0) in_0)"
"((config238_0) config_0)"
"                                                   ((temp239_0) \"#O\"))"
"(read-symbol-or-number.1 #f temp239_0 temp236_0 in237_0 config238_0)))"
"(let-values()"
"(let-values(((temp240_0) #f)"
"((in241_0) in_0)"
"((config242_0) config_0)"
"                                                   ((temp243_0) \"#D\"))"
"(read-symbol-or-number.1 #f temp243_0 temp240_0 in241_0 config242_0)))))))"
"(if(unsafe-fx< index_0 30)"
"(if(unsafe-fx< index_0 27)"
"(let-values()"
"(let-values(((temp244_0) #f)"
"((in245_0) in_0)"
"((config246_0) config_0)"
"                                               ((temp247_0) \"#b\"))"
"(read-symbol-or-number.1 #f temp247_0 temp244_0 in245_0 config246_0)))"
"(if(unsafe-fx< index_0 28)"
"(let-values()"
"(let-values(((temp248_0) #f)"
"((in249_0) in_0)"
"((config250_0) config_0)"
"                                                 ((temp251_0) \"#x\"))"
"(read-symbol-or-number.1 #f temp251_0 temp248_0 in249_0 config250_0)))"
"(if(unsafe-fx< index_0 29)"
"(let-values()"
"(let-values(((temp252_0) #f)"
"((in253_0) in_0)"
"((config254_0) config_0)"
"                                                   ((temp255_0) \"#X\"))"
"(read-symbol-or-number.1 #f temp255_0 temp252_0 in253_0 config254_0)))"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((tmp_1) c2_0))"
"(if(if(equal? tmp_1 '#\\s) #t(equal? tmp_1 '#\\S))"
"(let-values()"
"(read-one #f in_0(override-parameter read-case-sensitive config_0 #t)))"
"(if(if(equal? tmp_1 '#\\i) #t(equal? tmp_1 '#\\I))"
"(let-values()"
"(read-one #f in_0(override-parameter read-case-sensitive config_0 #f)))"
"(let-values()"
"(let-values(((in256_0) in_0)"
"((config257_0) config_0)"
"((c2258_0) c2_0)"
"                                                             ((temp259_0) \"expected `s', `S`, `i`, or `I` after `~a~a`\")"
"((dispatch-c260_0) dispatch-c_0)"
"((c261_0) c_0))"
"(reader-error.1"
" unsafe-undefined"
" c2258_0"
" #f"
" unsafe-undefined"
" in256_0"
" config257_0"
" temp259_0"
"(list dispatch-c260_0 c261_0))))))))))))"
"(if(unsafe-fx< index_0 32)"
"(if(unsafe-fx< index_0 31)"
"(let-values()(read-hash read-one dispatch-c_0 c_0 in_0 config_0))"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 dispatch-c_0)(values))))"
"(let-values((()(begin(accum-string-add! accum-str_0 c_0)(values))))"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(char? c2_0)"
"(let-values()(accum-string-add! accum-str_0 c2_0))"
"(void))"
"(let-values(((tmp_1) c2_0))"
"(if(equal? tmp_1 '#\\x)"
"(let-values()(read-regexp c_0 accum-str_0 in_0 config_0))"
"(if(equal? tmp_1 '#\\e)"
"(let-values()"
"(read-extension-reader"
" read-one"
" read-undotted"
" dispatch-c_0"
" in_0"
" config_0))"
"(let-values()"
"(let-values(((in262_0) in_0)"
"((config263_0) config_0)"
"((c2264_0) c2_0)"
"((temp265_0)"
"(let-values(((accum-str266_0) accum-str_0)"
"((config267_0) config_0))"
"(accum-string-get!.1"
" 0"
" accum-str266_0"
" config267_0))))"
"(bad-syntax-error.1"
" c2264_0"
" in262_0"
" config263_0"
" temp265_0)))))))))))))"
"(if(unsafe-fx< index_0 33)"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 dispatch-c_0)(values))))"
"(let-values((()(begin(accum-string-add! accum-str_0 c_0)(values))))"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(char? c2_0)"
"(let-values()(accum-string-add! accum-str_0 c2_0))"
"(void))"
"(let-values(((tmp_1) c2_0))"
"(if(equal? tmp_1 '#\\x)"
"(let-values()(read-regexp c_0 accum-str_0 in_0 config_0))"
"(let-values()"
"(let-values(((in268_0) in_0)"
"((config269_0) config_0)"
"((c2270_0) c2_0)"
"((temp271_0)"
"(let-values(((accum-str272_0) accum-str_0)"
"((config273_0) config_0))"
"(accum-string-get!.1"
" 0"
" accum-str272_0"
" config273_0))))"
"(bad-syntax-error.1"
" c2270_0"
" in268_0"
" config269_0"
" temp271_0)))))))))))"
"(if(unsafe-fx< index_0 34)"
"(let-values()"
"(let-values(((read-undotted274_0) read-undotted)"
"((dispatch-c275_0) dispatch-c_0)"
"((in276_0) in_0)"
"((config277_0) config_0))"
"(read-extension-lang.1"
" #f"
" read-undotted274_0"
" dispatch-c275_0"
" in276_0"
" config277_0)))"
"(if(unsafe-fx< index_0 35)"
"(let-values()"
"(let-values(((read-undotted278_0) read-undotted)"
"((dispatch-c279_0) dispatch-c_0)"
"((in280_0) in_0)"
"((config281_0) config_0))"
"(read-extension-#!.1"
" #f"
" read-undotted278_0"
" dispatch-c279_0"
" in280_0"
" config281_0)))"
"(let-values()"
"(if(check-parameter 1/read-accept-compiled config_0)"
"(let-values()"
"(wrap((read-config-read-compiled config_0) in_0) in_0 config_0 c_0))"
"(let-values()"
"(let-values(((in282_0) in_0)"
"((config283_0) config_0)"
"                                                         ((temp284_0) \"`~a~~` compiled expressions not enabled\")"
"((dispatch-c285_0) dispatch-c_0))"
"(reader-error.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in282_0"
" config283_0"
" temp284_0"
"(list dispatch-c285_0)))))))))))))))))))))))))"
"(define-values"
"(retry-special-comment)"
"(lambda(v_0 in_0 config_0)"
"(begin"
"(if(1/special-comment? v_0)"
"(let-values()(if(read-config-keep-comment? config_0) v_0(read-undotted #f in_0 config_0)))"
"(let-values() v_0)))))"
"(define-values"
"(1/module-declared?)"
"(let-values(((module-declared?_0)"
"(lambda(mod2_0 load?1_0)"
"(begin"
" 'module-declared?"
"(let-values(((mod_0) mod2_0))"
"(let-values(((load?_0) load?1_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(module-reference? mod_0)"
"(void)"
"(let-values()"
"(raise-argument-error 'module-declared? module-reference-str mod_0)))"
"(values))))"
"(let-values(((ns_0)(1/current-namespace)))"
"(let-values(((name_0)"
"(let-values(((mod24_0) mod_0)((load?25_0) load?_0))"
"(reference->resolved-module-path.1 load?25_0 mod24_0))))"
"(if(namespace->module ns_0 name_0) #t #f)))))))))))))"
"(case-lambda"
"((mod_0)(begin 'module-declared?(module-declared?_0 mod_0 #f)))"
"((mod_0 load?1_0)(module-declared?_0 mod_0 load?1_0)))))"
"(define-values"
"(1/module-predefined?)"
"(lambda(mod_0)"
"(begin"
" 'module-predefined?"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(module-reference? mod_0)"
"(void)"
"(let-values()(raise-argument-error 'module-predefined? module-reference-str mod_0)))"
"(values))))"
"(let-values(((ns_0)(1/current-namespace)))"
"(let-values(((name_0)"
"(let-values(((mod27_0) mod_0)((temp28_0) #f))"
"(reference->resolved-module-path.1 temp28_0 mod27_0))))"
"(let-values(((m_0)(namespace->module ns_0 name_0)))(if m_0(module-is-predefined? m_0) #f))))))))))"
"(define-values"
"(module->.1)"
"(lambda(extra-checks3_0 extract6_0 who7_0 mod8_0 load?5_0)"
"(begin"
" 'module->"
"(let-values(((extract_0) extract6_0))"
"(let-values(((who_0) who7_0))"
"(let-values(((mod_0) mod8_0))"
"(let-values(((load?_0) load?5_0))"
"(let-values(((extra-checks_0) extra-checks3_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(module-reference? mod_0)"
"(void)"
"(let-values()(raise-argument-error who_0 module-reference-str mod_0)))"
"(values))))"
"(let-values((()(begin(extra-checks_0)(values))))"
"(let-values(((m_0)"
"(namespace->module/complain"
" who_0"
"(1/current-namespace)"
"(let-values(((mod29_0) mod_0)((load?30_0) load?_0))"
"(reference->resolved-module-path.1 load?30_0 mod29_0)))))"
"(extract_0 m_0)))))))))))))"
"(define-values"
"(1/module->language-info)"
"(let-values(((module->language-info_0)"
"(lambda(mod11_0 load?10_0)"
"(begin"
" 'module->language-info"
"(let-values(((mod_0) mod11_0))"
"(let-values(((load?_0) load?10_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((module-language-info32_0) module-language-info)"
"((who33_0) 'module->language-info)"
"((mod34_0) mod_0)"
"((load?35_0) load?_0))"
"(module->.1 void module-language-info32_0 who33_0 mod34_0 load?35_0)))))))))))"
"(case-lambda"
"((mod_0)(begin 'module->language-info(module->language-info_0 mod_0 #f)))"
"((mod_0 load?10_0)(module->language-info_0 mod_0 load?10_0)))))"
"(define-values"
"(1/module->imports)"
"(lambda(mod_0)"
"(begin"
" 'module->imports"
"(let-values()"
"(let-values()"
"(let-values(((module-requires37_0) module-requires)((who38_0) 'module->imports)((mod39_0) mod_0))"
"(module->.1 void module-requires37_0 who38_0 mod39_0 #f)))))))"
"(define-values"
"(1/module->exports)"
"(let-values(((module->exports_0)"
"(lambda(mod13_0 verbosity12_0)"
"(begin"
" 'module->exports"
"(let-values(((mod_0) mod13_0))"
"(let-values(((verbosity_0) verbosity12_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((provides_0 self_0)"
"(let-values(((temp41_0)"
"(lambda(m_0)"
"(values(module-provides m_0)(module-self m_0))))"
"((who42_0) 'module->exports)"
"((mod43_0) mod_0)"
"((temp44_0)"
"(lambda()"
"(check-provides-verbosity 'module->exports verbosity_0))))"
"(module->.1 temp44_0 temp41_0 who42_0 mod43_0 #f))))"
"(provides->api-provides provides_0 self_0 verbosity_0)))))))))))"
"(case-lambda"
"((mod_0)(begin 'module->exports(module->exports_0 mod_0 #f)))"
"((mod_0 verbosity12_0)(module->exports_0 mod_0 verbosity12_0)))))"
"(define-values"
"(1/module->indirect-exports)"
"(lambda(mod_0)"
"(begin"
" 'module->indirect-exports"
"(let-values()"
"(let-values()"
"(let-values(((temp46_0)"
"(lambda(m_0)"
"(variables->api-nonprovides(module-provides m_0)((module-get-all-variables m_0)))))"
"((who47_0) 'module->indirect-exports)"
"((mod48_0) mod_0))"
"(module->.1 void temp46_0 who47_0 mod48_0 #f)))))))"
"(define-values"
"(1/module-provide-protected?)"
"(lambda(mod_0 sym_0)"
"(begin"
" 'module-provide-protected?"
"(let-values()"
"(let-values()"
"(let-values(((temp50_0)"
"(lambda(m_0)"
"(let-values(((b/p_0)(hash-ref(module-provides m_0) sym_0 #f)))"
"(let-values(((or-part_0)(not b/p_0)))"
"(if or-part_0 or-part_0(provided-as-protected? b/p_0))))))"
"((who51_0) 'module-provide-protected?)"
"((mod52_0) mod_0))"
"(module->.1 void temp50_0 who51_0 mod52_0 #f)))))))"
"(define-values"
"(1/module->realm)"
"(lambda(mod_0)"
"(begin"
" 'module->realm"
"(let-values()"
"(let-values()"
"(let-values(((temp54_0)(lambda(m_0)(module-realm m_0)))((who55_0) 'module->realm)((mod56_0) mod_0))"
"(module->.1 void temp54_0 who55_0 mod56_0 #f)))))))"
"(define-values"
"(1/module->namespace)"
"(let-values(((module->namespace_0)"
"(lambda(mod15_0 ns14_0)"
"(begin"
" 'module->namespace"
"(let-values(((mod_0) mod15_0))"
"(let-values(((ns_0)(if(eq? ns14_0 unsafe-undefined)(1/current-namespace) ns14_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(module-reference? mod_0)"
"(void)"
"(let-values()"
"(raise-argument-error 'module->namespace module-reference-str mod_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"                                                    (raise-argument-error 'module->namespace \"namespace?\" ns_0)))"
"(values))))"
"(let-values(((name_0)"
"(let-values(((mod61_0) mod_0)((temp62_0) #t))"
"(reference->resolved-module-path.1 temp62_0 mod61_0))))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"(let-values(((m-ns_0)"
"(let-values(((ns63_0) ns_0)"
"((name64_0) name_0)"
"((phase65_0) phase_0))"
"(namespace->module-namespace.1"
" #f"
" #f"
" void"
" ns63_0"
" name64_0"
" phase65_0))))"
"(begin"
"(if m-ns_0"
"(void)"
"(let-values()"
"(begin"
"(namespace->module/complain 'module->namespace ns_0 name_0)"
"(raise-arguments-error"
" 'module->namespace"
"                                                 \"module not instantiated in the current namespace\""
"                                                 \"name\""
" name_0))))"
"(if(inspector-superior?"
"(current-code-inspector)"
"(namespace-inspector m-ns_0))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'module->namespace"
"                                               \"current code inspector cannot access namespace of module\""
"                                               \"module name\""
" name_0)))"
"(if(namespace-get-root-expand-ctx m-ns_0)"
"(void)"
"(let-values()"
"(namespace-set-root-expand-ctx!"
" m-ns_0"
"(let-values(((temp66_0)(namespace-mpi m-ns_0)))"
"(make-root-expand-context.1"
" #f"
" null"
" unsafe-undefined"
" unsafe-undefined"
" temp66_0)))))"
"(let-values(((ns58_0) ns_0)"
"((temp59_0)(namespace-mpi m-ns_0))"
"((phase60_0) phase_0))"
"(namespace-module-make-available!.1"
" #f"
" unsafe-undefined"
" ns58_0"
" temp59_0"
" phase60_0))"
" m-ns_0)))))))))))))))"
"(case-lambda"
"((mod_0)(begin 'module->namespace(module->namespace_0 mod_0 unsafe-undefined)))"
"((mod_0 ns14_0)(module->namespace_0 mod_0 ns14_0)))))"
"(define-values"
"(1/namespace-unprotect-module)"
"(let-values(((namespace-unprotect-module_0)"
"(lambda(insp17_0 mod18_0 ns16_0)"
"(begin"
" 'namespace-unprotect-module"
"(let-values(((insp_0) insp17_0))"
"(let-values(((mod_0) mod18_0))"
"(let-values(((ns_0)(if(eq? ns16_0 unsafe-undefined)(1/current-namespace) ns16_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(inspector? insp_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-unprotect-module"
"                                                     \"inspector?\""
" insp_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/module-path? mod_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-unprotect-module"
"                                                       \"module-path?\""
" mod_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-unprotect-module"
"                                                         \"namespace?\""
" ns_0)))"
"(values))))"
"(let-values(((name_0)"
"(let-values(((mod68_0) mod_0)((temp69_0) #f))"
"(reference->resolved-module-path.1 temp69_0 mod68_0))))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"(let-values(((m-ns_0)"
"(let-values(((ns70_0) ns_0)"
"((name71_0) name_0)"
"((phase72_0) phase_0))"
"(namespace->module-namespace.1"
" #f"
" #f"
" void"
" ns70_0"
" name71_0"
" phase72_0))))"
"(begin"
"(if m-ns_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'namespace-unprotect-module"
"                                                   \"module not instantiated\""
"                                                   \"module name\""
" name_0)))"
"(if(inspector-superior? insp_0(namespace-inspector m-ns_0))"
"(let-values()"
"(set-namespace-inspector!"
" m-ns_0"
"(make-inspector(current-code-inspector))))"
"(void)))))))))))))))))))"
"(case-lambda"
"((insp_0 mod_0)(begin 'namespace-unprotect-module(namespace-unprotect-module_0 insp_0 mod_0 unsafe-undefined)))"
"((insp_0 mod_0 ns16_0)(namespace-unprotect-module_0 insp_0 mod_0 ns16_0)))))"
"(define-values"
"(namespace->module/complain)"
"(lambda(who_0 ns_0 name_0)"
"(begin"
"(let-values(((or-part_0)(namespace->module ns_0 name_0)))"
"(if or-part_0"
" or-part_0"
"          (raise-arguments-error who_0 \"unknown module in the current namespace\" \"name\" name_0))))))"
"(define-values"
"(module-reference?)"
"(lambda(mod_0)"
"(begin"
"(let-values(((or-part_0)(1/module-path? mod_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/module-path-index? mod_0)))"
"(if or-part_1 or-part_1(1/resolved-module-path? mod_0))))))))"
" (define-values (module-reference-str) \"(or/c module-path? module-path-index? resolved-module-path?)\")"
"(define-values"
"(reference->resolved-module-path.1)"
"(lambda(load?19_0 mod21_0)"
"(begin"
" 'reference->resolved-module-path"
"(let-values(((mod_0) mod21_0))"
"(let-values(((load?_0) load?19_0))"
"(let-values()"
"(if(1/resolved-module-path? mod_0)"
"(let-values() mod_0)"
"(let-values()"
"(let-values(((mpi_0)(if(1/module-path-index? mod_0) mod_0(module-path-index-join* mod_0 #f))))"
"(1/module-path-index-resolve mpi_0 load?_0))))))))))"
"(define-values"
"(read-linklet-bundle-or-directory)"
"(lambda(in_0)"
"(begin"
"(letrec-values(((read-linklet-or-directory_0)"
"(lambda(initial?_0)"
"(begin"
" 'read-linklet-or-directory"
"(let-values(((start-pos_0)(-(file-position in_0) 2)))"
"(let-values(((vers-len_0)(min 63(read-byte in_0))))"
"(let-values(((vers_0)(read-bytes vers-len_0 in_0)))"
"(let-values((()"
"(begin"
"(if(equal? vers_0 version-bytes$1)"
"(void)"
"(let-values()"
"(raise-read-error"
" '|loading code|"
"                                                      \"version mismatch\""
"                                                      \"expected\""
"(version)"
"                                                      \"found\""
"(bytes->string/utf-8 vers_0 '#\\?)"
"                                                      \"in\""
"(let-values(((n_0)(object-name in_0)))"
"(if(path? n_0)"
"(unquoted-printing-string(path->string n_0))"
" in_0))"
"                                                      \"possible solution\""
"(unquoted-printing-string"
"                                                       \"running `racket -y`, `raco make`, or `raco setup`\"))))"
"(values))))"
"(let-values(((vm-len_0)(min 63(read-byte in_0))))"
"(let-values(((vm_0)(read-bytes vm-len_0 in_0)))"
"(let-values(((as-correlated-linklet?_0)"
"(equal? vm_0 correlated-linklet-vm-bytes)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0) as-correlated-linklet?_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(equal? vm_0 vm-bytes$1)))"
"(if or-part_1"
" or-part_1"
"(equal?"
"                                                                      (equal? vm_0 #\"racket\")"
"                                                                      (equal? vm-bytes$1 #\"racket\"))))))"
"(void)"
"(let-values()"
"(raise-read-error"
" '|loading code|"
"                                                              \"machine mismatch\""
"                                                              \"expected\""
"(bytes->string/utf-8 vm-bytes$1)"
"                                                              \"found\""
"(bytes->string/utf-8 vm_0 '#\\?)"
"                                                              \"in\""
"(let-values(((n_0)(object-name in_0)))"
"(if(path? n_0)"
"(unquoted-printing-string(path->string n_0))"
" in_0)))))"
"(values))))"
"(let-values(((tag_0)(read-byte in_0)))"
"(if(eqv? tag_0(char->integer '#\\B))"
"(let-values()"
"(let-values(((sha-1_0)(read-bytes 20 in_0)))"
"(let-values(((b-ht_0)"
"(if as-correlated-linklet?_0"
"(read-correlated-linklet-bundle-hash in_0)"
"(1/read-linklet-bundle-hash"
" in_0"
"(if(not(equal? vm_0 vm-bytes$1))"
"(string->symbol(bytes->string/utf-8 vm_0 '#\\?))"
" #f)))))"
"(begin"
"(if(hash? b-ht_0)"
"(void)"
"(let-values()"
"(raise-read-error"
" 'read-linklet-bundle-hash"
"                                                            \"bad read result\""
"                                                            \"expected\""
"                                                            \"hash/c\""
"                                                            \"found\""
"                                                            (format \"~s\" b-ht_0)"
"                                                            \"in\""
"(let-values(((n_0)(object-name in_0)))"
"(if(path? n_0)(path->string n_0) in_0)))))"
"(1/hash->linklet-bundle"
"(add-hash-code"
"(if initial?_0(strip-submodule-references b-ht_0) b-ht_0)"
" sha-1_0))))))"
"(if(eqv? tag_0(char->integer '#\\D))"
"(let-values()"
"(begin"
"(if initial?_0"
"(void)"
"(let-values()"
"(raise-read-error"
" 'read-compiled-linklet"
"                                                          \"expected a linklet bundle\")))"
"(read-bundle-directory_0 start-pos_0)))"
"(let-values()"
"(raise-read-error"
" 'read-compiled-linklet"
"                                                    \"expected a `B` or `D`\"))))))))))))))))"
"((read-bundle-directory_0)"
"(lambda(pos_0)"
"(begin"
" 'read-bundle-directory"
"(let-values(((count_0)(read-int in_0)))"
"(let-values(((position-to-name_0)"
"((letrec-values(((loop_0)"
"(lambda(count_1 accum_0)"
"(begin"
" 'loop"
"(if(zero? count_1)"
"(let-values() accum_0)"
"(let-values()"
"(let-values(((bstr_0)"
"(read-bytes(read-int in_0) in_0)))"
"(let-values(((offset_0)(read-int in_0)))"
"(let-values(((len_0)(read-int in_0)))"
"(begin"
"(read-int in_0)"
"(read-int in_0)"
"(loop_0"
"(sub1 count_1)"
"(hash-set"
" accum_0"
" offset_0"
" bstr_0))))))))))))"
" loop_0)"
" count_0"
"(hasheqv))))"
"((letrec-values(((loop_0)"
"(lambda(count_1 accum_0)"
"(begin"
" 'loop"
"(if(zero? count_1)"
"(let-values()"
"(list->bundle-directory accum_0 1/hash->linklet-directory))"
"(let-values()"
"(let-values(((name_0)"
"(hash-ref"
" position-to-name_0"
"(-(file-position in_0) pos_0)"
" #f)))"
"(let-values((()"
"(begin"
"(if name_0"
"(void)"
"(let-values()"
"(raise-read-error"
" 'read-compiled-linklet"
"                                                                                \"bundle not at an expected file position\")))"
"(values))))"
"(let-values(((bstr_0)(read-bytes 2 in_0)))"
"(let-values(((bundle_0)"
"                                                                             (if (equal? #\"#~\" bstr_0)"
"(let-values()"
"(read-linklet-or-directory_0 #f))"
"                                                                               (if (equal? #\"#f\" bstr_0)"
"(let-values() #f)"
"(let-values()"
"(raise-read-error"
" 'read-compiled-linklet"
"                                                                                    \"expected a `#~` or `#f` for a bundle\"))))))"
"(loop_0"
"(sub1 count_1)"
"(cons"
"(cons(decode-name name_0 0) bundle_0)"
" accum_0))))))))))))"
" loop_0)"
" count_0"
" '())))))))"
"(read-linklet-or-directory_0 #t)))))"
"(define-values(read-int)(lambda(in_0)(begin(integer-bytes->integer(read-bytes 4 in_0) #f #f))))"
"(define-values"
"(decode-name)"
"(lambda(bstr_0 pos_0)"
"(begin"
"(let-values(((blen_0)(bytes-length bstr_0)))"
"(let-values(((bad-bundle_0)"
"                      (lambda () (begin 'bad-bundle (raise-read-error 'read-compiled-linklet \"malformed bundle\")))))"
"(if(= pos_0 blen_0)"
"(let-values() '())"
"(if(> pos_0 blen_0)"
"(let-values()(bad-bundle_0))"
"(let-values()"
"(let-values(((len_0)(bytes-ref bstr_0 pos_0)))"
"(begin"
"(if(>(+ pos_0 len_0 1) blen_0)(let-values()(bad-bundle_0))(void))"
"(if(= len_0 255)"
"(let-values()"
"(let-values(((len_1)(integer-bytes->integer bstr_0 #f #f(add1 pos_0)(+ pos_0 5))))"
"(begin"
"(if(>(+ pos_0 len_1 1) blen_0)(let-values()(bad-bundle_0))(void))"
"(cons"
"(string->symbol(bytes->string/utf-8(subbytes bstr_0(+ pos_0 5)(+ pos_0 5 len_1)) '#\\?))"
"(decode-name bstr_0(+ pos_0 5 len_1))))))"
"(let-values()"
"(cons"
"(string->symbol(bytes->string/utf-8(subbytes bstr_0(add1 pos_0)(+ pos_0 1 len_0)) '#\\?))"
"(decode-name bstr_0(+ pos_0 1 len_0)))))))))))))))"
"(define-values"
"(list->bundle-directory)"
"(lambda(l_0 hash->linklet-directory_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(l_1 prev-len_0 stack_0 accum_0)"
"(begin"
" 'loop"
"(begin"
"(if(null? l_1)"
"                                (let-values () (raise-read-error 'read-compiled-linklet \"invalid bundle sequence\"))"
"(void))"
"(let-values(((p_0)(car l_1)))"
"(let-values(((path_0)(car p_0)))"
"(let-values(((v_0)(cdr p_0)))"
"(let-values(((len_0)(length path_0)))"
"(begin"
"(if(< len_0 prev-len_0)"
"(let-values()"
"                                            (raise-read-error 'read-compiled-linklet \"invalid bundle sequence\"))"
"(void))"
"((letrec-values(((sloop_0)"
"(lambda(prev-len_1 stack_1 accum_1)"
"(begin"
" 'sloop"
"(if(> len_0(add1 prev-len_1))"
"(let-values()"
"(sloop_0"
"(add1 prev-len_1)"
"(cons accum_1 stack_1)"
"(hasheq)))"
"(let-values()"
"(let-values(((path_1)"
"(list-tail"
" path_0"
"(max 0(sub1 prev-len_1)))))"
"(if(= len_0 prev-len_1)"
"(let-values()"
"(let-values(((accum_2)"
"(if v_0"
"(hash-set accum_1 #f v_0)"
" accum_1)))"
"(if(zero? len_0)"
"(hash->linklet-directory_0 accum_2)"
"(loop_0"
"(cdr l_1)"
"(sub1 prev-len_1)"
"(cdr stack_1)"
"(hash-set"
"(car stack_1)"
"(car path_1)"
"(hash->linklet-directory_0 accum_2))))))"
"(let-values()"
"(let-values(((path_2)"
"(if(positive? prev-len_1)"
"(cdr path_1)"
" path_1)))"
"(loop_0"
"(cdr l_1)"
" prev-len_1"
" stack_1"
"(hash-set"
" accum_1"
"(car path_2)"
"(hash->linklet-directory_0"
"(if v_0"
"(hasheq #f v_0)"
"(hasheq)))))))))))))))"
" sloop_0)"
" prev-len_0"
" stack_0"
" accum_0)))))))))))"
" loop_0)"
" l_0"
" 0"
" '()"
"(hasheq)))))"
"(define-values(strip-submodule-references)(lambda(b-ht_0)(begin(hash-remove(hash-remove b-ht_0 'pre) 'post))))"
"(define-values"
"(add-hash-code)"
"(lambda(b-ht_0 sha-1_0)"
"(begin"
"      (if (bytes=? sha-1_0 #\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\") b-ht_0 (hash-set b-ht_0 'hash-code sha-1_0)))))"
"(define-values"
"(raise-read-error)"
"(lambda(who_0 msg_0 . details_0)"
"(begin"
"(raise"
"(exn:fail:read"
"(apply"
" string-append"
"         (format \"~a: ~a\" who_0 msg_0)"
"((letrec-values(((loop_0)"
"(lambda(details_1)"
"(begin"
" 'loop"
"(if(null? details_1)"
"(let-values() null)"
"(let-values()"
"(list*"
"                                    \"\\n  \""
"(car details_1)"
"                                    \": \""
"                                    (format \"~v\" (cadr details_1))"
"(loop_0(cddr details_1)))))))))"
" loop_0)"
" details_0))"
"(current-continuation-marks)"
" null)))))"
"(define-values"
"(read-syntax$1)"
"(lambda(src_0 in_0)"
"(begin"
" 'read-syntax"
"(if(default-read-handler? in_0)"
"(let-values()"
"(begin"
"(maybe-flush-stdout in_0)"
"(let-values(((in18_0) in_0)((temp19_0) #t)((src20_0) src_0))"
"(read*.1 temp19_0 #f #f unsafe-undefined #f src20_0 in18_0))))"
"(let-values()(values((port-read-handler in_0) in_0 src_0)))))))"
"(define-values"
"(read-syntax/recursive$1)"
"(lambda(src_0 in_0 start_0 readtable_0 graph?_0)"
"(begin"
" 'read-syntax/recursive"
"(let-values(((in21_0) in_0)"
"((temp22_0) #t)"
"((temp23_0) #t)"
"((src24_0) src_0)"
"((start25_0) start_0)"
"((readtable26_0) readtable_0)"
"((temp27_0)(not graph?_0)))"
"(read*.1 temp22_0 start25_0 temp27_0 readtable26_0 temp23_0 src24_0 in21_0)))))"
"(define-values"
"(read$1)"
"(lambda(in_0)"
"(begin"
" 'read"
"(if(default-read-handler? in_0)"
"(let-values()"
"(begin"
"(maybe-flush-stdout in_0)"
"(let-values(((in28_0) in_0)((temp29_0) #f))(read*.1 temp29_0 #f #f unsafe-undefined #f #f in28_0))))"
"(let-values()(values((port-read-handler in_0) in_0)))))))"
"(define-values"
"(read/recursive$1)"
"(lambda(in_0 start_0 readtable_0 graph?_0)"
"(begin"
" 'read/recursive"
"(let-values(((in30_0) in_0)"
"((temp31_0) #f)"
"((temp32_0) #t)"
"((start33_0) start_0)"
"((readtable34_0) readtable_0)"
"((temp35_0)(not graph?_0)))"
"(read*.1 temp31_0 start33_0 temp35_0 readtable34_0 temp32_0 #f in30_0)))))"
"(define-values"
"(read*.1)"
"(lambda(for-syntax?1_0 init-c4_0 local-graph?6_0 readtable5_0 recursive?2_0 source3_0 in13_0)"
"(begin"
" 'read*"
"(let-values(((in_0) in13_0))"
"(let-values(((for-syntax?_0) for-syntax?1_0))"
"(let-values(((recursive?_0) recursive?2_0))"
"(let-values(((source_0) source3_0))"
"(let-values(((init-c_0) init-c4_0))"
"(let-values(((readtable_0)"
"(if(eq? readtable5_0 unsafe-undefined)(1/current-readtable) readtable5_0)))"
"(let-values(((local-graph?_0) local-graph?6_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'read))(void))"
"(begin0"
"(let-values()"
"(let-values(((in36_0) in_0)"
"((for-syntax?37_0) for-syntax?_0)"
"((recursive?38_0) recursive?_0)"
"((source39_0) source_0)"
"((temp40_0)(if for-syntax?_0 read-to-syntax #f))"
"((init-c41_0) init-c_0)"
"((readtable42_0) readtable_0)"
"((local-graph?43_0) local-graph?_0)"
"((read-linklet-bundle-or-directory44_0) read-linklet-bundle-or-directory)"
"((call-with-root-namespace45_0) call-with-root-namespace)"
"((locked-dynamic-require46_0) locked-dynamic-require)"
"((read-module-declared?47_0) read-module-declared?)"
"((read-coerce48_0) read-coerce)"
"((read-coerce-key49_0) read-coerce-key))"
"(read.1"
" call-with-root-namespace45_0"
" read-coerce48_0"
" read-coerce-key49_0"
" locked-dynamic-require46_0"
" for-syntax?37_0"
" init-c41_0"
" unsafe-undefined"
" local-graph?43_0"
" read-module-declared?47_0"
" unsafe-undefined"
" read-linklet-bundle-or-directory44_0"
" readtable42_0"
" recursive?38_0"
" source39_0"
" temp40_0"
" in36_0)))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))))))))))"
"(define-values"
"(read-language$1)"
"(lambda(in_0 fail-thunk_0)"
"(begin"
" 'read-language"
"(let-values(((in50_0) in_0)"
"((fail-thunk51_0) fail-thunk_0)"
"((temp52_0) #t)"
"((read-to-syntax53_0) read-to-syntax)"
"((read-linklet-bundle-or-directory54_0) read-linklet-bundle-or-directory)"
"((call-with-root-namespace55_0) call-with-root-namespace)"
"((locked-dynamic-require56_0) locked-dynamic-require)"
"((read-module-declared?57_0) read-module-declared?)"
"((read-coerce58_0) read-coerce)"
"((read-coerce-key59_0) read-coerce-key))"
"(read-language.1"
" call-with-root-namespace55_0"
" read-coerce58_0"
" read-coerce-key59_0"
" locked-dynamic-require56_0"
" temp52_0"
" read-module-declared?57_0"
" read-linklet-bundle-or-directory54_0"
" read-to-syntax53_0"
" in50_0"
" fail-thunk51_0)))))"
"(define-values"
"(read-to-syntax)"
"(lambda(s-exp_0 srcloc_0 rep_0)"
"(begin"
"(let-values(((the-struct_0) empty-syntax))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content*60_0)(datum-intern-literal s-exp_0))"
"((srcloc61_0) srcloc_0)"
"((props62_0)"
"(let-values(((tmp_0) rep_0))"
"(if(equal? tmp_0 '#\\[)"
"(let-values() original-square-props)"
"(if(equal? tmp_0 '#\\{)"
"(let-values() original-curly-props)"
"(let-values() original-props))))))"
"(syntax2.1"
" content*60_0"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
" srcloc61_0"
" props62_0"
"(syntax-inspector the-struct_0)))"
"          (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"(define-values(original-props)(syntax-props(syntax-property$1 empty-syntax original-property-sym #t)))"
"(define-values"
"(original-square-props)"
"(syntax-props(syntax-property$1(syntax-property$1 empty-syntax original-property-sym #t) 'paren-shape '#\\[)))"
"(define-values"
"(original-curly-props)"
"(syntax-props(syntax-property$1(syntax-property$1 empty-syntax original-property-sym #t) 'paren-shape '#\\{)))"
"(define-values(read-module-declared?)(lambda(mod-path_0)(begin(1/module-declared? mod-path_0 #t))))"
"(define-values"
"(read-coerce)"
"(lambda(for-syntax?_0 v_0 srcloc_0)"
"(begin"
"(if(not for-syntax?_0)"
"(let-values()(if(syntax?$1 v_0)(let-values()(syntax->datum$1 v_0))(let-values() v_0)))"
"(if(syntax?$1 v_0)"
"(let-values() v_0)"
"(if(list? v_0)"
"(let-values()"
"(read-to-syntax"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(read-coerce #t e_0 srcloc_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" srcloc_0"
" #f))"
"(if(pair? v_0)"
"(let-values()"
"(read-to-syntax"
"(cons(read-coerce #t(car v_0) srcloc_0)(read-coerce #t(cdr v_0) srcloc_0))"
" srcloc_0"
" #f))"
"(let-values()(read-to-syntax v_0 srcloc_0 #f)))))))))"
"(define-values"
"(read-coerce-key)"
"(lambda(for-syntax?_0 k_0)"
"(begin(if for-syntax?_0(let-values()(datum-intern-literal k_0))(let-values() k_0)))))"
"(define-values(default-read-handler) #f)"
"(define-values"
"(default-read-handler?)"
"(lambda(in_0)"
"(begin"
"(if(not default-read-handler)"
"(let-values()(begin(set! default-read-handler(port-read-handler in_0)) #t))"
"(let-values()(eq? default-read-handler(port-read-handler in_0)))))))"
"(define-values(orig-input-port)(current-input-port))"
"(define-values(orig-output-port)(current-output-port))"
"(define-values(orig-error-port)(current-error-port))"
"(define-values"
"(maybe-flush-stdout)"
"(lambda(in_0)"
"(begin"
"(if(eq? in_0 orig-input-port)"
"(let-values()(begin(flush-output orig-output-port)(flush-output orig-error-port)))"
"(void)))))"
"(define-values"
"(call-with-root-namespace)"
"(lambda(thunk_0)"
"(begin"
"(let-values(((root-ns_0)(namespace-root-namespace(1/current-namespace))))"
"(if root-ns_0"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace root-ns_0)"
"(let-values()(thunk_0)))"
"(thunk_0))))))"
"(define-values"
"(locked-dynamic-require)"
"(let-values(((locked-dynamic-require_0)"
"(lambda(mod16_0 sym17_0 fail-thunk15_0)"
"(begin"
" 'locked-dynamic-require"
"(let-values(((mod_0) mod16_0))"
"(let-values(((sym_0) sym17_0))"
"(let-values(((fail-thunk_0) fail-thunk15_0))"
"(let-values()"
"(registry-call-with-lock"
"(namespace-module-registry$1(1/current-namespace))"
"(lambda()"
"(if fail-thunk_0"
"(1/dynamic-require mod_0 sym_0 fail-thunk_0)"
"(1/dynamic-require mod_0 sym_0))))))))))))"
"(case-lambda"
"((mod_0 sym_0)(begin(locked-dynamic-require_0 mod_0 sym_0 #f)))"
"((mod_0 sym_0 fail-thunk15_0)(locked-dynamic-require_0 mod_0 sym_0 fail-thunk15_0)))))"
"(define-values"
"(1/read-syntax)"
"(let-values(((read-syntax_0)"
"(lambda(src1_0 in2_0)"
"(begin"
" 'read-syntax"
"(let-values(((src_0)(if(eq? src1_0 unsafe-undefined)(object-name(current-input-port)) src1_0)))"
"(let-values(((in_0)(if(eq? in2_0 unsafe-undefined)(current-input-port) in2_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'read-syntax \"input-port?\" in_0)))"
"(read-syntax$1 src_0 in_0)))))))))))"
"(case-lambda"
"(()(begin 'read-syntax(read-syntax_0 unsafe-undefined unsafe-undefined)))"
"((src_0 in2_0)(read-syntax_0 src_0 in2_0))"
"((src1_0)(read-syntax_0 src1_0 unsafe-undefined)))))"
"(define-values"
"(1/read-syntax/recursive)"
"(let-values(((read-syntax/recursive_0)"
"(lambda(src3_0 in4_0 start5_0 readtable6_0 graph?7_0)"
"(begin"
" 'read-syntax/recursive"
"(let-values(((src_0)(if(eq? src3_0 unsafe-undefined)(object-name(current-input-port)) src3_0)))"
"(let-values(((in_0)(if(eq? in4_0 unsafe-undefined)(current-input-port) in4_0)))"
"(let-values(((start_0) start5_0))"
"(let-values(((readtable_0)"
"(if(eq? readtable6_0 unsafe-undefined)(1/current-readtable) readtable6_0)))"
"(let-values(((graph?_0) graph?7_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'read-syntax/recursive \"input-port?\" in_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(char? x_0))))"
" start_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'read-syntax/recursive \"(or/c char? #f)\" start_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(1/readtable? x_0))))"
" readtable_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'read-syntax/recursive"
"                                           \"(or/c readtable? #f)\""
" readtable_0)))"
"(read-syntax/recursive$1 src_0 in_0 start_0 readtable_0 graph?_0))))))))))))))"
"(case-lambda"
"(()"
"(begin 'read-syntax/recursive(read-syntax/recursive_0 unsafe-undefined unsafe-undefined #f unsafe-undefined #t)))"
"((src_0 in_0 start_0 readtable_0 graph?7_0)(read-syntax/recursive_0 src_0 in_0 start_0 readtable_0 graph?7_0))"
"((src_0 in_0 start_0 readtable6_0)(read-syntax/recursive_0 src_0 in_0 start_0 readtable6_0 #t))"
"((src_0 in_0 start5_0)(read-syntax/recursive_0 src_0 in_0 start5_0 unsafe-undefined #t))"
"((src_0 in4_0)(read-syntax/recursive_0 src_0 in4_0 #f unsafe-undefined #t))"
"((src3_0)(read-syntax/recursive_0 src3_0 unsafe-undefined #f unsafe-undefined #t)))))"
"(define-values"
"(1/read)"
"(let-values(((read_0)"
"(lambda(in8_0)"
"(begin"
" 'read"
"(let-values(((in_0)(if(eq? in8_0 unsafe-undefined)(current-input-port) in8_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"                                (let-values () (raise-argument-error 'read \"input-port?\" in_0)))"
"(read$1 in_0))))))))))"
"(case-lambda(()(begin 'read(read_0 unsafe-undefined)))((in8_0)(read_0 in8_0)))))"
"(define-values"
"(1/read/recursive)"
"(let-values(((read/recursive_0)"
"(lambda(in9_0 start10_0 readtable11_0 graph?12_0)"
"(begin"
" 'read/recursive"
"(let-values(((in_0)(if(eq? in9_0 unsafe-undefined)(current-input-port) in9_0)))"
"(let-values(((start_0) start10_0))"
"(let-values(((readtable_0)"
"(if(eq? readtable11_0 unsafe-undefined)(1/current-readtable) readtable11_0)))"
"(let-values(((graph?_0) graph?12_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'read/recursive \"input-port?\" in_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))(if or-part_0 or-part_0(char? x_0))))"
" start_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'read/recursive \"(or/c char? #f)\" start_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(1/readtable? x_0))))"
" readtable_0)"
"(void)"
"(let-values()"
"                                        (raise-argument-error 'read/recursive \"(or/c readtable? #f)\" readtable_0)))"
"(read/recursive$1 in_0 start_0 readtable_0 graph?_0)))))))))))))"
"(case-lambda"
"(()(begin 'read/recursive(read/recursive_0 unsafe-undefined #f unsafe-undefined #t)))"
"((in_0 start_0 readtable_0 graph?12_0)(read/recursive_0 in_0 start_0 readtable_0 graph?12_0))"
"((in_0 start_0 readtable11_0)(read/recursive_0 in_0 start_0 readtable11_0 #t))"
"((in_0 start10_0)(read/recursive_0 in_0 start10_0 unsafe-undefined #t))"
"((in9_0)(read/recursive_0 in9_0 #f unsafe-undefined #t)))))"
"(define-values"
"(1/read-language)"
"(let-values(((read-language_0)"
"(lambda(in13_0 fail-thunk14_0)"
"(begin"
" 'read-language"
"(let-values(((in_0)(if(eq? in13_0 unsafe-undefined)(current-input-port) in13_0)))"
"(let-values(((fail-thunk_0)"
"(if(eq? fail-thunk14_0 unsafe-undefined) read-language-fail-thunk fail-thunk14_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'read-language \"input-port?\" in_0)))"
"(if((lambda(p_0)(if(procedure? p_0)(procedure-arity-includes? p_0 0) #f))"
" fail-thunk_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'read-language"
"                                     \"(procedure-arity-includes/c 0)\""
" fail-thunk_0)))"
"(read-language$1"
" in_0"
"(if(eq? fail-thunk_0 read-language-fail-thunk) #f fail-thunk_0))))))))))))"
"(case-lambda"
"(()(begin 'read-language(read-language_0 unsafe-undefined unsafe-undefined)))"
"((in_0 fail-thunk14_0)(read-language_0 in_0 fail-thunk14_0))"
"((in13_0)(read-language_0 in13_0 unsafe-undefined)))))"
" (define-values (read-language-fail-thunk) (lambda () (begin (error \"fail\"))))"
"(define-values"
"(declare-primitive-module!)"
"(lambda(name_0 inst_0 in-ns_0 protected_0 cross-phase-persistent?_0)"
"(begin"
"(let-values(((mpi_0)(module-path-index-join*(list 'quote name_0) #f)))"
"(let-values(((in-ns1_0) in-ns_0)"
"((temp2_0)"
"(let-values(((temp4_0)(1/current-module-declare-source))"
"((cross-phase-persistent?5_0) cross-phase-persistent?_0)"
"((temp6_0)(zero?(hash-count protected_0)))"
"((mpi7_0) mpi_0)"
"((temp8_0)"
"(hasheqv"
" 0"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((lst_0)(1/instance-variable-names inst_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((binding_0)"
"(let-values(((mpi10_0)"
" mpi_0)"
"((temp11_0)"
" 0)"
"((sym12_0)"
" sym_0))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" mpi10_0"
" temp11_0"
" sym12_0))))"
"(values"
" sym_0"
"(if(hash-ref"
" protected_0"
" sym_0"
" #f)"
"(provided1.1"
" binding_0"
" #t"
" #f)"
" binding_0))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2 rest_0)"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0))))))"
"((temp9_0)"
"(lambda(data-box_0"
" ns_0"
" phase-shift_0"
" phase-level_0"
" self_0"
" bulk-binding-registry_0"
" insp_0)"
"(if(= 0 phase-level_0)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)(1/instance-variable-names inst_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((val_0)"
"(1/instance-variable-value"
" inst_0"
" sym_0)))"
"(namespace-set-variable!"
" ns_0"
" 0"
" sym_0"
" val_0)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))"
"(void)))))"
"(make-module.1"
" cross-phase-persistent?5_0"
" #f"
" void"
" unsafe-undefined"
" unsafe-undefined"
" temp9_0"
" #f"
" 0"
" 0"
" temp6_0"
" unsafe-undefined"
" #f"
" void"
" #f"
" temp8_0"
" 'racket"
" unsafe-undefined"
" null"
" mpi7_0"
" temp4_0"
" null"
" #f)))"
"((temp3_0)(substitute-module-declare-name name_0)))"
"(declare-module!.1 #t in-ns1_0 temp2_0 temp3_0))))))"
"(define-values"
"(1/prop:exn:missing-module 1/exn:missing-module? 1/exn:missing-module-accessor)"
"(make-struct-type-property"
" 'missing-module"
"(lambda(v_0 info_0)"
"(begin"
"(if(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)"
"(void)"
"         (let-values () (raise-argument-error 'guard-for-prop:exn:missing-module \"(procedure-arity-includes/c 1)\" v_0)))"
" v_0))))"
"(define-values"
"(1/struct:exn:fail:filesystem:missing-module"
" 1/make-exn:fail:filesystem:missing-module"
" 1/exn:fail:filesystem:missing-module?"
" 1/exn:fail:filesystem:missing-module-path)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'exn:fail:filesystem:missing-module"
" struct:exn:fail:filesystem"
" 1"
" 0"
" #f"
"(list"
"(cons 1/prop:exn:missing-module(lambda(e_0)(1/exn:fail:filesystem:missing-module-path e_0))))"
" #f"
" #f"
" '(0)"
" #f"
" 'exn:fail:filesystem:missing-module)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'path))))"
"(define-values"
"(1/struct:exn:fail:syntax:missing-module"
" 1/make-exn:fail:syntax:missing-module"
" 1/exn:fail:syntax:missing-module?"
" 1/exn:fail:syntax:missing-module-path)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'exn:fail:syntax:missing-module"
" 1/struct:exn:fail:syntax"
" 1"
" 0"
" #f"
"(list(cons 1/prop:exn:missing-module(lambda(e_0)(1/exn:fail:syntax:missing-module-path e_0))))"
" #f"
" #f"
" '(0)"
" #f"
" 'exn:fail:syntax:missing-module)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'path))))"
"(define-values"
"(1/current-module-path-for-load)"
"(make-parameter"
" #f"
"(lambda(v_0)"
"(begin"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/module-path? v_0)))"
"(if or-part_1 or-part_1(if(syntax?$1 v_0)(1/module-path?(syntax->datum$1 v_0)) #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'current-module-path-for-load"
"(string-append"
"             \"(or/c module-path?\""
"             \" (and/c syntax? (lambda (stx) (module-path? (syntax->datum stx))))\""
"             \" #f)\")"
" v_0)))"
" v_0))"
" 'current-module-path-for-load))"
"(define-values"
"(maybe-raise-missing-module)"
"(lambda(name_0 filename_0 pre_0 rel_0 post_0 errstr_0)"
"(begin"
"(let-values(((path_0)(1/current-module-path-for-load)))"
"(if path_0"
"(let-values()"
"(begin"
"(if(syntax?$1 path_0)"
"(let-values()"
"(raise"
"(1/make-exn:fail:syntax:missing-module"
"(format"
"(string-append"
"                      \"~a: cannot open module file\\n\""
"                      \"  module path: ~a\\n\""
"                      \"  path: ~a~a~a~a\\n\""
"                      \"  system error: ~a\")"
"(if(syntax-srcloc$1 path_0)(srcloc->string(syntax-srcloc$1 path_0)) name_0)"
"((error-module-path->string-handler)(syntax->datum$1 path_0)(error-print-width))"
" filename_0"
" pre_0"
" rel_0"
" post_0"
" errstr_0)"
"(current-continuation-marks)"
"(list path_0)"
"(syntax->datum$1 path_0))))"
"(void))"
"(raise"
"(1/make-exn:fail:filesystem:missing-module"
"(error-message->adjusted-string"
"(if(string? name_0)(string->symbol name_0) name_0)"
" 'racket/primitive"
"(format"
"(string-append"
"                   \"cannot open module file\\n\""
"                   \"  module path: ~a\\n\""
"                   \"  path: ~a~a~a~a\\n\""
"                   \"  system error: ~a\")"
"((error-module-path->string-handler) path_0(error-print-width))"
" filename_0"
" pre_0"
" rel_0"
" post_0"
" errstr_0)"
" 'racket/primitive)"
"(current-continuation-marks)"
" path_0))))"
"(void))))))"
"(define-values"
"(1/local-expand)"
"(let-values(((local-expand_0)"
"(lambda(s2_0 context3_0 stop-ids4_0 intdefs1_0)"
"(begin"
" 'local-expand"
"(let-values(((s_0) s2_0))"
"(let-values(((context_0) context3_0))"
"(let-values(((stop-ids_0) stop-ids4_0))"
"(let-values(((intdefs_0) intdefs1_0))"
"(let-values()"
"(let-values(((temp41_0) 'local-expand)"
"((s42_0) s_0)"
"((context43_0) context_0)"
"((stop-ids44_0) stop-ids_0)"
"((intdefs45_0) intdefs_0))"
"(do-local-expand.1"
" #f"
" #f"
" #t"
" unsafe-undefined"
" #f"
" #f"
" #f"
" temp41_0"
" s42_0"
" context43_0"
" stop-ids44_0"
" intdefs45_0)))))))))))"
"(case-lambda"
"((s_0 context_0 stop-ids_0)(begin 'local-expand(local-expand_0 s_0 context_0 stop-ids_0 #f)))"
"((s_0 context_0 stop-ids_0 intdefs1_0)(local-expand_0 s_0 context_0 stop-ids_0 intdefs1_0)))))"
"(define-values"
"(1/local-expand/capture-lifts)"
"(let-values(((local-expand/capture-lifts_0)"
"(lambda(s7_0 context8_0 stop-ids9_0 intdefs5_0 lift-key6_0)"
"(begin"
" 'local-expand/capture-lifts"
"(let-values(((s_0) s7_0))"
"(let-values(((context_0) context8_0))"
"(let-values(((stop-ids_0) stop-ids9_0))"
"(let-values(((intdefs_0) intdefs5_0))"
"(let-values(((lift-key_0)"
"(if(eq? lift-key6_0 unsafe-undefined)(generate-lift-key) lift-key6_0)))"
"(let-values()"
"(let-values(((temp46_0) 'local-expand)"
"((s47_0) s_0)"
"((context48_0) context_0)"
"((stop-ids49_0) stop-ids_0)"
"((intdefs50_0) intdefs_0)"
"((temp51_0) #t)"
"((lift-key52_0) lift-key_0))"
"(do-local-expand.1"
" #f"
" temp51_0"
" #t"
" lift-key52_0"
" #f"
" #f"
" #f"
" temp46_0"
" s47_0"
" context48_0"
" stop-ids49_0"
" intdefs50_0))))))))))))"
"(case-lambda"
"((s_0 context_0 stop-ids_0)"
"(begin 'local-expand/capture-lifts(local-expand/capture-lifts_0 s_0 context_0 stop-ids_0 #f unsafe-undefined)))"
"((s_0 context_0 stop-ids_0 intdefs_0 lift-key6_0)"
"(local-expand/capture-lifts_0 s_0 context_0 stop-ids_0 intdefs_0 lift-key6_0))"
"((s_0 context_0 stop-ids_0 intdefs5_0)"
"(local-expand/capture-lifts_0 s_0 context_0 stop-ids_0 intdefs5_0 unsafe-undefined)))))"
"(define-values"
"(1/local-transformer-expand)"
"(let-values(((local-transformer-expand_0)"
"(lambda(s11_0 context12_0 stop-ids13_0 intdefs10_0)"
"(begin"
" 'local-transformer-expand"
"(let-values(((s_0) s11_0))"
"(let-values(((context_0) context12_0))"
"(let-values(((stop-ids_0) stop-ids13_0))"
"(let-values(((intdefs_0) intdefs10_0))"
"(let-values()"
"(let-values(((temp53_0) 'local-expand)"
"((s54_0) s_0)"
"((context55_0) context_0)"
"((stop-ids56_0) stop-ids_0)"
"((intdefs57_0) intdefs_0)"
"((temp58_0) #t))"
"(do-local-expand.1"
" temp58_0"
" #f"
" #t"
" unsafe-undefined"
" #f"
" #f"
" #f"
" temp53_0"
" s54_0"
" context55_0"
" stop-ids56_0"
" intdefs57_0)))))))))))"
"(case-lambda"
"((s_0 context_0 stop-ids_0)"
"(begin 'local-transformer-expand(local-transformer-expand_0 s_0 context_0 stop-ids_0 #f)))"
"((s_0 context_0 stop-ids_0 intdefs10_0)(local-transformer-expand_0 s_0 context_0 stop-ids_0 intdefs10_0)))))"
"(define-values"
"(1/local-transformer-expand/capture-lifts)"
"(let-values(((local-transformer-expand/capture-lifts_0)"
"(lambda(s16_0 context17_0 stop-ids18_0 intdefs14_0 lift-key15_0)"
"(begin"
" 'local-transformer-expand/capture-lifts"
"(let-values(((s_0) s16_0))"
"(let-values(((context_0) context17_0))"
"(let-values(((stop-ids_0) stop-ids18_0))"
"(let-values(((intdefs_0) intdefs14_0))"
"(let-values(((lift-key_0)"
"(if(eq? lift-key15_0 unsafe-undefined)(generate-lift-key) lift-key15_0)))"
"(let-values()"
"(let-values(((temp59_0) 'local-expand)"
"((s60_0) s_0)"
"((context61_0) context_0)"
"((stop-ids62_0) stop-ids_0)"
"((intdefs63_0) intdefs_0)"
"((temp64_0) #t)"
"((temp65_0) #t)"
"((lift-key66_0) lift-key_0))"
"(do-local-expand.1"
" temp64_0"
" temp65_0"
" #t"
" lift-key66_0"
" #f"
" #f"
" #f"
" temp59_0"
" s60_0"
" context61_0"
" stop-ids62_0"
" intdefs63_0))))))))))))"
"(case-lambda"
"((s_0 context_0 stop-ids_0)"
"(begin"
" 'local-transformer-expand/capture-lifts"
"(local-transformer-expand/capture-lifts_0 s_0 context_0 stop-ids_0 #f unsafe-undefined)))"
"((s_0 context_0 stop-ids_0 intdefs_0 lift-key15_0)"
"(local-transformer-expand/capture-lifts_0 s_0 context_0 stop-ids_0 intdefs_0 lift-key15_0))"
"((s_0 context_0 stop-ids_0 intdefs14_0)"
"(local-transformer-expand/capture-lifts_0 s_0 context_0 stop-ids_0 intdefs14_0 unsafe-undefined)))))"
"(define-values"
"(1/syntax-local-expand-expression)"
"(let-values(((syntax-local-expand-expression_0)"
"(lambda(s20_0 opaque-only?19_0)"
"(begin"
" 'syntax-local-expand-expression"
"(let-values(((s_0) s20_0))"
"(let-values(((opaque-only?_0) opaque-only?19_0))"
"(let-values()"
"(let-values(((exp-s_0)"
"(let-values(((temp67_0) 'syntax-local-expand-expression)"
"((s68_0) s_0)"
"((temp69_0) 'expression)"
"((null70_0) null)"
"((temp71_0) #f)"
"((opaque-only?72_0) opaque-only?_0)"
"((temp73_0) #t)"
"((temp74_0) #t)"
"((temp75_0) #f))"
"(do-local-expand.1"
" #f"
" #f"
" temp75_0"
" unsafe-undefined"
" temp73_0"
" opaque-only?72_0"
" temp74_0"
" temp67_0"
" s68_0"
" temp69_0"
" null70_0"
" temp71_0))))"
"(let-values(((ctx_0)(let-values()(get-current-expand-context.1 #f 'unexpected))))"
"(let-values(((ae_0)"
"(flip-introduction-scopes"
"(datum->syntax$1"
" #f"
"(already-expanded1.1"
"(if(parsed? exp-s_0) exp-s_0(flip-introduction-scopes exp-s_0 ctx_0))"
"(expand-context-binding-layer ctx_0)))"
" ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'opaque-expr ae_0)))"
"(void)))"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'exit-local exp-s_0)))"
"(void)))"
"(values(if(not opaque-only?_0) exp-s_0 #f) ae_0))))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-local-expand-expression(syntax-local-expand-expression_0 s_0 #f)))"
"((s_0 opaque-only?19_0)(syntax-local-expand-expression_0 s_0 opaque-only?19_0)))))"
"(define-values"
"(do-local-expand.1)"
"(lambda(as-transformer?22_0"
" capture-lifts?21_0"
" keep-#%expression?24_0"
" lift-key25_0"
" skip-log-exit?27_0"
" to-parsed-ok?23_0"
" track-to-be-defined?26_0"
" who36_0"
" s-or-s-exp37_0"
" context38_0"
" stop-ids39_0"
" intdefs35_0)"
"(begin"
" 'do-local-expand"
"(let-values(((who_0) who36_0))"
"(let-values(((s-or-s-exp_0) s-or-s-exp37_0))"
"(let-values(((context_0) context38_0))"
"(let-values(((stop-ids_0) stop-ids39_0))"
"(let-values(((intdefs_0) intdefs35_0))"
"(let-values(((capture-lifts?_0) capture-lifts?21_0))"
"(let-values(((as-transformer?_0) as-transformer?22_0))"
"(let-values(((to-parsed-ok?_0) to-parsed-ok?23_0))"
"(let-values(((keep-#%expression?_0) keep-#%expression?24_0))"
"(let-values(((lift-key_0)"
"(if(eq? lift-key25_0 unsafe-undefined)"
"(if(let-values(((or-part_0) capture-lifts?_0))"
"(if or-part_0 or-part_0 as-transformer?_0))"
"(generate-lift-key)"
" #f)"
" lift-key25_0)))"
"(let-values(((track-to-be-defined?_0) track-to-be-defined?26_0))"
"(let-values(((skip-log-exit?_0) skip-log-exit?27_0))"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'expand 'local-expand))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((s_0)(datum->syntax$1 #f s-or-s-exp_0)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(list? context_0)))"
"(if or-part_0"
" or-part_0"
"(memq"
" context_0"
"(if as-transformer?_0"
" '(expression top-level)"
" '(expression top-level module module-begin)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"(if as-transformer?_0"
"                                                               \"(or/c 'expression 'top-level list?)\""
"                                                               \"(or/c 'expression 'top-level 'module 'module-begin list?)\")"
" context_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not stop-ids_0)))"
"(if or-part_0"
" or-part_0"
"(if(list? stop-ids_0)"
"(andmap2 identifier? stop-ids_0)"
" #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                               \"(or/c (listof identifier?) #f)\""
" stop-ids_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(intdefs-or-false? intdefs_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
" intdefs-or-false?-string"
" intdefs_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((who76_0) who_0))"
"(get-current-expand-context.1 #f who76_0))))"
"(let-values(((phase_0)"
"(if as-transformer?_0"
"(add1(expand-context-phase ctx_0))"
"(expand-context-phase ctx_0))))"
"(let-values(((local-ctx_0)"
"(let-values(((ctx77_0) ctx_0)"
"((context78_0) context_0)"
"((phase79_0) phase_0)"
"((intdefs80_0) intdefs_0)"
"((stop-ids81_0) stop-ids_0)"
"((to-parsed-ok?82_0) to-parsed-ok?_0)"
"((temp83_0)"
"(let-values(((or-part_0)"
" keep-#%expression?_0))"
"(if or-part_0"
" or-part_0"
"(if(expand-context-in-local-expand?"
" ctx_0)"
"(expand-context-keep-#%expression?"
" ctx_0)"
" #f))))"
"((track-to-be-defined?84_0)"
" track-to-be-defined?_0))"
"(make-local-expand-context.1"
" context78_0"
" #t"
" intdefs80_0"
" temp83_0"
" phase79_0"
" stop-ids81_0"
" to-parsed-ok?82_0"
" track-to-be-defined?84_0"
" ctx77_0))))"
"(let-values((()"
"(begin"
"(with-continuation-mark"
" current-expand-context"
" #f"
"(let-values()"
"(if(expand-context-skip-visit-available? ctx_0)"
"(void)"
"(let-values()"
"(namespace-visit-available-modules!"
"(expand-context-namespace ctx_0)"
" phase_0)))))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-local"
" s_0)))"
"(void)))"
"(values))))"
"(let-values(((input-s_0)"
"(let-values(((temp85_0)"
"(flip-introduction-scopes"
" s_0"
" ctx_0))"
"((intdefs86_0) intdefs_0))"
"(add-intdef-scopes.1"
" unsafe-undefined"
" #f"
" temp85_0"
" intdefs86_0))))"
"(let-values((()"
"(begin"
"(if as-transformer?_0"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'phase-up)))"
"(void))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-pre"
" input-s_0)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if stop-ids_0"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'start)))"
"(void))))"
"(void))"
"(values))))"
"(let-values(((output-s_0)"
"(with-continuation-mark"
" current-expand-context"
" #f"
"(let-values()"
"(if(if as-transformer?_0"
" capture-lifts?_0"
" #f)"
"(let-values()"
"(let-values(((input-s87_0)"
" input-s_0)"
"((local-ctx88_0)"
" local-ctx_0)"
"((context89_0)"
" context_0)"
"((temp90_0) #f)"
"((temp91_0) #t)"
"((lift-key92_0)"
" lift-key_0)"
"((temp93_0) #t)"
"((temp94_0) #t))"
"(expand-transformer.1"
" temp93_0"
" temp91_0"
" context89_0"
" temp90_0"
" temp94_0"
" lift-key92_0"
" input-s87_0"
" local-ctx88_0)))"
"(if as-transformer?_0"
"(let-values()"
"(let-values(((input-s95_0)"
" input-s_0)"
"((local-ctx96_0)"
" local-ctx_0)"
"((context97_0)"
" context_0)"
"((temp98_0) #f)"
"((temp99_0)"
"(eq?"
" 'top-level"
" context_0))"
"((lift-key100_0)"
" lift-key_0)"
"((temp101_0) #t))"
"(expand-transformer.1"
" #f"
" temp99_0"
" context97_0"
" temp98_0"
" temp101_0"
" lift-key100_0"
" input-s95_0"
" local-ctx96_0)))"
"(if capture-lifts?_0"
"(let-values()"
"(let-values(((input-s102_0)"
" input-s_0)"
"((local-ctx103_0)"
" local-ctx_0)"
"((temp104_0) #t)"
"((lift-key105_0)"
" lift-key_0)"
"((temp106_0) #t))"
"(expand/capture-lifts.1"
" temp106_0"
" temp104_0"
" #f"
" lift-key105_0"
" input-s102_0"
" local-ctx103_0)))"
"(let-values()"
"(let-values(((input-s107_0)"
" input-s_0)"
"((local-ctx108_0)"
" local-ctx_0))"
"(expand.1"
" #f"
" #f"
" input-s107_0"
" local-ctx108_0))))))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-post"
" output-s_0)))"
"(void)))"
"(values))))"
"(let-values(((result-s_0)"
"(if(parsed? output-s_0)"
" output-s_0"
"(flip-introduction-scopes"
" output-s_0"
" ctx_0))))"
"(begin"
"(if skip-log-exit?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-local"
" result-s_0)))"
"(void)))))"
" result-s_0))))))))))))))))))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))))))))))))))))"
"(define-values"
"(transform-syntax-vals)"
"(lambda(f_0 vs_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) vs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((v_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(syntax?$1 v_0)(f_0 v_0) v_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(define-values"
"(1/syntax-local-apply-transformer)"
"(lambda(transformer_0 binding-id_0 context_0 intdef-ctx_0 . args_0)"
"(begin"
" 'syntax-local-apply-transformer"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(procedure? transformer_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'syntax-local-apply-transformer \"procedure?\" transformer_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(binding-id_1)"
"(let-values(((or-part_0)(identifier? binding-id_1)))"
"(if or-part_0 or-part_0(eq? binding-id_1 #f))))"
" binding-id_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-apply-transformer"
"                                 \"(or/c identifier? #f)\""
" binding-id_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(context_1)"
"(let-values(((or-part_0)(list? context_1)))"
"(if or-part_0"
" or-part_0"
"(memq context_1 '(expression top-level module module-begin)))))"
" context_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-apply-transformer"
"                                   \"(or/c 'expression 'top-level 'module 'module-begin list?)\""
" context_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(intdef-ctx_1)"
"(let-values(((or-part_0)(not intdef-ctx_1)))"
"(if or-part_0 or-part_0(1/internal-definition-context? intdef-ctx_1))))"
" intdef-ctx_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-apply-transformer"
"                                     \"(or/c internal-definition-context? #f)\""
" intdef-ctx_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((who2_0) 'syntax-local-apply-transformer))"
"(get-current-expand-context.1 #f who2_0))))"
"(let-values(((local-ctx_0)"
"(let-values(((ctx3_0) ctx_0)((context4_0) context_0)((intdef-ctx5_0) intdef-ctx_0))"
"(make-local-expand-context.1"
" context4_0"
" #t"
" intdef-ctx5_0"
" #t"
" unsafe-undefined"
" #f"
" #f"
" #f"
" ctx3_0))))"
"(let-values(((scoped-args_0)"
"(transform-syntax-vals"
"(lambda(s_0)"
"(let-values(((temp6_0)(flip-introduction-scopes s_0 ctx_0))"
"((intdef-ctx7_0) intdef-ctx_0))"
"(add-intdef-scopes.1 unsafe-undefined #f temp6_0 intdef-ctx7_0)))"
" args_0)))"
"(let-values(((scoped-binding-id_0)"
"(if binding-id_0(flip-introduction-scopes binding-id_0 ctx_0) #f)))"
"(let-values(((output-vals_0)"
"(with-continuation-mark"
" current-expand-context"
" #f"
"(let-values()"
"(apply-transformer"
" 'syntax-local-apply-transformer"
" transformer_0"
" scoped-binding-id_0"
" scoped-args_0"
" local-ctx_0)))))"
"(let-values(((result-vals_0)"
"(transform-syntax-vals"
"(lambda(s_0)(flip-introduction-scopes s_0 ctx_0))"
" output-vals_0)))"
"(apply values result-vals_0))))))))))))))))"
"(define-values"
"(apply-transformer)"
"(lambda(who_0 transformer_0 binding-id_0 args_0 ctx_0)"
"(begin"
"(let-values(((binding_0 insp-of-t_0)"
"(if binding-id_0"
"(let-values(((binding_0)"
"(let-values(((binding-id8_0) binding-id_0)"
"((temp9_0)(expand-context-phase ctx_0))"
"((temp10_0) 'ambiguous)"
"((temp11_0) #t))"
"(resolve+shift.1 temp10_0 #f null temp11_0 #f binding-id8_0 temp9_0))))"
"(begin"
"(if(not binding_0)"
"                            (let-values () (error who_0 \"unbound identifier: ~v\" binding-id_0))"
"(void))"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(let-values(((binding12_0) binding_0)"
"((ctx13_0) ctx_0)"
"((binding-id14_0) binding-id_0)"
"((temp15_0) #t))"
"(lookup.1 #f temp15_0 binding12_0 ctx13_0 binding-id14_0))))"
"(values binding_0 insp-of-t_0))))"
"(values #f #f))))"
"(let-values(((intro-scope_0)(new-scope 'macro)))"
"(let-values(((use-scopes_0)(maybe-create-use-site-scope ctx_0 binding_0)))"
"(let-values(((scope-arg_0)"
"(lambda(s_0)"
"(begin"
" 'scope-arg"
"(let-values(((intro-s_0)(add-scope s_0 intro-scope_0)))"
"(let-values(((use-s_0)(add-scopes intro-s_0 use-scopes_0))) use-s_0))))))"
"(let-values(((scoped-args_0)(transform-syntax-vals scope-arg_0 args_0)))"
"(let-values(((transformed-vals_0)"
"(apply-transformer-in-context"
" transformer_0"
" scoped-args_0"
" ctx_0"
" intro-scope_0"
" use-scopes_0"
" binding-id_0"
" insp-of-t_0)))"
"(let-values(((scope-res_0)"
"(lambda(s_0)"
"(begin"
" 'scope-res"
"(let-values(((result-s_0)(flip-scope s_0 intro-scope_0)))"
"(let-values(((post-s_0)(maybe-add-post-expansion result-s_0 ctx_0)))"
" post-s_0))))))"
"(let-values(((result-vals_0)(transform-syntax-vals scope-res_0 transformed-vals_0)))"
" result-vals_0)))))))))))"
"(define-values"
"(apply-transformer-in-context)"
"(lambda(transformer_0 args_0 ctx_0 intro-scope_0 use-scopes_0 binding-id_0 insp-of-t_0)"
"(begin"
"(let-values(((m-ctx_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((current-introduction-scopes16_0)(list intro-scope_0))"
"((current-use-scopes17_0) use-scopes_0)"
"((inner18_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner18_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
" current-introduction-scopes16_0"
" current-use-scopes17_0"
"(expand-context/outer-name the-struct_0)))"
"                          (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))"
"(let-values(((transformed-vals_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
"(namespace->namespace-at-phase"
"(expand-context-namespace ctx_0)"
"(add1(expand-context-phase ctx_0))))"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" m-ctx_0"
"(with-continuation-mark"
" current-module-code-inspector"
"(let-values(((a_0) insp-of-t_0)((b_0)(current-module-code-inspector)))"
"(if(eq? a_0 b_0)"
"(let-values() a_0)"
"(if(not a_0)"
"(let-values() #f)"
"(if(not b_0)"
"(let-values() #f)"
"(if(inspector-superior? a_0 b_0)"
"(let-values() b_0)"
"(if(inspector-superior? b_0 a_0)(let-values() a_0)(let-values() #f)))))))"
"(let-values()"
"(call-with-continuation-barrier"
"(lambda()(call-with-values(lambda()(apply transformer_0 args_0)) list))))))))))"
" transformed-vals_0)))))"
"(define-values"
"(1/syntax-tainted?)"
"(lambda(s_0)"
"(begin"
" 'syntax-tainted?"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-tainted? \"syntax?\" s_0)))"
"(syntax-tainted?$1 s_0)))))))"
"(define-values"
"(1/syntax-arm)"
"(let-values(((syntax-arm_0)"
"(lambda(s3_0 maybe-insp1_0 use-mode?2_0)"
"(begin"
" 'syntax-arm"
"(let-values(((s_0) s3_0))"
"(let-values(((maybe-insp_0) maybe-insp1_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'syntax-arm \"syntax?\" s_0)))"
"(if(let-values(((or-part_0)(not maybe-insp_0)))"
"(if or-part_0 or-part_0(inspector? maybe-insp_0)))"
"(void)"
"(let-values()"
"                                      (raise-argument-error 'syntax-arm \"(or/c inspector? #f)\" maybe-insp_0)))"
" s_0)))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-arm(syntax-arm_0 s_0 #f #f)))"
"((s_0 maybe-insp_0 use-mode?2_0)(syntax-arm_0 s_0 maybe-insp_0 use-mode?2_0))"
"((s_0 maybe-insp1_0)(syntax-arm_0 s_0 maybe-insp1_0 #f)))))"
"(define-values"
"(1/syntax-disarm)"
"(lambda(s_0 maybe-insp_0)"
"(begin"
" 'syntax-disarm"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-disarm \"syntax?\" s_0)))"
"(if(let-values(((or-part_0)(not maybe-insp_0)))(if or-part_0 or-part_0(inspector? maybe-insp_0)))"
"(void)"
"              (let-values () (raise-argument-error 'syntax-disarm \"(or/c inspector? #f)\" maybe-insp_0)))"
" s_0))))))"
"(define-values"
"(1/syntax-rearm)"
"(let-values(((syntax-rearm_0)"
"(lambda(s5_0 from-s6_0 use-mode?4_0)"
"(begin"
" 'syntax-rearm"
"(let-values(((s_0) s5_0))"
"(let-values(((from-s_0) from-s6_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'syntax-rearm \"syntax?\" s_0)))"
"(if(syntax?$1 from-s_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'syntax-rearm \"syntax?\" from-s_0)))"
" s_0)))))))))))"
"(case-lambda"
"((s_0 from-s_0)(begin 'syntax-rearm(syntax-rearm_0 s_0 from-s_0 #f)))"
"((s_0 from-s_0 use-mode?4_0)(syntax-rearm_0 s_0 from-s_0 use-mode?4_0)))))"
"(define-values"
"(1/syntax-taint)"
"(lambda(s_0)"
"(begin"
" 'syntax-taint"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-taint \"syntax?\" s_0)))"
"(syntax-taint$1 s_0)))))))"
"(define-values"
"(struct:serialized-syntax"
" serialized-syntax1.1"
" serialized-syntax?"
" serialized-syntax-version"
" serialized-syntax-mpis"
" serialized-syntax-base-mpi-pos"
" serialized-syntax-data"
" serialized-syntax-need-registry?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'serialized-syntax"
" #f"
" 5"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0 1 2 3 4)"
" #f"
" 'serialized-syntax)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'version)"
"(make-struct-field-accessor -ref_0 1 'mpis)"
"(make-struct-field-accessor -ref_0 2 'base-mpi-pos)"
"(make-struct-field-accessor -ref_0 3 'data)"
"(make-struct-field-accessor -ref_0 4 'need-registry?))))"
"(define-values"
"(1/syntax-serialize)"
"(let-values(((syntax-serialize_0)"
"(lambda(stx10_0"
" base-mpi2_0"
" preserve-prop-keys3_0"
" provides-namespace4_0"
" as-data?5_0"
" init-mpis6_0"
" report-mpi-shifts7_0"
" map-mpi8_0"
" map-binding-symbol9_0)"
"(begin"
" 'syntax-serialize"
"(let-values(((stx_0) stx10_0))"
"(let-values(((base-mpi_0) base-mpi2_0))"
"(let-values(((preserve-prop-keys_0) preserve-prop-keys3_0))"
"(let-values(((provides-namespace_0)"
"(if(eq? provides-namespace4_0 unsafe-undefined)"
"(1/current-namespace)"
" provides-namespace4_0)))"
"(let-values(((as-data?_0) as-data?5_0))"
"(let-values(((init-mpis_0) init-mpis6_0))"
"(let-values(((report-mpi-shifts_0) report-mpi-shifts7_0))"
"(let-values(((map-mpi_0)"
"(if(eq? map-mpi8_0 unsafe-undefined)"
"(lambda(mpi_0)(begin 'map-mpi mpi_0))"
" map-mpi8_0)))"
"(let-values(((map-binding-symbol_0)"
"(if(eq? map-binding-symbol9_0 unsafe-undefined)"
"(lambda(mpi_0 sym_0 phase_0)"
"(begin 'map-binding-symbol(values sym_0 phase_0)))"
" map-binding-symbol9_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if as-data?_0"
"(if(syntax?$1 stx_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-serialize"
"                                                                   \"syntax?\""
" stx_0)))"
"(if(vector? stx_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-serialize"
"                                                                   \"vector?\""
" stx_0))))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0"
" or-part_0"
"(1/module-path-index? x_0))))"
" base-mpi_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-serialize"
"                                                                   \"(or/c module-path-index? #f)\""
" base-mpi_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(l_0)"
"(if(list? l_0)(andmap2 symbol? l_0) #f))"
" preserve-prop-keys_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-serialize"
"                                                                     \"(listof symbol?)\""
" preserve-prop-keys_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(if(not as-data?_0)"
"(hash? provides-namespace_0)"
" #f)"
"(void)"
"(let-values()"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0"
" or-part_0"
"(1/namespace? x_0))))"
" provides-namespace_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-serialize"
"                                                                           \"(or/c namespace? #f)\""
" provides-namespace_0)))))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0) as-data?_0))"
"(if or-part_0"
" or-part_0"
"(eq?"
"(current-code-inspector)"
" initial-code-inspector)))"
"(void)"
"(let-values()"
"(error"
" 'syntax-serialize"
"                                                                         \"internal serialization disallowed by code inspector\")))"
"(values))))"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values((()"
"(begin"
"(let-values()"
"(let-values(((lst_0) init-mpis_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((init-mpi_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(add-module-path-index!/pos"
" mpis_0"
" init-mpi_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(values))))"
"(let-values()"
"(let-values(((base-mpi-pos_0)"
"(if base-mpi_0"
"(add-module-path-index!/pos"
" mpis_0"
" base-mpi_0)"
" #f)))"
"(let-values(((data_0)"
"(let-values(((stx13_0) stx_0)"
"((mpis14_0) mpis_0)"
"((as-data?15_0) as-data?_0)"
"((temp16_0)"
"(let-values(((table_0)"
"(let-values(((table_0)"
" '#hasheq()))"
" table_0)))"
"(let-values(((lst_0)"
" preserve-prop-keys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" k_0"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_2"
" rest_0)"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0)))))"
"((temp17_0)"
"(if provides-namespace_0"
"(lambda(modname_0)"
"(begin"
" 'temp17"
"(if(hash?"
" provides-namespace_0)"
"(not"
"(hash-ref"
" provides-namespace_0"
" modname_0"
" #f))"
"(not"
"(namespace->module"
" provides-namespace_0"
" modname_0)))))"
"(lambda(modname_0)"
"(begin 'temp17 #t))))"
"((map-mpi18_0) map-mpi_0)"
"((map-binding-symbol19_0)"
" map-binding-symbol_0)"
"((report-mpi-shifts20_0)"
" report-mpi-shifts_0))"
"(generate-deserialize.1"
" as-data?15_0"
" temp17_0"
" map-binding-symbol19_0"
" map-mpi18_0"
" mpis14_0"
" #f"
" temp16_0"
" report-mpi-shifts20_0"
" #t"
" stx13_0))))"
"(if as-data?_0"
"(serialized-syntax1.1"
"(version)"
"(let-values(((mpis21_0) mpis_0)((temp22_0) #t))"
"(generate-module-path-index-deserialize.1"
" temp22_0"
" mpis21_0))"
" base-mpi-pos_0"
" data_0"
"(if provides-namespace_0 #t #f))"
"(values"
" data_0"
"(module-path-index-table-mpis"
" mpis_0)))))))))))))))))))))))))))))"
"(case-lambda"
"((stx_0)"
"(begin"
" 'syntax-serialize"
"(syntax-serialize_0 stx_0 #f '() unsafe-undefined #t '() #f unsafe-undefined unsafe-undefined)))"
"((stx_0"
" base-mpi_0"
" preserve-prop-keys_0"
" provides-namespace_0"
" as-data?_0"
" init-mpis_0"
" report-mpi-shifts_0"
" map-mpi_0"
" map-binding-symbol9_0)"
"(syntax-serialize_0"
" stx_0"
" base-mpi_0"
" preserve-prop-keys_0"
" provides-namespace_0"
" as-data?_0"
" init-mpis_0"
" report-mpi-shifts_0"
" map-mpi_0"
" map-binding-symbol9_0))"
"((stx_0 base-mpi_0 preserve-prop-keys_0 provides-namespace_0 as-data?_0 init-mpis_0 report-mpi-shifts_0 map-mpi8_0)"
"(syntax-serialize_0"
" stx_0"
" base-mpi_0"
" preserve-prop-keys_0"
" provides-namespace_0"
" as-data?_0"
" init-mpis_0"
" report-mpi-shifts_0"
" map-mpi8_0"
" unsafe-undefined))"
"((stx_0 base-mpi_0 preserve-prop-keys_0 provides-namespace_0 as-data?_0 init-mpis_0 report-mpi-shifts7_0)"
"(syntax-serialize_0"
" stx_0"
" base-mpi_0"
" preserve-prop-keys_0"
" provides-namespace_0"
" as-data?_0"
" init-mpis_0"
" report-mpi-shifts7_0"
" unsafe-undefined"
" unsafe-undefined))"
"((stx_0 base-mpi_0 preserve-prop-keys_0 provides-namespace_0 as-data?_0 init-mpis6_0)"
"(syntax-serialize_0"
" stx_0"
" base-mpi_0"
" preserve-prop-keys_0"
" provides-namespace_0"
" as-data?_0"
" init-mpis6_0"
" #f"
" unsafe-undefined"
" unsafe-undefined))"
"((stx_0 base-mpi_0 preserve-prop-keys_0 provides-namespace_0 as-data?5_0)"
"(syntax-serialize_0"
" stx_0"
" base-mpi_0"
" preserve-prop-keys_0"
" provides-namespace_0"
" as-data?5_0"
" '()"
" #f"
" unsafe-undefined"
" unsafe-undefined))"
"((stx_0 base-mpi_0 preserve-prop-keys_0 provides-namespace4_0)"
"(syntax-serialize_0"
" stx_0"
" base-mpi_0"
" preserve-prop-keys_0"
" provides-namespace4_0"
" #t"
" '()"
" #f"
" unsafe-undefined"
" unsafe-undefined))"
"((stx_0 base-mpi_0 preserve-prop-keys3_0)"
"(syntax-serialize_0"
" stx_0"
" base-mpi_0"
" preserve-prop-keys3_0"
" unsafe-undefined"
" #t"
" '()"
" #f"
" unsafe-undefined"
" unsafe-undefined))"
"((stx_0 base-mpi2_0)"
"(syntax-serialize_0 stx_0 base-mpi2_0 '() unsafe-undefined #t '() #f unsafe-undefined unsafe-undefined)))))"
"(define-values"
"(1/syntax-deserialize)"
"(let-values()"
"(let-values()"
"(case-lambda"
"(()"
"(begin"
" 'syntax-deserialize"
"(let-values((()"
"(begin"
"(if(eq?(current-code-inspector) initial-code-inspector)"
"(void)"
"                            (let-values () (error 'syntax-deserialize \"deserialization disallowed by code inspector\")))"
"(values))))"
"(let-values(((bulk-binding-registry_0)(make-bulk-binding-registry)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(mod-name_0)"
"(begin"
" 'loop"
"(let-values(((m_0)(namespace->module(1/current-namespace) mod-name_0)))"
"(begin"
"(register-bulk-provide!"
" bulk-binding-registry_0"
" mod-name_0"
"(module-self m_0)"
"(module-provides m_0))"
"(let-values()"
"(let-values(((lst_0)(module-requires m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase+requires_0)"
"(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values(((lst_2)"
"(cdr"
" phase+requires_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((req_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
"(1/module-path-index-resolve"
" req_0)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))))"
" loop_0)"
"(1/make-resolved-module-path '#%builtin))"
"(values"
" deserialize-instance"
" bulk-binding-registry_0"
" register-bulk-provide!"
" syntax-shift-module-path-index))))))"
"((data_0)(1/syntax-deserialize data_0 #f))"
"((data_0 base-mpi_0)"
"(let-values((()"
"(begin"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(1/module-path-index? x_0))))"
" base-mpi_0)"
"(void)"
"(let-values()"
"                            (raise-argument-error 'syntax-deserialize \"(or/c module-path-index? #f)\" base-mpi_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(serialized-syntax? data_0)"
"(void)"
"(let-values()"
"                              (raise-arguments-error 'syntax-deserialize \"invalid serialized form\" \"value\" data_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(equal?(version)(serialized-syntax-version data_0))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-deserialize"
"                                 \"version mismatch\""
"                                 \"expected\""
"(version)"
"                                 \"found\""
"(serialized-syntax-version data_0))))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?(current-code-inspector) initial-code-inspector)"
"(void)"
"(let-values()"
"                                  (error 'syntax-deserialize \"deserialization disallowed by code inspector\")))"
"(values))))"
"(let-values(((orig-mpis_0)(deserialize-module-path-index-data(serialized-syntax-mpis data_0))))"
"(let-values(((orig-base-mpi_0)"
"(if base-mpi_0"
"(let-values(((pos_0)(serialized-syntax-base-mpi-pos data_0)))"
"(if pos_0(vector-ref orig-mpis_0 pos_0) #f))"
" #f)))"
"(let-values(((shifted-mpis_0)"
"(if orig-base-mpi_0"
"(let-values(((len_0)(vector-length orig-mpis_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"                                            (1/raise-argument-error 'for/vector \"exact-nonnegative-integer?\" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((i_0)(let-values(((i_0) 0)) i_0)))"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) orig-mpis_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-vector vec_0)))"
"(values vec_0(unsafe-vector-length vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1 pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_0 len_1)"
"(let-values(((mpi_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values(((i_2)"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(module-path-index-shift"
" mpi_0"
" orig-base-mpi_0"
" base-mpi_0)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values i_2))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx= i_2 len_0))"
" mpi_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_2"
"(unsafe-fx+ 1 pos_0))"
" i_2)))"
" i_1))))))"
" for-loop_0)"
" i_0"
" 0)))))"
" v_0))))"
" orig-mpis_0)))"
"(let-values(((bulk-binding-registry_0)"
"(if(serialized-syntax-need-registry? data_0)"
"(namespace-bulk-binding-registry(1/current-namespace))"
" #f)))"
"(deserialize-data"
" shifted-mpis_0"
" #f"
" bulk-binding-registry_0"
"(serialized-syntax-data data_0)))))))))))))))"
"(define-values"
"(syntax-shift-module-path-index)"
"(lambda(stx_0 from-mpi_0 to-mpi_0)"
"(begin"
"(let-values(((stx24_0) stx_0)((from-mpi25_0) from-mpi_0)((to-mpi26_0) to-mpi_0))"
"(syntax-module-path-index-shift.1 #f stx24_0 from-mpi25_0 to-mpi26_0 #f)))))"
"(define-values"
"(1/variable-reference->empty-namespace)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->empty-namespace"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"              (let-values () (raise-argument-error 'variable-reference->empty-namespace \"variable-reference?\" vr_0)))"
"(let-values(((temp2_0)(1/variable-reference->namespace vr_0)))"
"(new-namespace.1 #t unsafe-undefined temp2_0))))))))"
"(define-values"
"(1/variable-reference->namespace)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->namespace"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'variable-reference->namespace \"variable-reference?\" vr_0)))"
"(values))))"
"(let-values(((ns_0)(variable-reference->namespace* vr_0)))"
"(let-values(((mpi_0)(namespace-mpi ns_0)))"
"(begin"
"(if(non-self-module-path-index? mpi_0)"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" ns_0)"
"(let-values()"
"(let-values(((ns4_0) ns_0)((mpi5_0) mpi_0)((temp6_0)(namespace-0-phase ns_0)))"
"(namespace-module-make-available!.1 #f unsafe-undefined ns4_0 mpi5_0 temp6_0)))))"
"(void))"
" ns_0)))))))))"
"(define-values"
"(variable-reference->namespace*)"
"(lambda(vr_0)"
"(begin"
"(let-values(((inst_0)(1/variable-reference->instance vr_0)))"
"(if(symbol? inst_0)"
"(let-values()"
"(1/module->namespace(list 'quote inst_0)(1/instance-data(1/variable-reference->instance vr_0 #t))))"
"(if(not inst_0)"
"(let-values()(1/instance-data(1/variable-reference->instance vr_0 #t)))"
"(let-values()(1/instance-data inst_0))))))))"
"(define-values"
"(1/variable-reference->module-path-index)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->module-path-index"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'variable-reference->module-path-index \"variable-reference?\" vr_0)))"
"(values))))"
"(let-values(((mpi_0)(namespace-mpi(variable-reference->namespace* vr_0))))"
"(if(top-level-module-path-index? mpi_0) #f mpi_0))))))))"
"(define-values"
"(1/variable-reference->resolved-module-path)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->resolved-module-path"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'variable-reference->resolved-module-path"
"                               \"variable-reference?\""
" vr_0)))"
"(values))))"
"(let-values(((mpi_0)(1/variable-reference->module-path-index vr_0)))"
"(if mpi_0(1/module-path-index-resolve mpi_0) #f))))))))"
"(define-values"
"(1/variable-reference->module-source)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->module-source"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'variable-reference->module-source \"variable-reference?\" vr_0)))"
"(values))))"
"(let-values(((ns_0)(variable-reference->namespace* vr_0)))(namespace-source-name ns_0))))))))"
"(define-values"
"(1/variable-reference->phase)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->phase"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"              (let-values () (raise-argument-error 'variable-reference->phase \"variable-reference?\" vr_0)))"
"(namespace-phase(variable-reference->namespace* vr_0))))))))"
"(define-values"
"(1/variable-reference->module-base-phase)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->module-base-phase"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"              (let-values () (raise-argument-error 'variable-reference->module-base-phase \"variable-reference?\" vr_0)))"
"(namespace-0-phase(variable-reference->namespace* vr_0))))))))"
"(define-values"
"(1/variable-reference->module-declaration-inspector)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->module-declaration-inspector"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"                (raise-argument-error 'variable-reference->module-declaration-inspector \"variable-reference?\" vr_0)))"
"(if(1/variable-reference->instance vr_0)"
"(let-values()"
"(raise-arguments-error"
" 'variable-reference->module-declaration-inspector"
"                 \"variable reference does not refer to an anonymous module variable\""
"                 \"variable reference\""
" vr_0))"
"(void))"
"(let-values(((or-part_0)(namespace-declaration-inspector(variable-reference->namespace* vr_0))))"
"(if or-part_0"
" or-part_0"
"(raise-arguments-error"
" 'variable-reference->module-declaration-inspector"
"                 \"given variable reference is not from a module\")))))))))"
"(define-values"
"(primitive-ids)"
"(seteq"
" 'syntax?"
" 'syntax-e"
" 'syntax->datum"
" 'datum->syntax"
" 'bound-identifier=?"
" 'free-identifier=?"
" 'free-transformer-identifier=?"
" 'free-template-identifier=?"
" 'free-label-identifier=?"
" 'identifier-binding"
" 'identifier-transformer-binding"
" 'identifier-template-binding"
" 'identifier-label-binding"
" 'identifier-binding-symbol"
" 'identifier-distinct-binding"
" 'identifier-binding-portal-syntax"
" 'identifier-prune-lexical-context"
" 'syntax-debug-info"
" 'syntax-track-origin"
" 'syntax-shift-phase-level"
" 'syntax-source-module"
" 'identifier-prune-to-source-module"
" 'syntax-bound-symbols"
" 'syntax-bound-phases"
" 'syntax-bound-interned-scope-symbols"
" 'syntax-srcloc"
" 'syntax-source"
" 'syntax-line"
" 'syntax-column"
" 'syntax-position"
" 'syntax-span"
" 'syntax->list"
" 'syntax-property"
" 'syntax-property-remove"
" 'syntax-property-preserved?"
" 'syntax-property-symbol-keys"
" 'syntax-original?"
" 'syntax-tainted?"
" 'syntax-arm"
" 'syntax-disarm"
" 'syntax-rearm"
" 'syntax-taint"
" 'syntax-binding-set"
" 'syntax-binding-set?"
" 'syntax-binding-set-extend"
" 'syntax-binding-set->syntax"
" 'syntax-serialize"
" 'syntax-deserialize"
" 'do-raise-syntax-error"
" 'raise-syntax-error"
" 'struct:exn:fail:syntax"
" 'exn:fail:syntax"
" 'make-exn:fail:syntax"
" 'exn:fail:syntax?"
" 'exn:fail:syntax-exprs"
" 'struct:exn:fail:syntax:unbound"
" 'exn:fail:syntax:unbound"
" 'make-exn:fail:syntax:unbound"
" 'exn:fail:syntax:unbound?"
" 'current-module-path-for-load"
" 'prop:exn:missing-module"
" 'exn:missing-module?"
" 'exn:missing-module-accessor"
" 'struct:exn:fail:filesystem:missing-module"
" 'exn:fail:filesystem:missing-module"
" 'make-exn:fail:filesystem:missing-module"
" 'exn:fail:filesystem:missing-module?"
" 'exn:fail:filesystem:missing-module-path"
" 'struct:exn:fail:syntax:missing-module"
" 'exn:fail:syntax:missing-module"
" 'make-exn:fail:syntax:missing-module"
" 'exn:fail:syntax:missing-module?"
" 'exn:fail:syntax:missing-module-path"
" 'syntax-transforming?"
" 'syntax-transforming-with-lifts?"
" 'syntax-transforming-module-expression?"
" 'syntax-local-transforming-module-provides?"
" 'syntax-local-compiling-module?"
" 'syntax-local-context"
" 'syntax-local-introduce"
" 'syntax-local-identifier-as-binding"
" 'syntax-local-phase-level"
" 'syntax-local-name"
" 'make-syntax-introducer"
" 'make-interned-syntax-introducer"
" 'make-syntax-delta-introducer"
" 'syntax-local-make-delta-introducer"
" 'syntax-local-value"
" 'syntax-local-value/immediate"
" 'syntax-local-lift-expression"
" 'syntax-local-lift-values-expression"
" 'syntax-local-lift-context"
" 'syntax-local-lift-module"
" 'syntax-local-lift-require"
" 'syntax-local-lift-provide"
" 'syntax-local-lift-module-end-declaration"
" 'syntax-local-module-defined-identifiers"
" 'syntax-local-module-required-identifiers"
" 'syntax-local-module-exports"
" 'syntax-local-submodules"
" 'syntax-local-module-interned-scope-symbols"
" 'syntax-local-get-shadower"
" 'syntax-local-apply-transformer"
" 'local-expand"
" 'local-expand/capture-lifts"
" 'local-transformer-expand"
" 'local-transformer-expand/capture-lifts"
" 'syntax-local-expand-expression"
" 'internal-definition-context?"
" 'syntax-local-make-definition-context"
" 'syntax-local-make-definition-context-introducer"
" 'syntax-local-bind-syntaxes"
" 'internal-definition-context-binding-identifiers"
" 'internal-definition-context-introduce"
" 'internal-definition-context-seal"
" 'identifier-remove-from-definition-context"
" 'internal-definition-context-add-scopes"
" 'internal-definition-context-splice-binding-identifier"
" 'make-set!-transformer"
" 'prop:set!-transformer"
" 'set!-transformer?"
" 'set!-transformer-procedure"
" 'rename-transformer?"
" 'prop:rename-transformer"
" 'make-rename-transformer"
" 'rename-transformer-target"
" 'portal-syntax?"
" 'make-portal-syntax"
" 'portal-syntax-content"
" 'prop:liberal-define-context"
" 'liberal-define-context?"
" 'prop:expansion-contexts"
" 'module-path?"
" 'resolved-module-path?"
" 'make-resolved-module-path"
" 'resolved-module-path-name"
" 'module-path-index?"
" 'module-path-index-resolve"
" 'module-path-index-join"
" 'module-path-index-split"
" 'module-path-index-submodule"
" 'current-module-name-resolver"
" 'current-module-declare-name"
" 'current-module-declare-source"
" 'current-namespace"
" 'namespace-module-registry"
" 'namespace?"
" 'variable-reference->empty-namespace"
" 'variable-reference->namespace"
" 'variable-reference->resolved-module-path"
" 'variable-reference->module-path-index"
" 'variable-reference->module-source"
" 'variable-reference->phase"
" 'variable-reference->module-base-phase"
" 'variable-reference->module-declaration-inspector"
" 'read-syntax"
" 'read-syntax/recursive))"
"(void"
"(begin"
"(let-values(((temp1_0) 'syntax?)((syntax?2_0) syntax?$1))(add-core-primitive!.1 #f temp1_0 syntax?2_0))"
"(let-values(((temp3_0) 'syntax-e)((syntax-e4_0) 1/syntax-e))(add-core-primitive!.1 #f temp3_0 syntax-e4_0))"
"(let-values(((temp5_0) 'syntax->datum)((syntax->datum6_0) 1/syntax->datum))"
"(add-core-primitive!.1 #f temp5_0 syntax->datum6_0))"
"(let-values(((temp7_0) 'datum->syntax)((datum->syntax8_0) 1/datum->syntax))"
"(add-core-primitive!.1 #f temp7_0 datum->syntax8_0))"
"(let-values(((temp9_0) 'bound-identifier=?)((bound-identifier=?10_0) 1/bound-identifier=?))"
"(add-core-primitive!.1 #f temp9_0 bound-identifier=?10_0))"
"(let-values(((temp11_0) 'free-identifier=?)((free-identifier=?12_0) 1/free-identifier=?))"
"(add-core-primitive!.1 #f temp11_0 free-identifier=?12_0))"
"(let-values(((temp13_0) 'free-transformer-identifier=?)"
"((free-transformer-identifier=?14_0) 1/free-transformer-identifier=?))"
"(add-core-primitive!.1 #f temp13_0 free-transformer-identifier=?14_0))"
"(let-values(((temp15_0) 'free-template-identifier=?)"
"((free-template-identifier=?16_0) 1/free-template-identifier=?))"
"(add-core-primitive!.1 #f temp15_0 free-template-identifier=?16_0))"
"(let-values(((temp17_0) 'free-label-identifier=?)((free-label-identifier=?18_0) 1/free-label-identifier=?))"
"(add-core-primitive!.1 #f temp17_0 free-label-identifier=?18_0))"
"(let-values(((temp19_0) 'identifier-binding)((identifier-binding20_0) 1/identifier-binding))"
"(add-core-primitive!.1 #f temp19_0 identifier-binding20_0))"
"(let-values(((temp21_0) 'identifier-transformer-binding)"
"((identifier-transformer-binding22_0) 1/identifier-transformer-binding))"
"(add-core-primitive!.1 #f temp21_0 identifier-transformer-binding22_0))"
"(let-values(((temp23_0) 'identifier-template-binding)"
"((identifier-template-binding24_0) 1/identifier-template-binding))"
"(add-core-primitive!.1 #f temp23_0 identifier-template-binding24_0))"
"(let-values(((temp25_0) 'identifier-label-binding)((identifier-label-binding26_0) 1/identifier-label-binding))"
"(add-core-primitive!.1 #f temp25_0 identifier-label-binding26_0))"
"(let-values(((temp27_0) 'identifier-binding-symbol)((identifier-binding-symbol28_0) 1/identifier-binding-symbol))"
"(add-core-primitive!.1 #f temp27_0 identifier-binding-symbol28_0))"
"(let-values(((temp29_0) 'identifier-distinct-binding)"
"((identifier-distinct-binding30_0) 1/identifier-distinct-binding))"
"(add-core-primitive!.1 #f temp29_0 identifier-distinct-binding30_0))"
"(let-values(((temp31_0) 'identifier-binding-portal-syntax)"
"((identifier-binding-portal-syntax32_0) 1/identifier-binding-portal-syntax)"
"((temp33_0) #t))"
"(add-core-primitive!.1 temp33_0 temp31_0 identifier-binding-portal-syntax32_0))"
"(let-values(((temp34_0) 'identifier-prune-lexical-context)"
"((identifier-prune-lexical-context35_0) 1/identifier-prune-lexical-context))"
"(add-core-primitive!.1 #f temp34_0 identifier-prune-lexical-context35_0))"
"(let-values(((temp36_0) 'syntax-debug-info)((syntax-debug-info37_0) 1/syntax-debug-info))"
"(add-core-primitive!.1 #f temp36_0 syntax-debug-info37_0))"
"(let-values(((temp38_0) 'syntax-track-origin)((syntax-track-origin39_0) 1/syntax-track-origin))"
"(add-core-primitive!.1 #f temp38_0 syntax-track-origin39_0))"
"(let-values(((temp40_0) 'syntax-shift-phase-level)((syntax-shift-phase-level41_0) 1/syntax-shift-phase-level))"
"(add-core-primitive!.1 #f temp40_0 syntax-shift-phase-level41_0))"
"(let-values(((temp42_0) 'syntax-source-module)((syntax-source-module43_0) 1/syntax-source-module))"
"(add-core-primitive!.1 #f temp42_0 syntax-source-module43_0))"
"(let-values(((temp44_0) 'identifier-prune-to-source-module)"
"((identifier-prune-to-source-module45_0) 1/identifier-prune-to-source-module))"
"(add-core-primitive!.1 #f temp44_0 identifier-prune-to-source-module45_0))"
"(let-values(((temp46_0) 'syntax-bound-symbols)((syntax-bound-symbols47_0) 1/syntax-bound-symbols))"
"(add-core-primitive!.1 #f temp46_0 syntax-bound-symbols47_0))"
"(let-values(((temp48_0) 'syntax-bound-phases)((syntax-bound-phases49_0) 1/syntax-bound-phases))"
"(add-core-primitive!.1 #f temp48_0 syntax-bound-phases49_0))"
"(let-values(((temp50_0) 'syntax-bound-interned-scope-symbols)"
"((syntax-bound-interned-scope-symbols51_0) 1/syntax-bound-interned-scope-symbols))"
"(add-core-primitive!.1 #f temp50_0 syntax-bound-interned-scope-symbols51_0))"
"(let-values(((temp52_0) 'syntax-srcloc)((syntax-srcloc53_0) 1/syntax-srcloc))"
"(add-core-primitive!.1 #f temp52_0 syntax-srcloc53_0))"
"(let-values(((temp54_0) 'syntax-source)((syntax-source55_0) 1/syntax-source))"
"(add-core-primitive!.1 #f temp54_0 syntax-source55_0))"
"(let-values(((temp56_0) 'syntax-line)((syntax-line57_0) 1/syntax-line))"
"(add-core-primitive!.1 #f temp56_0 syntax-line57_0))"
"(let-values(((temp58_0) 'syntax-column)((syntax-column59_0) 1/syntax-column))"
"(add-core-primitive!.1 #f temp58_0 syntax-column59_0))"
"(let-values(((temp60_0) 'syntax-position)((syntax-position61_0) 1/syntax-position))"
"(add-core-primitive!.1 #f temp60_0 syntax-position61_0))"
"(let-values(((temp62_0) 'syntax-span)((syntax-span63_0) 1/syntax-span))"
"(add-core-primitive!.1 #f temp62_0 syntax-span63_0))"
"(let-values(((temp64_0) 'syntax->list)((syntax->list65_0) 1/syntax->list))"
"(add-core-primitive!.1 #f temp64_0 syntax->list65_0))"
"(let-values(((temp66_0) 'syntax-property)((syntax-property67_0) syntax-property$1))"
"(add-core-primitive!.1 #f temp66_0 syntax-property67_0))"
"(let-values(((temp68_0) 'syntax-property-remove)((syntax-property-remove69_0) 1/syntax-property-remove))"
"(add-core-primitive!.1 #f temp68_0 syntax-property-remove69_0))"
"(let-values(((temp70_0) 'syntax-property-preserved?)"
"((syntax-property-preserved?71_0) 1/syntax-property-preserved?))"
"(add-core-primitive!.1 #f temp70_0 syntax-property-preserved?71_0))"
"(let-values(((temp72_0) 'syntax-property-symbol-keys)"
"((syntax-property-symbol-keys73_0) 1/syntax-property-symbol-keys))"
"(add-core-primitive!.1 #f temp72_0 syntax-property-symbol-keys73_0))"
"(let-values(((temp74_0) 'syntax-original?)((syntax-original?75_0) 1/syntax-original?))"
"(add-core-primitive!.1 #f temp74_0 syntax-original?75_0))"
"(let-values(((temp76_0) 'syntax-tainted?)((syntax-tainted?77_0) 1/syntax-tainted?))"
"(add-core-primitive!.1 #f temp76_0 syntax-tainted?77_0))"
"(let-values(((temp78_0) 'syntax-arm)((syntax-arm79_0) 1/syntax-arm))"
"(add-core-primitive!.1 #f temp78_0 syntax-arm79_0))"
"(let-values(((temp80_0) 'syntax-disarm)((syntax-disarm81_0) 1/syntax-disarm))"
"(add-core-primitive!.1 #f temp80_0 syntax-disarm81_0))"
"(let-values(((temp82_0) 'syntax-rearm)((syntax-rearm83_0) 1/syntax-rearm))"
"(add-core-primitive!.1 #f temp82_0 syntax-rearm83_0))"
"(let-values(((temp84_0) 'syntax-taint)((syntax-taint85_0) 1/syntax-taint))"
"(add-core-primitive!.1 #f temp84_0 syntax-taint85_0))"
"(let-values(((temp86_0) 'syntax-binding-set)((syntax-binding-set87_0) 1/syntax-binding-set))"
"(add-core-primitive!.1 #f temp86_0 syntax-binding-set87_0))"
"(let-values(((temp88_0) 'syntax-binding-set?)((syntax-binding-set?89_0) 1/syntax-binding-set?))"
"(add-core-primitive!.1 #f temp88_0 syntax-binding-set?89_0))"
"(let-values(((temp90_0) 'syntax-binding-set-extend)((syntax-binding-set-extend91_0) 1/syntax-binding-set-extend))"
"(add-core-primitive!.1 #f temp90_0 syntax-binding-set-extend91_0))"
"(let-values(((temp92_0) 'syntax-binding-set->syntax)"
"((syntax-binding-set->syntax93_0) 1/syntax-binding-set->syntax))"
"(add-core-primitive!.1 #f temp92_0 syntax-binding-set->syntax93_0))"
"(let-values(((temp94_0) 'syntax-serialize)((syntax-serialize95_0) 1/syntax-serialize))"
"(add-core-primitive!.1 #f temp94_0 syntax-serialize95_0))"
"(let-values(((temp96_0) 'syntax-deserialize)((syntax-deserialize97_0) 1/syntax-deserialize))"
"(add-core-primitive!.1 #f temp96_0 syntax-deserialize97_0))"
"(let-values(((temp98_0) 'do-raise-syntax-error)((do-raise-syntax-error99_0) 1/do-raise-syntax-error))"
"(add-core-primitive!.1 #f temp98_0 do-raise-syntax-error99_0))"
"(let-values(((temp100_0) 'raise-syntax-error)((raise-syntax-error101_0) raise-syntax-error$1))"
"(add-core-primitive!.1 #f temp100_0 raise-syntax-error101_0))"
"(let-values(((temp102_0) 'struct:exn:fail:syntax)((struct:exn:fail:syntax103_0) 1/struct:exn:fail:syntax))"
"(add-core-primitive!.1 #f temp102_0 struct:exn:fail:syntax103_0))"
"(let-values(((temp104_0) 'exn:fail:syntax)((exn:fail:syntax105_0) make-exn:fail:syntax$1))"
"(add-core-primitive!.1 #f temp104_0 exn:fail:syntax105_0))"
"(let-values(((temp106_0) 'make-exn:fail:syntax)((make-exn:fail:syntax107_0) make-exn:fail:syntax$1))"
"(add-core-primitive!.1 #f temp106_0 make-exn:fail:syntax107_0))"
"(let-values(((temp108_0) 'exn:fail:syntax?)((exn:fail:syntax?109_0) 1/exn:fail:syntax?))"
"(add-core-primitive!.1 #f temp108_0 exn:fail:syntax?109_0))"
"(let-values(((temp110_0) 'exn:fail:syntax-exprs)((exn:fail:syntax-exprs111_0) 1/exn:fail:syntax-exprs))"
"(add-core-primitive!.1 #f temp110_0 exn:fail:syntax-exprs111_0))"
"(let-values(((temp112_0) 'struct:exn:fail:syntax:unbound)"
"((struct:exn:fail:syntax:unbound113_0) 1/struct:exn:fail:syntax:unbound))"
"(add-core-primitive!.1 #f temp112_0 struct:exn:fail:syntax:unbound113_0))"
"(let-values(((temp114_0) 'exn:fail:syntax:unbound)((exn:fail:syntax:unbound115_0) make-exn:fail:syntax:unbound$1))"
"(add-core-primitive!.1 #f temp114_0 exn:fail:syntax:unbound115_0))"
"(let-values(((temp116_0) 'make-exn:fail:syntax:unbound)"
"((make-exn:fail:syntax:unbound117_0) make-exn:fail:syntax:unbound$1))"
"(add-core-primitive!.1 #f temp116_0 make-exn:fail:syntax:unbound117_0))"
"(let-values(((temp118_0) 'exn:fail:syntax:unbound?)((exn:fail:syntax:unbound?119_0) 1/exn:fail:syntax:unbound?))"
"(add-core-primitive!.1 #f temp118_0 exn:fail:syntax:unbound?119_0))"
"(let-values(((temp120_0) 'current-module-path-for-load)"
"((current-module-path-for-load121_0) 1/current-module-path-for-load))"
"(add-core-primitive!.1 #f temp120_0 current-module-path-for-load121_0))"
"(let-values(((temp122_0) 'prop:exn:missing-module)((prop:exn:missing-module123_0) 1/prop:exn:missing-module))"
"(add-core-primitive!.1 #f temp122_0 prop:exn:missing-module123_0))"
"(let-values(((temp124_0) 'exn:missing-module?)((exn:missing-module?125_0) 1/exn:missing-module?))"
"(add-core-primitive!.1 #f temp124_0 exn:missing-module?125_0))"
"(let-values(((temp126_0) 'exn:missing-module-accessor)"
"((exn:missing-module-accessor127_0) 1/exn:missing-module-accessor))"
"(add-core-primitive!.1 #f temp126_0 exn:missing-module-accessor127_0))"
"(let-values(((temp128_0) 'struct:exn:fail:filesystem:missing-module)"
"((struct:exn:fail:filesystem:missing-module129_0) 1/struct:exn:fail:filesystem:missing-module))"
"(add-core-primitive!.1 #f temp128_0 struct:exn:fail:filesystem:missing-module129_0))"
"(let-values(((temp130_0) 'exn:fail:filesystem:missing-module)"
"((exn:fail:filesystem:missing-module131_0) 1/make-exn:fail:filesystem:missing-module))"
"(add-core-primitive!.1 #f temp130_0 exn:fail:filesystem:missing-module131_0))"
"(let-values(((temp132_0) 'make-exn:fail:filesystem:missing-module)"
"((make-exn:fail:filesystem:missing-module133_0) 1/make-exn:fail:filesystem:missing-module))"
"(add-core-primitive!.1 #f temp132_0 make-exn:fail:filesystem:missing-module133_0))"
"(let-values(((temp134_0) 'exn:fail:filesystem:missing-module?)"
"((exn:fail:filesystem:missing-module?135_0) 1/exn:fail:filesystem:missing-module?))"
"(add-core-primitive!.1 #f temp134_0 exn:fail:filesystem:missing-module?135_0))"
"(let-values(((temp136_0) 'exn:fail:filesystem:missing-module-path)"
"((exn:fail:filesystem:missing-module-path137_0) 1/exn:fail:filesystem:missing-module-path))"
"(add-core-primitive!.1 #f temp136_0 exn:fail:filesystem:missing-module-path137_0))"
"(let-values(((temp138_0) 'struct:exn:fail:syntax:missing-module)"
"((struct:exn:fail:syntax:missing-module139_0) 1/struct:exn:fail:syntax:missing-module))"
"(add-core-primitive!.1 #f temp138_0 struct:exn:fail:syntax:missing-module139_0))"
"(let-values(((temp140_0) 'exn:fail:syntax:missing-module)"
"((exn:fail:syntax:missing-module141_0) 1/make-exn:fail:syntax:missing-module))"
"(add-core-primitive!.1 #f temp140_0 exn:fail:syntax:missing-module141_0))"
"(let-values(((temp142_0) 'make-exn:fail:syntax:missing-module)"
"((make-exn:fail:syntax:missing-module143_0) 1/make-exn:fail:syntax:missing-module))"
"(add-core-primitive!.1 #f temp142_0 make-exn:fail:syntax:missing-module143_0))"
"(let-values(((temp144_0) 'exn:fail:syntax:missing-module?)"
"((exn:fail:syntax:missing-module?145_0) 1/exn:fail:syntax:missing-module?))"
"(add-core-primitive!.1 #f temp144_0 exn:fail:syntax:missing-module?145_0))"
"(let-values(((temp146_0) 'exn:fail:syntax:missing-module-path)"
"((exn:fail:syntax:missing-module-path147_0) 1/exn:fail:syntax:missing-module-path))"
"(add-core-primitive!.1 #f temp146_0 exn:fail:syntax:missing-module-path147_0))"
"(let-values(((temp148_0) 'syntax-transforming?)((syntax-transforming?149_0) 1/syntax-transforming?))"
"(add-core-primitive!.1 #f temp148_0 syntax-transforming?149_0))"
"(let-values(((temp150_0) 'syntax-transforming-with-lifts?)"
"((syntax-transforming-with-lifts?151_0) 1/syntax-transforming-with-lifts?))"
"(add-core-primitive!.1 #f temp150_0 syntax-transforming-with-lifts?151_0))"
"(let-values(((temp152_0) 'syntax-transforming-module-expression?)"
"((syntax-transforming-module-expression?153_0) 1/syntax-transforming-module-expression?))"
"(add-core-primitive!.1 #f temp152_0 syntax-transforming-module-expression?153_0))"
"(let-values(((temp154_0) 'syntax-local-transforming-module-provides?)"
"((syntax-local-transforming-module-provides?155_0) 1/syntax-local-transforming-module-provides?))"
"(add-core-primitive!.1 #f temp154_0 syntax-local-transforming-module-provides?155_0))"
"(let-values(((temp156_0) 'syntax-local-compiling-module?)"
"((syntax-local-compiling-module?157_0) 1/syntax-local-compiling-module?))"
"(add-core-primitive!.1 #f temp156_0 syntax-local-compiling-module?157_0))"
"(let-values(((temp158_0) 'syntax-local-context)((syntax-local-context159_0) 1/syntax-local-context))"
"(add-core-primitive!.1 #f temp158_0 syntax-local-context159_0))"
"(let-values(((temp160_0) 'syntax-local-introduce)((syntax-local-introduce161_0) 1/syntax-local-introduce))"
"(add-core-primitive!.1 #f temp160_0 syntax-local-introduce161_0))"
"(let-values(((temp162_0) 'syntax-local-identifier-as-binding)"
"((syntax-local-identifier-as-binding163_0) 1/syntax-local-identifier-as-binding))"
"(add-core-primitive!.1 #f temp162_0 syntax-local-identifier-as-binding163_0))"
"(let-values(((temp164_0) 'syntax-local-phase-level)((syntax-local-phase-level165_0) 1/syntax-local-phase-level))"
"(add-core-primitive!.1 #f temp164_0 syntax-local-phase-level165_0))"
"(let-values(((temp166_0) 'syntax-local-name)((syntax-local-name167_0) 1/syntax-local-name))"
"(add-core-primitive!.1 #f temp166_0 syntax-local-name167_0))"
"(let-values(((temp168_0) 'make-syntax-introducer)((make-syntax-introducer169_0) 1/make-syntax-introducer))"
"(add-core-primitive!.1 #f temp168_0 make-syntax-introducer169_0))"
"(let-values(((temp170_0) 'make-interned-syntax-introducer)"
"((make-interned-syntax-introducer171_0) 1/make-interned-syntax-introducer))"
"(add-core-primitive!.1 #f temp170_0 make-interned-syntax-introducer171_0))"
"(let-values(((temp172_0) 'make-syntax-delta-introducer)"
"((make-syntax-delta-introducer173_0) 1/make-syntax-delta-introducer))"
"(add-core-primitive!.1 #f temp172_0 make-syntax-delta-introducer173_0))"
"(let-values(((temp174_0) 'syntax-local-make-delta-introducer)"
"((syntax-local-make-delta-introducer175_0) 1/syntax-local-make-delta-introducer))"
"(add-core-primitive!.1 #f temp174_0 syntax-local-make-delta-introducer175_0))"
"(let-values(((temp176_0) 'syntax-local-value)((syntax-local-value177_0) 1/syntax-local-value)((temp178_0) #t))"
"(add-core-primitive!.1 temp178_0 temp176_0 syntax-local-value177_0))"
"(let-values(((temp179_0) 'syntax-local-value/immediate)"
"((syntax-local-value/immediate180_0) 1/syntax-local-value/immediate)"
"((temp181_0) #t))"
"(add-core-primitive!.1 temp181_0 temp179_0 syntax-local-value/immediate180_0))"
"(let-values(((temp182_0) 'syntax-local-lift-expression)"
"((syntax-local-lift-expression183_0) 1/syntax-local-lift-expression))"
"(add-core-primitive!.1 #f temp182_0 syntax-local-lift-expression183_0))"
"(let-values(((temp184_0) 'syntax-local-lift-values-expression)"
"((syntax-local-lift-values-expression185_0) 1/syntax-local-lift-values-expression))"
"(add-core-primitive!.1 #f temp184_0 syntax-local-lift-values-expression185_0))"
"(let-values(((temp186_0) 'syntax-local-lift-context)"
"((syntax-local-lift-context187_0) 1/syntax-local-lift-context))"
"(add-core-primitive!.1 #f temp186_0 syntax-local-lift-context187_0))"
"(let-values(((temp188_0) 'syntax-local-lift-module)((syntax-local-lift-module189_0) 1/syntax-local-lift-module))"
"(add-core-primitive!.1 #f temp188_0 syntax-local-lift-module189_0))"
"(let-values(((temp190_0) 'syntax-local-lift-require)"
"((syntax-local-lift-require191_0) 1/syntax-local-lift-require))"
"(add-core-primitive!.1 #f temp190_0 syntax-local-lift-require191_0))"
"(let-values(((temp192_0) 'syntax-local-lift-provide)"
"((syntax-local-lift-provide193_0) 1/syntax-local-lift-provide))"
"(add-core-primitive!.1 #f temp192_0 syntax-local-lift-provide193_0))"
"(let-values(((temp194_0) 'syntax-local-lift-module-end-declaration)"
"((syntax-local-lift-module-end-declaration195_0) 1/syntax-local-lift-module-end-declaration))"
"(add-core-primitive!.1 #f temp194_0 syntax-local-lift-module-end-declaration195_0))"
"(let-values(((temp196_0) 'syntax-local-module-defined-identifiers)"
"((syntax-local-module-defined-identifiers197_0) 1/syntax-local-module-defined-identifiers))"
"(add-core-primitive!.1 #f temp196_0 syntax-local-module-defined-identifiers197_0))"
"(let-values(((temp198_0) 'syntax-local-module-required-identifiers)"
"((syntax-local-module-required-identifiers199_0) 1/syntax-local-module-required-identifiers))"
"(add-core-primitive!.1 #f temp198_0 syntax-local-module-required-identifiers199_0))"
"(let-values(((temp200_0) 'syntax-local-module-exports)"
"((syntax-local-module-exports201_0) 1/syntax-local-module-exports))"
"(add-core-primitive!.1 #f temp200_0 syntax-local-module-exports201_0))"
"(let-values(((temp202_0) 'syntax-local-submodules)((syntax-local-submodules203_0) 1/syntax-local-submodules))"
"(add-core-primitive!.1 #f temp202_0 syntax-local-submodules203_0))"
"(let-values(((temp204_0) 'syntax-local-module-interned-scope-symbols)"
"((syntax-local-module-interned-scope-symbols205_0) 1/syntax-local-module-interned-scope-symbols))"
"(add-core-primitive!.1 #f temp204_0 syntax-local-module-interned-scope-symbols205_0))"
"(let-values(((temp206_0) 'syntax-local-get-shadower)"
"((syntax-local-get-shadower207_0) 1/syntax-local-get-shadower))"
"(add-core-primitive!.1 #f temp206_0 syntax-local-get-shadower207_0))"
"(let-values(((temp208_0) 'syntax-local-apply-transformer)"
"((syntax-local-apply-transformer209_0) 1/syntax-local-apply-transformer))"
"(add-core-primitive!.1 #f temp208_0 syntax-local-apply-transformer209_0))"
"(let-values(((temp210_0) 'local-expand)((local-expand211_0) 1/local-expand)((temp212_0) #t))"
"(add-core-primitive!.1 temp212_0 temp210_0 local-expand211_0))"
"(let-values(((temp213_0) 'local-expand/capture-lifts)"
"((local-expand/capture-lifts214_0) 1/local-expand/capture-lifts)"
"((temp215_0) #t))"
"(add-core-primitive!.1 temp215_0 temp213_0 local-expand/capture-lifts214_0))"
"(let-values(((temp216_0) 'local-transformer-expand)"
"((local-transformer-expand217_0) 1/local-transformer-expand)"
"((temp218_0) #t))"
"(add-core-primitive!.1 temp218_0 temp216_0 local-transformer-expand217_0))"
"(let-values(((temp219_0) 'local-transformer-expand/capture-lifts)"
"((local-transformer-expand/capture-lifts220_0) 1/local-transformer-expand/capture-lifts)"
"((temp221_0) #t))"
"(add-core-primitive!.1 temp221_0 temp219_0 local-transformer-expand/capture-lifts220_0))"
"(let-values(((temp222_0) 'syntax-local-expand-expression)"
"((syntax-local-expand-expression223_0) 1/syntax-local-expand-expression)"
"((temp224_0) #t))"
"(add-core-primitive!.1 temp224_0 temp222_0 syntax-local-expand-expression223_0))"
"(let-values(((temp225_0) 'internal-definition-context?)"
"((internal-definition-context?226_0) 1/internal-definition-context?))"
"(add-core-primitive!.1 #f temp225_0 internal-definition-context?226_0))"
"(let-values(((temp227_0) 'syntax-local-make-definition-context)"
"((syntax-local-make-definition-context228_0) 1/syntax-local-make-definition-context))"
"(add-core-primitive!.1 #f temp227_0 syntax-local-make-definition-context228_0))"
"(let-values(((temp229_0) 'syntax-local-make-definition-context-introducer)"
"((syntax-local-make-definition-context-introducer230_0)"
" 1/syntax-local-make-definition-context-introducer))"
"(add-core-primitive!.1 #f temp229_0 syntax-local-make-definition-context-introducer230_0))"
"(let-values(((temp231_0) 'syntax-local-bind-syntaxes)"
"((syntax-local-bind-syntaxes232_0) 1/syntax-local-bind-syntaxes))"
"(add-core-primitive!.1 #f temp231_0 syntax-local-bind-syntaxes232_0))"
"(let-values(((temp233_0) 'internal-definition-context-binding-identifiers)"
"((internal-definition-context-binding-identifiers234_0)"
" 1/internal-definition-context-binding-identifiers))"
"(add-core-primitive!.1 #f temp233_0 internal-definition-context-binding-identifiers234_0))"
"(let-values(((temp235_0) 'internal-definition-context-introduce)"
"((internal-definition-context-introduce236_0) 1/internal-definition-context-introduce))"
"(add-core-primitive!.1 #f temp235_0 internal-definition-context-introduce236_0))"
"(let-values(((temp237_0) 'internal-definition-context-seal)"
"((internal-definition-context-seal238_0) 1/internal-definition-context-seal))"
"(add-core-primitive!.1 #f temp237_0 internal-definition-context-seal238_0))"
"(let-values(((temp239_0) 'identifier-remove-from-definition-context)"
"((identifier-remove-from-definition-context240_0) 1/identifier-remove-from-definition-context))"
"(add-core-primitive!.1 #f temp239_0 identifier-remove-from-definition-context240_0))"
"(let-values(((temp241_0) 'internal-definition-context-add-scopes)"
"((internal-definition-context-add-scopes242_0) 1/internal-definition-context-add-scopes))"
"(add-core-primitive!.1 #f temp241_0 internal-definition-context-add-scopes242_0))"
"(let-values(((temp243_0) 'internal-definition-context-splice-binding-identifier)"
"((internal-definition-context-splice-binding-identifier244_0)"
" 1/internal-definition-context-splice-binding-identifier))"
"(add-core-primitive!.1 #f temp243_0 internal-definition-context-splice-binding-identifier244_0))"
"(let-values(((temp245_0) 'make-set!-transformer)((make-set!-transformer246_0) 1/make-set!-transformer))"
"(add-core-primitive!.1 #f temp245_0 make-set!-transformer246_0))"
"(let-values(((temp247_0) 'prop:set!-transformer)((prop:set!-transformer248_0) 1/prop:set!-transformer))"
"(add-core-primitive!.1 #f temp247_0 prop:set!-transformer248_0))"
"(let-values(((temp249_0) 'set!-transformer?)((set!-transformer?250_0) 1/set!-transformer?))"
"(add-core-primitive!.1 #f temp249_0 set!-transformer?250_0))"
"(let-values(((temp251_0) 'set!-transformer-procedure)"
"((set!-transformer-procedure252_0) 1/set!-transformer-procedure))"
"(add-core-primitive!.1 #f temp251_0 set!-transformer-procedure252_0))"
"(let-values(((temp253_0) 'rename-transformer?)((rename-transformer?254_0) 1/rename-transformer?))"
"(add-core-primitive!.1 #f temp253_0 rename-transformer?254_0))"
"(let-values(((temp255_0) 'prop:rename-transformer)((prop:rename-transformer256_0) 1/prop:rename-transformer))"
"(add-core-primitive!.1 #f temp255_0 prop:rename-transformer256_0))"
"(let-values(((temp257_0) 'make-rename-transformer)((make-rename-transformer258_0) 1/make-rename-transformer))"
"(add-core-primitive!.1 #f temp257_0 make-rename-transformer258_0))"
"(let-values(((temp259_0) 'rename-transformer-target)"
"((rename-transformer-target260_0) 1/rename-transformer-target))"
"(add-core-primitive!.1 #f temp259_0 rename-transformer-target260_0))"
"(let-values(((temp261_0) 'portal-syntax?)((portal-syntax?262_0) 1/portal-syntax?))"
"(add-core-primitive!.1 #f temp261_0 portal-syntax?262_0))"
"(let-values(((temp263_0) 'make-portal-syntax)((make-portal-syntax264_0) 1/make-portal-syntax))"
"(add-core-primitive!.1 #f temp263_0 make-portal-syntax264_0))"
"(let-values(((temp265_0) 'portal-syntax-content)((portal-syntax-content266_0) 1/portal-syntax-content))"
"(add-core-primitive!.1 #f temp265_0 portal-syntax-content266_0))"
"(let-values(((temp267_0) 'prop:liberal-define-context)"
"((prop:liberal-define-context268_0) 1/prop:liberal-define-context))"
"(add-core-primitive!.1 #f temp267_0 prop:liberal-define-context268_0))"
"(let-values(((temp269_0) 'liberal-define-context?)"
"((liberal-define-context?270_0) has-liberal-define-context-property?))"
"(add-core-primitive!.1 #f temp269_0 liberal-define-context?270_0))"
"(let-values(((temp271_0) 'prop:expansion-contexts)((prop:expansion-contexts272_0) 1/prop:expansion-contexts))"
"(add-core-primitive!.1 #f temp271_0 prop:expansion-contexts272_0))"
"(let-values(((temp273_0) 'module-path?)((module-path?274_0) 1/module-path?))"
"(add-core-primitive!.1 #f temp273_0 module-path?274_0))"
"(let-values(((temp275_0) 'resolved-module-path?)((resolved-module-path?276_0) 1/resolved-module-path?))"
"(add-core-primitive!.1 #f temp275_0 resolved-module-path?276_0))"
"(let-values(((temp277_0) 'make-resolved-module-path)"
"((make-resolved-module-path278_0) 1/make-resolved-module-path))"
"(add-core-primitive!.1 #f temp277_0 make-resolved-module-path278_0))"
"(let-values(((temp279_0) 'resolved-module-path-name)"
"((safe-resolved-module-path-name280_0) safe-resolved-module-path-name))"
"(add-core-primitive!.1 #f temp279_0 safe-resolved-module-path-name280_0))"
"(let-values(((temp281_0) 'module-path-index?)((module-path-index?282_0) 1/module-path-index?))"
"(add-core-primitive!.1 #f temp281_0 module-path-index?282_0))"
"(let-values(((temp283_0) 'module-path-index-resolve)"
"((module-path-index-resolve284_0) 1/module-path-index-resolve))"
"(add-core-primitive!.1 #f temp283_0 module-path-index-resolve284_0))"
"(let-values(((temp285_0) 'module-path-index-join)((module-path-index-join286_0) 1/module-path-index-join))"
"(add-core-primitive!.1 #f temp285_0 module-path-index-join286_0))"
"(let-values(((temp287_0) 'module-path-index-split)((module-path-index-split288_0) 1/module-path-index-split))"
"(add-core-primitive!.1 #f temp287_0 module-path-index-split288_0))"
"(let-values(((temp289_0) 'module-path-index-submodule)"
"((module-path-index-submodule290_0) 1/module-path-index-submodule))"
"(add-core-primitive!.1 #f temp289_0 module-path-index-submodule290_0))"
"(let-values(((temp291_0) 'current-module-name-resolver)"
"((current-module-name-resolver292_0) 1/current-module-name-resolver)"
"((temp293_0) #t))"
"(add-core-primitive!.1 temp293_0 temp291_0 current-module-name-resolver292_0))"
"(let-values(((temp294_0) 'current-module-declare-name)"
"((current-module-declare-name295_0) 1/current-module-declare-name))"
"(add-core-primitive!.1 #f temp294_0 current-module-declare-name295_0))"
"(let-values(((temp296_0) 'current-module-declare-source)"
"((current-module-declare-source297_0) 1/current-module-declare-source))"
"(add-core-primitive!.1 #f temp296_0 current-module-declare-source297_0))"
"(let-values(((temp298_0) 'current-namespace)((current-namespace299_0) 1/current-namespace))"
"(add-core-primitive!.1 #f temp298_0 current-namespace299_0))"
"(let-values(((temp300_0) 'namespace-module-registry)"
"((namespace-module-registry301_0) namespace-module-registry$1))"
"(add-core-primitive!.1 #f temp300_0 namespace-module-registry301_0))"
"(let-values(((temp302_0) 'namespace?)((namespace?303_0) 1/namespace?))"
"(add-core-primitive!.1 #f temp302_0 namespace?303_0))"
"(let-values(((temp304_0) 'variable-reference->empty-namespace)"
"((variable-reference->empty-namespace305_0) 1/variable-reference->empty-namespace))"
"(add-core-primitive!.1 #f temp304_0 variable-reference->empty-namespace305_0))"
"(let-values(((temp306_0) 'variable-reference->namespace)"
"((variable-reference->namespace307_0) 1/variable-reference->namespace))"
"(add-core-primitive!.1 #f temp306_0 variable-reference->namespace307_0))"
"(let-values(((temp308_0) 'variable-reference->resolved-module-path)"
"((variable-reference->resolved-module-path309_0) 1/variable-reference->resolved-module-path))"
"(add-core-primitive!.1 #f temp308_0 variable-reference->resolved-module-path309_0))"
"(let-values(((temp310_0) 'variable-reference->module-path-index)"
"((variable-reference->module-path-index311_0) 1/variable-reference->module-path-index))"
"(add-core-primitive!.1 #f temp310_0 variable-reference->module-path-index311_0))"
"(let-values(((temp312_0) 'variable-reference->module-source)"
"((variable-reference->module-source313_0) 1/variable-reference->module-source))"
"(add-core-primitive!.1 #f temp312_0 variable-reference->module-source313_0))"
"(let-values(((temp314_0) 'variable-reference->phase)"
"((variable-reference->phase315_0) 1/variable-reference->phase))"
"(add-core-primitive!.1 #f temp314_0 variable-reference->phase315_0))"
"(let-values(((temp316_0) 'variable-reference->module-base-phase)"
"((variable-reference->module-base-phase317_0) 1/variable-reference->module-base-phase))"
"(add-core-primitive!.1 #f temp316_0 variable-reference->module-base-phase317_0))"
"(let-values(((temp318_0) 'variable-reference->module-declaration-inspector)"
"((variable-reference->module-declaration-inspector319_0)"
" 1/variable-reference->module-declaration-inspector))"
"(add-core-primitive!.1 #f temp318_0 variable-reference->module-declaration-inspector319_0))"
"(let-values(((temp320_0) 'read-syntax)((read-syntax321_0) 1/read-syntax))"
"(add-core-primitive!.1 #f temp320_0 read-syntax321_0))"
"(let-values(((temp322_0) 'read-syntax/recursive)((read-syntax/recursive323_0) 1/read-syntax/recursive))"
"(add-core-primitive!.1 #f temp322_0 read-syntax/recursive323_0))))"
"(define-values"
"(declare-kernel-module!.1)"
"(lambda(main-ids1_0 read-ids2_0 ns5_0)"
"(begin"
" 'declare-kernel-module!"
"(let-values(((ns_0) ns5_0))"
"(let-values(((main-ids_0) main-ids1_0))"
"(let-values(((read-ids_0) read-ids2_0))"
"(let-values()"
"(begin"
"(let-values(((temp43_0) '#%kernel)"
"((temp44_0) '#%runtime)"
"((temp45_0)(set-union primitive-ids(set-union main-ids_0 read-ids_0)))"
"((temp46_0)"
"(hasheq"
" 'variable-reference?"
" 1/variable-reference?"
" 'variable-reference-constant?"
" 1/variable-reference-constant?"
" 'variable-reference-from-unsafe?"
" 1/variable-reference-from-unsafe?))"
"((ns47_0) ns_0))"
"(copy-runtime-module!.1 '#hasheq() temp46_0 ns47_0 #t #f temp45_0 temp44_0 temp43_0))"
"(let-values(((temp48_0) '#%kernel)((temp49_0) '(#%core #%runtime #%main #%read))((ns50_0) ns_0))"
"(declare-reexporting-module!.1 ns50_0 #t temp48_0 temp49_0))))))))))"
"(define-values"
"(copy-runtime-module!.1)"
"(lambda(alts10_0 extras11_0 namespace8_0 primitive?12_0 protected?13_0 skip9_0 to7_0 name21_0)"
"(begin"
" 'copy-runtime-module!"
"(let-values(((name_0) name21_0))"
"(let-values(((to-name_0)(if(eq? to7_0 unsafe-undefined) name_0 to7_0)))"
"(let-values(((ns_0) namespace8_0))"
"(let-values(((skip-syms_0)(if(eq? skip9_0 unsafe-undefined)(seteq) skip9_0)))"
"(let-values(((alts_0) alts10_0))"
"(let-values(((extras_0) extras11_0))"
"(let-values(((primitive?_0) primitive?12_0))"
"(let-values(((protected?_0) protected?13_0))"
"(let-values()"
"(let-values(((prims_0)(1/primitive-table name_0)))"
"(let-values((()"
"(begin"
"(let-values()"
"(let-values(((ht_0) prims_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)"
"(hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(register-built-in-symbol!"
" sym_0))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(values))))"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((table_0)(let-values(((table_0) '#hasheq())) table_0)))"
"(let-values(((ht_0) prims_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0 val_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_2)"
"(if(set-member?"
" skip-syms_0"
" sym_0)"
" table_1"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_1)"
"(let-values()"
"(values"
" sym_0"
"(let-values(((or-part_0)"
"(hash-ref"
" alts_0"
" sym_0"
" #f)))"
"(if or-part_0"
" or-part_0"
" val_0))))))"
"(hash-set"
" table_1"
" key_0"
" val_1)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(let-values(((ht+extras_0)"
"(let-values(((ht_1)(let-values(((ht_1) ht_0)) ht_1)))"
"(let-values(((ht_2) extras_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_3 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_2"
" i_0)))"
"(let-values(((ht_4)"
"(let-values(((ht_4)"
"(let-values()"
"(hash-set"
" ht_3"
" k_0"
" v_0))))"
"(values ht_4))))"
"(if(not #f)"
"(for-loop_0"
" ht_4"
"(hash-iterate-next ht_2 i_0))"
" ht_4)))"
" ht_3))))))"
" for-loop_0)"
" ht_1"
"(hash-iterate-first ht_2)))))))"
"(let-values(((to-name51_0) to-name_0)"
"((ht+extras52_0) ht+extras_0)"
"((ns53_0) ns_0)"
"((primitive?54_0) primitive?_0)"
"((protected?55_0) protected?_0))"
"(declare-hash-based-module!.1"
" ns53_0"
" primitive?54_0"
" null"
" protected?55_0"
" #f"
" to-name51_0"
" ht+extras52_0)))))))))))))))))))"
"(define-values"
"(declare-hash-based-module!.1)"
"(lambda(namespace23_0 primitive?24_0 protected26_0 protected?25_0 register-builtin?27_0 name33_0 ht34_0)"
"(begin"
" 'declare-hash-based-module!"
"(let-values(((name_0) name33_0))"
"(let-values(((ht_0) ht34_0))"
"(let-values(((ns_0) namespace23_0))"
"(let-values(((primitive?_0) primitive?24_0))"
"(let-values(((protected?_0) protected?25_0))"
"(let-values(((protected-syms_0) protected26_0))"
"(let-values(((register-builtin?_0) register-builtin?27_0))"
"(let-values()"
"(let-values(((mpi_0)(module-path-index-join*(list 'quote name_0) #f)))"
"(let-values(((ns56_0) ns_0)"
"((temp57_0)"
"(let-values(((temp59_0) #t)"
"((primitive?60_0) primitive?_0)"
"((temp61_0) #t)"
"((temp62_0)(if(not protected?_0)(null? protected-syms_0) #f))"
"((mpi63_0) mpi_0)"
"((temp64_0)"
"(hasheqv"
" 0"
"(let-values(((table_0)"
"(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((sym_0)"
"(hash-iterate-key"
" ht_1"
" i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(if register-builtin?_0"
"(let-values()"
"(register-built-in-symbol!"
" sym_0))"
"(void))"
"(values))))"
"(let-values(((binding_0)"
"(let-values(((mpi66_0)"
" mpi_0)"
"((temp67_0)"
" 0)"
"((sym68_0)"
" sym_0))"
"(make-module-binding.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" mpi66_0"
" temp67_0"
" sym68_0))))"
"(values"
" sym_0"
"(if(let-values(((or-part_0)"
" protected?_0))"
"(if or-part_0"
" or-part_0"
"(member"
" sym_0"
" protected-syms_0)))"
"(provided1.1"
" binding_0"
" #t"
" #f)"
" binding_0)))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2))))"
"(if(not #f)"
"(for-loop_0"
" table_2"
"(hash-iterate-next"
" ht_1"
" i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_1)))))))"
"((temp65_0)"
"(lambda(data-box_0"
" ns_1"
" phase-shift_0"
" phase-level_0"
" self_0"
" bulk-binding-registry_0"
" insp_0)"
"(if(= 0 phase-level_0)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 val_0)"
"(hash-iterate-key+value"
" ht_1"
" i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-set-variable!"
" ns_1"
" 0"
" sym_0"
" val_0"
" #t))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next"
" ht_1"
" i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_1)))))"
"(void)))"
"(void)))))"
"(make-module.1"
" temp59_0"
" #f"
" void"
" unsafe-undefined"
" unsafe-undefined"
" temp65_0"
" #f"
" 0"
" 0"
" temp62_0"
" unsafe-undefined"
" temp61_0"
" void"
" primitive?60_0"
" temp64_0"
" 'racket"
" unsafe-undefined"
" null"
" mpi63_0"
" #f"
" null"
" #f)))"
"((temp58_0)(1/module-path-index-resolve mpi_0)))"
"(declare-module!.1 #t ns56_0 temp57_0 temp58_0))))))))))))))"
"(define-values"
"(declare-reexporting-module!.1)"
"(lambda(namespace37_0 reexport?36_0 name40_0 require-names41_0)"
"(begin"
" 'declare-reexporting-module!"
"(let-values(((name_0) name40_0))"
"(let-values(((require-names_0) require-names41_0))"
"(let-values(((reexport?_0) reexport?36_0))"
"(let-values(((ns_0) namespace37_0))"
"(let-values()"
"(let-values(((mpi_0)(module-path-index-join*(list 'quote name_0) #f)))"
"(let-values(((require-mpis_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) require-names_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((require-name_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-path-index-join*"
"(list"
" 'quote"
" require-name_0)"
" #f))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((ns69_0) ns_0)"
"((temp70_0)"
"(let-values(((temp72_0) #t)"
"((temp73_0) #t)"
"((mpi74_0) mpi_0)"
"((temp75_0)(list(cons 0 require-mpis_0)))"
"((temp76_0)"
"(if reexport?_0"
"(hasheqv"
" 0"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((lst_0) require-mpis_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((require-mpi_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((id*_0)"
"(namespace->module"
" ns_0"
"(1/module-path-index-resolve"
" require-mpi_0))))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2)"
"(begin"
" 'for-loop"
"(let-values(((m_0)"
" id*_0))"
"(let-values(((table_3)"
"(let-values(((ht_0)"
"(hash-ref"
"(shift-provides-module-path-index"
"(module-provides"
" m_0)"
"(module-self"
" m_0)"
" require-mpi_0)"
" 0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_2)"
"(lambda(table_3"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0"
" binding_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_4)"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
" binding_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4))))"
"(if(not"
" #f)"
"(for-loop_2"
" table_4"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_4)))"
" table_3)))))"
" for-loop_2)"
" table_2"
"(hash-iterate-first"
" ht_0))))))"
" table_3))))))"
" for-loop_1)"
" table_1))))"
"(if(not #f)"
"(for-loop_0 table_2 rest_0)"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
" lst_0)))))"
" '#hasheqv()))"
"((void77_0) void))"
"(make-module.1"
" temp72_0"
" #f"
" void"
" unsafe-undefined"
" unsafe-undefined"
" void77_0"
" #f"
" 0"
" 0"
" #f"
" unsafe-undefined"
" temp73_0"
" void"
" #f"
" temp76_0"
" 'racket"
" unsafe-undefined"
" temp75_0"
" mpi74_0"
" #f"
" null"
" #f)))"
"((temp71_0)(1/module-path-index-resolve mpi_0)))"
"(declare-module!.1 #t ns69_0 temp70_0 temp71_0))))))))))))"
"(define-values"
"(read-primitives)"
"(hasheq"
" 'read"
" 1/read"
" 'read/recursive"
" 1/read/recursive"
" 'read-language"
" 1/read-language"
" 'string->number"
" 1/string->number"
" 'current-reader-guard"
" 1/current-reader-guard"
" 'read-square-bracket-as-paren"
" 1/read-square-bracket-as-paren"
" 'read-curly-brace-as-paren"
" 1/read-curly-brace-as-paren"
" 'read-square-bracket-with-tag"
" 1/read-square-bracket-with-tag"
" 'read-curly-brace-with-tag"
" 1/read-curly-brace-with-tag"
" 'read-cdot"
" 1/read-cdot"
" 'read-accept-graph"
" 1/read-accept-graph"
" 'read-syntax-accept-graph"
" 1/read-syntax-accept-graph"
" 'read-accept-compiled"
" 1/read-accept-compiled"
" 'read-accept-box"
" 1/read-accept-box"
" 'read-decimal-as-inexact"
" 1/read-decimal-as-inexact"
" 'read-single-flonum"
" 1/read-single-flonum"
" 'read-accept-dot"
" 1/read-accept-dot"
" 'read-accept-infix-dot"
" 1/read-accept-infix-dot"
" 'read-accept-quasiquote"
" 1/read-accept-quasiquote"
" 'read-accept-reader"
" 1/read-accept-reader"
" 'read-accept-lang"
" 1/read-accept-lang"
" 'current-readtable"
" 1/current-readtable"
" 'readtable?"
" 1/readtable?"
" 'make-readtable"
" 1/make-readtable"
" 'readtable-mapping"
" 1/readtable-mapping"
" 'special-comment?"
" 1/special-comment?"
" 'make-special-comment"
" 1/make-special-comment"
" 'special-comment-value"
" 1/special-comment-value))"
"(define-values"
"(main-primitives)"
"(hasheq"
" 'eval"
" eval$1"
" 'eval-syntax"
" 1/eval-syntax"
" 'compile"
" compile$1"
" 'compile-syntax"
" 1/compile-syntax"
" 'expand"
" 1/expand"
" 'expand-syntax"
" 1/expand-syntax"
" 'expand-once"
" 1/expand-once"
" 'expand-syntax-once"
" 1/expand-syntax-once"
" 'expand-to-top-form"
" 1/expand-to-top-form"
" 'expand-syntax-to-top-form"
" 1/expand-syntax-to-top-form"
" 'dynamic-require"
" 1/dynamic-require"
" 'dynamic-require-for-syntax"
" 1/dynamic-require-for-syntax"
" 'load"
" 1/load"
" 'load-extension"
" 1/load-extension"
" 'load/use-compiled"
" 1/load/use-compiled"
" 'current-eval"
" 1/current-eval"
" 'current-compile"
" 1/current-compile"
" 'current-load"
" 1/current-load"
" 'current-load/use-compiled"
" 1/current-load/use-compiled"
" 'collection-path"
" 1/collection-path"
" 'collection-file-path"
" 1/collection-file-path"
" 'find-library-collection-paths"
" 1/find-library-collection-paths"
" 'find-library-collection-links"
" 1/find-library-collection-links"
" 'find-compiled-file-roots"
" 1/find-compiled-file-roots"
" 'read-installation-configuration-table"
" 1/read-installation-configuration-table"
" 'current-library-collection-paths"
" 1/current-library-collection-paths"
" 'current-library-collection-links"
" 1/current-library-collection-links"
" 'use-compiled-file-paths"
" 1/use-compiled-file-paths"
" 'current-compiled-file-roots"
" 1/current-compiled-file-roots"
" 'use-compiled-file-check"
" 1/use-compiled-file-check"
" 'use-collection-link-paths"
" 1/use-collection-link-paths"
" 'use-user-specific-search-paths"
" 1/use-user-specific-search-paths"
" 'compiled-expression?"
" 1/compiled-expression?"
" 'compiled-module-expression?"
" 1/compiled-module-expression?"
" 'module-compiled-name"
" 1/module-compiled-name"
" 'module-compiled-submodules"
" 1/module-compiled-submodules"
" 'module-compiled-language-info"
" 1/module-compiled-language-info"
" 'module-compiled-imports"
" 1/module-compiled-imports"
" 'module-compiled-exports"
" 1/module-compiled-exports"
" 'module-compiled-indirect-exports"
" 1/module-compiled-indirect-exports"
" 'module-compiled-cross-phase-persistent?"
" 1/module-compiled-cross-phase-persistent?"
" 'module-compiled-realm"
" 1/module-compiled-realm"
" 'compiled-expression-recompile"
" 1/compiled-expression-recompile"
" 'compiled-expression-add-target-machine"
" 1/compiled-expression-add-target-machine"
" 'compiled-expression-summarize-target-machine"
" 1/compiled-expression-summarize-target-machine"
" 'make-empty-namespace"
" 1/make-empty-namespace"
" 'namespace-attach-module"
" 1/namespace-attach-module"
" 'namespace-attach-module-declaration"
" 1/namespace-attach-module-declaration"
" 'namespace-symbol->identifier"
" 1/namespace-symbol->identifier"
" 'namespace-module-identifier"
" 1/namespace-module-identifier"
" 'namespace-syntax-introduce"
" 1/namespace-syntax-introduce"
" 'namespace-require"
" 1/namespace-require"
" 'namespace-require/copy"
" 1/namespace-require/copy"
" 'namespace-require/constant"
" 1/namespace-require/constant"
" 'namespace-require/expansion-time"
" 1/namespace-require/expansion-time"
" 'namespace-variable-value"
" 1/namespace-variable-value"
" 'namespace-set-variable-value!"
" 1/namespace-set-variable-value!"
" 'namespace-undefine-variable!"
" 1/namespace-undefine-variable!"
" 'namespace-mapped-symbols"
" 1/namespace-mapped-symbols"
" 'namespace-base-phase"
" 1/namespace-base-phase"
" 'namespace-call-with-registry-lock"
" 1/namespace-call-with-registry-lock"
" 'module-declared?"
" 1/module-declared?"
" 'module-predefined?"
" 1/module-predefined?"
" 'module->language-info"
" 1/module->language-info"
" 'module->imports"
" 1/module->imports"
" 'module->exports"
" 1/module->exports"
" 'module->indirect-exports"
" 1/module->indirect-exports"
" 'module->realm"
" 1/module->realm"
" 'module-provide-protected?"
" 1/module-provide-protected?"
" 'module->namespace"
" 1/module->namespace"
" 'module-cache-clear!"
" 1/module-cache-clear!"
" 'namespace-unprotect-module"
" 1/namespace-unprotect-module))"
"(define-values"
"(utils-primitives)"
"(hasheq"
" 'path-string?"
" path-string?"
" 'normal-case-path"
" normal-case-path"
" 'path-replace-extension"
" path-replace-extension"
" 'path-add-extension"
" path-add-extension"
" 'reroot-path"
" reroot-path"
" 'path-list-string->path-list"
" path-list-string->path-list"
" 'find-executable-path"
" find-executable-path"
" 'call-with-default-reading-parameterization"
" call-with-default-reading-parameterization"
" 'collection-path"
" 1/collection-path"
" 'collection-file-path"
" 1/collection-file-path"
" 'find-library-collection-paths"
" 1/find-library-collection-paths"
" 'find-library-collection-links"
" 1/find-library-collection-links"
" 'get-installation-name"
" get-installation-name"
" 'load/use-compiled"
" 1/load/use-compiled"
" 'find-main-config"
" find-main-config"
" 'find-main-collects"
" find-main-collects))"
"(define-values"
"(expobs-primitives)"
"(hasheq 'current-expand-observe current-expand-observe 'syntax-local-expand-observer syntax-local-expand-observer))"
"(define-values"
"(struct:TH-place-channel TH-place-channel TH-place-channel? TH-place-channel-ref TH-place-channel-set!)"
"(make-struct-type 'TH-place-channel #f 2 0 #f(list(cons prop:evt(lambda(x_0)(TH-place-channel-ref x_0 0))))))"
"(define-values"
"(TH-place-channel-in TH-place-channel-out)"
"(values(lambda(x_0)(TH-place-channel-ref x_0 0))(lambda(x_0)(TH-place-channel-ref x_0 1))))"
"(define-values"
"(place-struct-primitives)"
"(hasheq"
" 'struct:TH-place-channel"
" struct:TH-place-channel"
" 'TH-place-channel"
" TH-place-channel"
" 'TH-place-channel?"
" TH-place-channel?"
" 'TH-place-channel-in"
" TH-place-channel-in"
" 'TH-place-channel-out"
" TH-place-channel-out))"
"(define-values"
"(1/linklet-directory?)"
"(lambda(v_0)"
"(begin"
" 'linklet-directory?"
"(let-values(((or-part_0)(linklet-directory?$1 v_0)))(if or-part_0 or-part_0(compiled-in-memory? v_0))))))"
"(define-values"
"(1/linklet-directory->hash)"
"(lambda(ld_0)"
"(begin"
" 'linklet-directory->hash"
"(linklet-directory->hash$1(if(compiled-in-memory? ld_0)(compiled-in-memory-linklet-directory ld_0) ld_0)))))"
"(define-values"
"(1/linklet?)"
"(lambda(l_0)"
"(begin 'linklet?(let-values(((or-part_0)(linklet?$1 l_0)))(if or-part_0 or-part_0(correlated-linklet? l_0))))))"
"(define-values"
"(1/recompile-linklet)"
"(case-lambda"
"((lnk_0)(begin 'recompile-linklet(recompile-linklet$1(force-compile-linklet lnk_0))))"
"((lnk_0 info_0)(recompile-linklet$1(force-compile-linklet lnk_0) info_0))"
"((lnk_0 info_0 import-keys_0)(recompile-linklet$1(force-compile-linklet lnk_0) info_0 import-keys_0))"
"((lnk_0 info_0 import-keys_0 get-import_0)"
"(recompile-linklet$1(force-compile-linklet lnk_0) info_0 import-keys_0 get-import_0))"
"((lnk_0 info_0 import-keys_0 get-import_0 options_0)"
"(recompile-linklet$1(force-compile-linklet lnk_0) info_0 import-keys_0 get-import_0 options_0))))"
"(define-values(1/eval-linklet)(lambda(lnk_0)(begin 'eval-linklet(eval-linklet$1(force-compile-linklet lnk_0)))))"
"(define-values"
"(1/instantiate-linklet)"
"(let-values(((instantiate-linklet_0)"
"(lambda(lnk3_0 import-instances4_0 target-instance1_0 use-prompt?2_0)"
"(begin"
" 'instantiate-linklet"
"(let-values(((lnk_0) lnk3_0))"
"(let-values(((import-instances_0) import-instances4_0))"
"(let-values(((target-instance_0) target-instance1_0))"
"(let-values(((use-prompt?_0) use-prompt?2_0))"
"(let-values()"
"(instantiate-linklet$1"
"(force-compile-linklet lnk_0)"
" import-instances_0"
" target-instance_0"
" use-prompt?_0))))))))))"
"(case-lambda"
"((lnk_0 import-instances_0)(begin 'instantiate-linklet(instantiate-linklet_0 lnk_0 import-instances_0 #f #f)))"
"((lnk_0 import-instances_0 target-instance_0 use-prompt?2_0)"
"(instantiate-linklet_0 lnk_0 import-instances_0 target-instance_0 use-prompt?2_0))"
"((lnk_0 import-instances_0 target-instance1_0)"
"(instantiate-linklet_0 lnk_0 import-instances_0 target-instance1_0 #f)))))"
"(define-values"
"(1/linklet-import-variables)"
"(lambda(lnk_0)(begin 'linklet-import-variables(linklet-import-variables$1(force-compile-linklet lnk_0)))))"
"(define-values"
"(1/linklet-export-variables)"
"(lambda(lnk_0)(begin 'linklet-export-variables(linklet-export-variables$1(force-compile-linklet lnk_0)))))"
"(define-values"
"(1/linklet-body-reserved-symbol?)"
"(lambda(s_0)"
"(begin"
" 'linklet-body-reserved-symbol?"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? s_0)"
"(void)"
"              (let-values () (raise-argument-error 'linklet-body-reserved-symbol? \"symbol?\" s_0)))"
"(built-in-symbol? s_0)))))))"
"(define-values"
"(linklet-primitives)"
"(hasheq"
" 'primitive-table"
" 1/primitive-table"
" 'primitive->compiled-position"
" 1/primitive->compiled-position"
" 'compiled-position->primitive"
" 1/compiled-position->primitive"
" 'primitive-in-category?"
" 1/primitive-in-category?"
" 'primitive-lookup"
" 1/primitive-lookup"
" 'compile-linklet"
" 1/compile-linklet"
" 'linklet-add-target-machine-info"
" 1/linklet-add-target-machine-info"
" 'linklet-summarize-target-machine-info"
" 1/linklet-summarize-target-machine-info"
" 'instance?"
" 1/instance?"
" 'make-instance"
" 1/make-instance"
" 'instance-name"
" 1/instance-name"
" 'instance-data"
" 1/instance-data"
" 'instance-variable-names"
" 1/instance-variable-names"
" 'instance-variable-value"
" 1/instance-variable-value"
" 'instance-set-variable-value!"
" 1/instance-set-variable-value!"
" 'instance-unset-variable!"
" 1/instance-unset-variable!"
" 'instance-describe-variable!"
" 1/instance-describe-variable!"
" 'linklet-virtual-machine-bytes"
" 1/linklet-virtual-machine-bytes"
" 'linklet-cross-machine-type"
" 1/linklet-cross-machine-type"
" 'write-linklet-bundle-hash"
" 1/write-linklet-bundle-hash"
" 'read-linklet-bundle-hash"
" 1/read-linklet-bundle-hash"
" 'variable-reference?"
" 1/variable-reference?"
" 'variable-reference->instance"
" 1/variable-reference->instance"
" 'variable-reference-constant?"
" 1/variable-reference-constant?"
" 'variable-reference-from-unsafe?"
" 1/variable-reference-from-unsafe?))"
"(define-values"
"(linklet-expander-primitives)"
"(hasheq"
" 'linklet-directory?"
" 1/linklet-directory?"
" 'linklet-directory->hash"
" 1/linklet-directory->hash"
" 'hash->linklet-directory"
" 1/hash->linklet-directory"
" 'linklet-bundle?"
" 1/linklet-bundle?"
" 'linklet-bundle->hash"
" 1/linklet-bundle->hash"
" 'hash->linklet-bundle"
" 1/hash->linklet-bundle"
" 'linklet-body-reserved-symbol?"
" 1/linklet-body-reserved-symbol?"
" 'linklet?"
" 1/linklet?"
" 'recompile-linklet"
" 1/recompile-linklet"
" 'eval-linklet"
" 1/eval-linklet"
" 'instantiate-linklet"
" 1/instantiate-linklet"
" 'linklet-import-variables"
" 1/linklet-import-variables"
" 'linklet-export-variables"
" 1/linklet-export-variables))"
"(define-values"
"(choose-file-to-load)"
"(lambda(path_0"
" expect-module_0"
" so-okay?_0"
" rkt-try-ss?_0"
" choose_0"
" compiled-file-roots_0"
" compiled-file-paths_0"
" file-check_0)"
"(begin"
"(let-values(((resolve_0)"
"(lambda(s_0)"
"(begin"
" 'resolve"
"(if(complete-path? s_0)"
" s_0"
"(let-values(((d_0)(current-load-relative-directory)))"
"(if d_0(path->complete-path s_0 d_0) s_0)))))))"
"(let-values(((use-seconds?_0)(eq? file-check_0 'modify-seconds)))"
"(let-values(((date-of-1_0)"
"(lambda(a_0)"
"(begin"
" 'date-of-1"
"(let-values(((v_0)(file-or-directory-modify-seconds a_0 #f(lambda() #f))))"
"(if v_0(cons a_0(if use-seconds?_0 v_0 0)) #f))))))"
"(let-values(((date-of_0)"
"(lambda(a_0 modes_0 roots_0)"
"(begin"
" 'date-of"
"(ormap2"
"(lambda(root-dir_0)"
"(ormap2"
"(lambda(compiled-dir_0)"
"(let-values(((a_1)(a_0 root-dir_0 compiled-dir_0)))(date-of-1_0 a_1)))"
" modes_0))"
" roots_0)))))"
"(let-values(((date>=?_0)"
"(lambda(modes_0 roots_0 a_0 bm_0)"
"(begin"
" 'date>=?"
"(if a_0"
"(let-values(((am_0)(date-of_0 a_0 modes_0 roots_0)))"
"(let-values(((or-part_0)(if(not bm_0) am_0 #f)))"
"(if or-part_0"
" or-part_0"
"(if am_0(if bm_0(if(>=(cdr am_0)(cdr bm_0)) am_0 #f) #f) #f))))"
" #f)))))"
"(let-values(((orig-path_0)(resolve_0 path_0)))"
"(let-values(((base_0 orig-file_0 dir?_0)(split-path path_0)))"
"(let-values(((file_0 alt-file_0)"
"(if rkt-try-ss?_0"
"(let-values(((b_0)(path->bytes orig-file_0)))"
"(let-values(((len_0)(bytes-length b_0)))"
"                                        (if (if (>= len_0 4) (bytes=? #\".rkt\" (subbytes b_0 (- len_0 4))) #f)"
"(let-values()"
"(values"
" orig-file_0"
"                                             (bytes->path (bytes-append (subbytes b_0 0 (- len_0 4)) #\".ss\"))))"
"(let-values()(values orig-file_0 #f)))))"
"(values orig-file_0 #f))))"
"(let-values(((path_1)(if(eq? file_0 orig-file_0) orig-path_0(build-path base_0 file_0))))"
"(let-values(((alt-path_0)"
"(if alt-file_0"
"(if(eq? alt-file_0 orig-file_0) orig-path_0(build-path base_0 alt-file_0))"
" #f)))"
"(let-values(((base_1)(if(eq? base_0 'relative) 'same base_0)))"
"(let-values(((modes_0) compiled-file-paths_0))"
"(let-values(((roots_0) compiled-file-roots_0))"
"(let-values(((reroot_0)"
"(lambda(p_0 d_0)"
"(begin"
" 'reroot"
"(if(eq? d_0 'same)"
"(let-values() p_0)"
"(if(relative-path? d_0)"
"(let-values()(build-path p_0 d_0))"
"(let-values()(reroot-path p_0 d_0))))))))"
"(let-values(((main-path-d_0)(date-of-1_0 path_1)))"
"(let-values(((alt-path-d_0)"
"(if alt-path_0"
"(if(not main-path-d_0)(date-of-1_0 alt-path_0) #f)"
" #f)))"
"(let-values(((path-d_0)"
"(let-values(((or-part_0) main-path-d_0))"
"(if or-part_0 or-part_0 alt-path-d_0))))"
"(let-values(((get-so_0)"
"(lambda(file_1 rep-sfx?_0)"
"(begin"
" 'get-so"
"(if(eq? 'racket(system-type 'vm))"
"(lambda(root-dir_0 compiled-dir_0)"
"(build-path"
"(reroot_0 base_1 root-dir_0)"
" compiled-dir_0"
"                                                               \"native\""
"(system-library-subpath)"
"(if rep-sfx?_0"
"(path-add-extension file_1 dll-suffix)"
" file_1)))"
" #f)))))"
"(let-values(((zo_0)"
"(lambda(root-dir_0 compiled-dir_0)"
"(begin"
" 'zo"
"(build-path"
"(reroot_0 base_1 root-dir_0)"
" compiled-dir_0"
"                                                             (path-add-extension file_0 #\".zo\"))))))"
"(let-values(((alt-zo_0)"
"(lambda(root-dir_0 compiled-dir_0)"
"(begin"
" 'alt-zo"
"(build-path"
"(reroot_0 base_1 root-dir_0)"
" compiled-dir_0"
"                                                               (path-add-extension alt-file_0 #\".zo\"))))))"
"(let-values(((so_0)(get-so_0 file_0 #t)))"
"(let-values(((alt-so_0)(get-so_0 alt-file_0 #t)))"
"(let-values(((try-main?_0)"
"(let-values(((or-part_0) main-path-d_0))"
"(if or-part_0 or-part_0(not alt-path-d_0)))))"
"(let-values(((try-alt?_0)"
"(if alt-file_0"
"(let-values(((or-part_0) alt-path-d_0))"
"(if or-part_0 or-part_0(not main-path-d_0)))"
" #f)))"
"(let-values(((choice_0)"
"(if choose_0"
"(let-values()"
"(let-values(((p_0)"
"(if try-main?_0"
" path_1"
" alt-path_0)))"
"(let-values(((base_2 name_0 dir?_1)"
"(split-path p_0)))"
"(let-values(((subdir_0)"
"(if(pair?"
" compiled-file-paths_0)"
"(car compiled-file-paths_0)"
"                                                                                            \"compiled\")))"
"(choose_0"
"(if(string? p_0)(string->path p_0) p_0)"
"(build-path"
" base_2"
" subdir_0"
"                                                                                (replace-extension name_0 #\".zo\"))"
"(build-path"
" base_2"
" subdir_0"
"                                                                                (replace-extension name_0 #\".so\")))))))"
"(let-values() #f))))"
"(let-values(((c4_0)"
"(if(not(equal? choice_0 'src))"
"(if so-okay?_0"
"(if so_0"
"(if try-main?_0"
"(date>=?_0 modes_0 roots_0 so_0 path-d_0)"
" #f)"
" #f)"
" #f)"
" #f)))"
"(if c4_0"
"((lambda(so-d_0)(values #f 'so(car so-d_0))) c4_0)"
"(let-values(((c3_0)"
"(if(not(equal? choice_0 'src))"
"(if so-okay?_0"
"(if alt-so_0"
"(if try-alt?_0"
"(date>=?_0"
" modes_0"
" roots_0"
" alt-so_0"
" alt-path-d_0)"
" #f)"
" #f)"
" #f)"
" #f)))"
"(if c3_0"
"((lambda(so-d_0)(values alt-path_0 'so(car so-d_0)))"
" c3_0)"
"(let-values(((c2_0)"
"(if(not(equal? choice_0 'src))"
"(if try-main?_0"
"(date>=?_0"
" modes_0"
" roots_0"
" zo_0"
" path-d_0)"
" #f)"
" #f)))"
"(if c2_0"
"((lambda(zo-d_0)(values #f 'zo(car zo-d_0)))"
" c2_0)"
"(let-values(((c1_0)"
"(if(not(equal? choice_0 'src))"
"(if try-alt?_0"
"(date>=?_0"
" modes_0"
" roots_0"
" alt-zo_0"
" path-d_0)"
" #f)"
" #f)))"
"(if c1_0"
"((lambda(zo-d_0)"
"(values alt-path_0 'zo(car zo-d_0)))"
" c1_0)"
"(if(let-values(((or-part_0)"
"(not"
"(pair? expect-module_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(car expect-module_0)))"
"(if or-part_1"
" or-part_1"
"(is-compiled-file?"
"(if try-main?_0"
" path_1"
" alt-path_0))))))"
"(let-values()"
"(let-values(((p_0)"
"(if try-main?_0"
" path_1"
" alt-path_0)))"
"(values"
"(if expect-module_0"
"(if(not try-main?_0) p_0 #f)"
" #f)"
" 'src"
"(if(let-values(((or-part_0)"
"(not"
"(pair?"
" expect-module_0))))"
"(if or-part_0"
" or-part_0"
"(file-exists? p_0)))"
" p_0"
" #f))))"
"(let-values()"
"(values"
" #f"
" 'src"
" #f)))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(replace-extension)"
"(lambda(pth_0 what_0)"
"    (begin (bytes->path (bytes-append (regexp-replace '#rx#\"[.]([^.]*)$\" (path->bytes pth_0) #\"_\\\\1\") what_0)))))"
"(define-values(dll-suffix)(system-type 'so-suffix))"
"(define-values"
"(is-compiled-file?)"
"(lambda(p_0)"
"(begin"
"(if(file-exists? p_0)"
"(let-values(((p1_0) p_0)((linklet-directory-start2_0) linklet-directory-start))"
"(call-with-input-file*.1 'binary p1_0 linklet-directory-start2_0))"
" #f))))"
"(define-values(version-bytes)(string->bytes/utf-8(version)))"
"(define-values(version-length)(bytes-length version-bytes))"
"(define-values(vm-bytes)(string->bytes/utf-8(symbol->string(system-type 'target-machine))))"
"(define-values(vm-length)(bytes-length vm-bytes))"
"(define-values"
"(linklet-bundle-or-directory-start)"
"(lambda(i_0 tag_0)"
"(begin"
"(if(equal?(peek-byte i_0)(char->integer '#\\#))"
"(if(equal?(peek-byte i_0 1)(char->integer '#\\~))"
"(if(equal?(peek-byte i_0 2) version-length)"
"(if(equal?(peek-bytes version-length 3 i_0) version-bytes)"
"(if(equal?(peek-byte i_0(+ 3 version-length)) vm-length)"
"(if(equal?(peek-bytes vm-length(+ 4 version-length) i_0) vm-bytes)"
"(if(equal?(peek-byte i_0(+ 4 version-length vm-length))(char->integer tag_0))"
"(+ version-length vm-length 5)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f))))"
"(define-values"
"(linklet-directory-start)"
"(lambda(i_0)"
"(begin(let-values(((pos_0)(linklet-bundle-or-directory-start i_0 '#\\D)))(if pos_0(+ pos_0 4) #f)))))"
"(define-values"
"(linklet-bundle-hash-code)"
"(lambda(i_0)"
"(begin"
"(let-values(((pos_0)(linklet-bundle-or-directory-start i_0 '#\\B)))"
"(let-values(((hash-code_0)(if pos_0(peek-bytes 20 pos_0 i_0) #f)))"
"(if(bytes? hash-code_0)"
"(if(= 20(bytes-length hash-code_0))"
"(if(let-values(((result_0)(let-values(((result_0) #f)) result_0)))"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0) hash-code_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-bytes vec_0)))"
"(values vec_0(unsafe-bytes-length vec_0))))))"
"((letrec-values(((for-loop_0)"
"(lambda(result_1 pos_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(unsafe-fx< pos_1 len_0)"
"(let-values(((c_0)(unsafe-bytes-ref vec_0 pos_1)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()(not(eq? c_0 0))))))"
"(values result_2))))"
"(if(if(not((lambda x_0 result_2) c_0))(not #f) #f)"
"(for-loop_0 result_2(unsafe-fx+ 1 pos_1))"
" result_2)))"
" result_1))))))"
" for-loop_0)"
" result_0"
" 0)))"
" hash-code_0"
" #f)"
" #f)"
" #f))))))"
"(define-values"
"(with-module-reading-parameterization)"
"(lambda(thunk_0)"
"(begin"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/read-accept-reader"
" #t"
" 1/read-accept-lang"
" #t"
" 1/read-accept-compiled"
" #t"
" read-case-sensitive"
" #t"
" 1/read-square-bracket-as-paren"
" #t"
" 1/read-curly-brace-as-paren"
" #t"
" 1/read-square-bracket-with-tag"
" #f"
" 1/read-curly-brace-with-tag"
" #f"
" 1/read-accept-box"
" #t"
" read-accept-bar-quote"
" #t"
" 1/read-accept-graph"
" #t"
" 1/read-syntax-accept-graph"
" #f"
" 1/read-decimal-as-inexact"
" #t"
" 1/read-cdot"
" #f"
" 1/read-accept-dot"
" #t"
" 1/read-accept-infix-dot"
" #t"
" 1/read-accept-quasiquote"
" #t"
" 1/current-readtable"
" #f)"
"(let-values()(thunk_0))))))"
"(define-values"
"(check-module-form)"
"(lambda(exp_0 filename_0)"
"(begin"
"(if(let-values(((or-part_0)(eof-object? exp_0)))(if or-part_0 or-part_0(eof-object?(1/syntax-e exp_0))))"
"(let-values()"
"(if filename_0"
"(error"
" 'load-handler"
"             (string-append \"expected a `module' declaration, but found end-of-file\\n\" \"  file: ~a\")"
" filename_0)"
" #f))"
"(if(1/compiled-module-expression?(1/syntax-e exp_0))"
"(let-values() exp_0)"
"(if(if(syntax?$1 exp_0)"
"(if(pair?(1/syntax-e exp_0))"
"(if(eq? 'module(1/syntax-e(car(1/syntax-e exp_0))))"
"(let-values(((r_0)(cdr(1/syntax-e exp_0))))"
"(let-values(((r_1)(if(syntax?$1 r_0)(1/syntax-e r_0) r_0)))"
"(if(pair? r_1)(identifier?(car r_1)) #f)))"
" #f)"
" #f)"
" #f)"
"(let-values()"
"(1/datum->syntax exp_0(cons(1/namespace-module-identifier)(cdr(1/syntax-e exp_0))) exp_0 exp_0))"
"(let-values()"
"(if filename_0"
"(error"
" 'default-load-handler"
"                 (string-append \"expected a `module' declaration, but found something else\\n\" \"  file: ~a\")"
" filename_0)"
" #f))))))))"
"(define-values"
"(default-load-handler)"
"(lambda(path_0 expected-mod_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                        (let-values () (raise-argument-error 'default-load-handler \"path-string?\" path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not expected-mod_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? expected-mod_0)))"
"(if or-part_1"
" or-part_1"
"(if(pair? expected-mod_0)"
"(if(list? expected-mod_0)"
"(if(let-values(((or-part_2)(not(car expected-mod_0))))"
"(if or-part_2 or-part_2(symbol?(car expected-mod_0))))"
"(andmap2 symbol?(cdr expected-mod_0))"
" #f)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'default-load-handler"
"                             \"(or/c #f symbol? (cons/c (or/c #f symbol?) (non-empty-listof symbol?)))\""
" expected-mod_0)))"
"(values))))"
"(let-values(((maybe-count-lines!_0)"
"(lambda(i_0)"
"(begin"
" 'maybe-count-lines!"
"                            (if (regexp-match? '#rx\"[.]zo$\" path_0) (void) (let-values () (port-count-lines! i_0)))))))"
"(if expected-mod_0"
"(let-values()"
"((call-with-input-module-file"
" path_0"
"(lambda(i_0)"
"(begin"
"(maybe-count-lines!_0 i_0)"
"(with-module-reading-parameterization+delay-source"
" path_0"
"(lambda()"
"(let-values(((c2_0)(linklet-directory-start i_0)))"
"(if c2_0"
"((lambda(pos_0)"
"(let-values(((b-pos_0)(search-directory i_0 pos_0(encode-symbols expected-mod_0))))"
"(if b-pos_0"
"(let-values()"
"(begin"
"(file-position i_0 b-pos_0)"
"(let-values(((or-part_0)(cached-bundle i_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((v_0)(1/read i_0)))"
"(if(1/compiled-module-expression? v_0)"
"(lambda()((1/current-eval) v_0))"
"(error"
" 'default-load-handler"
"(string-append"
"                                                  \"expected a compiled module\\n\""
"                                                  \"  in: ~e\\n\""
"                                                  \"  found: ~e\")"
"(object-name i_0)"
" v_0)))))))"
"(if(pair? expected-mod_0)"
"(let-values() void)"
"(let-values()"
"(error"
" 'default-load-handler"
"                                         (string-append \"could not find main module\\n\" \"  in: ~e\")"
"(object-name i_0)))))))"
" c2_0)"
"(if(if(pair? expected-mod_0)(not(car expected-mod_0)) #f)"
"(let-values() void)"
"(let-values(((c1_0)(cached-bundle i_0)))"
"(if c1_0"
"((lambda(thunk_0) thunk_0) c1_0)"
"(let-values()"
"(let-values(((s_0)(1/read-syntax(object-name i_0) i_0)))"
"(let-values((()"
"(begin"
"(if(eof-object? s_0)"
"(let-values()"
"(error"
" 'default-load-handler"
"(string-append"
"                                                             \"expected a `module' declaration;\\n\""
"                                                             \" found end-of-file\\n\""
"                                                             \"  in: ~e\")"
"(object-name i_0)))"
"(void))"
"(values))))"
"(let-values(((m-s_0)(check-module-form s_0 path_0)))"
"(let-values(((s2_0)(1/read-syntax(object-name i_0) i_0)))"
"(begin"
"(if(eof-object? s2_0)"
"(void)"
"(let-values()"
"(error"
" 'default-load-handler"
"(string-append"
"                                                     \"expected a `module' declaration;\\n\""
"                                                     \" found an extra form\\n\""
"                                                     \"  in: ~e\\n\""
"                                                     \"  found: ~.s\")"
"(object-name i_0)"
" s2_0)))"
"(lambda()((1/current-eval) m-s_0))))))))))))))))))))"
"(let-values()"
"(let-values(((add-top-interaction_0)"
"(lambda(s_0)"
"(begin"
" 'add-top-interaction"
"(1/namespace-syntax-introduce"
"(1/datum->syntax #f(cons '#%top-interaction s_0) s_0))))))"
"(let-values(((path1_0) path_0)"
"((temp2_0)"
"(lambda(i_0)"
"(begin"
"(maybe-count-lines!_0 i_0)"
"((letrec-values(((loop_0)"
"(lambda(vals_0)"
"(begin"
" 'loop"
"(let-values(((s_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/read-accept-compiled"
" #t"
" 1/read-accept-reader"
" #t"
" 1/read-accept-lang"
" #t)"
"(let-values()"
"(if(load-on-demand-enabled)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" read-on-demand-source"
"(path->complete-path path_0))"
"(let-values()"
"(1/read-syntax(object-name i_0) i_0)))"
"(1/read-syntax(object-name i_0) i_0))))))"
"(if(eof-object? s_0)"
"(apply values vals_0)"
"(loop_0"
"(call-with-continuation-prompt"
"(lambda()"
"(call-with-values"
"(lambda()"
"((1/current-eval)(add-top-interaction_0 s_0)))"
" list))"
"(default-continuation-prompt-tag)"
"(lambda args_0"
"(apply"
" abort-current-continuation"
"(default-continuation-prompt-tag)"
" args_0))))))))))"
" loop_0)"
"(list(void)))))))"
"(call-with-input-file*.1 'binary path1_0 temp2_0)))))))))))"
"(define-values"
"(cached-bundle)"
"(lambda(i_0)"
"(begin"
"(let-values(((c3_0)(module-cache-ref(make-module-cache-key(linklet-bundle-hash-code i_0)))))"
"(if c3_0"
"((lambda(declare-module_0)(lambda()(declare-module_0(1/current-namespace)))) c3_0)"
"(let-values() #f))))))"
"(define-values"
"(read-number)"
"(lambda(i_0)"
"(begin"
"(let-values(((read-byte/not-eof_0)"
"(lambda(i_1)"
"(begin 'read-byte/not-eof(let-values(((v_0)(read-byte i_1)))(if(eof-object? v_0) 0 v_0))))))"
"(bitwise-ior"
"(read-byte/not-eof_0 i_0)"
"(arithmetic-shift(read-byte/not-eof_0 i_0) 8)"
"(arithmetic-shift(read-byte/not-eof_0 i_0) 16)"
"(arithmetic-shift(read-byte/not-eof_0 i_0) 24))))))"
"(define-values"
"(search-directory)"
"(lambda(i_0 pos_0 bstr_0)"
"(begin"
"(if(zero? pos_0)"
"(let-values() #f)"
"(let-values()"
"(let-values((()(begin(file-position i_0 pos_0)(values))))"
"(let-values(((name-len_0)(read-number i_0)))"
"(let-values(((v_0)(read-bytes name-len_0 i_0)))"
"(begin"
"(if(if(bytes? v_0)(=(bytes-length v_0) name-len_0) #f)"
"(void)"
"(let-values()"
"(error"
" 'deafult-load-handler"
"(string-append"
"                        \"failure getting submodule path\\n\""
"                        \"  in: ~e\\n\""
"                        \"  at position: ~a\\n\""
"                        \"  expected bytes: ~a\\n\""
"                        \"  read bytes: ~e\")"
"(object-name i_0)"
" pos_0"
" name-len_0"
" v_0)))"
"(if(bytes=? bstr_0 v_0)"
"(let-values()(read-number i_0))"
"(if(bytes<? bstr_0 v_0)"
"(let-values()"
"(begin(read-number i_0)(read-number i_0)(search-directory i_0(read-number i_0) bstr_0)))"
"(let-values()"
"(begin"
"(read-number i_0)"
"(read-number i_0)"
"(read-number i_0)"
"(search-directory i_0(read-number i_0) bstr_0))))))))))))))"
"(define-values"
"(encode-symbols)"
"(lambda(expected-mod_0)"
"(begin"
"(if(symbol? expected-mod_0)"
"        (let-values () #\"\")"
"(let-values()"
"(apply"
" bytes-append"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(cdr expected-mod_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((bstr_0)"
"(string->bytes/utf-8"
"(symbol->string s_0))))"
"(let-values(((len_0)"
"(bytes-length bstr_0)))"
"(if(< len_0 255)"
"(let-values()"
"(bytes-append"
"(bytes len_0)"
" bstr_0))"
"(let-values()"
"(bytes-append"
" 255"
"(integer->integer-bytes"
" len_0"
" 4"
" #f"
" #f)"
" bstr_0))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))))"
"(define-values"
"(with-module-reading-parameterization+delay-source)"
"(lambda(path_0 thunk_0)"
"(begin"
"(if(load-on-demand-enabled)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" read-on-demand-source"
"(path->complete-path path_0))"
"(let-values()(with-module-reading-parameterization thunk_0)))"
"(with-module-reading-parameterization thunk_0)))))"
"(define-values"
"(call-with-input-module-file)"
"(lambda(path_0 proc_0)"
"(begin"
"(let-values(((i_0) #f))"
"(dynamic-wind"
"(lambda()"
"(set! i_0(let-values(((path3_0) path_0)((temp4_0) #t))(open-input-file.1 temp4_0 'binary path3_0))))"
"(lambda()(proc_0 i_0))"
"(lambda()(close-input-port i_0)))))))"
"(define-values"
"(default-load/use-compiled)"
"(let-values(((with-dir*_0)"
"(lambda(base_0 t_0)"
"(begin"
" 'with-dir*"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-load-relative-directory"
"(if(path? base_0) base_0(current-directory)))"
"(let-values()(t_0)))))))"
"(lambda(path_0 expect-module_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                          (let-values () (raise-argument-error 'load/use-compiled \"path-string?\" path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not expect-module_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? expect-module_0)))"
"(if or-part_1"
" or-part_1"
"(if(list? expect-module_0)"
"(if(>(length expect-module_0) 1)"
"(if(let-values(((or-part_2)(symbol?(car expect-module_0))))"
"(if or-part_2 or-part_2(not(car expect-module_0))))"
"(andmap2 symbol?(cdr expect-module_0))"
" #f)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'load/use-compiled"
"                               \"(or/c #f symbol? (cons/c (or/c #f symbol?) (non-empty-listof symbol?)))\""
" path_0)))"
"(values))))"
"(let-values(((name_0)(if expect-module_0(1/current-module-declare-name) #f)))"
"(let-values(((ns-hts_0)"
"(if name_0(registry-table-ref(namespace-module-registry$1(1/current-namespace))) #f)))"
"(let-values(((use-path/src_0)(if ns-hts_0(hash-ref(cdr ns-hts_0) name_0 #f) #f)))"
"(if use-path/src_0"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-module-declare-source"
"(cadr use-path/src_0))"
"(let-values()"
"(with-dir*_0"
"(caddr use-path/src_0)"
"(lambda()((1/current-load)(car use-path/src_0) expect-module_0)))))"
"(let-values(((the-module-declare-source_0 file-type_0 the-path_0)"
"(choose-file-to-load"
" path_0"
" expect-module_0"
" #t"
" expect-module_0"
" #f"
"(1/current-compiled-file-roots)"
"(1/use-compiled-file-paths)"
"(1/use-compiled-file-check))))"
"(if the-path_0"
"(let-values()"
"(let-values(((_base_0 orig-file_0 dir?_0)(split-path path_0)))"
"(let-values(((base_0)(if(eq? _base_0 'relative) 'same _base_0)))"
"(begin"
"(if(equal? file-type_0 'zo)"
"(let-values()"
"(register-zo-path name_0 ns-hts_0 the-path_0 the-module-declare-source_0 base_0))"
"(void))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-module-declare-source"
" the-module-declare-source_0)"
"(let-values()"
"(with-dir*_0"
" base_0"
"(lambda()"
"((if(equal? file-type_0 'so)(current-load-extension)(1/current-load))"
" the-path_0"
" expect-module_0)))))))))"
"(void)))))))))))))"
"(define-values"
"(register-zo-path)"
"(lambda(name_0 ns-hts_0 path_0 src-path_0 base_0)"
"(begin(if ns-hts_0(let-values()(hash-set!(cdr ns-hts_0) name_0(list path_0 src-path_0 base_0)))(void)))))"
"(define-values(default-reader-guard)(lambda(path_0)(begin path_0)))"
"(define-values(cell.1)(unsafe-make-place-local(make-weak-hasheq)))"
"(define-values"
"(registry-table-ref)"
"(lambda(reg_0)"
"(begin"
"(let-values(((e_0)(hash-ref(unsafe-place-local-ref cell.1) reg_0 #f)))(if e_0(ephemeron-value e_0) #f)))))"
"(define-values"
"(registry-table-set!)"
"(lambda(reg_0 v_0)(begin(hash-set!(unsafe-place-local-ref cell.1) reg_0(make-ephemeron reg_0 v_0)))))"
"(define-values(cell.2)(unsafe-make-place-local(make-weak-hasheq)))"
"(define-values"
"(path-cache-get)"
"(lambda(p_0 reg_0)"
"(begin"
"(let-values(((cache_0)(hash-ref(unsafe-place-local-ref cell.2) reg_0 '#hash())))(hash-ref cache_0 p_0 #f)))))"
"(define-values"
"(path-cache-set!)"
"(lambda(p_0 reg_0 v_0)"
"(begin"
"(let-values(((current-cache_0)(hash-ref(unsafe-place-local-ref cell.2) reg_0 '#hash())))"
"(let-values(((cache_0)(if(=(hash-count current-cache_0) 1024) '#hash() current-cache_0)))"
"(hash-set!(unsafe-place-local-ref cell.2) reg_0(hash-set cache_0 p_0 v_0)))))))"
"(define-values(-loading-filename)(gensym))"
"(define-values(-loading-prompt-tag)(make-continuation-prompt-tag 'module-loading))"
"(define-values(cell.3)(unsafe-make-place-local #f))"
"(define-values(cell.4)(unsafe-make-place-local #f))"
"(define-values"
"(split-relative-string)"
"(lambda(s_0 coll-mode?_0)"
"(begin"
"(let-values(((l_0)"
"((letrec-values(((loop_0)"
"(lambda(s_1)"
"(begin"
" 'loop"
"(let-values(((len_0)(string-length s_1)))"
"((letrec-values(((iloop_0)"
"(lambda(i_0)"
"(begin"
" 'iloop"
"(if(= i_0 len_0)"
"(let-values()(list s_1))"
"(if(char=? '#\\/(string-ref s_1 i_0))"
"(let-values()"
"(cons"
"(substring s_1 0 i_0)"
"(loop_0(substring s_1(add1 i_0)))))"
"(let-values()(iloop_0(add1 i_0)))))))))"
" iloop_0)"
" 0))))))"
" loop_0)"
" s_0)))"
"(if coll-mode?_0"
" l_0"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null?(cdr l_1))"
"(values null(car l_1))"
"(let-values(((c_0 f_0)(loop_0(cdr l_1))))(values(cons(car l_1) c_0) f_0)))))))"
" loop_0)"
" l_0))))))"
"(define-values"
"(format-source-location)"
"(lambda(stx_0)"
"(begin"
"(srcloc->string"
"(srcloc"
"(1/syntax-source stx_0)"
"(1/syntax-line stx_0)"
"(1/syntax-column stx_0)"
"(1/syntax-position stx_0)"
"(1/syntax-span stx_0))))))"
"(define-values(cell.5)(unsafe-make-place-local #f))"
"(define-values(cell.6)(unsafe-make-place-local #f))"
"(define-values"
"(prep-planet-resolver!)"
"(lambda()"
"(begin"
"(if(unsafe-place-local-ref cell.6)"
"(void)"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(unsafe-place-local-ref cell.5)"
"(unsafe-place-local-set!"
" cell.6"
"            (1/dynamic-require '(lib \"planet/resolver.rkt\") 'planet-module-name-resolver))))))))"
"(define-values"
"(standard-module-name-resolver)"
"(case-lambda"
"((s_0 from-namespace_0)"
"(begin"
"(begin"
"(if(1/resolved-module-path? s_0)"
"(void)"
"          (let-values () (raise-argument-error 'standard-module-name-resolver \"resolved-module-path?\" s_0)))"
"(if(let-values(((or-part_0)(not from-namespace_0)))(if or-part_0 or-part_0(1/namespace? from-namespace_0)))"
"(void)"
"          (let-values () (raise-argument-error 'standard-module-name-resolver \"(or/c #f namespace?)\" from-namespace_0)))"
"(if(unsafe-place-local-ref cell.6)(let-values()((unsafe-place-local-ref cell.6) s_0))(void))"
"(let-values(((hts_0)"
"(let-values(((or-part_0)"
"(registry-table-ref(namespace-module-registry$1(1/current-namespace)))))"
"(if or-part_0"
" or-part_0"
"(let-values(((hts_0)(cons(make-hasheq)(make-hasheq))))"
"(begin"
"(registry-table-set!(namespace-module-registry$1(1/current-namespace)) hts_0)"
" hts_0))))))"
"(begin"
"(hash-set!(car hts_0) s_0 'declared)"
"(if from-namespace_0"
"(let-values()"
"(let-values(((root-name_0)"
"(if(pair?(1/resolved-module-path-name s_0))"
"(1/make-resolved-module-path(car(1/resolved-module-path-name s_0)))"
" s_0))"
"((from-hts_0)(registry-table-ref(namespace-module-registry$1 from-namespace_0))))"
"(if from-hts_0"
"(let-values()"
"(let-values(((use-path/src_0)(hash-ref(cdr from-hts_0) root-name_0 #f)))"
"(if use-path/src_0(let-values()(hash-set!(cdr hts_0) root-name_0 use-path/src_0))(void))))"
"(void))))"
"(void)))))))"
"((s_0 relto_0 stx_0)"
"(begin"
"      (log-message (current-logger) 'error \"default module name resolver called with three arguments (deprecated)\" #f)"
"(standard-module-name-resolver s_0 relto_0 stx_0 #t)))"
"((s_0 relto_0 stx_0 load?_0)"
"(let-values((()"
"(begin"
"(if(1/module-path? s_0)"
"(void)"
"(let-values()"
"(if(syntax?$1 stx_0)"
"                          (raise-syntax-error$1 #f \"bad module path\" stx_0)"
"                          (raise-argument-error 'standard-module-name-resolver \"module-path?\" s_0))))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not relto_0)))"
"(if or-part_0 or-part_0(1/resolved-module-path? relto_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'standard-module-name-resolver"
"                           \"(or/c #f resolved-module-path?)\""
" relto_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not stx_0)))(if or-part_0 or-part_0(syntax?$1 stx_0)))"
"(void)"
"(let-values()"
"                            (raise-argument-error 'standard-module-name-resolver \"(or/c #f syntax?)\" stx_0)))"
"(values))))"
"(let-values(((flatten-sub-path_0)"
"(lambda(base_0 orig-l_0)"
"(begin"
" 'flatten-sub-path"
"((letrec-values(((loop_0)"
"(lambda(a_0 l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
"(let-values()"
"(if(null? a_0) base_0(cons base_0(reverse$1 a_0))))"
"                                                    (if (equal? (car l_0) \"..\")"
"(let-values()"
"(if(null? a_0)"
"(error"
" 'standard-module-name-resolver"
"                                                           \"too many \\\"..\\\"s in submodule path: ~.s\""
"(list*"
" 'submod"
"                                                            (if (equal? base_0 \".\")"
" base_0"
"(if(path? base_0)"
" base_0"
"(list(if(symbol? base_0) 'quote 'file) base_0)))"
" orig-l_0))"
"(loop_0(cdr a_0)(cdr l_0))))"
"(let-values()(loop_0(cons(car l_0) a_0)(cdr l_0)))))))))"
" loop_0)"
" null"
" orig-l_0)))))"
"(if(if(pair? s_0)(eq?(car s_0) 'quote) #f)"
"(let-values()(1/make-resolved-module-path(cadr s_0)))"
"(if(if(pair? s_0)"
"(if(eq?(car s_0) 'submod)(if(pair?(cadr s_0))(eq?(caadr s_0) 'quote) #f) #f)"
" #f)"
"(let-values()(1/make-resolved-module-path(flatten-sub-path_0(cadadr s_0)(cddr s_0))))"
"(if(if(pair? s_0)"
"(if(eq?(car s_0) 'submod)"
"                        (if (let-values (((or-part_0) (equal? (cadr s_0) \".\")))"
"                              (if or-part_0 or-part_0 (equal? (cadr s_0) \"..\")))"
"(if relto_0"
"(let-values(((p_0)(1/resolved-module-path-name relto_0)))"
"(let-values(((or-part_0)(symbol? p_0)))"
"(if or-part_0 or-part_0(if(pair? p_0)(symbol?(car p_0)) #f))))"
" #f)"
" #f)"
" #f)"
" #f)"
"(let-values()"
"(let-values(((rp_0)(1/resolved-module-path-name relto_0)))"
"(1/make-resolved-module-path"
"(flatten-sub-path_0"
"(if(pair? rp_0)(car rp_0) rp_0)"
"                        (let-values (((r_0) (if (equal? (cadr s_0) \"..\") (cdr s_0) (cddr s_0))))"
"(if(pair? rp_0)(append(cdr rp_0) r_0) r_0))))))"
"(if(if(pair? s_0)(eq?(car s_0) 'planet) #f)"
"(let-values()"
"(begin"
"(prep-planet-resolver!)"
"((unsafe-place-local-ref cell.6) s_0 relto_0 stx_0 load?_0 #f(unsafe-place-local-ref cell.5))))"
"(if(if(pair? s_0)"
"(if(eq?(car s_0) 'submod)(if(pair?(cadr s_0))(eq?(caadr s_0) 'planet) #f) #f)"
" #f)"
"(let-values()"
"(begin"
"(prep-planet-resolver!)"
"((unsafe-place-local-ref cell.6)"
"(cadr s_0)"
" relto_0"
" stx_0"
" load?_0"
"(cddr s_0)"
"(unsafe-place-local-ref cell.5))))"
"(let-values()"
"(let-values(((get-dir_0)"
"(lambda()"
"(begin"
" 'get-dir"
"(let-values(((or-part_0)"
"(if relto_0"
"(if(eq? relto_0(unsafe-place-local-ref cell.3))"
"(unsafe-place-local-ref cell.4)"
"(let-values(((p_0)(1/resolved-module-path-name relto_0)))"
"(let-values(((p_1)(if(pair? p_0)(car p_0) p_0)))"
"(if(path? p_1)"
"(let-values(((base_0 n_0 d?_0)(split-path p_1)))"
"(begin"
"(unsafe-place-local-set! cell.3 relto_0)"
"(unsafe-place-local-set! cell.4 base_0)"
" base_0))"
" #f))))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(current-load-relative-directory)))"
"(if or-part_1 or-part_1(current-directory))))))))"
"((get-reg_0)"
"(lambda()(begin 'get-reg(namespace-module-registry$1(1/current-namespace)))))"
"((show-collection-err_0)"
"(lambda(msg_0)"
"(begin"
" 'show-collection-err"
"(let-values(((msg_1)"
"(string-append"
"(let-values(((or-part_0)"
"(if stx_0"
"(if(error-print-source-location)"
"(format-source-location stx_0)"
" #f)"
" #f)))"
"                                                           (if or-part_0 or-part_0 \"standard-module-name-resolver\"))"
"                                                         \": \""
"(regexp-replace"
"                                                          '#rx\"\\n\""
" msg_0"
"(format"
"                                                           \"\\n  for module path: ~a\\n\""
"((error-module-path->string-handler)"
" s_0"
"(error-print-width)))))))"
"(raise"
"(if stx_0"
"(1/make-exn:fail:syntax:missing-module"
" msg_1"
"(current-continuation-marks)"
"(list(syntax-taint$1 stx_0))"
" s_0)"
"(1/make-exn:fail:filesystem:missing-module"
" msg_1"
"(current-continuation-marks)"
" s_0)))))))"
"((invent-collection-dir_0)"
"(lambda(f-file_0 col_0 col-path_0 fail_0)"
"(begin"
" 'invent-collection-dir"
"(lambda(msg_0)"
"(string->uninterned-symbol"
"(path->string"
"(build-path(apply build-path col_0 col-path_0) f-file_0)))))))"
"((ss->rkt_0)"
"(lambda(s_1)"
"(begin"
" 'ss->rkt"
"(let-values(((len_0)(string-length s_1)))"
"(if(if(>= len_0 3)"
"(if(equal? '#\\.(string-ref s_1(- len_0 3)))"
"(if(equal? '#\\s(string-ref s_1(- len_0 2)))"
"(equal? '#\\s(string-ref s_1(- len_0 1)))"
" #f)"
" #f)"
" #f)"
"                                              (string-append (substring s_1 0 (- len_0 3)) \".rkt\")"
" s_1)))))"
"((path-ss->rkt_0)"
"(lambda(p_0)"
"(begin"
" 'path-ss->rkt"
"(let-values(((base_0 name_0 dir?_0)(split-path p_0)))"
"                                            (if (regexp-match '#rx\"[.]ss$\" (path->bytes name_0))"
"                                              (path-replace-extension p_0 #\".rkt\")"
" p_0)))))"
"((s_1)"
"(if(if(pair? s_0)(eq? 'submod(car s_0)) #f)"
"(let-values(((v_0)(cadr s_0)))"
"                                          (if (let-values (((or-part_0) (equal? v_0 \".\")))"
"                                                (if or-part_0 or-part_0 (equal? v_0 \"..\")))"
"(if relto_0"
"(let-values(((p_0)(1/resolved-module-path-name relto_0)))"
"(if(pair? p_0)(car p_0) p_0))"
"(error"
" 'standard-module-name-resolver"
"                                               \"no base path for relative submodule path: ~.s\""
" s_0))"
" v_0))"
" s_0))"
"((subm-path_0)"
"(if(if(pair? s_0)(eq? 'submod(car s_0)) #f)"
"(let-values(((p_0)"
"                                                      (if (if (let-values (((or-part_0) (equal? (cadr s_0) \".\")))"
"                                                                (if or-part_0 or-part_0 (equal? (cadr s_0) \"..\")))"
" relto_0"
" #f)"
"(let-values(((p_0)(1/resolved-module-path-name relto_0))"
"((r_0)"
"                                                                      (if (equal? (cadr s_0) \"..\")"
"(cdr s_0)"
"(cddr s_0))))"
"(if(pair? p_0)"
"(flatten-sub-path_0(car p_0)(append(cdr p_0) r_0))"
"(flatten-sub-path_0 p_0 r_0)))"
"(flatten-sub-path_0"
"                                                         \".\""
"                                                         (if (equal? (cadr s_0) \"..\") (cdr s_0) (cddr s_0))))))"
"(if(pair? p_0)(cdr p_0) #f))"
" #f)))"
"(let-values(((s-parsed_0)"
"(if(symbol? s_1)"
"(let-values()"
"(let-values(((or-part_0)(path-cache-get s_1(get-reg_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((cols_0 file_0)"
"(split-relative-string(symbol->string s_1) #f)))"
"(let-values(((f-file_0)"
"(if(null? cols_0)"
"                                                                  \"main.rkt\""
"                                                                  (string-append file_0 \".rkt\"))))"
"(let-values(((col_0)(if(null? cols_0) file_0(car cols_0))))"
"(let-values(((col-path_0)(if(null? cols_0) null(cdr cols_0))))"
"(find-col-file"
"(if(not subm-path_0)"
" show-collection-err_0"
"(invent-collection-dir_0"
" f-file_0"
" col_0"
" col-path_0"
" show-collection-err_0))"
" col_0"
" col-path_0"
" f-file_0"
" #t))))))))"
"(if(string? s_1)"
"(let-values()"
"(let-values(((dir_0)(get-dir_0)))"
"(let-values(((or-part_0)(path-cache-get(cons s_1 dir_0) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((cols_0 file_0)(split-relative-string s_1 #f)))"
"(if(null? cols_0)"
"(build-path dir_0(ss->rkt_0 file_0))"
"(apply"
" build-path"
" dir_0"
"(append"
"(map2"
"(lambda(s_2)"
"                                                             (if (string=? s_2 \".\")"
"(let-values() 'same)"
"                                                               (if (string=? s_2 \"..\")"
"(let-values() 'up)"
"(let-values() s_2))))"
" cols_0)"
"(list(ss->rkt_0 file_0))))))))))"
"(if(path? s_1)"
"(let-values()"
"(path-ss->rkt_0"
"(simplify-path"
"(if(complete-path? s_1) s_1(path->complete-path s_1(get-dir_0))))))"
"(if(eq?(car s_1) 'lib)"
"(let-values()"
"(let-values(((or-part_0)(path-cache-get s_1(get-reg_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((cols_0 file_0)"
"(split-relative-string(cadr s_1) #f)))"
"(let-values(((old-style?_0)"
"(if(null?(cddr s_1))"
"(if(null? cols_0)"
"                                                                          (regexp-match? '#rx\"[.]\" file_0)"
" #f)"
" #t)))"
"(let-values(((f-file_0)"
"(if old-style?_0"
"(ss->rkt_0 file_0)"
"(if(null? cols_0)"
"                                                                            \"main.rkt\""
"                                                                            (if (regexp-match? '#rx\"[.]\" file_0)"
"(ss->rkt_0 file_0)"
"                                                                              (string-append file_0 \".rkt\"))))))"
"(let-values(((cols_1)"
"(if old-style?_0"
"(append"
"(if(null?(cddr s_1))"
"                                                                               '(\"mzlib\")"
"(apply"
" append"
"(map2"
"(lambda(p_0)"
"(split-relative-string p_0 #t))"
"(cddr s_1))))"
" cols_0)"
"(if(null? cols_0)(list file_0) cols_0))))"
"(find-col-file"
" show-collection-err_0"
"(car cols_1)"
"(cdr cols_1)"
" f-file_0"
" #t))))))))"
"(if(eq?(car s_1) 'file)"
"(let-values()"
"(path-ss->rkt_0"
"(simplify-path"
"(path->complete-path(expand-user-path(cadr s_1))(get-dir_0)))))"
"(void))))))))"
"(if(symbol? s-parsed_0)"
"(let-values()(1/make-resolved-module-path(cons s-parsed_0 subm-path_0)))"
"(if(not"
"(let-values(((or-part_0)(path? s-parsed_0)))"
"(if or-part_0 or-part_0(vector? s-parsed_0))))"
"(let-values()"
"(if stx_0"
"(raise-syntax-error$1"
" 'require"
"                                     (format \"bad module path~a\" (if s-parsed_0 (car s-parsed_0) \"\"))"
" stx_0)"
"                                    (raise-argument-error 'standard-module-name-resolver \"module-path?\" s_1)))"
"(let-values()"
"(let-values(((filename_0)"
"(if(vector? s-parsed_0)"
"(vector-ref s-parsed_0 0)"
"(simplify-path(cleanse-path s-parsed_0) #f))))"
"(let-values(((normal-filename_0)"
"(if(vector? s-parsed_0)"
"(vector-ref s-parsed_0 1)"
"(normal-case-path filename_0))))"
"(let-values(((base_0 name_0 dir?_0)"
"(if(vector? s-parsed_0)"
"(values 'ignored(vector-ref s-parsed_0 2) 'ignored)"
"(split-path filename_0))))"
"(let-values(((no-sfx_0)"
"(if(vector? s-parsed_0)"
"(vector-ref s-parsed_0 3)"
"                                                        (path-replace-extension name_0 #\"\"))))"
"(let-values(((root-modname_0)"
"(if(vector? s-parsed_0)"
"(vector-ref s-parsed_0 4)"
"(1/make-resolved-module-path filename_0))))"
"(let-values(((hts_0)"
"(let-values(((or-part_0)(registry-table-ref(get-reg_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((hts_0)(cons(make-hasheq)(make-hasheq))))"
"(begin"
"(registry-table-set!(get-reg_0) hts_0)"
" hts_0))))))"
"(let-values(((modname_0)"
"(if subm-path_0"
"(1/make-resolved-module-path"
"(cons"
"(1/resolved-module-path-name root-modname_0)"
" subm-path_0))"
" root-modname_0)))"
"(begin"
"(if load?_0"
"(let-values()"
"(let-values(((got_0)(hash-ref(car hts_0) modname_0 #f)))"
"(if got_0"
"(void)"
"(let-values()"
"(let-values(((loading_0)"
"(let-values(((tag_0)"
"(if(continuation-prompt-available?"
" -loading-prompt-tag)"
" -loading-prompt-tag"
"(default-continuation-prompt-tag))))"
"(continuation-mark-set-first"
" #f"
" -loading-filename"
" null"
" tag_0)))"
"((nsr_0)(get-reg_0)))"
"(begin"
"(for-each2"
"(lambda(s_2)"
"(if(if(equal?(cdr s_2) normal-filename_0)"
"(eq?(car s_2) nsr_0)"
" #f)"
"(let-values()"
"(error"
" 'standard-module-name-resolver"
"                                                                        \"cycle in loading\\n  at path: ~a\\n  paths:~a\""
" filename_0"
"(apply"
" string-append"
"((letrec-values(((loop_0)"
"(lambda(l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
" '()"
"(list*"
"                                                                                                  \"\\n   \""
"(path->string"
"(cdar l_0))"
"(loop_0"
"(cdr l_0))))))))"
" loop_0)"
"(reverse$1 loading_0)))))"
"(void)))"
" loading_0)"
"((if(continuation-prompt-available?"
" -loading-prompt-tag)"
"(lambda(f_0)(f_0))"
"(lambda(f_0)"
"(call-with-continuation-prompt"
" f_0"
" -loading-prompt-tag)))"
"(lambda()"
"(with-continuation-mark"
" -loading-filename"
"(cons(cons nsr_0 normal-filename_0) loading_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-module-declare-name"
" root-modname_0"
" 1/current-module-path-for-load"
"((if stx_0"
"(lambda(p_0)(1/datum->syntax #f p_0 stx_0))"
" values)"
"(if(symbol? s_1)"
"(let-values() s_1)"
"(if(if(pair? s_1)(eq?(car s_1) 'lib) #f)"
"(let-values() s_1)"
"(let-values()"
"(if(1/resolved-module-path?"
" root-modname_0)"
"(let-values(((src_0)"
"(1/resolved-module-path-name"
" root-modname_0)))"
"(if(symbol? src_0)"
"(list 'quote src_0)"
" src_0))"
" root-modname_0))))))"
"(let-values()"
"((1/current-load/use-compiled)"
" filename_0"
"(let-values(((sym_0)"
"(string->symbol"
"(path->string no-sfx_0))))"
"(if subm-path_0"
"(if(hash-ref(car hts_0) root-modname_0 #f)"
"(cons #f subm-path_0)"
"(cons sym_0 subm-path_0))"
" sym_0))))))))))))))"
"(void))"
"(if(if(not(vector? s-parsed_0))"
"(if load?_0"
"(let-values(((or-part_0)(string? s_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? s_1)))"
"(if or-part_1"
" or-part_1"
"(if(pair? s_1)(eq?(car s_1) 'lib) #f)))))"
" #f)"
" #f)"
"(let-values()"
"(path-cache-set!"
"(if(string? s_1)(cons s_1(get-dir_0)) s_1)"
"(if(string? s_1) #f(get-reg_0))"
"(vector"
" filename_0"
" normal-filename_0"
" name_0"
" no-sfx_0"
" root-modname_0)))"
"(void))"
" modname_0))))))))))))))))))))))))))"
"(define-values"
"(default-eval-handler)"
"(lambda(s_0)"
"(begin"
"(1/eval"
" s_0"
"(1/current-namespace)"
"(let-values(((c_0)(1/current-compile)))"
"(lambda(e_0 ns_0)"
"(if(eq? ns_0(1/current-namespace))"
"(c_0 e_0 #t)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace ns_0)"
"(let-values()(c_0 e_0 #t))))))))))"
"(define-values"
"(default-compile-handler)"
"(lambda(s_0 immediate-eval?_0)(begin(1/compile s_0(1/current-namespace)(not immediate-eval?_0)))))"
"(define-values"
"(default-read-interaction)"
"(lambda(src_0 in_0)"
"(begin"
"(begin"
"(if(input-port? in_0)"
"(void)"
"          (let-values () (raise-argument-error 'default-read-interaction \"input-port?\" in_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/read-accept-reader"
" #t"
" 1/read-accept-lang"
" #f)"
"(let-values()(1/read-syntax src_0 in_0)))))))"
"(define-values"
"(boot)"
"(lambda()"
"(begin"
"(begin"
"(unsafe-place-local-set! cell.1(make-weak-hasheq))"
"(unsafe-place-local-set! cell.2(make-weak-hasheq))"
"(seal)"
"(1/current-module-name-resolver standard-module-name-resolver)"
"(1/current-load/use-compiled default-load/use-compiled)"
"(1/current-reader-guard default-reader-guard)"
"(1/current-eval default-eval-handler)"
"(1/current-compile default-compile-handler)"
"(1/current-load default-load-handler)"
"(current-read-interaction default-read-interaction)))))"
"(define-values"
"(seal)"
"(lambda()"
"(begin(unsafe-place-local-set! cell.5(reparameterize(continuation-mark-set-first #f parameterization-key))))))"
"(define-values(get-original-parameterization)(lambda()(begin(unsafe-place-local-ref cell.5))))"
"(define-values"
"(default-current-read-interaction?)"
"(lambda()(begin(eq?(current-read-interaction) default-read-interaction))))"
"(define-values"
"(boot-primitives)"
"(hash"
" 'boot"
" boot"
" 'seal"
" seal"
" 'get-original-parameterization"
" get-original-parameterization"
" 'default-current-read-interaction?"
" default-current-read-interaction?))"
"(define-values"
"(load-configure-expand)"
"(lambda(mpi_0 ns_0)(begin(values current-parameterization current-parameterization))))"
"(define-values(set-load-configure-expand!)(lambda(proc_0)(begin(set! load-configure-expand proc_0))))"
"(define-values(exit-parameteterization-key)(gensym 'exit-paramz))"
"(define-values"
"(current-exit-parameterization)"
"(lambda()"
"(begin"
"(let-values(((or-part_0)(continuation-mark-set-first #f exit-parameteterization-key)))"
"(if or-part_0 or-part_0 current-parameterization)))))"
"(define-values"
"(enter-configure-parameterization)"
"(lambda(enter_0)"
"(begin"
"(call-with-parameterization"
"(check 'exit-parameterization((current-exit-parameterization)))"
"(lambda()(check 'enter-parameterization(enter_0)))))))"
"(define-values"
"(call-with-configure-parameterization)"
"(lambda(paramz_0 exit-paramz_0 thunk_0)"
"(begin"
"(with-continuation-mark"
" exit-parameteterization-key"
" exit-paramz_0"
"(call-with-parameterization paramz_0 thunk_0)))))"
"(define-values"
"(check)"
"(lambda(who_0 what_0)"
"(begin"
"(begin"
"        (if (parameterization? what_0) (void) (let-values () (raise-result-error who_0 \"parameterization?\" what_0)))"
" what_0))))"
"(define-values"
"(prepare-next-phase-namespace)"
"(lambda(ctx_0)"
"(begin"
"(let-values(((phase_0)(add1(expand-context-phase ctx_0))))"
"(let-values(((ns_0)(namespace->namespace-at-phase(expand-context-namespace ctx_0) phase_0)))"
"(namespace-visit-available-modules! ns_0 phase_0))))))"
"(define-values"
"(expand-body.1)"
"(lambda(source1_0 stratified?2_0 bodys5_0 ctx6_0)"
"(begin"
" 'expand-body"
"(let-values(((bodys_0) bodys5_0))"
"(let-values(((ctx_0) ctx6_0))"
"(let-values(((s_0) source1_0))"
"(let-values(((stratified?_0) stratified?2_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'enter-block bodys_0)))"
"(void)))"
"(values))))"
"(let-values(((inside-sc_0)(new-scope 'intdef)))"
"(let-values(((init-bodys_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" body_0"
" inside-sc_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'block-renames init-bodys_0 bodys_0)))"
"(void)))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((frame-id_0)(make-reference-record)))"
"(let-values(((def-ctx-scopes_0)(box null)))"
"(let-values(((body-ctx_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context51_0)(list(make-liberal-define-context)))"
"((name52_0) #f)"
"((only-immediate?53_0) #t)"
"((def-ctx-scopes54_0) def-ctx-scopes_0)"
"((post-expansion55_0)"
"(lambda(s_1)"
"(begin"
" 'post-expansion55"
"(add-scope s_1 inside-sc_0))))"
"((scopes56_0)"
"(append"
"(unbox"
"(let-values(((or-part_0)"
"(root-expand-context-use-site-scopes"
" ctx_0)))"
"(if or-part_0 or-part_0(box null))))"
"(cons inside-sc_0(expand-context-scopes ctx_0))))"
"((use-site-scopes57_0)(box null))"
"((frame-id58_0) frame-id_0)"
"((reference-records59_0)"
"(cons"
" frame-id_0"
"(expand-context-reference-records ctx_0)))"
"((inner60_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner60_0"
" post-expansion55_0"
" use-site-scopes57_0"
" frame-id58_0"
" context51_0"
"(expand-context/outer-env the-struct_0)"
" scopes56_0"
" def-ctx-scopes54_0"
"(expand-context/outer-binding-layer the-struct_0)"
" reference-records59_0"
" only-immediate?53_0"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name52_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                   \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((maybe-increment-binding-layer_0)"
"(lambda(ids_0 body-ctx_1)"
"(begin"
" 'maybe-increment-binding-layer"
"(if(eq?"
"(expand-context-binding-layer body-ctx_1)"
"(expand-context-binding-layer ctx_0))"
"(increment-binding-layer ids_0 body-ctx_1 inside-sc_0)"
"(expand-context-binding-layer body-ctx_1))))))"
"(let-values(((name_0)(expand-context-name ctx_0)))"
"((letrec-values(((loop_0)"
"(lambda(body-ctx_1"
" bodys_1"
" done-bodys_0"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" dups_0"
" just-saw-define-syntaxes?_0)"
"(begin"
" 'loop"
"(if(null? bodys_1)"
"(let-values()"
"(let-values(((body-ctx61_0) body-ctx_1)"
"((frame-id62_0) frame-id_0)"
"((def-ctx-scopes63_0) def-ctx-scopes_0)"
"((temp64_0)(reverse$1 val-idss_0))"
"((temp65_0)(reverse$1 val-keyss_0))"
"((temp66_0)(reverse$1 val-rhss_0))"
"((temp67_0)(reverse$1 track-stxs_0))"
"((temp68_0)(reverse$1 stx-clauses_0))"
"((temp69_0)(reverse$1 done-bodys_0))"
"((init-bodys70_0) init-bodys_0)"
"((s71_0) s_0)"
"((stratified?72_0) stratified?_0)"
"((just-saw-define-syntaxes?73_0)"
" just-saw-define-syntaxes?_0)"
"((name74_0) name_0)"
"((temp75_0)(reverse$1 trans-idss_0))"
"((temp76_0)(reverse$1 trans-stxs_0)))"
"(finish-expanding-body.1"
" temp75_0"
" temp76_0"
" just-saw-define-syntaxes?73_0"
" name74_0"
" init-bodys70_0"
" s71_0"
" stratified?72_0"
" body-ctx61_0"
" frame-id62_0"
" def-ctx-scopes63_0"
" temp64_0"
" temp65_0"
" temp66_0"
" temp67_0"
" temp68_0"
" temp69_0)))"
"(let-values()"
"(let-values(((rest-bodys_0)(cdr bodys_1)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-body_0)"
"(let-values(((temp77_0)(car bodys_1))"
"((temp78_0)"
"(if(if name_0"
"(null?"
"(cdr bodys_1))"
" #f)"
"(let-values(((v_0)"
" body-ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((name79_0)"
" name_0)"
"((inner80_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner80_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
" name79_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                       \"expand-context/outer?\""
" the-struct_0))))"
" body-ctx_1)))"
"(expand.1 #f #f temp77_0 temp78_0))))"
"(let-values(((tmp_0)"
"(core-form-sym exp-body_0 phase_0)))"
"(if(equal? tmp_0 'begin)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-begin"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 begin81_0 e82_0)"
"(let-values(((s_1)"
" exp-body_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((begin81_0"
" e82_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((begin83_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((e84_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_4)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                         \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin83_0"
" e84_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                 \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin81_0"
" e82_0))))))"
"(let-values(((track_0)"
"(lambda(e_0)"
"(begin"
" 'track"
"(syntax-track-origin$1"
" e_0"
" exp-body_0)))))"
"(let-values(((splice-bodys_0)"
"(append"
"(map2 track_0 e82_0)"
" rest-bodys_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'splice"
" splice-bodys_0)))"
"(void)))"
"(loop_0"
" body-ctx_1"
" splice-bodys_0"
" done-bodys_0"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" dups_0"
" just-saw-define-syntaxes?_0)))))))"
"(if(equal? tmp_0 'define-values)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-define-values"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" define-values85_0"
" id86_0"
" rhs87_0)"
"(let-values(((s_1)"
" exp-body_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((define-values85_0"
" id86_0"
" rhs87_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((define-values88_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((id89_0"
" rhs90_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((id91_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id94_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_7)"
"(symbol?"
"(syntax-e$1"
" s_7))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_7)))"
" s_7"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_0"
" s_7)))))"
"(cons"
" id94_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_2"
" rest_0)"
" id_2)))"
" id_1))))))"
" for-loop_0)"
" id_0"
" lst_0))))))"
"(reverse$1"
" id_0))))))))"
"((rhs92_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((rhs93_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs93_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values"
" id91_0"
" rhs92_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-values88_0"
" id89_0"
" rhs90_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                   \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-values85_0"
" id86_0"
" rhs87_0))))))"
"(let-values(((ids_0)"
"(remove-use-site-scopes"
" id86_0"
" body-ctx_1)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
"(list"
" ids_0"
" rhs87_0))))"
"(void)))"
"(values))))"
"(let-values(((new-dups_0)"
"(let-values(((ids95_0)"
" ids_0)"
"((phase96_0)"
" phase_0)"
"((exp-body97_0)"
" exp-body_0)"
"((dups98_0)"
" dups_0))"
"(check-no-duplicate-ids.1"
" unsafe-undefined"
" ids95_0"
" phase96_0"
" exp-body97_0"
" dups98_0))))"
"(let-values(((counter_0)"
"(root-expand-context-counter"
" ctx_0)))"
"(let-values(((local-sym_0)"
"(if(expand-context-normalize-locals?"
" ctx_0)"
" 'loc"
" #f)))"
"(let-values(((keys_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id99_0)"
" id_0)"
"((phase100_0)"
" phase_0)"
"((counter101_0)"
" counter_0)"
"((frame-id102_0)"
" frame-id_0)"
"((exp-body103_0)"
" exp-body_0)"
"((local-sym104_0)"
" local-sym_0))"
"(add-local-binding!.1"
" frame-id102_0"
" exp-body103_0"
" local-sym104_0"
" id99_0"
" phase100_0"
" counter101_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((extended-env_0)"
"(let-values(((env_0)"
"(let-values(((env_0)"
"(expand-context-env"
" body-ctx_1)))"
" env_0)))"
"(let-values(((lst_0)"
" keys_0)"
"((lst_1)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_1"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((key_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((env_2)"
"(let-values(((env_2)"
"(let-values()"
"(env-extend"
" env_1"
" key_0"
"(local-variable1.1"
" id_0)))))"
"(values"
" env_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_2"
" rest_0"
" rest_1)"
" env_2)))"
" env_1))))))"
" for-loop_0)"
" env_0"
" lst_0"
" lst_1))))))"
"(loop_0"
"(let-values(((v_0)"
" body-ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((env105_0)"
" extended-env_0)"
"((binding-layer106_0)"
"(maybe-increment-binding-layer_0"
" ids_0"
" body-ctx_1))"
"((inner107_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner107_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
" env105_0"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
" binding-layer106_0"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                      \"expand-context/outer?\""
" the-struct_0))))"
" rest-bodys_0"
" null"
"(cons"
" ids_0"
"(append"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" done-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" null)"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" val-idss_0))"
"(cons"
" keys_0"
"(append"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" done-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" null)"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" val-keyss_0))"
"(cons"
" rhs87_0"
"(append"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" done-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(no-binds"
" done-body_0"
" s_0"
" phase_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" val-rhss_0))"
"(cons"
"(let-values(((body-ctx108_0)"
" body-ctx_1)"
"((exp-body109_0)"
" exp-body_0)"
"((temp110_0)"
" #t))"
"(keep-as-needed.1"
" temp110_0"
" #f"
" #f"
" body-ctx108_0"
" exp-body109_0))"
"(append"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" done-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" #f)"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" track-stxs_0))"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" new-dups_0"
" #f)))))))))))"
"(if(equal? tmp_0 'define-syntaxes)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-define-syntaxes"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" define-syntaxes111_0"
" id112_0"
" rhs113_0)"
"(let-values(((s_1)"
" exp-body_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((define-syntaxes111_0"
" id112_0"
" rhs113_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((define-syntaxes114_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((id115_0"
" rhs116_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((id117_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id120_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_7)"
"(symbol?"
"(syntax-e$1"
" s_7))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_7)))"
" s_7"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_0"
" s_7)))))"
"(cons"
" id120_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_2"
" rest_0)"
" id_2)))"
" id_1))))))"
" for-loop_0)"
" id_0"
" lst_0))))))"
"(reverse$1"
" id_0))))))))"
"((rhs118_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((rhs119_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs119_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" id117_0"
" rhs118_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-syntaxes114_0"
" id115_0"
" rhs116_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                     \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-syntaxes111_0"
" id112_0"
" rhs113_0))))))"
"(let-values(((ids_0)"
"(remove-use-site-scopes"
" id112_0"
" body-ctx_1)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
"(list"
" ids_0"
" rhs113_0))))"
"(void)))"
"(values))))"
"(let-values(((new-dups_0)"
"(let-values(((ids121_0)"
" ids_0)"
"((phase122_0)"
" phase_0)"
"((exp-body123_0)"
" exp-body_0)"
"((dups124_0)"
" dups_0))"
"(check-no-duplicate-ids.1"
" unsafe-undefined"
" ids121_0"
" phase122_0"
" exp-body123_0"
" dups124_0))))"
"(let-values(((counter_0)"
"(root-expand-context-counter"
" ctx_0)))"
"(let-values(((local-sym_0)"
"(if(expand-context-normalize-locals?"
" ctx_0)"
" 'mac"
" #f)))"
"(let-values(((keys_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id125_0)"
" id_0)"
"((phase126_0)"
" phase_0)"
"((counter127_0)"
" counter_0)"
"((frame-id128_0)"
" frame-id_0)"
"((exp-body129_0)"
" exp-body_0)"
"((local-sym130_0)"
" local-sym_0))"
"(add-local-binding!.1"
" frame-id128_0"
" exp-body129_0"
" local-sym130_0"
" id125_0"
" phase126_0"
" counter127_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(prepare-next-phase-namespace"
" ctx_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-bind)))"
"(void)))"
"(values))))"
"(let-values(((vals_0)"
"(eval-for-syntaxes-binding"
" 'define-syntaxes"
" rhs113_0"
" ids_0"
" body-ctx_1)))"
"(let-values(((extended-env_0)"
"(let-values(((env_0)"
"(let-values(((env_0)"
"(expand-context-env"
" body-ctx_1)))"
" env_0)))"
"(let-values(((lst_0)"
" keys_0)"
"((lst_1)"
" vals_0)"
"((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_1"
" lst_3"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_3)"
"(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
" #f)"
"(let-values(((key_0)"
"(unsafe-car"
" lst_3))"
"((rest_0)"
"(unsafe-cdr"
" lst_3))"
"((val_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((env_2)"
"(let-values(((env_2)"
"(let-values()"
"(begin"
"(maybe-install-free=id-in-context!"
" val_0"
" id_0"
" phase_0"
" body-ctx_1)"
"(env-extend"
" env_1"
" key_0"
" val_0)))))"
"(values"
" env_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_2"
" rest_0"
" rest_1"
" rest_2)"
" env_2)))"
" env_1))))))"
" for-loop_0)"
" env_0"
" lst_0"
" lst_1"
" lst_2))))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-bind)))"
"(void)))"
"(loop_0"
"(let-values(((v_0)"
" body-ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((env131_0)"
" extended-env_0)"
"((binding-layer132_0)"
"(maybe-increment-binding-layer_0"
" ids_0"
" body-ctx_1))"
"((inner133_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner133_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
" env131_0"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
" binding-layer132_0"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                  \"expand-context/outer?\""
" the-struct_0))))"
" rest-bodys_0"
" done-bodys_0"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
"(cons"
" ids_0"
" trans-idss_0)"
"(cons"
"(let-values(((body-ctx134_0)"
" body-ctx_1)"
"((exp-body135_0)"
" exp-body_0)"
"((temp136_0)"
" #t))"
"(keep-as-needed.1"
" temp136_0"
" #f"
" #f"
" body-ctx134_0"
" exp-body135_0))"
" trans-stxs_0)"
"(cons"
"(datum->syntax$1"
" #f"
"(list"
" ids_0"
" rhs113_0)"
" exp-body_0)"
" stx-clauses_0)"
" new-dups_0"
" #t))))))))))))))))"
"(let-values()"
"(if stratified?_0"
"(let-values()"
"(begin"
"(if(null? done-bodys_0)"
"(void)"
"(let-values()"
"(error"
"                                                                                         \"internal error: accumulated expressions not empty\")))"
"(loop_0"
" body-ctx_1"
" null"
"(if(if(null? val-idss_0)"
"(null? trans-idss_0)"
" #f)"
"(reverse$1"
"(cons exp-body_0 rest-bodys_0))"
"(list"
"(datum->syntax$1"
" #f"
"(cons"
"(core-id"
" '#%stratified-body"
" phase_0)"
"(cons"
" exp-body_0"
" rest-bodys_0)))))"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" dups_0"
" #f)))"
"(let-values()"
"(loop_0"
" body-ctx_1"
" rest-bodys_0"
"(cons exp-body_0 done-bodys_0)"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" dups_0"
" #f)))))))))))))))))"
" loop_0)"
" body-ctx_0"
" init-bodys_0"
" null"
" null"
" null"
" null"
" null"
" null"
" null"
" null"
"(make-check-no-duplicate-table)"
" #f)))))))))))))))))))"
"(define-values(last)(lambda(xs_0)(begin(if(null?(cdr xs_0))(car xs_0)(last(cdr xs_0))))))"
"(define-values"
"(finish-expanding-body.1)"
"(lambda(disappeared-transformer-bindings13_0"
" disappeared-transformer-forms14_0"
" just-saw-define-syntaxes?11_0"
" name12_0"
" original-bodys8_0"
" source9_0"
" stratified?10_0"
" body-ctx22_0"
" frame-id23_0"
" def-ctx-scopes24_0"
" val-idss25_0"
" val-keyss26_0"
" val-rhss27_0"
" track-stxs28_0"
" stx-clauses29_0"
" done-bodys30_0)"
"(begin"
" 'finish-expanding-body"
"(let-values(((body-ctx_0) body-ctx22_0))"
"(let-values(((frame-id_0) frame-id23_0))"
"(let-values(((def-ctx-scopes_0) def-ctx-scopes24_0))"
"(let-values(((val-idss_0) val-idss25_0))"
"(let-values(((val-keyss_0) val-keyss26_0))"
"(let-values(((val-rhss_0) val-rhss27_0))"
"(let-values(((track-stxs_0) track-stxs28_0))"
"(let-values(((stx-clauses_0) stx-clauses29_0))"
"(let-values(((done-bodys_0) done-bodys30_0))"
"(let-values(((init-bodys_0) original-bodys8_0))"
"(let-values(((s_0) source9_0))"
"(let-values(((stratified?_0) stratified?10_0))"
"(let-values(((just-saw-define-syntaxes?_0) just-saw-define-syntaxes?11_0))"
"(let-values(((name_0) name12_0))"
"(let-values(((disappeared-transformer-bindings_0)"
" disappeared-transformer-bindings13_0))"
"(let-values(((disappeared-transformer-forms_0) disappeared-transformer-forms14_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(null? done-bodys_0)))"
"(if or-part_0 or-part_0 just-saw-define-syntaxes?_0))"
"(let-values()"
"(raise-syntax-error$1"
"                                                             (string->symbol \"begin (possibly implicit)\")"
"                                                             \"the last form is not an expression\""
"(datum->syntax$1 #f(cons 'begin init-bodys_0) s_0)"
"(if(null? init-bodys_0) #f(last init-bodys_0))))"
"(void))"
"(values))))"
"(let-values(((accum-ctx_0)"
"(accumulate-def-ctx-scopes body-ctx_0 def-ctx-scopes_0)))"
"(let-values(((finish-ctx_0)"
"(let-values(((v_0) accum-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context137_0) 'expression)"
"((use-site-scopes138_0)(box null))"
"((only-immediate?139_0) #f)"
"((def-ctx-scopes140_0) #f)"
"((scopes141_0)"
"(append"
"(unbox"
"(root-expand-context-use-site-scopes"
" accum-ctx_0))"
"(expand-context-scopes accum-ctx_0)))"
"((post-expansion142_0) #f)"
"((inner143_0)"
"(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner143_0"
" post-expansion142_0"
" use-site-scopes138_0"
"(root-expand-context/outer-frame-id the-struct_0)"
" context137_0"
"(expand-context/outer-env the-struct_0)"
" scopes141_0"
" def-ctx-scopes140_0"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
" only-immediate?139_0"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                 \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((finish-bodys_0)"
"(lambda(finish-ctx_1)"
"(begin"
" 'finish-bodys"
"(let-values(((last-i_0)(sub1(length done-bodys_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-list"
" done-bodys_0)))"
"(void)))"
"(values))))"
"(let-values(((exp-bodys_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0) done-bodys_0)"
"((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1"
" pos_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_1)"
" #t"
" #f)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(let-values(((done-body144_0)"
" done-body_0)"
"((temp145_0)"
"(if(if name_0"
"(="
" i_0"
" last-i_0)"
" #f)"
"(let-values(((v_0)"
" finish-ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((name146_0)"
" name_0)"
"((inner147_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner147_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
" name146_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                               \"expand-context/outer?\""
" the-struct_0))))"
" finish-ctx_1)))"
"(expand.1"
" #f"
" #f"
" done-body144_0"
" temp145_0))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0"
"(+"
" pos_0"
" 1))"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" start_0)))))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-list"
" exp-bodys_0)))"
"(void)))"
"(reference-record-clear! frame-id_0)"
" exp-bodys_0))))))))"
"(if(if(null? val-idss_0)"
"(null? disappeared-transformer-bindings_0)"
" #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer finish-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'block->list)))"
"(void)))"
"(finish-bodys_0 finish-ctx_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" finish-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'block->letrec"
" val-idss_0"
" val-rhss_0"
" done-bodys_0)))"
"(void)))"
"(values))))"
"(let-values(((exp-s_0)"
"(let-values(((val-idss148_0) val-idss_0)"
"((val-keyss149_0) val-keyss_0)"
"((val-rhss150_0) val-rhss_0)"
"((track-stxs151_0) track-stxs_0)"
"((temp152_0)(not stratified?_0))"
"((frame-id153_0) frame-id_0)"
"((finish-ctx154_0) finish-ctx_0)"
"((s155_0) s_0)"
"((temp156_0)(pair? stx-clauses_0))"
"((finish-bodys157_0) finish-bodys_0)"
"((temp158_0) #f))"
"(expand-and-split-bindings-by-reference.1"
" finish-ctx154_0"
" frame-id153_0"
" finish-bodys157_0"
" temp156_0"
" s155_0"
" temp152_0"
" temp158_0"
" val-idss148_0"
" val-keyss149_0"
" val-rhss150_0"
" track-stxs151_0))))"
"(if(expand-context-to-parsed? body-ctx_0)"
"(list exp-s_0)"
"(let-values(((exp-s_1)"
"(attach-disappeared-transformer-bindings"
" exp-s_0"
" disappeared-transformer-bindings_0)))"
"(let-values(((tracked-exp-s_0)"
"(let-values(((exp-s_2)"
"(let-values(((exp-s_2)"
" exp-s_1))"
" exp-s_2)))"
"(let-values(((lst_0)"
" disappeared-transformer-forms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(exp-s_3"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((form_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((exp-s_4)"
"(if form_0"
"(let-values(((exp-s_4)"
"(let-values()"
"(syntax-track-origin$1"
" exp-s_3"
" form_0))))"
"(values"
" exp-s_4))"
" exp-s_3)))"
"(if(not"
" #f)"
"(for-loop_0"
" exp-s_4"
" rest_0)"
" exp-s_4)))"
" exp-s_3))))))"
" for-loop_0)"
" exp-s_2"
" lst_0))))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer finish-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'finish-block"
"(list tracked-exp-s_0))))"
"(void)))"
"(list tracked-exp-s_0)))))))))))))))))))))))))))))))))"
"(define-values"
"(expand-and-split-bindings-by-reference.1)"
"(lambda(ctx34_0"
" frame-id33_0"
" get-body37_0"
" had-stxes?36_0"
" source35_0"
" split?32_0"
" track?38_0"
" idss46_0"
" keyss47_0"
" rhss48_0"
" track-stxs49_0)"
"(begin"
" 'expand-and-split-bindings-by-reference"
"(let-values(((idss_0) idss46_0))"
"(let-values(((keyss_0) keyss47_0))"
"(let-values(((rhss_0) rhss48_0))"
"(let-values(((track-stxs_0) track-stxs49_0))"
"(let-values(((split?_0) split?32_0))"
"(let-values(((frame-id_0) frame-id33_0))"
"(let-values(((ctx_0) ctx34_0))"
"(let-values(((s_0) source35_0))"
"(let-values()"
"(let-values(((get-body_0) get-body37_0))"
"(let-values(((track?_0) track?38_0))"
"(let-values()"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"((letrec-values(((loop_0)"
"(lambda(idss_1"
" keyss_1"
" rhss_1"
" track-stxs_1"
" accum-idss_0"
" accum-keyss_0"
" accum-rhss_0"
" accum-track-stxs_0"
" ctx_1"
" track?_1"
" get-list?_0)"
"(begin"
" 'loop"
"(if(null? idss_1)"
"(let-values()"
"(if(if(null? accum-idss_0) get-list?_0 #f)"
"(let-values()(get-body_0 ctx_1))"
"(let-values()"
"(let-values(((exp-body_0)(get-body_0 ctx_1)))"
"(let-values(((result-s_0)"
"(if(expand-context-to-parsed? ctx_1)"
"(if(null? accum-idss_0)"
"(parsed-let-values17.1"
"(keep-properties-only s_0)"
" null"
" null"
" exp-body_0)"
"(parsed-letrec-values18.1"
"(keep-properties-only s_0)"
"(reverse$1 accum-idss_0)"
"(reverse$1"
"(map2"
" list"
" accum-keyss_0"
" accum-rhss_0))"
" exp-body_0))"
"(let-values(((track?159_0) track?_1)"
"((s160_0) s_0)"
"((temp161_0)"
"(list*"
"(if(null? accum-idss_0)"
"(core-id"
" 'let-values"
" phase_0)"
"(core-id"
" 'letrec-values"
" phase_0))"
"(build-clauses"
" accum-idss_0"
" accum-rhss_0"
" accum-track-stxs_0)"
" exp-body_0)))"
"(rebuild.1"
" track?159_0"
" s160_0"
" temp161_0)))))"
"(if get-list?_0(list result-s_0) result-s_0))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((ids_0)(car idss_1)))"
"(let-values(((expanded-rhs_0)"
"(let-values(((temp162_0)(car rhss_1))"
"((temp163_0)"
"(as-named-context"
" ctx_1"
" ids_0)))"
"(expand.1 #f #f temp162_0 temp163_0))))"
"(let-values(((track-stx_0)(car track-stxs_1)))"
"(let-values(((local-or-forward-references?_0)"
"(reference-record-forward-references?"
" frame-id_0)))"
"(let-values((()"
"(begin"
"(reference-record-bound!"
" frame-id_0"
"(car keyss_1))"
"(values))))"
"(let-values(((forward-references?_0)"
"(reference-record-forward-references?"
" frame-id_0)))"
"(if(if(not local-or-forward-references?_0)"
" split?_0"
" #f)"
"(let-values()"
"(let-values((()"
"(begin"
"(if(null? accum-idss_0)"
"(void)"
"(let-values()"
"(error"
"                                                                                                 \"internal error: accumulated ids not empty\")))"
"(values))))"
"(let-values(((next-idss_0 next-ctx_0)"
"(create-binding-layer"
"(cdr idss_1)"
"(cdr keyss_1)"
" ctx_1)))"
"(let-values(((exp-rest_0)"
"(loop_0"
" next-idss_0"
"(cdr keyss_1)"
"(cdr rhss_1)"
"(cdr track-stxs_1)"
" null"
" null"
" null"
" null"
" next-ctx_0"
" #f"
" #t)))"
"(let-values(((result-s_0)"
"(if(expand-context-to-parsed?"
" next-ctx_0)"
"(parsed-let-values17.1"
"(keep-properties-only"
" s_0)"
"(list ids_0)"
"(list"
"(list"
"(car keyss_1)"
" expanded-rhs_0))"
" exp-rest_0)"
"(let-values(((track?164_0)"
" track?_1)"
"((s165_0)"
" s_0)"
"((temp166_0)"
"(list*"
"(core-id"
" 'let-values"
" phase_0)"
"(list"
"(build-clause"
" ids_0"
" expanded-rhs_0"
" track-stx_0))"
" exp-rest_0)))"
"(rebuild.1"
" track?164_0"
" s165_0"
" temp166_0)))))"
"(if get-list?_0"
"(list result-s_0)"
" result-s_0))))))"
"(if(if(not forward-references?_0)"
"(let-values(((or-part_0) split?_0))"
"(if or-part_0"
" or-part_0"
"(null?(cdr idss_1))))"
" #f)"
"(let-values()"
"(let-values(((next-idss_0 next-ctx_0)"
"(create-binding-layer"
"(cdr idss_1)"
"(cdr keyss_1)"
" ctx_1)))"
"(let-values(((exp-rest_0)"
"(loop_0"
" next-idss_0"
"(cdr keyss_1)"
"(cdr rhss_1)"
"(cdr track-stxs_1)"
" null"
" null"
" null"
" null"
" next-ctx_0"
" #f"
" #t)))"
"(let-values(((result-s_0)"
"(if(expand-context-to-parsed?"
" next-ctx_0)"
"(parsed-letrec-values18.1"
"(keep-properties-only"
" s_0)"
"(reverse$1"
"(cons"
" ids_0"
" accum-idss_0))"
"(reverse$1"
"(cons"
"(list"
"(car keyss_1)"
" expanded-rhs_0)"
"(map2"
" list"
" accum-keyss_0"
" accum-rhss_0)))"
" exp-rest_0)"
"(let-values(((track?167_0)"
" track?_1)"
"((s168_0)"
" s_0)"
"((temp169_0)"
"(list*"
"(core-id"
" 'letrec-values"
" phase_0)"
"(build-clauses"
"(cons"
" ids_0"
" accum-idss_0)"
"(cons"
" expanded-rhs_0"
" accum-rhss_0)"
"(cons"
" track-stx_0"
" accum-track-stxs_0))"
" exp-rest_0)))"
"(rebuild.1"
" track?167_0"
" s168_0"
" temp169_0)))))"
"(if get-list?_0"
"(list result-s_0)"
" result-s_0)))))"
"(let-values()"
"(loop_0"
"(cdr idss_1)"
"(cdr keyss_1)"
"(cdr rhss_1)"
"(cdr track-stxs_1)"
"(cons ids_0 accum-idss_0)"
"(cons(car keyss_1) accum-keyss_0)"
"(cons expanded-rhs_0 accum-rhss_0)"
"(cons track-stx_0 accum-track-stxs_0)"
" ctx_1"
" track?_1"
" get-list?_0)))))))))))))))))"
" loop_0)"
" idss_0"
" keyss_0"
" rhss_0"
" track-stxs_0"
" null"
" null"
" null"
" null"
" ctx_0"
" track?_0"
" #f)))))))))))))))))"
"(define-values"
"(create-binding-layer)"
"(lambda(idss_0 keyss_0 ctx_0)"
"(begin"
"(if(let-values(((or-part_0)(expand-context-to-parsed? ctx_0)))(if or-part_0 or-part_0(null? idss_0)))"
"(let-values()(values idss_0 ctx_0))"
"(let-values()"
"(let-values(((sc_0)(new-scope 'local)))"
"(let-values(((new-idss_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((ids_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" sc_0))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((env_0)(expand-context-env ctx_0)))"
"(let-values(((new-env_0)"
"(let-values(((env_1)(let-values(((env_1) env_0)) env_1)))"
"(let-values(((lst_0) new-idss_0)((lst_1) keyss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_2 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((new-ids_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((keys_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((env_3)"
"(let-values(((lst_4) new-ids_0)"
"((lst_5) keys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_5)))"
"((letrec-values(((for-loop_1)"
"(lambda(env_3"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((new-id_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((key_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((env_4)"
"(let-values(((env_4)"
"(let-values()"
"(env-extend"
" env_3"
" key_0"
"(local-variable1.1"
" new-id_0)))))"
"(values"
" env_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" env_4"
" rest_2"
" rest_3)"
" env_4)))"
" env_3)))))"
" for-loop_1)"
" env_2"
" lst_4"
" lst_5)))))"
"(if(not #f)(for-loop_0 env_3 rest_0 rest_1) env_3)))"
" env_2))))))"
" for-loop_0)"
" env_1"
" lst_0"
" lst_1))))))"
"(values"
" new-idss_0"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((env170_0) new-env_0)((inner171_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner171_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
" env170_0"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"                         (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))))))))))"
"(define-values"
"(build-clauses)"
"(lambda(accum-idss_0 accum-rhss_0 accum-track-stxs_0)"
"(begin(map2 build-clause(reverse$1 accum-idss_0)(reverse$1 accum-rhss_0)(reverse$1 accum-track-stxs_0)))))"
"(define-values"
"(build-clause)"
"(lambda(ids_0 rhs_0 track-stx_0)"
"(begin"
"(let-values(((clause_0)(datum->syntax$1 #f(list ids_0 rhs_0))))"
"(if track-stx_0(syntax-track-origin$1 clause_0 track-stx_0) clause_0)))))"
"(define-values"
"(no-binds)"
"(lambda(expr_0 s_0 phase_0)"
"(begin"
"(let-values(((s-runtime-stx_0)(syntax-shift-phase-level$1 runtime-stx phase_0)))"
"(datum->syntax$1"
"(core-id '#%app phase_0)"
"(list(core-id 'begin phase_0) expr_0(list(datum->syntax$1 s-runtime-stx_0 'values)))"
" s_0)))))"
"(define-values"
"(lambda-clause-expander)"
"(lambda(s_0 formals_0 bodys_0 ctx_0)"
"(begin"
"(let-values(((sc_0)(if(not(expand-context-parsing-expanded? ctx_0))(new-scope 'local) #f)))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((ids_0)(parse-and-flatten-formals formals_0 sc_0 s_0)))"
"(let-values((()"
"(begin"
"(let-values(((ids15_0) ids_0)"
"((phase16_0) phase_0)"
"((s17_0) s_0)"
"                                         ((temp18_0) \"argument name\"))"
"(check-no-duplicate-ids.1 temp18_0 ids15_0 phase16_0 s17_0 unsafe-undefined))"
"(values))))"
"(let-values(((counter_0)(root-expand-context-counter ctx_0)))"
"(let-values(((local-sym_0)(if(expand-context-normalize-locals? ctx_0) 'arg #f)))"
"(let-values(((keys_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if sc_0"
"(let-values(((id19_0)"
" id_0)"
"((phase20_0)"
" phase_0)"
"((counter21_0)"
" counter_0)"
"((s22_0)"
" s_0)"
"((local-sym23_0)"
" local-sym_0))"
"(add-local-binding!.1"
" #f"
" s22_0"
" local-sym23_0"
" id19_0"
" phase20_0"
" counter21_0))"
"(existing-binding-key"
" id_0"
"(expand-context-phase"
" ctx_0))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((body-env_0)"
"(let-values(((env_0)(let-values(((env_0)(expand-context-env ctx_0))) env_0)))"
"(let-values(((lst_0) keys_0)((lst_1) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((key_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((id_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((env_2)"
"(let-values(((env_2)"
"(let-values()"
"(env-extend"
" env_1"
" key_0"
"(local-variable1.1"
" id_0)))))"
"(values env_2))))"
"(if(not #f)"
"(for-loop_0 env_2 rest_0 rest_1)"
" env_2)))"
" env_1))))))"
" for-loop_0)"
" env_0"
" lst_0"
" lst_1))))))"
"(let-values(((sc-formals_0)(if sc_0(add-scope formals_0 sc_0) formals_0)))"
"(let-values(((sc-bodys_0)"
"(if sc_0"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" body_0"
" sc_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" bodys_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'lambda-renames sc-formals_0 sc-bodys_0)))"
"(void)))"
"(values))))"
"(let-values(((body-ctx_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((env24_0) body-env_0)"
"((scopes25_0)"
"(if sc_0"
"(cons sc_0(expand-context-scopes ctx_0))"
"(expand-context-scopes ctx_0)))"
"((binding-layer26_0)"
"(if sc_0"
"(increment-binding-layer ids_0 ctx_0 sc_0)"
"(expand-context-binding-layer ctx_0)))"
"((name27_0) #f)"
"((frame-id28_0) #f)"
"((inner29_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner29_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
" frame-id28_0"
"(expand-context/outer-context the-struct_0)"
" env24_0"
" scopes25_0"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
" binding-layer26_0"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name27_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                 \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((exp-body_0)"
"(if sc_0"
"(let-values(((sc-bodys30_0) sc-bodys_0)"
"((body-ctx31_0) body-ctx_0)"
"((temp32_0)"
"(let-values(((ctx33_0) ctx_0)"
"((s34_0) s_0)"
"((temp35_0) #t))"
"(keep-as-needed.1 #f temp35_0 #f ctx33_0 s34_0))))"
"(expand-body.1 temp32_0 #f sc-bodys30_0 body-ctx31_0))"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) sc-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((sc-body_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((sc-body36_0)"
" sc-body_0)"
"((body-ctx37_0)"
" body-ctx_0))"
"(expand.1"
" #f"
" #f"
" sc-body36_0"
" body-ctx37_0)))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(values"
"(if(expand-context-to-parsed? ctx_0)"
"(unflatten-like-formals keys_0 formals_0)"
" sc-formals_0)"
" exp-body_0)))))))))))))))))"
"(void"
"(add-core-form!*"
" 'lambda"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-lambda s_0)))(void)))"
"(values))))"
"(let-values(((ok?_0 lambda38_0 formals39_0 body40_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((lambda38_0 formals39_0 body40_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((lambda41_0)(let-values(((s_3)(car s_2))) s_3))"
"((formals42_0 body43_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((formals44_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((body45_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1 s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                        \"bad syntax\""
" orig-s_0))"
"(if(null? flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                          \"bad syntax\""
" orig-s_0))"
"(let-values() flat-s_0))))))))"
"(values formals44_0 body45_0))"
"                                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values lambda41_0 formals42_0 body43_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t lambda38_0 formals39_0 body40_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx46_0) ctx_0)((s47_0) s_0)((temp48_0) #t))"
"(keep-as-needed.1 #f #f temp48_0 ctx46_0 s47_0))))"
"(let-values(((formals_0 body_0)(lambda-clause-expander s_0 formals39_0 body40_0 ctx_0)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-lambda5.1 rebuild-s_0 formals_0 body_0)"
"(let-values(((rebuild-s49_0) rebuild-s_0)((temp50_0)(list* lambda38_0 formals_0 body_0)))"
"(rebuild.1 #t rebuild-s49_0 temp50_0))))))))))"
"(void"
"(add-core-form!*"
" 'λ"
"(lambda(s_0)"
"(let-values(((ok?_0 lam-id51_0 formals52_0 _53_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((lam-id51_0 formals52_0 _53_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((lam-id54_0)(let-values(((s_3)(car s_2))) s_3))"
"((formals55_0 _56_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((formals57_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((_58_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1 s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                      \"bad syntax\""
" orig-s_0))"
"(if(null? flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                        \"bad syntax\""
" orig-s_0))"
"(let-values() flat-s_0))))))))"
"(values formals57_0 _58_0))"
"                                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values lam-id54_0 formals55_0 _56_0))"
"                                         (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t lam-id51_0 formals52_0 _53_0))))))"
"(let-values(((ids_0)(parse-and-flatten-formals formals52_0 #f s_0)))"
"(let-values(((ctx_0)(let-values(((temp63_0) #t))(get-current-expand-context.1 temp63_0 'unexpected))))"
"(let-values(((phase_0)(if ctx_0(expand-context-phase ctx_0) 0)))"
"(begin"
"               (let-values (((ids59_0) ids_0) ((phase60_0) phase_0) ((s61_0) s_0) ((temp62_0) \"argument name\"))"
"(check-no-duplicate-ids.1 temp62_0 ids59_0 phase60_0 s61_0 unsafe-undefined))"
"(datum->syntax$1"
" s_0"
"(cons"
"(datum->syntax$1(syntax-shift-phase-level$1 core-stx phase_0) 'lambda lam-id51_0 lam-id51_0)"
"(cdr(syntax-e$1 s_0)))"
" s_0"
" s_0)))))))))"
"(void"
"(add-core-form!*"
" 'case-lambda"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-case-lambda s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 case-lambda64_0 formals65_0 body66_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((case-lambda64_0 formals65_0 body66_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((case-lambda67_0)(let-values(((s_3)(car s_2))) s_3))"
"((formals68_0 body69_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                   (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values()"
"(let-values(((formals_0 body_0)"
"(let-values(((formals_0)"
"(let-values(((formals_0)"
" null))"
" formals_0))"
"((body_0)"
"(let-values(((body_0)"
" null))"
" body_0)))"
"(let-values(((lst_0) flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(formals_1"
" body_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_5)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((formals_2"
" body_2)"
"(let-values(((formals_2"
" body_2)"
"(let-values()"
"(let-values(((formals76_0"
" body77_0)"
"(let-values()"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((formals70_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((body71_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_1)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                              \"bad syntax\""
" orig-s_0))"
"(if(null?"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_1))))))))"
"(values"
" formals70_0"
" body71_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" formals76_0"
" formals_1)"
"(cons"
" body77_0"
" body_1))))))"
"(values"
" formals_2"
" body_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" formals_2"
" body_2"
" rest_0)"
"(values"
" formals_2"
" body_2))))"
"(values"
" formals_1"
" body_1)))))))"
" for-loop_0)"
" formals_0"
" body_0"
" lst_0))))))"
"(values"
"(reverse$1 formals_0)"
"(reverse$1 body_0))))))))))"
"(values case-lambda67_0 formals68_0 body69_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t case-lambda64_0 formals65_0 body66_0))))))"
"(let-values(((ok?_1 case-lambda72_0 clause73_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((case-lambda72_0 clause73_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((case-lambda74_0)(let-values(((s_3)(car s_2))) s_3))"
"((clause75_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                     (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values case-lambda74_0 clause75_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t case-lambda72_0 clause73_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx78_0) ctx_0)((s79_0) s_0)((temp80_0) #t))"
"(keep-as-needed.1 #f #f temp80_0 ctx78_0 s79_0))))"
"(let-values(((clauses_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) formals65_0)((lst_1) body66_0)((lst_2) clause73_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_3 lst_4 lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair? lst_3)(if(pair? lst_4)(pair? lst_5) #f) #f)"
"(let-values(((formals_0)(unsafe-car lst_3))"
"((rest_0)(unsafe-cdr lst_3))"
"((body_0)(unsafe-car lst_4))"
"((rest_1)(unsafe-cdr lst_4))"
"((clause_0)(unsafe-car lst_5))"
"((rest_2)(unsafe-cdr lst_5)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((rebuild-clause_0)"
"(let-values(((ctx81_0)"
" ctx_0)"
"((clause82_0)"
" clause_0))"
"(keep-as-needed.1"
" #f"
" #f"
" #f"
" ctx81_0"
" clause82_0))))"
"(let-values(((exp-formals_0"
" exp-body_0)"
"(lambda-clause-expander"
" s_0"
" formals_0"
" body_0"
" ctx_0)))"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(list"
" exp-formals_0"
" exp-body_0)"
"(let-values(((rebuild-clause83_0)"
" rebuild-clause_0)"
"((temp84_0)"
"(list*"
" exp-formals_0"
" exp-body_0)))"
"(rebuild.1"
" #t"
" rebuild-clause83_0"
" temp84_0)))))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0 rest_1 rest_2)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1"
" lst_2)))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-case-lambda6.1 rebuild-s_0 clauses_0)"
"(let-values(((rebuild-s85_0) rebuild-s_0)((temp86_0)(list* case-lambda64_0 clauses_0)))"
"(rebuild.1 #t rebuild-s85_0 temp86_0)))))))))))"
"(define-values"
"(parse-and-flatten-formals)"
"(lambda(all-formals_0 sc_0 s_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(formals_0)"
"(begin"
" 'loop"
"(if(identifier? formals_0)"
"(let-values()(list(if sc_0(add-scope formals_0 sc_0) formals_0)))"
"(if(syntax?$1 formals_0)"
"(let-values()"
"(let-values(((p_0)(syntax-e$1 formals_0)))"
"(if(pair? p_0)"
"(let-values()(loop_0 p_0))"
"(if(null? p_0)"
"(let-values() null)"
"                                        (let-values () (raise-syntax-error$1 #f \"not an identifier\" s_0 p_0))))))"
"(if(pair? formals_0)"
"(let-values()"
"(begin"
"(if(identifier?(car formals_0))"
"(void)"
"(let-values()"
"                                          (raise-syntax-error$1 #f \"not an identifier\" s_0 (car formals_0))))"
"(cons"
"(if sc_0(add-scope(car formals_0) sc_0)(car formals_0))"
"(loop_0(cdr formals_0)))))"
"(if(null? formals_0)"
"(let-values() null)"
"(let-values()"
"                                      (raise-syntax-error$1 \"bad argument sequence\" s_0 all-formals_0))))))))))"
" loop_0)"
" all-formals_0))))"
"(define-values"
"(unflatten-like-formals)"
"(lambda(keys_0 formals_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(keys_1 formals_1)"
"(begin"
" 'loop"
"(if(null? formals_1)"
"(let-values() null)"
"(if(pair? formals_1)"
"(let-values()(cons(car keys_1)(loop_0(cdr keys_1)(cdr formals_1))))"
"(if(syntax?$1 formals_1)"
"(let-values()(loop_0 keys_1(syntax-e$1 formals_1)))"
"(let-values()(car keys_1)))))))))"
" loop_0)"
" keys_0"
" formals_0))))"
"(define-values"
"(make-let-values-form.1)"
"(lambda(log-tag1_0 rec?3_0 split-by-reference?4_0 syntaxes?2_0)"
"(begin"
" 'make-let-values-form"
"(let-values(((log-tag_0) log-tag1_0))"
"(let-values(((syntaxes?_0) syntaxes?2_0))"
"(let-values(((rec?_0) rec?3_0))"
"(let-values(((split-by-reference?_0) split-by-reference?4_0))"
"(let-values()"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 log-tag_0 s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" letrec-syntaxes+values87_0"
" id:trans88_0"
" trans-rhs89_0"
" id:val90_0"
" val-rhs91_0"
" body92_0)"
"(let-values(((s_1) s_0))"
"(if(if syntaxes?_0 #t #f)"
"(let-values(((orig-s_0) s_1))"
"(let-values(((letrec-syntaxes+values87_0"
" id:trans88_0"
" trans-rhs89_0"
" id:val90_0"
" val-rhs91_0"
" body92_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((letrec-syntaxes+values93_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id:trans94_0"
" trans-rhs95_0"
" id:val96_0"
" val-rhs97_0"
" body98_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((id:trans99_0"
" trans-rhs100_0)"
"(let-values(((s_5)"
"(car s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                       \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:trans_0"
" trans-rhs_0)"
"(let-values(((id:trans_0)"
"(let-values(((id:trans_0)"
" null))"
" id:trans_0))"
"((trans-rhs_0)"
"(let-values(((trans-rhs_0)"
" null))"
" trans-rhs_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id:trans_1"
" trans-rhs_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id:trans_2"
" trans-rhs_2)"
"(let-values(((id:trans_2"
" trans-rhs_2)"
"(let-values()"
"(let-values(((id:trans130_0"
" trans-rhs131_0)"
"(let-values()"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(pair?"
" s_8)"
"(let-values(((id:trans104_0)"
"(let-values(((s_9)"
"(car"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(let-values(((flat-s_1)"
"(to-syntax-list.1"
" s_10)))"
"(if(not"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:trans_2)"
"(let-values(((id:trans_2)"
"(let-values(((id:trans_2)"
" null))"
" id:trans_2)))"
"(let-values(((lst_2)"
" flat-s_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id:trans_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_11)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id:trans_4)"
"(let-values(((id:trans_4)"
"(let-values()"
"(let-values(((id:trans132_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_11)"
"(symbol?"
"(syntax-e$1"
" s_11))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_11)))"
" s_11"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_0"
" s_11)))))"
"(cons"
" id:trans132_0"
" id:trans_3)))))"
"(values"
" id:trans_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" id:trans_4"
" rest_1)"
" id:trans_4)))"
" id:trans_3))))))"
" for-loop_1)"
" id:trans_2"
" lst_2))))))"
"(reverse$1"
" id:trans_2))))))))"
"((trans-rhs105_0)"
"(let-values(((s_9)"
"(cdr"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(pair?"
" s_10)"
"(let-values(((trans-rhs106_0)"
"(let-values(((s_11)"
"(car"
" s_10)))"
" s_11))"
"(()"
"(let-values(((s_11)"
"(cdr"
" s_10)))"
"(let-values(((s_12)"
"(if(syntax?$1"
" s_11)"
"(syntax-e$1"
" s_11)"
" s_11)))"
"(if(null?"
" s_12)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" trans-rhs106_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:trans104_0"
" trans-rhs105_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" id:trans130_0"
" id:trans_1)"
"(cons"
" trans-rhs131_0"
" trans-rhs_1))))))"
"(values"
" id:trans_2"
" trans-rhs_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id:trans_2"
" trans-rhs_2"
" rest_0)"
"(values"
" id:trans_2"
" trans-rhs_2))))"
"(values"
" id:trans_1"
" trans-rhs_1)))))))"
" for-loop_0)"
" id:trans_0"
" trans-rhs_0"
" lst_0))))))"
"(values"
"(reverse$1"
" id:trans_0)"
"(reverse$1"
" trans-rhs_0)))))))))"
"((id:val101_0"
" val-rhs102_0"
" body103_0)"
"(let-values(((s_5)"
"(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((id:val107_0"
" val-rhs108_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                           \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:val_0"
" val-rhs_0)"
"(let-values(((id:val_0)"
"(let-values(((id:val_0)"
" null))"
" id:val_0))"
"((val-rhs_0)"
"(let-values(((val-rhs_0)"
" null))"
" val-rhs_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id:val_1"
" val-rhs_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_9)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id:val_2"
" val-rhs_2)"
"(let-values(((id:val_2"
" val-rhs_2)"
"(let-values()"
"(let-values(((id:val133_0"
" val-rhs134_0)"
"(let-values()"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(pair?"
" s_10)"
"(let-values(((id:val110_0)"
"(let-values(((s_11)"
"(car"
" s_10)))"
"(let-values(((s_12)"
"(if(syntax?$1"
" s_11)"
"(syntax-e$1"
" s_11)"
" s_11)))"
"(let-values(((flat-s_1)"
"(to-syntax-list.1"
" s_12)))"
"(if(not"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:val_2)"
"(let-values(((id:val_2)"
"(let-values(((id:val_2)"
" null))"
" id:val_2)))"
"(let-values(((lst_2)"
" flat-s_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id:val_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_13)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id:val_4)"
"(let-values(((id:val_4)"
"(let-values()"
"(let-values(((id:val135_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_13)"
"(symbol?"
"(syntax-e$1"
" s_13))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_13)))"
" s_13"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                                     \"not an identifier\""
" orig-s_0"
" s_13)))))"
"(cons"
" id:val135_0"
" id:val_3)))))"
"(values"
" id:val_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" id:val_4"
" rest_1)"
" id:val_4)))"
" id:val_3))))))"
" for-loop_1)"
" id:val_2"
" lst_2))))))"
"(reverse$1"
" id:val_2))))))))"
"((val-rhs111_0)"
"(let-values(((s_11)"
"(cdr"
" s_10)))"
"(let-values(((s_12)"
"(if(syntax?$1"
" s_11)"
"(syntax-e$1"
" s_11)"
" s_11)))"
"(if(pair?"
" s_12)"
"(let-values(((val-rhs112_0)"
"(let-values(((s_13)"
"(car"
" s_12)))"
" s_13))"
"(()"
"(let-values(((s_13)"
"(cdr"
" s_12)))"
"(let-values(((s_14)"
"(if(syntax?$1"
" s_13)"
"(syntax-e$1"
" s_13)"
" s_13)))"
"(if(null?"
" s_14)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" val-rhs112_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:val110_0"
" val-rhs111_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" id:val133_0"
" id:val_1)"
"(cons"
" val-rhs134_0"
" val-rhs_1))))))"
"(values"
" id:val_2"
" val-rhs_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id:val_2"
" val-rhs_2"
" rest_0)"
"(values"
" id:val_2"
" val-rhs_2))))"
"(values"
" id:val_1"
" val-rhs_1)))))))"
" for-loop_0)"
" id:val_0"
" val-rhs_0"
" lst_0))))))"
"(values"
"(reverse$1"
" id:val_0)"
"(reverse$1"
" val-rhs_0)))))))))"
"((body109_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                           \"bad syntax\""
" orig-s_0))"
"(if(null?"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                             \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0))))))))"
"(values"
" id:val107_0"
" val-rhs108_0"
" body109_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:trans99_0"
" trans-rhs100_0"
" id:val101_0"
" val-rhs102_0"
" body103_0))"
"(raise-syntax-error$1"
" #f"
"                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" letrec-syntaxes+values93_0"
" id:trans94_0"
" trans-rhs95_0"
" id:val96_0"
" val-rhs97_0"
" body98_0))"
"                                                          (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values"
" #t"
" letrec-syntaxes+values87_0"
" id:trans88_0"
" trans-rhs89_0"
" id:val90_0"
" val-rhs91_0"
" body92_0)))"
"(values #f #f #f #f #f #f #f)))))"
"(let-values(((ok?_1 let-values113_0 id:val114_0 val-rhs115_0 body116_0)"
"(let-values(((s_1) s_0))"
"(if(if(not syntaxes?_0) #t #f)"
"(let-values(((orig-s_0) s_1))"
"(let-values(((let-values113_0 id:val114_0 val-rhs115_0 body116_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((let-values117_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id:val118_0 val-rhs119_0 body120_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((id:val121_0 val-rhs122_0)"
"(let-values(((s_5)"
"(car s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:val_0"
" val-rhs_0)"
"(let-values(((id:val_0)"
"(let-values(((id:val_0)"
" null))"
" id:val_0))"
"((val-rhs_0)"
"(let-values(((val-rhs_0)"
" null))"
" val-rhs_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id:val_1"
" val-rhs_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id:val_2"
" val-rhs_2)"
"(let-values(((id:val_2"
" val-rhs_2)"
"(let-values()"
"(let-values(((id:val136_0"
" val-rhs137_0)"
"(let-values()"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(pair?"
" s_8)"
"(let-values(((id:val124_0)"
"(let-values(((s_9)"
"(car"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(let-values(((flat-s_1)"
"(to-syntax-list.1"
" s_10)))"
"(if(not"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:val_2)"
"(let-values(((id:val_2)"
"(let-values(((id:val_2)"
" null))"
" id:val_2)))"
"(let-values(((lst_2)"
" flat-s_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id:val_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_11)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id:val_4)"
"(let-values(((id:val_4)"
"(let-values()"
"(let-values(((id:val138_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_11)"
"(symbol?"
"(syntax-e$1"
" s_11))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_11)))"
" s_11"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                   \"not an identifier\""
" orig-s_0"
" s_11)))))"
"(cons"
" id:val138_0"
" id:val_3)))))"
"(values"
" id:val_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" id:val_4"
" rest_1)"
" id:val_4)))"
" id:val_3))))))"
" for-loop_1)"
" id:val_2"
" lst_2))))))"
"(reverse$1"
" id:val_2))))))))"
"((val-rhs125_0)"
"(let-values(((s_9)"
"(cdr"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(pair?"
" s_10)"
"(let-values(((val-rhs126_0)"
"(let-values(((s_11)"
"(car"
" s_10)))"
" s_11))"
"(()"
"(let-values(((s_11)"
"(cdr"
" s_10)))"
"(let-values(((s_12)"
"(if(syntax?$1"
" s_11)"
"(syntax-e$1"
" s_11)"
" s_11)))"
"(if(null?"
" s_12)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" val-rhs126_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:val124_0"
" val-rhs125_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" id:val136_0"
" id:val_1)"
"(cons"
" val-rhs137_0"
" val-rhs_1))))))"
"(values"
" id:val_2"
" val-rhs_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id:val_2"
" val-rhs_2"
" rest_0)"
"(values"
" id:val_2"
" val-rhs_2))))"
"(values"
" id:val_1"
" val-rhs_1)))))))"
" for-loop_0)"
" id:val_0"
" val-rhs_0"
" lst_0))))))"
"(values"
"(reverse$1"
" id:val_0)"
"(reverse$1"
" val-rhs_0)))))))))"
"((body123_0)"
"(let-values(((s_5)"
"(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0))"
"(if(null?"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                           \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0))))))))"
"(values"
" id:val121_0"
" val-rhs122_0"
" body123_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" let-values117_0"
" id:val118_0"
" val-rhs119_0"
" body120_0))"
"                                                            (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t let-values113_0 id:val114_0 val-rhs115_0 body116_0)))"
"(values #f #f #f #f #f)))))"
"(let-values(((sc_0)(if(not(expand-context-parsing-expanded? ctx_0))(new-scope 'local) #f)))"
"(let-values((()"
"(begin"
"(if(if syntaxes?_0(not sc_0) #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                               \"encountered `letrec-syntaxes` in form that should be fully expanded\""
" s_0))"
"(void))"
"(values))))"
"(let-values(((body-sc_0)(if sc_0(if rec?_0(new-scope 'letrec-body) #f) #f)))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((frame-id_0)(if syntaxes?_0(make-reference-record) #f)))"
"(let-values(((trans-idss_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0)(if syntaxes?_0 id:trans88_0 null)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((ids_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" sc_0))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((trans-rhss_0)"
"(if syntaxes?_0"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) trans-rhs89_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((rhs_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" rhs_0"
" sc_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" '())))"
"(let-values(((val-idss_0)"
"(let-values(((val-idss_0)(if syntaxes?_0 id:val90_0 id:val114_0)))"
"(if sc_0"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) val-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" sc_0))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" val-idss_0))))"
"(let-values(((val-rhss_0)"
"(let-values(((val-rhss_0)"
"(if syntaxes?_0 val-rhs91_0 val-rhs115_0)))"
"(if(if rec?_0 sc_0 #f)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) val-rhss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((rhs_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" rhs_0"
" sc_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" val-rhss_0))))"
"(let-values(((val-clauses_0)"
"(if syntaxes?_0"
"(let-values()"
"(let-values(((ok?_2 _139_0 _140_0 clause141_0 _142_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((_139_0"
" _140_0"
" clause141_0"
" _142_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((_143_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((_144_0"
" clause145_0"
" _146_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((_147_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
" s_5))"
"((clause148_0"
" _149_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((clause150_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0))))))"
"((_151_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
" s_7)))"
"(values"
" clause150_0"
" _151_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values"
" _147_0"
" clause148_0"
" _149_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" _143_0"
" _144_0"
" clause145_0"
" _146_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                 \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _139_0"
" _140_0"
" clause141_0"
" _142_0))))))"
" clause141_0))"
"(let-values()"
"(let-values(((ok?_2 _152_0 clause153_0 _154_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((_152_0 clause153_0 _154_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((_155_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((clause156_0"
" _157_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((clause158_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                             \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0))))))"
"((_159_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
" s_5)))"
"(values"
" clause158_0"
" _159_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" _155_0"
" clause156_0"
" _157_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                 \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _152_0"
" clause153_0"
" _154_0))))))"
" clause153_0)))))"
"(let-values((()"
"(begin"
"(let-values(((temp127_0)(list trans-idss_0 val-idss_0))"
"((phase128_0) phase_0)"
"((s129_0) s_0))"
"(check-no-duplicate-ids.1"
" unsafe-undefined"
" temp127_0"
" phase128_0"
" s129_0"
" unsafe-undefined))"
"(values))))"
"(let-values(((counter_0)(root-expand-context-counter ctx_0)))"
"(let-values(((local-sym_0)"
"(if(expand-context-normalize-locals? ctx_0) 'loc #f)))"
"(let-values(((trans-keyss_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) trans-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id160_0)"
" id_0)"
"((phase161_0)"
" phase_0)"
"((counter162_0)"
" counter_0)"
"((frame-id163_0)"
" frame-id_0)"
"((s164_0)"
" s_0)"
"((local-sym165_0)"
" local-sym_0))"
"(add-local-binding!.1"
" frame-id163_0"
" s164_0"
" local-sym165_0"
" id160_0"
" phase161_0"
" counter162_0)))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((val-keyss_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) val-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(if sc_0"
"(let-values(((id166_0)"
" id_0)"
"((phase167_0)"
" phase_0)"
"((counter168_0)"
" counter_0)"
"((frame-id169_0)"
" frame-id_0)"
"((s170_0)"
" s_0)"
"((local-sym171_0)"
" local-sym_0))"
"(add-local-binding!.1"
" frame-id169_0"
" s170_0"
" local-sym171_0"
" id166_0"
" phase167_0"
" counter168_0))"
"(existing-binding-key"
" id_0"
"(expand-context-phase"
" ctx_0))))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((bodys_0)"
"(let-values(((bodys_0)"
"(if syntaxes?_0 body92_0 body116_0)))"
"(if sc_0"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0) null))"
" fold-var_0)))"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((new-body_0)"
"(add-scope"
" body_0"
" sc_0)))"
"(if rec?_0"
"(add-scope"
" new-body_0"
" body-sc_0)"
" new-body_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" bodys_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'letX-renames"
" trans-idss_0"
" trans-rhss_0"
" val-idss_0"
" val-rhss_0"
" bodys_0)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if syntaxes?_0"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(prepare-next-phase-namespace ctx_0)))"
"(void))"
"(values))))"
"(let-values(((trans-valss_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0) trans-rhss_0)"
"((lst_1) trans-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((rhs_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((ids_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'next)"
"(call-expand-observe"
" obs_0"
" 'enter-bind))))"
"(void)))"
"(values))))"
"(let-values(((trans-val_0)"
"(eval-for-syntaxes-binding"
" 'letrec-syntaxes+values"
" rhs_0"
" ids_0"
" ctx_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-bind)))"
"(void)))"
" trans-val_0))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0"
" rest_1)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1)))))))"
"(let-values(((rec-val-env_0)"
"(let-values(((env_0)"
"(let-values(((env_0)"
"(expand-context-env"
" ctx_0)))"
" env_0)))"
"(let-values(((lst_0) val-keyss_0)"
"((lst_1) val-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_1"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((keys_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((ids_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((env_2)"
"(let-values(((lst_4)"
" keys_0)"
"((lst_5)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_5)))"
"((letrec-values(((for-loop_1)"
"(lambda(env_2"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((key_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((id_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((env_3)"
"(let-values(((env_3)"
"(let-values()"
"(env-extend"
" env_2"
" key_0"
"(local-variable1.1"
" id_0)))))"
"(values"
" env_3))))"
"(if(not"
" #f)"
"(for-loop_1"
" env_3"
" rest_2"
" rest_3)"
" env_3)))"
" env_2)))))"
" for-loop_1)"
" env_1"
" lst_4"
" lst_5)))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_2"
" rest_0"
" rest_1)"
" env_2)))"
" env_1))))))"
" for-loop_0)"
" env_0"
" lst_0"
" lst_1))))))"
"(let-values(((rec-env_0)"
"(let-values(((env_0)"
"(let-values(((env_0)"
" rec-val-env_0))"
" env_0)))"
"(let-values(((lst_0) trans-keyss_0)"
"((lst_1) trans-valss_0)"
"((lst_2) trans-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_1"
" lst_3"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_3)"
"(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
" #f)"
"(let-values(((keys_0)"
"(unsafe-car"
" lst_3))"
"((rest_0)"
"(unsafe-cdr"
" lst_3))"
"((vals_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((ids_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((env_2)"
"(let-values(((env_2)"
"(let-values()"
"(let-values(((env_2)"
"(let-values(((env_2)"
" env_1))"
" env_2)))"
"(let-values(((lst_6)"
" keys_0)"
"((lst_7)"
" vals_0)"
"((lst_8)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_6)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_7)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_8)))"
"((letrec-values(((for-loop_1)"
"(lambda(env_3"
" lst_9"
" lst_10"
" lst_11)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_9)"
"(if(pair?"
" lst_10)"
"(pair?"
" lst_11)"
" #f)"
" #f)"
"(let-values(((key_0)"
"(unsafe-car"
" lst_9))"
"((rest_3)"
"(unsafe-cdr"
" lst_9))"
"((val_0)"
"(unsafe-car"
" lst_10))"
"((rest_4)"
"(unsafe-cdr"
" lst_10))"
"((id_0)"
"(unsafe-car"
" lst_11))"
"((rest_5)"
"(unsafe-cdr"
" lst_11)))"
"(let-values(((env_4)"
"(let-values(((env_4)"
"(let-values()"
"(begin"
"(maybe-install-free=id-in-context!"
" val_0"
" id_0"
" phase_0"
" ctx_0)"
"(env-extend"
" env_3"
" key_0"
" val_0)))))"
"(values"
" env_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" env_4"
" rest_3"
" rest_4"
" rest_5)"
" env_4)))"
" env_3))))))"
" for-loop_1)"
" env_2"
" lst_6"
" lst_7"
" lst_8)))))))"
"(values"
" env_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_2"
" rest_0"
" rest_1"
" rest_2)"
" env_2)))"
" env_1))))))"
" for-loop_0)"
" env_0"
" lst_0"
" lst_1"
" lst_2))))))"
"(let-values((()"
"(begin"
"(if syntaxes?_0"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void))))"
"(void))"
"(values))))"
"(let-values(((expr-ctx_0)"
"(as-expression-context ctx_0)))"
"(let-values(((orig-rrs_0)"
"(expand-context-reference-records"
" expr-ctx_0)))"
"(let-values(((rec-ctx_0)"
"(let-values(((v_0) expr-ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((env172_0)"
" rec-env_0)"
"((scopes173_0)"
"(if sc_0"
"(let-values(((scopes_0)"
"(cons"
" sc_0"
"(expand-context-scopes"
" ctx_0))))"
"(if rec?_0"
"(cons"
" body-sc_0"
" scopes_0)"
" scopes_0))"
"(expand-context-scopes"
" ctx_0)))"
"((reference-records174_0)"
"(if split-by-reference?_0"
"(cons"
" frame-id_0"
" orig-rrs_0)"
" orig-rrs_0))"
"((binding-layer175_0)"
"(if sc_0"
"(increment-binding-layer"
"(cons"
" trans-idss_0"
" val-idss_0)"
" ctx_0"
" sc_0)"
"(expand-context-binding-layer"
" ctx_0)))"
"((inner176_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner176_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
" env172_0"
" scopes173_0"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
" binding-layer175_0"
" reference-records174_0"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                             \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((letrec-values-id_0)"
"(if(not"
"(expand-context-to-parsed?"
" ctx_0))"
"(if syntaxes?_0"
"(core-id"
" 'letrec-values"
" phase_0)"
" let-values113_0)"
" #f)))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx177_0)"
" ctx_0)"
"((s178_0) s_0)"
"((temp179_0) #t))"
"(keep-as-needed.1"
" #f"
" temp179_0"
" #f"
" ctx177_0"
" s178_0))))"
"(let-values(((val-name-idss_0)"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" val-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((val-ids_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" null))"
" fold-var_2)))"
"(let-values(((lst_2)"
" val-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((val-id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1"
" #f"
"(syntax-e$1"
" val-id_0)"
" val-id_0"
" val-id_0))"
" fold-var_3))))"
"(values"
" fold-var_4))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_2"
" lst_2))))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" val-idss_0)))"
"(let-values(((get-body_0)"
"(lambda(rec-ctx_1)"
"(begin"
" 'get-body"
"(if(expand-context-parsing-expanded?"
" ctx_0)"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((body180_0)"
" body_0)"
"((rec-ctx181_0)"
" rec-ctx_1))"
"(expand.1"
" #f"
" #f"
" body180_0"
" rec-ctx181_0)))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
"(let-values()"
"(let-values(((body-ctx_0)"
"(let-values(((v_0)"
" rec-ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((reference-records185_0)"
" orig-rrs_0)"
"((inner186_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner186_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
" reference-records185_0"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                           \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((bodys182_0)"
" bodys_0)"
"((temp183_0)"
"(let-values(((body-ctx187_0)"
" body-ctx_0)"
"((ctx188_0)"
" ctx_0))"
"(as-tail-context.1"
" ctx188_0"
" body-ctx187_0)))"
"((rebuild-s184_0)"
" rebuild-s_0))"
"(expand-body.1"
" rebuild-s184_0"
" #f"
" bodys182_0"
" temp183_0)))))))))"
"(let-values(((result-s_0)"
"(if(not"
" split-by-reference?_0)"
"(let-values()"
"(let-values(((clauses_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" val-name-idss_0)"
"((lst_1)"
" val-keyss_0)"
"((lst_2)"
" val-rhss_0)"
"((lst_3)"
" val-clauses_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_3)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_4"
" lst_5"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(if(pair?"
" lst_4)"
"(if(pair?"
" lst_5)"
"(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
" #f)"
" #f)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_4))"
"((rest_0)"
"(unsafe-cdr"
" lst_4))"
"((keys_0)"
"(unsafe-car"
" lst_5))"
"((rest_1)"
"(unsafe-cdr"
" lst_5))"
"((rhs_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((clause_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-rhs_0)"
"(let-values(((rhs189_0)"
" rhs_0)"
"((temp190_0)"
"(if rec?_0"
"(as-named-context"
" rec-ctx_0"
" ids_0)"
"(as-named-context"
" expr-ctx_0"
" ids_0))))"
"(expand.1"
" #f"
" #f"
" rhs189_0"
" temp190_0))))"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(list"
" keys_0"
" exp-rhs_0)"
"(datum->syntax$1"
" #f"
"(list"
" ids_0"
" exp-rhs_0)"
" clause_0"
" clause_0)))))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0"
" rest_1"
" rest_2"
" rest_3)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0"
" lst_1"
" lst_2"
" lst_3)))))))"
"(let-values(((exp-body_0)"
"(get-body_0"
" rec-ctx_0)))"
"(begin"
"(if frame-id_0"
"(let-values()"
"(reference-record-clear!"
" frame-id_0))"
"(void))"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(if rec?_0"
"(parsed-letrec-values18.1"
" rebuild-s_0"
" val-name-idss_0"
" clauses_0"
" exp-body_0)"
"(parsed-let-values17.1"
" rebuild-s_0"
" val-name-idss_0"
" clauses_0"
" exp-body_0))"
"(let-values(((rebuild-s191_0)"
" rebuild-s_0)"
"((temp192_0)"
"(list*"
" letrec-values-id_0"
" clauses_0"
" exp-body_0)))"
"(rebuild.1"
" #t"
" rebuild-s191_0"
" temp192_0)))))))"
"(let-values()"
"(let-values(((val-idss193_0)"
" val-idss_0)"
"((val-keyss194_0)"
" val-keyss_0)"
"((val-rhss195_0)"
" val-rhss_0)"
"((val-clauses196_0)"
" val-clauses_0)"
"((temp197_0)"
" #t)"
"((frame-id198_0)"
" frame-id_0)"
"((rec-ctx199_0)"
" rec-ctx_0)"
"((rebuild-s200_0)"
" rebuild-s_0)"
"((syntaxes?201_0)"
" syntaxes?_0)"
"((get-body202_0)"
" get-body_0)"
"((temp203_0)"
" #t))"
"(expand-and-split-bindings-by-reference.1"
" rec-ctx199_0"
" frame-id198_0"
" get-body202_0"
" syntaxes?201_0"
" rebuild-s200_0"
" temp197_0"
" temp203_0"
" val-idss193_0"
" val-keyss194_0"
" val-rhss195_0"
" val-clauses196_0))))))"
"(if(expand-context-to-parsed?"
" ctx_0)"
" result-s_0"
"(attach-disappeared-transformer-bindings"
" result-s_0"
" trans-idss_0))))))))))))))))))))))))))))))))))))))))))))"
"(void"
"(add-core-form!*"
" 'let-values"
"(let-values(((temp204_0) 'prim-let-values))(make-let-values-form.1 temp204_0 #f #f #f))))"
"(void"
"(add-core-form!*"
" 'letrec-values"
"(let-values(((temp205_0) #t)((temp206_0) 'prim-letrec-values))"
"(make-let-values-form.1 temp206_0 temp205_0 #f #f))))"
"(void"
"(add-core-form!*"
" 'letrec-syntaxes+values"
"(let-values(((temp207_0) #t)((temp208_0) #t)((temp209_0) #t)((temp210_0) 'prim-letrec-syntaxes+values))"
"(make-let-values-form.1 temp210_0 temp208_0 temp209_0 temp207_0))))"
"(void"
"(add-core-form!*"
" '#%stratified-body"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-#%stratified s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 #%stratified-body211_0 body212_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%stratified-body211_0 body212_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%stratified-body213_0)(let-values(((s_3)(car s_2))) s_3))"
"((body214_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                   (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(if(null? flat-s_0)"
"(let-values()"
"                                                                     (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0))))))))"
"(values #%stratified-body213_0 body214_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%stratified-body211_0 body212_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx215_0) ctx_0)((s216_0) s_0)((temp217_0) #t))"
"(keep-as-needed.1 #f temp217_0 #f ctx215_0 s216_0))))"
"(let-values(((exp-body_0)"
"(let-values(((temp218_0) body212_0)"
"((ctx219_0) ctx_0)"
"((temp220_0) #t)"
"((rebuild-s221_0) rebuild-s_0))"
"(expand-body.1 rebuild-s221_0 temp220_0 temp218_0 ctx219_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-begin12.1 rebuild-s_0 exp-body_0)"
"(let-values(((rebuild-s222_0) rebuild-s_0)"
"((temp223_0)"
"(if(null?(cdr exp-body_0))"
"(car exp-body_0)"
"(list*(core-id 'begin(expand-context-phase ctx_0)) exp-body_0))))"
"(rebuild.1 #t rebuild-s222_0 temp223_0))))))))))"
"(void"
"(add-core-form!*"
" '#%datum"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-#%datum s_0)))(void)))"
"(values))))"
"(let-values(((ok?_0 #%datum224_0 datum225_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%datum224_0 datum225_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%datum226_0)(let-values(((s_3)(car s_2))) s_3))"
"((datum227_0)(let-values(((s_3)(cdr s_2))) s_3)))"
"(values #%datum226_0 datum227_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%datum224_0 datum225_0))))))"
"(let-values(((datum_0) datum225_0))"
"(let-values((()"
"(begin"
"(if(if(syntax?$1 datum_0)(keyword?(syntax-e$1 datum_0)) #f)"
"(let-values()"
"                               (raise-syntax-error$1 '#%datum \"keyword misused as an expression\" #f datum_0))"
"(void))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(if(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f)"
"(parsed-quote14.1(keep-properties-only~ s_0)(syntax->datum$1 datum_0))"
"(syntax-track-origin$1"
"(let-values(((s228_0) s_0)((temp229_0)(list(core-id 'quote phase_0) datum_0))((temp230_0) #f))"
"(rebuild.1 temp230_0 s228_0 temp229_0))"
" s_0"
" #%datum224_0))))))))))"
"(void"
"(add-core-form!*"
" '#%app"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-#%app s_0)))(void)))"
"(values))))"
"(let-values(((ok?_0 #%app231_0 e232_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%app231_0 e232_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%app233_0)(let-values(((s_3)(car s_2))) s_3))"
"((e234_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                   (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values #%app233_0 e234_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%app231_0 e232_0))))))"
"(let-values(((es_0) e232_0))"
"(if(null? es_0)"
"(let-values()"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-quote14.1(keep-properties-only~ s_0) null)"
"(let-values(((s235_0) s_0)((temp236_0)(list(core-id 'quote phase_0) null)))"
"(rebuild.1 #t s235_0 temp236_0)))))"
"(let-values()"
"(let-values(((keep-for-parsed?_0) keep-source-locations?))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx237_0) ctx_0)"
"((s238_0) s_0)"
"((keep-for-parsed?239_0) keep-for-parsed?_0))"
"(keep-as-needed.1 #f #f keep-for-parsed?239_0 ctx237_0 s238_0))))"
"(let-values(((prefixless_0)(cdr(syntax-e$1 s_0))))"
"(let-values(((rebuild-prefixless_0)"
"(if(syntax?$1 prefixless_0)"
"(let-values(((ctx240_0) ctx_0)"
"((prefixless241_0) prefixless_0)"
"((keep-for-parsed?242_0) keep-for-parsed?_0))"
"(keep-as-needed.1 #f #f keep-for-parsed?242_0 ctx240_0 prefixless241_0))"
" #f)))"
"(let-values(((expr-ctx_0)(as-expression-context ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer expr-ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((rest-es_0)(cdr es_0)))"
"(let-values(((exp-rator_0)"
"(let-values(((temp243_0)(car es_0))((expr-ctx244_0) expr-ctx_0))"
"(expand.1 #f #f temp243_0 expr-ctx244_0))))"
"(let-values(((exp-es_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) rest-es_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" expr-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(let-values(((e245_0)"
" e_0)"
"((expr-ctx246_0)"
" expr-ctx_0))"
"(expand.1"
" #f"
" #f"
" e245_0"
" expr-ctx246_0))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(let-values()"
"(parsed-app7.1"
"(let-values(((or-part_0) rebuild-prefixless_0))"
"(if or-part_0 or-part_0 rebuild-s_0))"
" exp-rator_0"
" exp-es_0))"
"(let-values()"
"(let-values(((es_1)"
"(let-values(((exp-es_1)(cons exp-rator_0 exp-es_0)))"
"(if rebuild-prefixless_0"
"(let-values(((rebuild-prefixless249_0) rebuild-prefixless_0)"
"((exp-es250_0) exp-es_1))"
"(rebuild.1 #t rebuild-prefixless249_0 exp-es250_0))"
" exp-es_1))))"
"(let-values(((rebuild-s247_0) rebuild-s_0)((temp248_0)(cons #%app231_0 es_1)))"
"(rebuild.1 #t rebuild-s247_0 temp248_0))))))))))))))))))))))"
"(void"
"(add-core-form!*"
" 'quote"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-quote #f)))(void)))"
"(values))))"
"(let-values(((ok?_0 quote251_0 datum252_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((quote251_0 datum252_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((quote253_0)(let-values(((s_3)(car s_2))) s_3))"
"((datum254_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((datum255_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                    \"bad syntax\""
" orig-s_0))))))"
"(values datum255_0))"
"                                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values quote253_0 datum254_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t quote251_0 datum252_0))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-quote14.1(keep-properties-only~ s_0)(syntax->datum$1 datum252_0))"
" s_0))))))"
"(void"
"(add-core-form!*"
" 'quote-syntax"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-quote-syntax s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 quote-syntax256_0 datum257_0)"
"(let-values(((s_1) s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(if(let-values(((s_5)(car s_4))) #t)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(if(pair? s_6)"
"(if(let-values(((s_7)(car s_6)))"
"(let-values(((s_8)(if(syntax?$1 s_7)(syntax-e$1 s_7) s_7)))"
"(eq? '#:local s_8)))"
"(let-values(((s_7)(cdr s_6)))"
"(let-values(((s_8)(if(syntax?$1 s_7)(syntax-e$1 s_7) s_7)))"
"(null? s_8)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((quote-syntax256_0 datum257_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((quote-syntax258_0)(let-values(((s_3)(car s_2))) s_3))"
"((datum259_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((datum260_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values((()"
"(let-values(((s_7)"
"(car s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(values))))"
"(()"
"(let-values(((s_7)"
"(cdr s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(values)))))"
"(values))))))"
"(values datum260_0))))))"
"(values quote-syntax258_0 datum259_0)))))"
"(values #t quote-syntax256_0 datum257_0)))"
"(values #f #f #f)))))"
"(let-values(((ok?_1 quote-syntax261_0 datum262_0)"
"(let-values(((s_1) s_0))"
"(if(if(not ok?_0) #t #f)"
"(let-values(((orig-s_0) s_1))"
"(let-values(((quote-syntax261_0 datum262_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((quote-syntax263_0)(let-values(((s_3)(car s_2))) s_3))"
"((datum264_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((datum265_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                        \"bad syntax\""
" orig-s_0))))))"
"(values datum265_0))"
"                                                                   (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values quote-syntax263_0 datum264_0))"
"                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t quote-syntax261_0 datum262_0)))"
"(values #f #f #f)))))"
"(if ok?_0"
"(let-values()"
"(let-values((()"
"(begin(reference-records-all-used!(expand-context-reference-records ctx_0))(values))))"
"(let-values(((ok?_2 _266_0 _267_0 kw268_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((_266_0 _267_0 kw268_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((_269_0)(let-values(((s_3)(car s_2))) s_3))"
"((_270_0 kw271_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((_272_0)"
"(let-values(((s_5)(car s_4)))"
" s_5))"
"((kw273_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((kw274_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                  \"bad syntax\""
" orig-s_0))))))"
"(values kw274_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                              \"bad syntax\""
" orig-s_0))))))"
"(values _272_0 kw273_0))"
"(raise-syntax-error$1"
" #f"
"                                                                          \"bad syntax\""
" orig-s_0))))))"
"(values _269_0 _270_0 kw271_0))"
"                                                     (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t _266_0 _267_0 kw268_0))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-quote-syntax15.1(keep-properties-only~ s_0) datum257_0)"
"(let-values(((s275_0) s_0)((temp276_0)(list quote-syntax256_0 datum257_0 kw268_0)))"
"(rebuild.1 #t s275_0 temp276_0))))))"
"(let-values()"
"(let-values(((use-site-scopes_0)(root-expand-context-use-site-scopes ctx_0)))"
"(let-values(((datum-s_0)"
"(remove-scopes"
"(remove-scopes datum262_0(expand-context-scopes ctx_0))"
"(if use-site-scopes_0(unbox use-site-scopes_0) '()))))"
"(if(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f)"
"(parsed-quote-syntax15.1(keep-properties-only~ s_0) datum-s_0)"
"(let-values(((s277_0) s_0)((temp278_0)(list quote-syntax261_0 datum-s_0)))"
"(rebuild.1 #t s277_0 temp278_0)))))))))))))"
"(void"
"(add-core-form!*"
" 'if"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-if s_0)))(void)))"
"(values))))"
"(let-values(((ok?_0 _279_0 _280_0 _281_0)"
"(let-values(((s_1) s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(if(let-values(((s_5)(car s_4))) #t)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(if(pair? s_6)"
"(if(let-values(((s_7)(car s_6))) #t)"
"(let-values(((s_7)(cdr s_6)))"
"(let-values(((s_8)(if(syntax?$1 s_7)(syntax-e$1 s_7) s_7)))"
"(null? s_8)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((_279_0 _280_0 _281_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((_282_0)(let-values(((s_3)(car s_2))) s_3))"
"((_283_0 _284_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((_285_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((_286_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((_287_0)"
"(let-values(((s_7)"
"(car s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(values)))))"
"(values _287_0))))))"
"(values _285_0 _286_0))))))"
"(values _282_0 _283_0 _284_0)))))"
"(values #t _279_0 _280_0 _281_0)))"
"(values #f #f #f #f)))))"
"(let-values((()"
"(begin"
"(if ok?_0"
"                           (let-values () (raise-syntax-error$1 #f \"missing an \\\"else\\\" expression\" s_0))"
"(void))"
"(values))))"
"(let-values(((ok?_1 if288_0 tst289_0 thn290_0 els291_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((if288_0 tst289_0 thn290_0 els291_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((if292_0)(let-values(((s_3)(car s_2))) s_3))"
"((tst293_0 thn294_0 els295_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((tst296_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((thn297_0 els298_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((thn299_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((els300_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(pair? s_8)"
"(let-values(((els301_0)"
"(let-values(((s_9)"
"(car"
" s_8)))"
" s_9))"
"(()"
"(let-values(((s_9)"
"(cdr"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(null?"
" s_10)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                \"bad syntax\""
" orig-s_0))))))"
"(values"
" els301_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                            \"bad syntax\""
" orig-s_0))))))"
"(values thn299_0 els300_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                        \"bad syntax\""
" orig-s_0))))))"
"(values tst296_0 thn297_0 els298_0))"
"                                                                   (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values if292_0 tst293_0 thn294_0 els295_0))"
"                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t if288_0 tst289_0 thn290_0 els291_0))))))"
"(let-values(((expr-ctx_0)(as-expression-context ctx_0)))"
"(let-values(((tail-ctx_0)"
"(let-values(((expr-ctx302_0) expr-ctx_0)((ctx303_0) ctx_0))"
"(as-tail-context.1 ctx303_0 expr-ctx302_0))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx304_0) ctx_0)((s305_0) s_0))"
"(keep-as-needed.1 #f #f #f ctx304_0 s305_0))))"
"(let-values(((exp-tst_0)"
"(let-values(((temp306_0) tst289_0)((expr-ctx307_0) expr-ctx_0))"
"(expand.1 #f #f temp306_0 expr-ctx307_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-thn_0)"
"(let-values(((temp308_0) thn290_0)((tail-ctx309_0) tail-ctx_0))"
"(expand.1 #f #f temp308_0 tail-ctx309_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-els_0)"
"(let-values(((temp310_0) els291_0)((tail-ctx311_0) tail-ctx_0))"
"(expand.1 #f #f temp310_0 tail-ctx311_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-if8.1 rebuild-s_0 exp-tst_0 exp-thn_0 exp-els_0)"
"(let-values(((rebuild-s312_0) rebuild-s_0)"
"((temp313_0)(list if288_0 exp-tst_0 exp-thn_0 exp-els_0)))"
"(rebuild.1 #t rebuild-s312_0 temp313_0))))))))))))))))))"
"(void"
"(add-core-form!*"
" 'with-continuation-mark"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-with-continuation-mark s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 with-continuation-mark314_0 key315_0 val316_0 body317_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((with-continuation-mark314_0 key315_0 val316_0 body317_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((with-continuation-mark318_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((key319_0 val320_0 body321_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((key322_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((val323_0 body324_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((val325_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((body326_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(pair? s_8)"
"(let-values(((body327_0)"
"(let-values(((s_9)"
"(car"
" s_8)))"
" s_9))"
"(()"
"(let-values(((s_9)"
"(cdr"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(null?"
" s_10)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                            \"bad syntax\""
" orig-s_0))))))"
"(values"
" body327_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                        \"bad syntax\""
" orig-s_0))))))"
"(values val325_0 body326_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                    \"bad syntax\""
" orig-s_0))))))"
"(values key322_0 val323_0 body324_0))"
"                                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values with-continuation-mark318_0 key319_0 val320_0 body321_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t with-continuation-mark314_0 key315_0 val316_0 body317_0))))))"
"(let-values(((expr-ctx_0)(as-expression-context ctx_0)))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx328_0) ctx_0)((s329_0) s_0))(keep-as-needed.1 #f #f #f ctx328_0 s329_0))))"
"(let-values(((exp-key_0)"
"(let-values(((temp330_0) key315_0)((expr-ctx331_0) expr-ctx_0))"
"(expand.1 #f #f temp330_0 expr-ctx331_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'next)))(void)))"
"(values))))"
"(let-values(((exp-val_0)"
"(let-values(((temp332_0) val316_0)((expr-ctx333_0) expr-ctx_0))"
"(expand.1 #f #f temp332_0 expr-ctx333_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-body_0)"
"(let-values(((temp334_0) body317_0)"
"((temp335_0)"
"(let-values(((expr-ctx336_0) expr-ctx_0)((ctx337_0) ctx_0))"
"(as-tail-context.1 ctx337_0 expr-ctx336_0))))"
"(expand.1 #f #f temp334_0 temp335_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-with-continuation-mark10.1 rebuild-s_0 exp-key_0 exp-val_0 exp-body_0)"
"(let-values(((rebuild-s338_0) rebuild-s_0)"
"((temp339_0)(list with-continuation-mark314_0 exp-key_0 exp-val_0 exp-body_0)))"
"(rebuild.1 #t rebuild-s338_0 temp339_0)))))))))))))))"
"(define-values"
"(make-begin.1)"
"(lambda(last-is-tail?10_0 log-tag12_0 parsed-begin13_0)"
"(begin"
" 'make-begin"
"(let-values(((log-tag_0) log-tag12_0))"
"(let-values(((parsed-begin_0) parsed-begin13_0))"
"(let-values(((last-is-tail?_0) last-is-tail?10_0))"
"(let-values()"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 log-tag_0 s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 begin340_0 e341_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((begin340_0 e341_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((begin342_0)(let-values(((s_3)(car s_2))) s_3))"
"((e343_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                               \"bad syntax\""
" orig-s_0))"
"(if(null? flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values() flat-s_0))))))))"
"(values begin342_0 e343_0))"
"                                                      (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t begin340_0 e341_0))))))"
"(let-values(((expr-ctx_0)"
"(if last-is-tail?_0"
"(as-begin-expression-context ctx_0)"
"(as-expression-context ctx_0))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx344_0) ctx_0)((s345_0) s_0))"
"(keep-as-needed.1 #f #f #f ctx344_0 s345_0))))"
"(let-values(((exp-es_0)"
"((letrec-values(((loop_0)"
"(lambda(es_0)"
"(begin"
" 'loop"
"(if(null? es_0)"
"(let-values() null)"
"(let-values()"
"(let-values(((rest-es_0)(cdr es_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(cons"
"(let-values(((temp346_0)(car es_0))"
"((temp347_0)"
"(if(if last-is-tail?_0"
"(null? rest-es_0)"
" #f)"
"(let-values(((expr-ctx348_0)"
" expr-ctx_0)"
"((ctx349_0) ctx_0))"
"(as-tail-context.1"
" ctx349_0"
" expr-ctx348_0))"
" expr-ctx_0)))"
"(expand.1 #f #f temp346_0 temp347_0))"
"(loop_0 rest-es_0))))))))))"
" loop_0)"
" e341_0)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-begin_0 rebuild-s_0 exp-es_0)"
"(let-values(((rebuild-s350_0) rebuild-s_0)((temp351_0)(cons begin340_0 exp-es_0)))"
"(rebuild.1 #t rebuild-s350_0 temp351_0))))))))))))))))"
"(void"
"(add-core-form!*"
" 'begin"
"(let-values(((nonempty-begin_0)"
"(let-values(((temp352_0) 'prim-begin)((parsed-begin353_0) parsed-begin12.1)((temp354_0) #t))"
"(make-begin.1 temp354_0 temp352_0 parsed-begin353_0))))"
"(lambda(s_0 ctx_0)"
"(let-values(((context_0)(expand-context-context ctx_0)))"
"(if(let-values(((or-part_0)(eq? context_0 'top-level)))(if or-part_0 or-part_0(eq? context_0 'module)))"
"(let-values()"
"(let-values(((ok?_0 begin355_0)"
"(let-values(((s_1) s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))(null? s_4)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((begin355_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((begin356_0)(let-values(((s_3)(car s_2))) s_3))"
"(()"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(values)))))"
"(values begin356_0)))))"
"(values #t begin355_0)))"
"(values #f #f)))))"
"(if ok?_0"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-begin12.1"
"(let-values(((ctx357_0) ctx_0)((s358_0) s_0))(keep-as-needed.1 #f #f #f ctx357_0 s358_0))"
" '())"
" s_0)"
"(nonempty-begin_0 s_0 ctx_0))))"
"(let-values()(nonempty-begin_0 s_0 ctx_0))))))))"
"(void"
"(add-core-form!*"
" 'begin0"
"(let-values(((temp359_0) 'prim-begin0)((parsed-begin0360_0) parsed-begin013.1)((temp361_0) #f))"
"(make-begin.1 temp361_0 temp359_0 parsed-begin0360_0))))"
"(define-values"
"(register-eventual-variable!?)"
"(lambda(id_0 ctx_0)"
"(begin"
"(if(if(expand-context-need-eventually-defined ctx_0)(>=(expand-context-phase ctx_0) 1) #f)"
"(let-values()"
"(begin"
"(hash-update!"
"(expand-context-need-eventually-defined ctx_0)"
"(expand-context-phase ctx_0)"
"(lambda(l_0)(cons id_0 l_0))"
" null)"
" #t))"
"(let-values() #f)))))"
"(define-values"
"(check-top-binding-is-variable)"
"(lambda(ctx_0 b_0 id_0 s_0)"
"(begin"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(let-values(((b362_0) b_0)"
"((ctx363_0) ctx_0)"
"((id364_0) id_0)"
"((s365_0) s_0)"
"((temp366_0)(expand-context-in-local-expand? ctx_0)))"
"(lookup.1 s365_0 temp366_0 b362_0 ctx363_0 id364_0))))"
"(begin"
"(if(let-values(((or-part_0)(variable? t_0)))(if or-part_0 or-part_0(1/rename-transformer? t_0)))"
"(void)"
"            (let-values () (raise-syntax-error$1 #f \"identifier does not refer to a variable\" id_0 s_0)))"
"(values t_0 primitive?_0))))))"
"(void"
"(add-core-form!*"
" '#%top"
"(let-values(((...nder/expand/expr.rkt:603:1_0)"
"(lambda(s368_0 ctx369_0 implicit-omitted?367_0)"
"(begin"
" '...nder/expand/expr.rkt:603:1"
"(let-values(((s_0) s368_0))"
"(let-values(((ctx_0) ctx369_0))"
"(let-values(((implicit-omitted?_0) implicit-omitted?367_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'prim-#%top s_0)))"
"(void)))"
"(values))))"
"(let-values(((id_0)"
"(if implicit-omitted?_0"
"(let-values() s_0)"
"(let-values()"
"(let-values(((ok?_0 #%top370_0 id371_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%top370_0 id371_0)"
"(let-values(((s_2)"
"(if(syntax?$1 s_1)"
"(syntax-e$1 s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((#%top372_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((id373_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_3)"
"(symbol?"
"(syntax-e$1"
" s_3))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_3)))"
" s_3"
"(raise-syntax-error$1"
" #f"
"                                                                                                        \"not an identifier\""
" orig-s_0"
" s_3)))))"
"(values #%top372_0 id373_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                      \"bad syntax\""
" orig-s_0)))))"
"(values #t #%top370_0 id371_0))))))"
" id371_0)))))"
"(let-values(((b_0)"
"(let-values(((id374_0) id_0)"
"((temp375_0)(expand-context-phase ctx_0))"
"((temp376_0) 'ambiguous))"
"(resolve+shift.1"
" temp376_0"
" #f"
" null"
" unsafe-undefined"
" #f"
" id374_0"
" temp375_0))))"
"(if(eq? b_0 'ambiguous)"
"(let-values()(raise-ambiguous-error id_0 ctx_0))"
"(if(if b_0"
"(if(module-binding? b_0)"
"(eq?(module-binding-module b_0)(root-expand-context-self-mpi ctx_0))"
" #f)"
" #f)"
"(let-values()"
"(begin"
"(if(expand-context-allow-unbound? ctx_0)"
"(void)"
"(let-values()(check-top-binding-is-variable ctx_0 b_0 id_0 s_0)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-id2.1 id_0 b_0 #f)"
"(if(top-level-module-path-index?(module-binding-module b_0))"
"(let-values() s_0)"
"(let-values() id_0)))))"
"(if(local-binding? b_0)"
"(let-values()"
"(raise-unbound-syntax-error"
" #f"
"                                            \"unbound identifier\""
" id_0"
" #f"
" null"
"(syntax-debug-info-string id_0 ctx_0)))"
"(if(register-eventual-variable!? id_0 ctx_0)"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)(parsed-id2.1 id_0 b_0 #f) id_0))"
"(let-values()"
"(if(not(expand-context-allow-unbound? ctx_0))"
"(let-values()"
"(raise-unbound-syntax-error"
" #f"
"                                                  \"unbound identifier\""
" id_0"
" #f"
" null"
"(syntax-debug-info-string id_0 ctx_0)))"
"(let-values()"
"(let-values(((tl-id_0)"
"(add-scope"
" id_0"
"(root-expand-context-top-level-bind-scope ctx_0))))"
"(let-values(((tl-b_0)"
"(let-values(((tl-id377_0) tl-id_0)"
"((temp378_0)"
"(expand-context-phase ctx_0)))"
"(resolve.1 #f #f null #f tl-id377_0 temp378_0))))"
"(if tl-b_0"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-top-id4.1 tl-id_0 tl-b_0 #f)"
"(if implicit-omitted?_0"
"(let-values() id_0)"
"(let-values()"
"(let-values(((ok?_0 #%top379_0 id380_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%top379_0 id380_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((#%top381_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((id382_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_3)"
"(symbol?"
"(syntax-e$1"
" s_3))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_3)))"
" s_3"
"(raise-syntax-error$1"
" #f"
"                                                                                                                      \"not an identifier\""
" orig-s_0"
" s_3)))))"
"(values"
" #%top381_0"
" id382_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                    \"bad syntax\""
" orig-s_0)))))"
"(values #t #%top379_0 id380_0))))))"
"(let-values(((s383_0) s_0)"
"((temp384_0)(cons #%top379_0 id_0)))"
"(rebuild.1 #t s383_0 temp384_0)))))))"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-top-id4.1 id_0 b_0 #f)"
" s_0)))))))))))))))))))))))"
"(case-lambda"
"((s_0 ctx_0)(begin '...nder/expand/expr.rkt:603:1(...nder/expand/expr.rkt:603:1_0 s_0 ctx_0 #f)))"
"((s_0 ctx_0 implicit-omitted?367_0)(...nder/expand/expr.rkt:603:1_0 s_0 ctx_0 implicit-omitted?367_0))))))"
"(void"
"(add-core-form!*"
" 'set!"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-set! s_0)))(void)))"
"(values))))"
"(let-values(((ok?_0 set!385_0 id386_0 rhs387_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((set!385_0 id386_0 rhs387_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((set!388_0)(let-values(((s_3)(car s_2))) s_3))"
"((id389_0 rhs390_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((id391_0)"
"(let-values(((s_5)(car s_4)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1 s_5)"
"(symbol?"
"(syntax-e$1 s_5))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol? s_5)))"
" s_5"
"(raise-syntax-error$1"
" #f"
"                                                                                  \"not an identifier\""
" orig-s_0"
" s_5))))"
"((rhs392_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((rhs393_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null? s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                        \"bad syntax\""
" orig-s_0))))))"
"(values rhs393_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                    \"bad syntax\""
" orig-s_0))))))"
"(values id391_0 rhs392_0))"
"                                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values set!388_0 id389_0 rhs390_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t set!385_0 id386_0 rhs387_0))))))"
"(let-values(((orig-id_0) id386_0))"
"((letrec-values(((rename-loop_0)"
"(lambda(id_0 from-rename?_0)"
"(begin"
" 'rename-loop"
"(let-values(((binding_0)"
"(let-values(((id394_0) id_0)"
"((temp395_0)(expand-context-phase ctx_0))"
"((temp396_0) 'ambiguous)"
"((temp397_0) #t))"
"(resolve+shift.1 temp396_0 #f null temp397_0 #f id394_0 temp395_0))))"
"(let-values((()"
"(begin"
"(if(eq? binding_0 'ambiguous)"
"(let-values()(raise-ambiguous-error id_0 ctx_0))"
"(void))"
"(values))))"
"(let-values(((t_0 primitive?_0 insp_0 protected?_0)"
"(if binding_0"
"(let-values(((binding398_0) binding_0)"
"((ctx399_0) ctx_0)"
"((s400_0) s_0))"
"(lookup.1 #f #f binding398_0 ctx399_0 s400_0))"
"(values #f #f #f #f))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'resolve id_0)))"
"(void)))"
"(if(let-values(((or-part_0)(variable? t_0)))"
"(if or-part_0"
" or-part_0"
"(if(not binding_0)"
"(let-values(((or-part_1)(register-eventual-variable!? id_0 ctx_0)))"
"(if or-part_1 or-part_1(expand-context-allow-unbound? ctx_0)))"
" #f)))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if(module-binding? binding_0)"
"(not"
"(inside-module-context?"
"(module-binding-module binding_0)"
"(root-expand-context-self-mpi ctx_0)))"
" #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                  \"cannot mutate module-required identifier\""
" s_0"
" id_0))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(register-variable-referenced-if-local!"
" binding_0"
" ctx_0)"
"(values))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx401_0) ctx_0)((s402_0) s_0))"
"(keep-as-needed.1 #f #f #f ctx401_0 s402_0))))"
"(let-values(((exp-rhs_0)"
"(let-values(((temp403_0) rhs387_0)"
"((temp404_0)"
"(as-expression-context ctx_0)))"
"(expand.1 #f #f temp403_0 temp404_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-set!9.1"
" rebuild-s_0"
"(parsed-id2.1 id_0 binding_0 #f)"
" exp-rhs_0)"
"(let-values(((rebuild-s405_0) rebuild-s_0)"
"((temp406_0)"
"(list"
" set!385_0"
"(let-values(((id407_0) id_0)"
"((t408_0) t_0)"
"((temp409_0)"
"(free-id-set-empty-or-just-module*?"
"(expand-context-stops ctx_0))))"
"(substitute-variable.1"
" temp409_0"
" id407_0"
" t408_0))"
" exp-rhs_0)))"
"(rebuild.1 #t rebuild-s405_0 temp406_0)))))))))"
"(if(not binding_0)"
"(let-values()"
"(raise-unbound-syntax-error"
" #f"
"                                                \"unbound identifier\""
" s_0"
" id_0"
" null"
"(syntax-debug-info-string id_0 ctx_0)))"
"(if(1/set!-transformer? t_0)"
"(let-values()"
"(if(not-in-this-expand-context? t_0 ctx_0)"
"(let-values()"
"(let-values(((temp410_0)"
"(avoid-current-expand-context"
"(substitute-set!-rename"
" s_0"
" set!385_0"
" rhs387_0"
" id_0"
" from-rename?_0"
" ctx_0)"
" t_0"
" ctx_0))"
"((ctx411_0) ctx_0))"
"(expand.1 #f #f temp410_0 ctx411_0)))"
"(let-values()"
"(let-values(((exp-s_0 re-ctx_0)"
"(let-values(((t412_0) t_0)"
"((insp413_0) insp_0)"
"((s414_0) s_0)"
"((orig-id415_0) orig-id_0)"
"((ctx416_0) ctx_0)"
"((binding417_0) binding_0)"
"((orig-id418_0) orig-id_0))"
"(apply-transformer.1"
" orig-id418_0"
" t412_0"
" insp413_0"
" s414_0"
" orig-id415_0"
" ctx416_0"
" binding417_0))))"
"(if(expand-context-just-once? ctx_0)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((exp-s419_0) exp-s_0)((re-ctx420_0) re-ctx_0))"
"(expand.1 #f #f exp-s419_0 re-ctx420_0))))))))"
"(if(1/rename-transformer? t_0)"
"(let-values()"
"(if(not-in-this-expand-context? t_0 ctx_0)"
"(let-values()"
"(let-values(((temp421_0)"
"(avoid-current-expand-context"
"(substitute-set!-rename"
" s_0"
" set!385_0"
" rhs387_0"
" id_0"
" from-rename?_0"
" ctx_0)"
" t_0"
" ctx_0))"
"((ctx422_0) ctx_0))"
"(expand.1 #f #f temp421_0 ctx422_0)))"
"(let-values()"
"(rename-loop_0(apply-rename-transformer t_0 id_0 ctx_0) #t))))"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                    \"cannot mutate syntax identifier\""
" s_0"
" id_0))))))))))))))"
" rename-loop_0)"
" orig-id_0"
" #f)))))))"
"(define-values"
"(substitute-set!-rename)"
"(lambda(s_0 set!-id_0 id_0 rhs-s_0 from-rename?_0 ctx_0)"
"(begin"
"(if from-rename?_0"
"(let-values()(datum->syntax$1 s_0(list set!-id_0 id_0 rhs-s_0) s_0 s_0))"
"(let-values() s_0)))))"
"(void"
"(add-core-form!*"
" '#%variable-reference"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-#%variable-reference s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 #%variable-reference423_0 id424_0)"
"(let-values(((s_1) s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(if(let-values(((s_5)(car s_4)))"
"(let-values(((or-part_0)"
"(if(syntax?$1 s_5)(symbol?(syntax-e$1 s_5)) #f)))"
"(if or-part_0 or-part_0(symbol? s_5))))"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))(null? s_6)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((#%variable-reference423_0 id424_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((#%variable-reference425_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id426_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((id427_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(values)))))"
"(values id427_0))))))"
"(values #%variable-reference425_0 id426_0)))))"
"(values #t #%variable-reference423_0 id424_0)))"
"(values #f #f #f)))))"
"(let-values(((ok?_1 #%variable-reference428_0 #%top429_0 id430_0)"
"(let-values(((s_1) s_0))"
"(if(if(not ok?_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(if(let-values(((s_5)(car s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(if(pair? s_6)"
"(if(let-values(((s_7)(car s_6))) #t)"
"(let-values(((s_7)(cdr s_6)))"
"(let-values(((or-part_0)"
"(if(syntax?$1 s_7)"
"(symbol?(syntax-e$1 s_7))"
" #f)))"
"(if or-part_0 or-part_0(symbol? s_7))))"
" #f)"
" #f)))"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(null? s_6)))"
" #f)"
" #f)))"
" #f)"
" #f))"
" #f)"
"(let-values()"
"(let-values(((#%variable-reference428_0 #%top429_0 id430_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((#%variable-reference431_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((#%top432_0 id433_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((#%top434_0 id435_0)"
"(let-values(((s_5)(car s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((#%top436_0)"
"(let-values(((s_7)"
"(car s_6)))"
" s_7))"
"((id437_0)"
"(let-values(((s_7)"
"(cdr s_6)))"
" s_7)))"
"(values #%top436_0 id437_0)))))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(values)))))"
"(values #%top434_0 id435_0))))))"
"(values #%variable-reference431_0 #%top432_0 id433_0)))))"
"(values #t #%variable-reference428_0 #%top429_0 id430_0)))"
"(values #f #f #f #f)))))"
"(let-values(((ok?_2 #%variable-reference438_0)"
"(let-values(((s_1) s_0))"
"(if(if(not(let-values(((or-part_0) ok?_0))(if or-part_0 or-part_0 ok?_1))) #t #f)"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%variable-reference438_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%variable-reference439_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"(()"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(null? s_4)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values #%variable-reference439_0))"
"                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%variable-reference438_0)))"
"(values #f #f)))))"
"(if(let-values(((or-part_0) ok?_0))(if or-part_0 or-part_0 ok?_1))"
"(let-values()"
"(let-values((()"
"(begin"
"(if ok?_1"
"(let-values()"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(if(if(identifier? #%top429_0)"
"(free-identifier=?$1 #%top429_0(core-id '#%top phase_0) phase_0 phase_0)"
" #f)"
"(void)"
"                                         (let-values () (raise-syntax-error$1 #f \"bad syntax\" s_0)))))"
"(void))"
"(values))))"
"(let-values(((var-id_0)(if ok?_0 id424_0 id430_0)))"
"((letrec-values(((rename-loop_0)"
"(lambda(var-id_1 from-rename?_0)"
"(begin"
" 'rename-loop"
"(let-values(((binding_0)"
"(let-values(((var-id440_0) var-id_1)"
"((temp441_0)(expand-context-phase ctx_0))"
"((temp442_0) 'ambiguous)"
"((temp443_0)"
"(not(expand-context-to-parsed? ctx_0))))"
"(resolve+shift.1"
" temp442_0"
" #f"
" null"
" temp443_0"
" #f"
" var-id440_0"
" temp441_0))))"
"(let-values((()"
"(begin"
"(if(eq? binding_0 'ambiguous)"
"(let-values()(raise-ambiguous-error var-id_1 ctx_0))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(if(let-values(((or-part_0) binding_0))"
"(if or-part_0"
" or-part_0"
"(expand-context-allow-unbound? ctx_0)))"
"(not(if ok?_1(local-binding? binding_0) #f))"
" #f)"
"(void)"
"(let-values()"
"(raise-unbound-syntax-error"
" #f"
"                                                                    \"unbound identifier\""
" s_0"
" var-id_1"
" null"
"(syntax-debug-info-string var-id_1 ctx_0))))"
"(values))))"
"(let-values(((t_0 primitive?_0)"
"(if(let-values(((or-part_0)(not binding_0)))"
"(if or-part_0"
" or-part_0"
"(if(expand-context-allow-unbound? ctx_0)"
" ok?_1"
" #f)))"
"(let-values()(values #f #f))"
"(let-values()"
"(check-top-binding-is-variable"
" ctx_0"
" binding_0"
" var-id_1"
" s_0)))))"
"(let-values(((substitute-vr-rename_0)"
"(lambda()"
"(begin"
" 'substitute-vr-rename"
"(if(let-values(((or-part_0) from-rename?_0))"
"(if or-part_0"
" or-part_0"
"(local-variable? t_0)))"
"(let-values()"
"(let-values(((vr-id_0)"
"(if ok?_0"
" #%variable-reference423_0"
" #%variable-reference428_0)))"
"(let-values(((s-var-id_0)"
"(let-values(((var-id444_0)"
" var-id_1)"
"((t445_0) t_0)"
"((temp446_0)"
"(free-id-set-empty-or-just-module*?"
"(expand-context-stops"
" ctx_0))))"
"(substitute-variable.1"
" temp446_0"
" var-id444_0"
" t445_0))))"
"(datum->syntax$1"
" s_0"
"(list vr-id_0 s-var-id_0)"
" s_0"
" s_0))))"
"(let-values() s_0))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(let-values()"
"(parsed-#%variable-reference11.1"
"(keep-properties-only~ s_0)"
"(if ok?_1"
"(let-values()(parsed-top-id4.1 var-id_1 binding_0 #f))"
"(if primitive?_0"
"(let-values()"
"(parsed-primitive-id3.1 var-id_1 binding_0 #f))"
"(let-values()(parsed-id2.1 var-id_1 binding_0 #f))))))"
"(if(1/rename-transformer? t_0)"
"(let-values()"
"(if(not-in-this-expand-context? t_0 ctx_0)"
"(let-values()"
"(let-values(((temp447_0)"
"(avoid-current-expand-context"
"(substitute-vr-rename_0)"
" t_0"
" ctx_0))"
"((ctx448_0) ctx_0))"
"(expand.1 #f #f temp447_0 ctx448_0)))"
"(let-values()"
"(rename-loop_0"
"(apply-rename-transformer t_0 var-id_1 ctx_0)"
" #t))))"
"(let-values()(substitute-vr-rename_0)))))))))))))"
" rename-loop_0)"
" var-id_0"
" #f))))"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-#%variable-reference11.1(keep-properties-only~ s_0) #f)"
" s_0))))))))))"
"(void"
"(add-core-form!*"
" '#%expression"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-#%expression s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 #%expression449_0 e450_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%expression449_0 e450_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%expression451_0)(let-values(((s_3)(car s_2))) s_3))"
"((e452_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((e453_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                    \"bad syntax\""
" orig-s_0))))))"
"(values e453_0))"
"                                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values #%expression451_0 e452_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%expression449_0 e450_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx454_0) ctx_0)((s455_0) s_0)((temp456_0) #t))"
"(keep-as-needed.1 temp456_0 #f #f ctx454_0 s455_0))))"
"(let-values(((exp-e_0)"
"(let-values(((temp457_0) e450_0)"
"((temp458_0)"
"(let-values(((temp459_0)(as-expression-context ctx_0))((ctx460_0) ctx_0))"
"(as-tail-context.1 ctx460_0 temp459_0))))"
"(expand.1 #f #f temp457_0 temp458_0))))"
"(if(expand-context-to-parsed? ctx_0)"
" exp-e_0"
"(if(let-values(((or-part_0)"
"(if(expand-context-in-local-expand? ctx_0)"
"(expand-context-keep-#%expression? ctx_0)"
" #f)))"
"(if or-part_0 or-part_0(eq? 'top-level(expand-context-context ctx_0))))"
"(let-values()"
"(let-values(((rebuild-s461_0) rebuild-s_0)((temp462_0)(list #%expression449_0 exp-e_0)))"
"(rebuild.1 #t rebuild-s461_0 temp462_0)))"
"(let-values()"
"(let-values(((result-s_0)(syntax-track-origin$1 exp-e_0 rebuild-s_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'tag result-s_0)))(void)))"
" result-s_0))))))))))))"
" (void (add-core-form!* 'unquote (lambda (s_0 ctx_0) (raise-syntax-error$1 #f \"not in quasiquote\" s_0))))"
" (void (add-core-form!* 'unquote-splicing (lambda (s_0 ctx_0) (raise-syntax-error$1 #f \"not in quasiquote\" s_0))))"
"(define-values"
"(binding-for-transformer?)"
"(lambda(b_0 id_0 at-phase_0 ns_0)"
"(begin"
"(if(not at-phase_0)"
"(let-values()"
"(if(non-self-module-path-index?(module-binding-nominal-module b_0))"
"(let-values()"
"(let-values(((m_0)"
"(namespace->module ns_0(1/module-path-index-resolve(module-binding-nominal-module b_0)))))"
"(let-values(((b/p_0)"
"(hash-ref"
"(hash-ref(module-provides m_0)(module-binding-nominal-phase+space b_0) '#hasheq())"
"(module-binding-nominal-sym b_0)"
" #f)))"
"(provided-as-transformer? b/p_0))))"
"(let-values() #t)))"
"(let-values()"
"(let-values((()"
"(begin"
"(namespace-visit-available-modules! ns_0(+ at-phase_0(module-binding-phase b_0)))"
"(values))))"
"(let-values(((val_0 primitive?_0 insp_0 protected?_0)"
"(let-values(((b1_0) b_0)"
"((empty-env2_0) empty-env)"
"((null3_0) null)"
"((ns4_0) ns_0)"
"((at-phase5_0) at-phase_0)"
"((id6_0) id_0)"
"((temp7_0) #f))"
"(binding-lookup.1 temp7_0 #f #f b1_0 empty-env2_0 null3_0 ns4_0 at-phase5_0 id6_0))))"
"(not(variable? val_0)))))))))"
"(define-values(layers) '(raw phaseless spaceless id))"
"(define-values(provide-form-name) 'provide)"
"(define-values"
"(parse-and-expand-provides!)"
"(lambda(specs_0 orig-s_0 rp_0 self_0 phase_0 ctx_0)"
"(begin"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"((letrec-values(((loop_0)"
"(lambda(specs_1 at-phase_0 at-space-level_0 protected?_0 layer_0 orig-s_1)"
"(begin"
" 'loop"
"(let-values(((track-stxess_0 exp-specss_0)"
"(let-values(((track-stxes_0 exp-specs_0)"
"(let-values(((track-stxes_0)"
"(let-values(((track-stxes_0) null))"
" track-stxes_0))"
"((exp-specs_0)"
"(let-values(((exp-specs_0) null))"
" exp-specs_0)))"
"(let-values(((lst_0) specs_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(track-stxes_1"
" exp-specs_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((spec_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(let-values()"
"(let-values(((track-stxes1_0"
" exp-specs2_0)"
"(let-values()"
"(let-values(((fm_0)"
"(if(pair?"
"(syntax-e$1"
" spec_0))"
"(if(identifier?"
"(car"
"(syntax-e$1"
" spec_0)))"
"(syntax-e$1"
"(car"
"(syntax-e$1"
" spec_0)))"
" #f)"
" #f)))"
"(let-values(((check-nested_0)"
"(lambda(want-layer_0)"
"(begin"
" 'check-nested"
"(if(member"
" want-layer_0"
"(member"
" layer_0"
" layers))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"(format"
"                                                                                                                                                                    \"nested `~a' not allowed\""
" fm_0)"
" orig-s_1"
" spec_0)))))))"
"(let-values(((tmp_0)"
" fm_0))"
"(let-values(((index_0)"
"(if(symbol?"
" tmp_0)"
"(hash-ref"
" '#hasheq((all-defined"
" ."
" 10)"
"(all-defined-except"
" ."
" 11)"
"(all-from"
" ."
" 8)"
"(all-from-except"
" ."
" 9)"
"(expand"
" ."
" 14)"
"(for-label"
" ."
" 3)"
"(for-meta"
" ."
" 1)"
"(for-space"
" ."
" 4)"
"(for-syntax"
" ."
" 2)"
"(prefix-all-defined"
" ."
" 12)"
"(prefix-all-defined-except"
" ."
" 13)"
"(protect"
" ."
" 5)"
"(rename ."
" 6)"
"(struct"
" ."
" 7))"
" tmp_0"
"(lambda()"
" 0))"
" 0)))"
"(if(unsafe-fx<"
" index_0"
" 7)"
"(if(unsafe-fx<"
" index_0"
" 3)"
"(if(unsafe-fx<"
" index_0"
" 1)"
"(let-values()"
"(if(identifier?"
" spec_0)"
"(let-values()"
"(begin"
"(parse-identifier!"
" spec_0"
" orig-s_1"
"(syntax-e$1"
" spec_0)"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                               \"bad syntax\""
" orig-s_1"
" spec_0))))"
"(if(unsafe-fx<"
" index_0"
" 2)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw)"
"(values))))"
"(let-values(((ok?_0"
" for-meta3_0"
" phase-level4_0"
" spec5_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((for-meta3_0"
" phase-level4_0"
" spec5_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-meta6_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((phase-level7_0"
" spec8_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((phase-level9_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec10_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_2))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level9_0"
" spec10_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2))))))"
"(values"
" for-meta6_0"
" phase-level7_0"
" spec8_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" for-meta3_0"
" phase-level4_0"
" spec5_0))))))"
"(let-values(((p_0)"
"(syntax-e$1"
" phase-level4_0)))"
"(let-values((()"
"(begin"
"(if(phase?"
" p_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                                                       \"bad `for-meta' phase\""
" orig-s_1"
" spec_0)))"
"(values))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec5_0"
"(phase+"
" p_0"
" at-phase_0)"
" at-space-level_0"
" protected?_0"
" 'phaseless"
" orig-s_1)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec11_0)"
" spec_0)"
"((temp12_0)"
"(list*"
" for-meta3_0"
" phase-level4_0"
" exp-specs_2)))"
"(rebuild.1"
" #t"
" spec11_0"
" temp12_0)))))))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw)"
"(values))))"
"(let-values(((ok?_0"
" for-syntax13_0"
" spec14_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((for-syntax13_0"
" spec14_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-syntax15_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec16_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_2))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-syntax15_0"
" spec16_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" for-syntax13_0"
" spec14_0))))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec14_0"
"(phase+"
" 1"
" at-phase_0)"
" at-space-level_0"
" protected?_0"
" 'phaseless"
" orig-s_1)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec17_0)"
" spec_0)"
"((temp18_0)"
"(list*"
" for-syntax13_0"
" exp-specs_2)))"
"(rebuild.1"
" #t"
" spec17_0"
" temp18_0)))))))))))"
"(if(unsafe-fx<"
" index_0"
" 4)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw)"
"(values))))"
"(let-values(((ok?_0"
" for-label19_0"
" spec20_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((for-label19_0"
" spec20_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-label21_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec22_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_2))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-label21_0"
" spec22_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                 \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" for-label19_0"
" spec20_0))))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec20_0"
" #f"
" at-space-level_0"
" protected?_0"
" 'phaseless"
" orig-s_1)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec23_0)"
" spec_0)"
"((temp24_0)"
"(list*"
" for-label19_0"
" exp-specs_2)))"
"(rebuild.1"
" #t"
" spec23_0"
" temp24_0)))))))))"
"(if(unsafe-fx<"
" index_0"
" 5)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" for-space25_0"
" space26_0"
" spec27_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((for-space25_0"
" space26_0"
" spec27_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-space28_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((space29_0"
" spec30_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((space31_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec32_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_2))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" space31_0"
" spec32_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2))))))"
"(values"
" for-space28_0"
" space29_0"
" spec30_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" for-space25_0"
" space26_0"
" spec27_0))))))"
"(let-values(((space_0)"
"(syntax-e$1"
" space26_0)))"
"(let-values((()"
"(begin"
"(if(space?"
" space_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                                                       \"bad `for-space' space\""
" orig-s_1"
" spec_0)))"
"(values))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec27_0"
" at-phase_0"
" space_0"
" protected?_0"
" 'spaceless"
" orig-s_1)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec33_0)"
" spec_0)"
"((temp34_0)"
"(list*"
" for-space25_0"
" space26_0"
" exp-specs_2)))"
"(rebuild.1"
" #t"
" spec33_0"
" temp34_0)))))))))))"
"(if(unsafe-fx<"
" index_0"
" 6)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values((()"
"(begin"
"(if protected?_0"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                                                     \"nested `protect' not allowed\""
" orig-s_1"
" spec_0))"
"(void))"
"(values))))"
"(let-values(((ok?_0"
" protect35_0"
" p-spec36_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((protect35_0"
" p-spec36_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((protect37_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((p-spec38_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_2))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" protect37_0"
" p-spec38_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" protect35_0"
" p-spec36_0))))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" p-spec36_0"
" at-phase_0"
" at-space-level_0"
" #t"
" layer_0"
" orig-s_1)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec39_0)"
" spec_0)"
"((temp40_0)"
"(list*"
" protect35_0"
" exp-specs_2)))"
"(rebuild.1"
" #t"
" spec39_0"
" temp40_0))))))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values(((ok?_0"
" rename41_0"
" id:from42_0"
" id:to43_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((rename41_0"
" id:from42_0"
" id:to43_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((rename44_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:from45_0"
" id:to46_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:from47_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"not an identifier\""
" orig-s_2"
" s_4))))"
"((id:to48_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((id:to49_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_2"
" s_6))))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_2))))))"
"(values"
" id:to49_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_2))))))"
"(values"
" id:from47_0"
" id:to48_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_2))))))"
"(values"
" rename44_0"
" id:from45_0"
" id:to46_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                     \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" rename41_0"
" id:from42_0"
" id:to43_0))))))"
"(begin"
"(parse-identifier!"
" id:from42_0"
" orig-s_1"
"(syntax-e$1"
" id:to43_0)"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))))))"
"(if(unsafe-fx<"
" index_0"
" 10)"
"(if(unsafe-fx<"
" index_0"
" 8)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" struct50_0"
" id:struct51_0"
" id:field52_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((struct50_0"
" id:struct51_0"
" id:field52_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((struct53_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:struct54_0"
" id:field55_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:struct56_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                       \"not an identifier\""
" orig-s_2"
" s_4))))"
"((id:field57_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((id:field58_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_7)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_2))"
"(let-values()"
"(let-values(((id:field_0)"
"(let-values(((id:field_0)"
"(let-values(((id:field_0)"
" null))"
" id:field_0)))"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id:field_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_8)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id:field_2)"
"(let-values(((id:field_2)"
"(let-values()"
"(let-values(((id:field59_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_8)"
"(symbol?"
"(syntax-e$1"
" s_8))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_8)))"
" s_8"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_2"
" s_8)))))"
"(cons"
" id:field59_0"
" id:field_1)))))"
"(values"
" id:field_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" id:field_2"
" rest_1)"
" id:field_2)))"
" id:field_1))))))"
" for-loop_1)"
" id:field_0"
" lst_2))))))"
"(reverse$1"
" id:field_0))))))))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_2))))))"
"(values"
" id:field58_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_2))))))"
"(values"
" id:struct56_0"
" id:field57_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_2))))))"
"(values"
" struct53_0"
" id:struct54_0"
" id:field55_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                 \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" struct50_0"
" id:struct51_0"
" id:field52_0))))))"
"(begin"
"(parse-struct!"
" id:struct51_0"
" orig-s_1"
" id:field52_0"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(if(unsafe-fx<"
" index_0"
" 9)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values(((ok?_0"
" all-from60_0"
" mod-path61_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((all-from60_0"
" mod-path61_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-from62_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((mod-path63_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((mod-path64_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(null?"
" s_5)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_2))))))"
"(values"
" mod-path64_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2))))))"
"(values"
" all-from62_0"
" mod-path63_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" all-from60_0"
" mod-path61_0))))))"
"(begin"
"(parse-all-from"
" mod-path61_0"
" orig-s_1"
" self_0"
" null"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0"
" ctx_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values(((ok?_0"
" all-from-except65_0"
" mod-path66_0"
" id67_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((all-from-except65_0"
" mod-path66_0"
" id67_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-from-except68_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((mod-path69_0"
" id70_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((mod-path71_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((id72_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_2))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id73_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_2"
" s_6)))))"
"(cons"
" id73_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_2"
" rest_1)"
" id_2)))"
" id_1))))))"
" for-loop_1)"
" id_0"
" lst_2))))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" mod-path71_0"
" id72_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2))))))"
"(values"
" all-from-except68_0"
" mod-path69_0"
" id70_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" all-from-except65_0"
" mod-path66_0"
" id67_0))))))"
"(begin"
"(parse-all-from"
" mod-path66_0"
" orig-s_1"
" self_0"
" id67_0"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0"
" ctx_0)"
"(values"
" null"
"(list"
" spec_0))))))))"
"(if(unsafe-fx<"
" index_0"
" 12)"
"(if(unsafe-fx<"
" index_0"
" 11)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values(((ok?_0"
" all-defined74_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((all-defined74_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-defined75_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"(()"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(null?"
" s_3)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2))))))"
"(values"
" all-defined75_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" all-defined74_0))))))"
"(begin"
"(parse-all-from-module"
" self_0"
" spec_0"
" orig-s_1"
" null"
" #f"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values(((ok?_0"
" all-defined-except76_0"
" id77_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((all-defined-except76_0"
" id77_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-defined-except78_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id79_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_2))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_4)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id80_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                           \"not an identifier\""
" orig-s_2"
" s_4)))))"
"(cons"
" id80_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_2"
" rest_1)"
" id_2)))"
" id_1))))))"
" for-loop_1)"
" id_0"
" lst_2))))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" all-defined-except78_0"
" id79_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" all-defined-except76_0"
" id77_0))))))"
"(begin"
"(parse-all-from-module"
" self_0"
" spec_0"
" orig-s_1"
" id77_0"
" #f"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0)))))))"
"(if(unsafe-fx<"
" index_0"
" 13)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values(((ok?_0"
" prefix-all-defined81_0"
" id:prefix82_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((prefix-all-defined81_0"
" id:prefix82_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((prefix-all-defined83_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:prefix84_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:prefix85_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                         \"not an identifier\""
" orig-s_2"
" s_4))))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(null?"
" s_5)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_2))))))"
"(values"
" id:prefix85_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2))))))"
"(values"
" prefix-all-defined83_0"
" id:prefix84_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" prefix-all-defined81_0"
" id:prefix82_0))))))"
"(begin"
"(parse-all-from-module"
" self_0"
" spec_0"
" orig-s_1"
" null"
"(syntax-e$1"
" id:prefix82_0)"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(if(unsafe-fx<"
" index_0"
" 14)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'spaceless)"
"(values))))"
"(let-values(((ok?_0"
" prefix-all-defined-except86_0"
" id:prefix87_0"
" id88_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((prefix-all-defined-except86_0"
" id:prefix87_0"
" id88_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((prefix-all-defined-except89_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:prefix90_0"
" id91_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:prefix92_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"not an identifier\""
" orig-s_2"
" s_4))))"
"((id93_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_2))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id94_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_2"
" s_6)))))"
"(cons"
" id94_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_2"
" rest_1)"
" id_2)))"
" id_1))))))"
" for-loop_1)"
" id_0"
" lst_2))))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" id:prefix92_0"
" id93_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_2))))))"
"(values"
" prefix-all-defined-except89_0"
" id:prefix90_0"
" id91_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                     \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" prefix-all-defined-except86_0"
" id:prefix87_0"
" id88_0))))))"
"(begin"
"(parse-all-from-module"
" self_0"
" spec_0"
" orig-s_1"
" id88_0"
"(syntax-e$1"
" id:prefix87_0)"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(let-values()"
"(let-values(((ok?_0"
" expand95_0"
" id96_0"
" datum97_0"
" orig98_0)"
"(let-values(((s_0)"
" spec_0))"
"(if(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6))))"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
" #t)"
" #f)"
" #f)))"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
" #t)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(null?"
" s_7)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((expand95_0"
" id96_0"
" datum97_0"
" orig98_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(let-values(((expand99_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id100_0"
" datum101_0"
" orig102_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((id103_0"
" datum104_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((id106_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((datum107_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
" s_6)))"
"(values"
" id106_0"
" datum107_0)))))"
"((orig105_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((orig108_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(values)))))"
"(values"
" orig108_0))))))"
"(values"
" id103_0"
" datum104_0"
" orig105_0))))))"
"(values"
" expand99_0"
" id100_0"
" datum101_0"
" orig102_0)))))"
"(values"
" #t"
" expand95_0"
" id96_0"
" datum97_0"
" orig98_0)))"
"(values"
" #f"
" #f"
" #f"
" #f"
" #f)))))"
"(let-values(((ok?_1"
" expand109_0"
" id110_0"
" datum111_0)"
"(let-values(((s_0)"
" spec_0))"
"(if(if(not"
" ok?_0)"
" #t"
" #f)"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((expand109_0"
" id110_0"
" datum111_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((expand112_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id113_0"
" datum114_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id115_0"
" datum116_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((id117_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_2"
" s_6))))"
"((datum118_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
" s_6)))"
"(values"
" id117_0"
" datum118_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_2)))))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(null?"
" s_5)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_2))))))"
"(values"
" id115_0"
" datum116_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_2))))))"
"(values"
" expand112_0"
" id113_0"
" datum114_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" expand109_0"
" id110_0"
" datum111_0)))"
"(values"
" #f"
" #f"
" #f"
" #f)))))"
"(let-values(((ok?_2"
" expand119_0"
" form120_0"
" _121_0)"
"(let-values(((s_0)"
" spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((expand119_0"
" form120_0"
" _121_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((expand122_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((form123_0"
" _124_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((form125_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((_126_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
" s_4)))"
"(values"
" form125_0"
" _126_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_2))))))"
"(values"
" expand122_0"
" form123_0"
" _124_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                       \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" expand119_0"
" form120_0"
" _121_0))))))"
"(let-values(((exp-spec_0)"
"(let-values(((temp131_0)"
" form120_0)"
"((temp132_0)"
"(let-values(((v_0)"
" ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((def-ctx-scopes133_0)"
" #f)"
"((inner134_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((stops135_0)"
"(free-id-set"
" at-phase_0"
"(list"
"(core-id"
" 'begin"
" at-phase_0)))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
" stops135_0"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                         \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner134_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
" def-ctx-scopes133_0"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                       \"expand-context/outer?\""
" the-struct_0))))))"
"(expand.1"
" #f"
" #f"
" temp131_0"
" temp132_0))))"
"(let-values((()"
"(begin"
"(if(if(pair?"
"(syntax-e$1"
" exp-spec_0))"
"(if(identifier?"
"(car"
"(syntax-e$1"
" exp-spec_0)))"
"(eq?"
" 'begin"
"(core-form-sym"
" exp-spec_0"
" at-phase_0))"
" #f)"
" #f)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                                                           \"expansion was not a `begin' sequence\""
" orig-s_1"
" spec_0)))"
"(values))))"
"(let-values(((ok?_3"
" begin127_0"
" spec128_0)"
"(let-values(((s_0)"
" exp-spec_0))"
"(let-values(((orig-s_2)"
" s_0))"
"(let-values(((begin127_0"
" spec128_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((begin129_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec130_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_2))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin129_0"
" spec130_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                             \"bad syntax\""
" orig-s_2)))))"
"(values"
" #t"
" begin127_0"
" spec128_0))))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec128_0"
" at-phase_0"
" at-space-level_0"
" protected?_0"
" layer_0"
"(let-values(((or-part_0)"
" orig98_0))"
"(if or-part_0"
" or-part_0"
" orig-s_1)))))"
"(values"
"(list*"
" spec_0"
" exp-spec_0"
" track-stxes_2)"
" exp-specs_2)))))))))))))))))))))"
"(values"
"(cons"
" track-stxes1_0"
" track-stxes_1)"
"(cons"
" exp-specs2_0"
" exp-specs_1))))))"
"(values"
" track-stxes_2"
" exp-specs_2))))"
"(if(not #f)"
"(for-loop_0"
" track-stxes_2"
" exp-specs_2"
" rest_0)"
"(values"
" track-stxes_2"
" exp-specs_2))))"
"(values"
" track-stxes_1"
" exp-specs_1)))))))"
" for-loop_0)"
" track-stxes_0"
" exp-specs_0"
" lst_0))))))"
"(values(reverse$1 track-stxes_0)(reverse$1 exp-specs_0)))))"
"(values(apply append track-stxess_0)(apply append exp-specss_0)))))))"
" loop_0)"
" specs_0"
" phase_0"
" '#:none"
" #f"
" 'raw"
" orig-s_0)))))"
"(define-values"
"(parse-identifier!)"
"(lambda(spec_0 orig-s_0 sym_0 at-phase_0 at-space-level_0 ns_0 rp_0 protected?_0)"
"(begin"
"(let-values(((at-space_0)(space+ #f at-space-level_0)))"
"(let-values(((spec-at-space_0)(add-space-scope spec_0 at-space_0)))"
"(let-values(((b_0)(resolve+shift/extra-inspector spec-at-space_0 at-phase_0 ns_0)))"
"(let-values((()"
"(begin"
"(if(module-binding? b_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                 \"provided identifier is not defined or required\""
" orig-s_0"
" spec_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if at-space_0"
"(let-values()"
"(if(identifier-binding-uses-scope?"
" spec-at-space_0"
"(make-interned-scope at-space_0)"
" at-phase_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                       \"provided identifier is defined only outside the space\""
" orig-s_0"
" spec_0))))"
"(void))"
"(values))))"
"(let-values(((as-transformer?_0)(binding-for-transformer? b_0 spec_0 at-phase_0 ns_0)))"
"(let-values(((immed-b_0)"
"(let-values(((spec145_0) spec_0)((at-phase146_0) at-phase_0)((temp147_0) #t))"
"(resolve+shift.1 #f #f null temp147_0 #f spec145_0 at-phase146_0))))"
"(let-values(((rp136_0) rp_0)"
"((sym137_0) sym_0)"
"((temp138_0)(intern-phase+space at-phase_0 at-space_0))"
"((b139_0) b_0)"
"((immed-b140_0) immed-b_0)"
"((spec141_0) spec_0)"
"((orig-s142_0) orig-s_0)"
"((protected?143_0) protected?_0)"
"((as-transformer?144_0) as-transformer?_0))"
"(add-provide!.1"
" protected?143_0"
" as-transformer?144_0"
" rp136_0"
" sym137_0"
" temp138_0"
" b139_0"
" immed-b140_0"
" spec141_0"
" orig-s142_0))))))))))))"
"(define-values"
"(parse-struct!)"
"(lambda(id:struct_0 orig-s_0 fields_0 at-phase_0 ns_0 rp_0 protected?_0)"
"(begin"
"(let-values(((mk_0)"
"(lambda(fmt_0)"
"(begin"
" 'mk"
"(let-values(((sym_0)(string->symbol(format fmt_0(syntax-e$1 id:struct_0)))))"
"(datum->syntax$1 id:struct_0 sym_0 id:struct_0))))))"
"(let-values(((mk2_0)"
"(lambda(fmt_0 field-id_0)"
"(begin"
" 'mk2"
"(let-values(((sym_0)"
"(string->symbol"
"(format fmt_0(syntax-e$1 id:struct_0)(syntax-e$1 field-id_0)))))"
"(datum->syntax$1 id:struct_0 sym_0 id:struct_0))))))"
"(begin"
"(let-values()"
"              (let-values (((lst_0) (list \"~a\" \"make-~a\" \"struct:~a\" \"~a?\")))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((fmt_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((id_0)(mk_0 fmt_0)))"
"(parse-identifier!"
" id_0"
" orig-s_0"
"(syntax-e$1 id_0)"
" at-phase_0"
" #f"
" ns_0"
" rp_0"
" protected?_0)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(let-values()"
"(let-values(((lst_0) fields_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((field_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((get-id_0)"
"                                                                                            (mk2_0 \"~a-~a\" field_0)))"
"(let-values(((set-id_0)"
"(mk2_0"
"                                                                                               \"set-~a-~a!\""
" field_0)))"
"(begin"
"(parse-identifier!"
" get-id_0"
" orig-s_0"
"(syntax-e$1 get-id_0)"
" at-phase_0"
" #f"
" ns_0"
" rp_0"
" protected?_0)"
"(parse-identifier!"
" set-id_0"
" orig-s_0"
"(syntax-e$1 set-id_0)"
" at-phase_0"
" #f"
" ns_0"
" rp_0"
" protected?_0)))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))))"
"(define-values"
"(parse-all-from)"
"(lambda(mod-path-stx_0 orig-s_0 self_0 except-ids_0 at-phase_0 at-space-level_0 ns_0 rp_0 protected?_0 ctx_0)"
"(begin"
"(let-values(((mod-path_0)(syntax->datum$1 mod-path-stx_0)))"
"(let-values((()"
"(begin"
"(if(1/module-path? mod-path_0)"
"(void)"
"(let-values()"
"                            (raise-syntax-error$1 provide-form-name \"not a module path\" orig-s_0 mod-path-stx_0)))"
"(values))))"
"(let-values(((mpi_0)(module-path->mpi/context mod-path_0 ctx_0)))"
"(parse-all-from-module"
" mpi_0"
" #f"
" orig-s_0"
" except-ids_0"
" #f"
" at-phase_0"
" at-space-level_0"
" ns_0"
" rp_0"
" protected?_0)))))))"
"(define-values"
"(parse-all-from-module)"
"(lambda(mpi_0 matching-stx_0 orig-s_0 except-ids_0 prefix-sym_0 at-phase_0 at-space-level_0 ns_0 rp_0 protected?_0)"
"(begin"
"(let-values(((at-phase+space-shift_0)(intern-phase+space-shift at-phase_0 at-space-level_0)))"
"(let-values(((requireds_0)(extract-module-requires rp_0 mpi_0 at-phase+space-shift_0)))"
"(let-values(((phase-desc_0)"
"(lambda()"
"(begin"
" 'phase-desc"
"(string-append"
"(if(zero-phase? at-phase_0)"
"                               (let-values () \"\")"
"(if(label-phase? at-phase_0)"
"                                 (let-values () \" for-label\")"
"                                 (let-values () (format \" for phase level ~a\" at-phase_0))))"
"(if(not(space+ #f at-space-level_0))"
"                               (let-values () \"\")"
"                               (let-values () (format \" in space level ~s\" at-space-level_0))))))))"
"(let-values((()"
"(begin"
"(if requireds_0"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                 (format \"cannot provide from a module without a matching require~a\" (phase-desc_0))"
" orig-s_0"
" matching-stx_0)))"
"(values))))"
"(let-values(((add-prefix_0)"
"(lambda(sym_0)"
"(begin"
" 'add-prefix"
"(if prefix-sym_0"
"(string->symbol(string-append(symbol->string prefix-sym_0)(symbol->string sym_0)))"
" sym_0)))))"
"(let-values(((at-phase+space_0)(phase+space+ 0 at-phase+space-shift_0)))"
"(let-values(((found_0)(make-hasheq)))"
"(begin"
"(let-values()"
"(let-values(((lst_0) requireds_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((id_0)"
"(required-id"
" i_0)))"
"(let-values(((phase+space_0)"
"(required-phase+space"
" i_0)))"
"(let-values(((phase_0)"
"(phase+space-phase"
" phase+space_0)))"
"(let-values(((space_0)"
"(phase+space-space"
" phase+space_0)))"
"(if(let-values(((or-part_0)"
"(if matching-stx_0"
"(not"
"(if(eqv?"
" phase+space_0"
" at-phase+space_0)"
"(free-identifier=?$1"
" id_0"
"(add-space-scope"
"(datum->syntax$1"
" matching-stx_0"
"(syntax-e$1"
" id_0))"
" space_0)"
" phase_0"
" phase_0)"
" #f))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((result_0)"
"(let-values(((result_0)"
" #f))"
" result_0)))"
"(let-values(((lst_2)"
" except-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(result_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((except-id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(free-identifier=?$1"
" id_0"
"(add-space-scope"
" except-id_0"
" space_0)"
" phase_0"
" phase_0)"
"(hash-set!"
" found_0"
" except-id_0"
" #t)"
" #f)))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
" result_2)"
" except-id_0))"
"(not"
" #f)"
" #f)"
"(for-loop_1"
" result_2"
" rest_1)"
" result_2)))"
" result_1))))))"
" for-loop_1)"
" result_0"
" lst_2))))))"
"(void)"
"(let-values()"
"(let-values(((b_0)"
"(resolve+shift/extra-inspector"
" id_0"
" phase_0"
" ns_0)))"
"(let-values(((immed-b_0)"
"(let-values(((id157_0)"
" id_0)"
"((phase158_0)"
" phase_0)"
"((temp159_0)"
" #t))"
"(resolve+shift.1"
" #f"
" #f"
" null"
" temp159_0"
" #f"
" id157_0"
" phase158_0))))"
"(let-values(((rp148_0)"
" rp_0)"
"((temp149_0)"
"(add-prefix_0"
"(syntax-e$1"
" id_0)))"
"((phase+space150_0)"
" phase+space_0)"
"((b151_0)"
" b_0)"
"((immed-b152_0)"
" immed-b_0)"
"((id153_0)"
" id_0)"
"((orig-s154_0)"
" orig-s_0)"
"((protected?155_0)"
" protected?_0)"
"((temp156_0)"
"(required-as-transformer?"
" i_0)))"
"(add-provide!.1"
" protected?155_0"
" temp156_0"
" rp148_0"
" temp149_0"
" phase+space150_0"
" b151_0"
" immed-b152_0"
" id153_0"
" orig-s154_0)))))))))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(if(=(hash-count found_0)(length except-ids_0))"
"(void)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0) except-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((except-id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(let-values(((or-part_0)"
"(hash-ref"
" found_0"
" except-id_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((result_0)"
"(let-values(((result_0)"
" #f))"
" result_0)))"
"(let-values(((lst_2)"
" requireds_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(result_1"
" lst_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_3)"
"(let-values(((i_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_2)"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((id_0)"
"(required-id"
" i_0)))"
"(let-values(((phase+space_0)"
"(required-phase+space"
" i_0)))"
"(let-values(((phase_0)"
"(phase+space-phase"
" phase+space_0)))"
"(let-values(((space_0)"
"(phase+space-space"
" phase+space_0)))"
"(free-identifier=?$1"
" id_0"
"(add-space-scope"
" except-id_0"
" space_0)"
" phase_0"
" phase_0)))))))))"
"(values"
" result_2))))"
"(if(if(not"
"((lambda x_0"
" result_2)"
" i_0))"
"(not"
" #f)"
" #f)"
"(for-loop_1"
" result_2"
" rest_1)"
" result_2)))"
" result_1))))))"
" for-loop_1)"
" result_0"
" lst_2))))))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"(format"
"(if matching-stx_0"
"                                                                                                      \"excluded identifier was not defined or required in the module~a\""
"                                                                                                      \"excluded identifier was not required from the specified module~a\")"
"(phase-desc_0))"
" orig-s_0"
" except-id_0))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))))))))))))"
"(define-values"
"(check-cross-phase-persistent-form)"
"(lambda(bodys_0 self-mpi_0)"
"(begin"
"(letrec-values(((check-body_0)"
"(lambda(bodys_1)"
"(begin"
" 'check-body"
"(begin"
"(let-values()"
"(let-values(((lst_0) bodys_1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((p_0)"
"(if(expanded+parsed?"
" body_0)"
"(expanded+parsed-parsed"
" body_0)"
" body_0)))"
"(if(parsed-define-values?"
" p_0)"
"(let-values()"
"(check-expr_0"
"(parsed-define-values-rhs"
" p_0)"
"(length"
"(parsed-define-values-syms"
" p_0))"
" p_0))"
"(if(let-values(((or-part_0)"
"(parsed-#%declare?"
" p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(parsed-module?"
" p_0)))"
"(if or-part_1"
" or-part_1"
"(syntax?$1"
" p_0)))))"
"(let-values()"
"(void))"
"(let-values()"
"(disallow"
" p_0))))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))"
"((check-expr_0)"
"(lambda(e_0 num-results_0 enclosing_0)"
"(begin"
" 'check-expr"
"(if(parsed-lambda? e_0)"
"(let-values()"
"(begin(check-count 1 num-results_0 enclosing_0)(check-no-disallowed-expr_0 e_0)))"
"(if(parsed-case-lambda? e_0)"
"(let-values()"
"(begin(check-count 1 num-results_0 enclosing_0)(check-no-disallowed-expr_0 e_0)))"
"(if(parsed-quote? e_0)"
"(let-values()"
"(begin"
"(check-datum(parsed-quote-datum e_0) e_0)"
"(check-count 1 num-results_0 enclosing_0)))"
"(if(parsed-app? e_0)"
"(let-values()"
"(let-values(((rands_0)(parsed-app-rands e_0)))"
"(begin"
"(let-values()"
"(let-values(((lst_0) rands_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((rand_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-expr_0"
" rand_0"
" 1"
" e_0))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(let-values(((tmp_0)(cross-phase-primitive-name(parsed-app-rator e_0))))"
"(if(if(equal? tmp_0 'cons)"
" #t"
"(if(equal? tmp_0 'list) #t(equal? tmp_0 'hasheq)))"
"(let-values()(check-count 1 num-results_0 enclosing_0))"
"(if(equal? tmp_0 'make-struct-type)"
"(let-values()(check-count 5 num-results_0 enclosing_0))"
"(if(equal? tmp_0 'make-struct-type-property)"
"(let-values()(check-count 3 num-results_0 enclosing_0))"
"(if(equal? tmp_0 'make-parameter)"
"(let-values()(check-count 1 num-results_0 enclosing_0))"
"(if(equal? tmp_0 'gensym)"
"(let-values()"
"(if(let-values(((or-part_0)(= 0(length rands_0))))"
"(if or-part_0"
" or-part_0"
"(if(= 1(length rands_0))"
"(quoted-string?(car rands_0))"
" #f)))"
"(void)"
"(let-values()(disallow e_0))))"
"(if(equal? tmp_0 'string->uninterned-symbol)"
"(let-values()"
"(if(if(= 1(length rands_0))"
"(quoted-string?(car rands_0))"
" #f)"
"(void)"
"(let-values()(disallow e_0))))"
"(let-values()(disallow e_0))))))))))))"
"(let-values()(check-no-disallowed-expr_0 e_0)))))))))"
"((check-no-disallowed-expr_0)"
"(lambda(e_0)"
"(begin"
" 'check-no-disallowed-expr"
"(if(parsed-lambda? e_0)"
"(let-values()(check-body-no-disallowed-expr_0(parsed-lambda-body e_0)))"
"(if(parsed-case-lambda? e_0)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)(parsed-case-lambda-clauses e_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((clause_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-body-no-disallowed-expr_0"
"(cadr clause_0)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))"
"(if(if(parsed-app? e_0)"
"(if(eq?"
" 'variable-reference-from-unsafe?"
"(cross-phase-primitive-name(parsed-app-rator e_0)))"
"(andmap2 parsed-#%variable-reference?(parsed-app-rands e_0))"
" #f)"
" #f)"
"(let-values()(void))"
"(if(parsed-app? e_0)"
"(let-values()"
"(begin"
"(check-no-disallowed-expr_0(parsed-app-rator e_0))"
"(let-values()"
"(let-values(((lst_0)(parsed-app-rands e_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-no-disallowed-expr_0"
" e_1))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))"
"(if(parsed-if? e_0)"
"(let-values()"
"(begin"
"(check-no-disallowed-expr_0(parsed-if-tst e_0))"
"(check-no-disallowed-expr_0(parsed-if-thn e_0))"
"(check-no-disallowed-expr_0(parsed-if-els e_0))))"
"(if(parsed-set!? e_0)"
"(let-values()"
"(let-values(((id_0)(parsed-set!-id e_0)))"
"(let-values(((normal-b_0)(parsed-id-binding id_0)))"
"(begin"
"(if(let-values(((or-part_0)(not normal-b_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(parsed-top-id? id_0)))"
"(if or-part_1"
" or-part_1"
"(if(not(symbol? normal-b_0))"
"(eq?(module-binding-module normal-b_0) self-mpi_0)"
" #f)))))"
"(let-values()(disallow e_0))"
"(void))"
"(check-no-disallowed-expr_0(parsed-set!-rhs e_0))))))"
"(if(parsed-with-continuation-mark? e_0)"
"(let-values()"
"(begin"
"(check-no-disallowed-expr_0(parsed-with-continuation-mark-key e_0))"
"(check-no-disallowed-expr_0(parsed-with-continuation-mark-val e_0))"
"(check-no-disallowed-expr_0(parsed-with-continuation-mark-body e_0))))"
"(if(parsed-begin? e_0)"
"(let-values()(check-body-no-disallowed-expr_0(parsed-begin-body e_0)))"
"(if(parsed-begin0? e_0)"
"(let-values()(check-body-no-disallowed-expr_0(parsed-begin0-body e_0)))"
"(if(parsed-let_-values? e_0)"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)(parsed-let_-values-clauses e_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((clause_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-no-disallowed-expr_0"
"(cadr"
" clause_0)))"
"(values)))))"
"(values))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(check-body-no-disallowed-expr_0(parsed-let_-values-body e_0))))"
"(if(let-values(((or-part_0)(parsed-quote-syntax? e_0)))"
"(if or-part_0 or-part_0(parsed-#%variable-reference? e_0)))"
"(let-values()(disallow e_0))"
"(let-values()(void))))))))))))))))"
"((check-body-no-disallowed-expr_0)"
"(lambda(l_0)"
"(begin"
" 'check-body-no-disallowed-expr"
"(begin"
"(let-values()"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-no-disallowed-expr_0"
" e_0))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))))))"
"(check-body_0 bodys_0)))))"
"(define-values"
"(check-count)"
"(lambda(is-num_0 expected-num_0 enclosing_0)"
"(begin(if(= is-num_0 expected-num_0)(void)(let-values()(disallow enclosing_0))))))"
"(define-values"
"(check-datum)"
"(lambda(d_0 e_0)"
"(begin"
"(if(let-values(((or-part_0)(number? d_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? d_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(symbol? d_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(string? d_0)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(bytes? d_0)))(if or-part_4 or-part_4(null? d_0)))))))))))"
"(let-values()(void))"
"(let-values()(disallow e_0))))))"
"(define-values(quoted-string?)(lambda(e_0)(begin(if(parsed-quote? e_0)(string?(parsed-quote-datum e_0)) #f))))"
"(define-values"
"(cross-phase-primitive-name)"
"(lambda(id_0)"
"(begin"
"(if(parsed-id? id_0)"
"(let-values()"
"(let-values(((b_0)(parsed-id-binding id_0)))"
"(if(module-binding? b_0)"
"(if(eq? runtime-module-name(1/module-path-index-resolve(module-binding-module b_0)))"
"(module-binding-sym b_0)"
" #f)"
" #f)))"
"(let-values() #f)))))"
"(define-values"
"(disallow)"
"(lambda(body_0)"
"(begin"
"(raise-syntax-error$1"
" 'module"
"       \"not allowed in a cross-phase persistent module\""
"(if(parsed? body_0)(datum->syntax$1 #f body_0(parsed-s body_0)) body_0)))))"
"(define-values"
"(1/call-with-module-prompt)"
"(lambda(thunk_0)"
"(begin"
" 'call-with-module-prompt"
"(call-with-continuation-prompt thunk_0(default-continuation-prompt-tag) module-prompt-handler))))"
"(define-values"
"(call-with-module-prompt/value-list)"
"(lambda(who_0 thunk_0 ids_0 handler_0)"
"(begin"
"(1/call-with-module-prompt"
"(lambda()"
"(call-with-values"
" thunk_0"
"(lambda vals_0"
"(begin"
"(if(=(length vals_0)(length ids_0))"
"(void)"
"(let-values()(raise-bindings-arity-error who_0 ids_0 vals_0)))"
"(handler_0 vals_0)"
"(apply values vals_0)))))))))"
"(define-values"
"(module-prompt-handler)"
"(lambda args_0(begin(apply abort-current-continuation(default-continuation-prompt-tag) args_0))))"
"(void"
"(add-core-form!*"
" 'module"
"(lambda(s_0 ctx_0)"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-module #f)))(void)))"
"             (raise-syntax-error$1 #f \"allowed only at the top level or in a module top-level\" s_0))))"
"(if log-performance?(let-values()(start-performance-region 'expand 'module))(void))"
"(begin0"
"(let-values()"
"(let-values(((s211_0) s_0)((ctx212_0) ctx_0)((temp213_0) #f))"
"(expand-module.1 #f #f #f #f unsafe-undefined #f s211_0 ctx212_0 temp213_0)))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))"
"(void"
"(add-core-form!*"
" 'module*"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-module #f)))(void)))"
"       (raise-syntax-error$1 #f \"illegal use (not in a module top-level)\" s_0)))))"
"(void"
"(add-core-form!*"
" '#%module-begin"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-module-begin #f)))(void)))"
"(if(eq?(expand-context-context ctx_0) 'module-begin)"
"(void)"
"         (let-values () (raise-syntax-error$1 #f \"not in a module-definition context\" s_0)))"
"(if(expand-context-module-begin-k ctx_0)"
"(void)"
"         (let-values () (raise-syntax-error$1 #f \"not currently transforming a module\" s_0)))"
"((expand-context-module-begin-k ctx_0)"
" s_0"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner214_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((module-begin-k215_0) #f))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
"(expand-context/inner-to-parsed? the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once? the-struct_1)"
" module-begin-k215_0"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-parsing-expanded? the-struct_1)"
"(expand-context/inner-skip-visit-available? the-struct_1)))"
"                                (raise-argument-error 'struct-copy \"expand-context/inner?\" the-struct_1)))))"
"(expand-context/outer1.1"
" inner214_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"              (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))))"
"(void"
"(add-core-form!*"
" '#%declare"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-declare #f)))(void)))"
"       (raise-syntax-error$1 #f \"not allowed outside of a module top-level\" s_0)))))"
"(define-values"
"(expand-module.1)"
"(lambda(always-produce-compiled?1_0"
" enclosing-is-cross-phase-persistent?3_0"
" enclosing-requires+provides4_0"
" keep-enclosing-scope-at-phase2_0"
" modules-being-compiled6_0"
" mpis-for-enclosing-reset5_0"
" s13_0"
" init-ctx14_0"
" enclosing-self15_0)"
"(begin"
" 'expand-module"
"(let-values(((s_0) s13_0))"
"(let-values(((init-ctx_0) init-ctx14_0))"
"(let-values(((enclosing-self_0) enclosing-self15_0))"
"(let-values(((always-produce-compiled?_0) always-produce-compiled?1_0))"
"(let-values(((keep-enclosing-scope-at-phase_0) keep-enclosing-scope-at-phase2_0))"
"(let-values(((enclosing-is-cross-phase-persistent?_0) enclosing-is-cross-phase-persistent?3_0))"
"(let-values(((enclosing-r+p_0) enclosing-requires+provides4_0))"
"(let-values(((mpis-for-enclosing-reset_0) mpis-for-enclosing-reset5_0))"
"(let-values(((modules-being-compiled_0)"
"(if(eq? modules-being-compiled6_0 unsafe-undefined)"
"(make-hasheq)"
" modules-being-compiled6_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer init-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'prim-module s_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 module216_0 id:module-name217_0 initial-require218_0 body219_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((module216_0"
" id:module-name217_0"
" initial-require218_0"
" body219_0)"
"(let-values(((s_2)"
"(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((module220_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id:module-name221_0"
" initial-require222_0"
" body223_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((id:module-name224_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_5)"
"(symbol?"
"(syntax-e$1"
" s_5))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_5)))"
" s_5"
"(raise-syntax-error$1"
" #f"
"                                                                                                       \"not an identifier\""
" orig-s_0"
" s_5))))"
"((initial-require225_0"
" body226_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((initial-require227_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((body228_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" initial-require227_0"
" body228_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:module-name224_0"
" initial-require225_0"
" body226_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" module220_0"
" id:module-name221_0"
" initial-require222_0"
" body223_0))"
"                                                                (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values"
" #t"
" module216_0"
" id:module-name217_0"
" initial-require218_0"
" body219_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((init-ctx236_0) init-ctx_0)"
"((s237_0) s_0)"
"((temp238_0) #t)"
"((temp239_0) #t))"
"(keep-as-needed.1 #f temp239_0 temp238_0 init-ctx236_0 s237_0))))"
"(let-values(((initial-require_0)(syntax->datum$1 initial-require218_0)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0) keep-enclosing-scope-at-phase_0))"
"(if or-part_0 or-part_0(1/module-path? initial-require_0)))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                       \"not a module path\""
" s_0"
" initial-require218_0)))"
"(values))))"
"(let-values(((phase_0) 0))"
"(let-values(((module-name-sym_0)(syntax-e$1 id:module-name217_0)))"
"(let-values(((outside-scope_0)(new-scope 'module)))"
"(let-values(((inside-scope_0)(new-multi-scope module-name-sym_0)))"
"(let-values(((self_0)"
"(make-self-module-path-index"
"(if enclosing-self_0"
" module-name-sym_0"
"(string->uninterned-symbol"
"(symbol->string module-name-sym_0)))"
" enclosing-self_0)))"
"(let-values(((enclosing-mod_0)"
"(if enclosing-self_0"
"                                                              (1/module-path-index-join '(submod \"..\") self_0)"
" #f)))"
"(let-values((()"
"(begin"
"(if mpis-for-enclosing-reset_0"
"(let-values()"
"(set-box!"
" mpis-for-enclosing-reset_0"
"(cons"
" enclosing-mod_0"
"(unbox mpis-for-enclosing-reset_0))))"
"(void))"
"(values))))"
"(let-values(((apply-module-scopes_0)"
"(make-apply-module-scopes"
" outside-scope_0"
" inside-scope_0"
" init-ctx_0"
" keep-enclosing-scope-at-phase_0"
" self_0"
" enclosing-self_0"
" enclosing-mod_0)))"
"(let-values(((initial-require-s_0)"
"(apply-module-scopes_0 initial-require218_0)))"
"(let-values(((all-scopes-s_0) initial-require-s_0))"
"(let-values(((root-ctx_0)"
"(let-values(((self240_0) self_0)"
"((temp241_0)"
"(if keep-enclosing-scope-at-phase_0"
"(root-expand-context-module-scopes"
" init-ctx_0)"
" null))"
"((outside-scope242_0)"
" outside-scope_0)"
"((inside-scope243_0) inside-scope_0)"
"((all-scopes-s244_0) all-scopes-s_0))"
"(make-root-expand-context.1"
" all-scopes-s244_0"
" temp241_0"
" outside-scope242_0"
" inside-scope243_0"
" self240_0))))"
"(let-values(((new-module-scopes_0)"
"(root-expand-context-module-scopes root-ctx_0)))"
"(let-values(((frame-id_0)"
"(root-expand-context-frame-id root-ctx_0)))"
"(let-values(((portal-syntaxes_0)(make-hasheqv)))"
"(let-values(((make-m-ns_0)"
"(lambda(for-submodule?229_0 ns231_0)"
"(begin"
" 'make-m-ns"
"(let-values(((ns_0) ns231_0))"
"(let-values(((for-submodule?_0)"
"(if(eq?"
" for-submodule?229_0"
" unsafe-undefined)"
"(if enclosing-self_0"
" #t"
" #f)"
" for-submodule?229_0)))"
"(let-values()"
"(let-values(((ns245_0) ns_0)"
"((self246_0)"
" self_0)"
"((root-ctx247_0)"
" root-ctx_0)"
"((for-submodule?248_0)"
" for-submodule?_0)"
"((portal-syntaxes249_0)"
" portal-syntaxes_0))"
"(make-module-namespace.1"
" for-submodule?248_0"
" self246_0"
" portal-syntaxes249_0"
" root-ctx247_0"
" ns245_0)))))))))"
"(let-values()"
"(let-values()"
"(let-values(((m-ns_0)"
"(let-values(((temp250_0)"
"(expand-context-namespace"
" init-ctx_0)))"
"(make-m-ns_0"
" unsafe-undefined"
" temp250_0))))"
"(let-values(((ctx_0)"
"(let-values(((v_0)"
"(copy-root-expand-context"
" init-ctx_0"
" root-ctx_0)))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((post-expansion251_0)"
"(lambda(s_1)"
"(begin"
" 'post-expansion251"
"(add-scope"
" s_1"
" inside-scope_0))))"
"((inner252_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((allow-unbound?253_0)"
" #f)"
"((namespace254_0)"
" m-ns_0)"
"((phase255_0)"
" phase_0)"
"((just-once?256_0)"
" #f))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase255_0"
" namespace254_0"
" just-once?256_0"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
" allow-unbound?253_0"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                               \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner252_0"
" post-expansion251_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                             \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((bodys_0)"
"(let-values(((scoped-s_0)"
"(apply-module-scopes_0"
" s_0)))"
"(let-values(((ok?_1"
" _257_0"
" _258_0"
" _259_0"
" body260_0)"
"(let-values(((s_1)"
" scoped-s_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((_257_0"
" _258_0"
" _259_0"
" body260_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((_261_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((_262_0"
" _263_0"
" body264_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((_265_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
" s_5))"
"((_266_0"
" body267_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((_268_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((body269_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _268_0"
" body269_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" _265_0"
" _266_0"
" body267_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" _261_0"
" _262_0"
" _263_0"
" body264_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                               \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _257_0"
" _258_0"
" _259_0"
" body260_0))))))"
" body260_0))))"
"(let-values(((requires+provides_0)"
"(let-values(((self270_0)"
" self_0)"
"((portal-syntaxes271_0)"
" portal-syntaxes_0))"
"(make-requires+provides.1"
" #f"
" portal-syntaxes271_0"
" self270_0))))"
"(let-values(((defined-syms_0)"
"(root-expand-context-defined-syms"
" root-ctx_0)))"
"(let-values(((compiled-submodules_0)"
"(make-hasheq)))"
"(let-values(((compiled-module-box_0)"
"(box #f)))"
"(let-values(((mpis-to-reset_0)"
"(box null)))"
"(let-values(((add-defined-portal_0)"
"(make-add-defined-portal"
" self_0"
" requires+provides_0"
" portal-syntaxes_0"
" defined-syms_0"
" all-scopes-s_0"
" frame-id_0"
" m-ns_0)))"
"(let-values(((initial-require!_0)"
"(lambda(bind?233_0)"
"(begin"
" 'initial-require!"
"(let-values(((bind?_0)"
" bind?233_0))"
"(let-values()"
"(if(not"
" keep-enclosing-scope-at-phase_0)"
"(let-values()"
"(let-values(((initial-mpi_0)"
"(build-initial-require-mpi"
" initial-require_0"
" self_0)))"
"(begin"
"(let-values(((initial-mpi272_0)"
" initial-mpi_0)"
"((self273_0)"
" self_0)"
"((all-scopes-s274_0)"
" all-scopes-s_0)"
"((m-ns275_0)"
" m-ns_0)"
"((requires+provides276_0)"
" requires+provides_0)"
"((bind?277_0)"
" bind?_0)"
"((temp278_0)"
" 'module))"
"(perform-initial-require!.1"
" bind?277_0"
" temp278_0"
" initial-mpi272_0"
" self273_0"
" all-scopes-s274_0"
" m-ns275_0"
" requires+provides276_0))"
" initial-mpi_0)))"
"(let-values()"
"(begin"
"(add-required-module!"
" requires+provides_0"
" enclosing-mod_0"
" keep-enclosing-scope-at-phase_0"
" enclosing-is-cross-phase-persistent?_0)"
"(let-values(((requires+provides279_0)"
" requires+provides_0)"
"((enclosing-r+p280_0)"
" enclosing-r+p_0)"
"((enclosing-mod281_0)"
" enclosing-mod_0)"
"((keep-enclosing-scope-at-phase282_0)"
" keep-enclosing-scope-at-phase_0))"
"(add-enclosing-module-defined-and-required!.1"
" enclosing-r+p280_0"
" requires+provides279_0"
" enclosing-mod281_0"
" keep-enclosing-scope-at-phase282_0))"
"(let-values(((m-ns283_0)"
" m-ns_0)"
"((enclosing-mod284_0)"
" enclosing-mod_0)"
"((keep-enclosing-scope-at-phase285_0)"
" keep-enclosing-scope-at-phase_0))"
"(namespace-module-visit!.1"
" #f"
" unsafe-undefined"
" m-ns283_0"
" enclosing-mod284_0"
" keep-enclosing-scope-at-phase285_0))"
" #f)))))))))"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" init-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values(((initial-mpi_0)"
"(let-values(((temp286_0)"
" #t))"
"(initial-require!_0"
" temp286_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" init-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
" bodys_0)))"
"(void)))"
"(values))))"
"(let-values(((paramz_0"
" exit-paramz_0)"
"(if initial-mpi_0"
"(let-values()"
"(let-values(((enter_0"
" exit_0)"
"(load-configure-expand"
" initial-mpi_0"
"(namespace-root-namespace"
" m-ns_0))))"
"(values"
"(enter-configure-parameterization"
" enter_0)"
" exit_0)))"
"(let-values()"
"(values"
"(current-parameterization)"
" current-parameterization)))))"
"(let-values(((again?_0)"
" #f))"
"(letrec-values(((module-begin-k_0)"
"(lambda(mb-s_0"
" mb-init-ctx_0)"
"(begin"
" 'module-begin-k"
"(let-values((()"
"(begin"
"(if again?_0"
"(let-values()"
"(begin"
"(requires+provides-reset!"
" requires+provides_0)"
"(let-values(((temp291_0)"
" #f))"
"(initial-require!_0"
" temp291_0))"
"(hash-clear!"
" compiled-submodules_0)"
"(set-box!"
" compiled-module-box_0"
" #f)))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(set! again?_0"
" #t)"
"(values))))"
"(let-values(((ctx_1)"
"(let-values(((v_0)"
" mb-init-ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((post-expansion292_0)"
"(lambda(s_1)"
"(begin"
" 'post-expansion292"
"(add-scope"
" s_1"
" inside-scope_0))))"
"((inner293_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((module-begin-k294_0)"
"(lambda(s_1"
" ctx_1)"
"(begin"
" 'module-begin-k294"
"(let-values(((new-requires+provides_0)"
"(let-values(((self303_0)"
" self_0)"
"((requires+provides304_0)"
" requires+provides_0))"
"(make-requires+provides.1"
" requires+provides304_0"
" unsafe-undefined"
" self303_0))))"
"(let-values(((requires+provides295_0)"
" requires+provides_0)"
"((compiled-submodules296_0)"
" compiled-submodules_0)"
"((compiled-module-box297_0)"
" compiled-module-box_0)"
"((defined-syms298_0)"
" defined-syms_0)"
"((requires+provides299_0)"
" new-requires+provides_0)"
"((compiled-submodules300_0)"
"(make-hasheq))"
"((compiled-module-box301_0)"
"(box"
" #f))"
"((defined-syms302_0)"
"(make-hasheq)))"
"(dynamic-wind"
"(lambda()"
"(begin"
"(set! requires+provides_0"
" requires+provides299_0)"
"(set! compiled-submodules_0"
" compiled-submodules300_0)"
"(set! compiled-module-box_0"
" compiled-module-box301_0)"
"(set! defined-syms_0"
" defined-syms302_0)))"
"(lambda()"
"(module-begin-k_0"
" s_1"
" ctx_1))"
"(lambda()"
"(begin"
"(set! requires+provides_0"
" requires+provides295_0)"
"(set! compiled-submodules_0"
" compiled-submodules296_0)"
"(set! compiled-module-box_0"
" compiled-module-box297_0)"
"(set! defined-syms_0"
" defined-syms298_0))))))))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
" module-begin-k294_0"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                        \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner293_0"
" post-expansion292_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                      \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((added-s_0)"
"(add-scope"
" mb-s_0"
" inside-scope_0)))"
"(let-values(((ok?_1"
" #%module-begin287_0"
" body288_0)"
"(let-values(((s_1)"
" added-s_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((#%module-begin287_0"
" body288_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((#%module-begin289_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((body290_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_4)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                  \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" #%module-begin289_0"
" body290_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                          \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" #%module-begin287_0"
" body288_0))))))"
"(let-values(((bodys_1)"
" body288_0))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
" added-s_0)))"
"(void)))"
"(values))))"
"(let-values(((rebuild-mb-s_0)"
"(let-values(((ctx305_0)"
" ctx_1)"
"((mb-s306_0)"
" mb-s_0))"
"(keep-as-needed.1"
" #f"
" #f"
" #f"
" ctx305_0"
" mb-s306_0))))"
"(let-values(((need-eventually-defined_0)"
"(make-hasheqv)))"
"(let-values(((module-ends_0)"
"(make-shared-module-ends)))"
"(let-values(((declared-keywords_0)"
"(make-hasheq)))"
"(let-values(((declared-submodule-names_0)"
"(make-hasheq)))"
"(let-values(((initial-lifted-requires_0)"
"(get-require-lifts"
"(expand-context-require-lifts"
" ctx_1))))"
"(let-values(((expression-expanded-bodys_0)"
"((letrec-values(((pass-1-and-2-loop_0)"
"(lambda(bodys_2"
" phase_1"
" keep-stops?_0"
" initial-lifted-requires_1)"
"(begin"
" 'pass-1-and-2-loop"
"(let-values(((def-ctx-scopes_0)"
"(box"
" null)))"
"(let-values(((partial-body-ctx_0)"
"(let-values(((v_0)"
" ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((context315_0)"
" 'module)"
"((def-ctx-scopes316_0)"
" def-ctx-scopes_0)"
"((need-eventually-defined317_0)"
" need-eventually-defined_0)"
"((inner318_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((phase319_0)"
" phase_1)"
"((namespace320_0)"
"(namespace->namespace-at-phase"
" m-ns_0"
" phase_1))"
"((stops321_0)"
"(free-id-set"
" phase_1"
"(module-expand-stop-ids"
" phase_1)))"
"((declared-submodule-names322_0)"
" declared-submodule-names_0)"
"((lift-key323_0)"
"(generate-lift-key))"
"((lifts324_0)"
"(let-values(((temp328_0)"
"(make-wrap-as-definition"
" self_0"
" frame-id_0"
" inside-scope_0"
" all-scopes-s_0"
" defined-syms_0"
" requires+provides_0)))"
"(make-lift-context.1"
" #f"
" temp328_0)))"
"((module-lifts325_0)"
"(make-module-lift-context"
" phase_1"
" #t))"
"((require-lifts326_0)"
"(make-require-lift-context"
" phase_1"
"(let-values(((m-ns329_0)"
" m-ns_0)"
"((self330_0)"
" self_0)"
"((requires+provides331_0)"
" requires+provides_0)"
"((declared-submodule-names332_0)"
" declared-submodule-names_0)"
"((add-defined-portal333_0)"
" add-defined-portal_0))"
"(make-parse-lifted-require.1"
" add-defined-portal333_0"
" declared-submodule-names332_0"
" m-ns329_0"
" self330_0"
" requires+provides331_0))"
" initial-lifted-requires_1))"
"((to-module-lifts327_0)"
"(let-values(((phase334_0)"
" phase_1)"
"((module-ends335_0)"
" module-ends_0)"
"((temp336_0)"
" #f))"
"(make-to-module-lift-context.1"
" temp336_0"
" module-ends335_0"
" phase334_0))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
" lift-key323_0"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase319_0"
" namespace320_0"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
" stops321_0"
" declared-submodule-names322_0"
" lifts324_0"
"(expand-context/inner-lift-envs"
" the-struct_1)"
" module-lifts325_0"
" require-lifts326_0"
" to-module-lifts327_0"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                                    \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner318_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
" context315_0"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
" def-ctx-scopes316_0"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
" need-eventually-defined317_0"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                  \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((partially-expanded-bodys_0)"
"(let-values(((bodys337_0)"
" bodys_2)"
"((phase338_0)"
" phase_1)"
"((partial-body-ctx339_0)"
" partial-body-ctx_0)"
"((m-ns340_0)"
" m-ns_0)"
"((self341_0)"
" self_0)"
"((frame-id342_0)"
" frame-id_0)"
"((requires+provides343_0)"
" requires+provides_0)"
"((need-eventually-defined344_0)"
" need-eventually-defined_0)"
"((all-scopes-s345_0)"
" all-scopes-s_0)"
"((defined-syms346_0)"
" defined-syms_0)"
"((declared-keywords347_0)"
" declared-keywords_0)"
"((declared-submodule-names348_0)"
" declared-submodule-names_0)"
"((compiled-submodules349_0)"
" compiled-submodules_0)"
"((modules-being-compiled350_0)"
" modules-being-compiled_0)"
"((mpis-to-reset351_0)"
" mpis-to-reset_0)"
"((portal-syntaxes352_0)"
" portal-syntaxes_0)"
"((add-defined-portal353_0)"
" add-defined-portal_0)"
"((pass-1-and-2-loop354_0)"
" pass-1-and-2-loop_0))"
"(partially-expand-bodys.1"
" add-defined-portal353_0"
" all-scopes-s345_0"
" compiled-submodules349_0"
" partial-body-ctx339_0"
" declared-keywords347_0"
" declared-submodule-names348_0"
" defined-syms346_0"
" frame-id342_0"
" pass-1-and-2-loop354_0"
" modules-being-compiled350_0"
" mpis-to-reset351_0"
" m-ns340_0"
" need-eventually-defined344_0"
" phase338_0"
" portal-syntaxes352_0"
" requires+provides343_0"
" self341_0"
" bodys337_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))"
"(values))))"
"(let-values(((body-ctx_0)"
"(let-values(((v_0)"
"(accumulate-def-ctx-scopes"
" partial-body-ctx_0"
" def-ctx-scopes_0)))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((def-ctx-scopes355_0)"
" #f)"
"((post-expansion356_0)"
" #f)"
"((inner357_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((stops358_0)"
"(if keep-stops?_0"
"(expand-context-stops"
" ctx_1)"
" empty-free-id-set))"
"((to-module-lifts359_0)"
"(let-values(((phase360_0)"
" phase_1)"
"((module-ends361_0)"
" module-ends_0)"
"((temp362_0)"
" #t))"
"(make-to-module-lift-context.1"
" temp362_0"
" module-ends361_0"
" phase360_0))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
" stops358_0"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
" to-module-lifts359_0"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                                          \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner357_0"
" post-expansion356_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
" def-ctx-scopes355_0"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                        \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((partially-expanded-bodys307_0)"
" partially-expanded-bodys_0)"
"((phase308_0)"
" phase_1)"
"((body-ctx309_0)"
" body-ctx_0)"
"((self310_0)"
" self_0)"
"((declared-submodule-names311_0)"
" declared-submodule-names_0)"
"((compiled-submodules312_0)"
" compiled-submodules_0)"
"((modules-being-compiled313_0)"
" modules-being-compiled_0)"
"((mpis-to-reset314_0)"
" mpis-to-reset_0))"
"(finish-expanding-body-expressions.1"
" compiled-submodules312_0"
" body-ctx309_0"
" declared-submodule-names311_0"
" modules-being-compiled313_0"
" mpis-to-reset314_0"
" phase308_0"
" self310_0"
" partially-expanded-bodys307_0)))))))))))"
" pass-1-and-2-loop_0)"
" bodys_1"
" phase_0"
"(stop-at-module*?"
" ctx_1)"
" initial-lifted-requires_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(check-defined-by-now"
" need-eventually-defined_0"
" self_0"
" ctx_1"
" requires+provides_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))"
"(values))))"
"(let-values(((fully-expanded-bodys-except-post-submodules_0)"
"(let-values(((expression-expanded-bodys363_0)"
" expression-expanded-bodys_0)"
"((requires+provides364_0)"
" requires+provides_0)"
"((declared-submodule-names365_0)"
" declared-submodule-names_0)"
"((m-ns366_0)"
" m-ns_0)"
"((phase367_0)"
" phase_0)"
"((self368_0)"
" self_0)"
"((ctx369_0)"
" ctx_1))"
"(resolve-provides.1"
" ctx369_0"
" declared-submodule-names365_0"
" m-ns366_0"
" phase367_0"
" requires+provides364_0"
" self368_0"
" expression-expanded-bodys363_0))))"
"(let-values(((is-cross-phase-persistent?_0)"
"(hash-ref"
" declared-keywords_0"
" '#:cross-phase-persistent"
" #f)))"
"(let-values((()"
"(begin"
"(if is-cross-phase-persistent?_0"
"(let-values()"
"(begin"
"(if(requires+provides-can-cross-phase-persistent?"
" requires+provides_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                              \"cannot be cross-phase persistent due to required modules\""
" rebuild-s_0"
"(hash-ref"
" declared-keywords_0"
" '#:cross-phase-persistent))))"
"(check-cross-phase-persistent-form"
" fully-expanded-bodys-except-post-submodules_0"
" self_0)))"
"(void))"
"(values))))"
"(let-values(((realm_0)"
"(let-values(((realm-stx_0)"
"(hash-ref"
" declared-keywords_0"
" '#:realm"
" #f)))"
"(if realm-stx_0"
"(syntax-e$1"
" realm-stx_0)"
"(current-compile-realm)))))"
"(let-values(((flatten-requires?_0)"
"(hash-ref"
" declared-keywords_0"
" '#:flatten-requires"
" #f)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))"
"(values))))"
"(let-values(((submod-m-ns_0)"
"(let-values(((m-ns370_0)"
" m-ns_0)"
"((temp371_0)"
" #t))"
"(make-m-ns_0"
" temp371_0"
" m-ns370_0))))"
"(let-values(((submod-ctx_0)"
"(let-values(((v_0)"
" ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((frame-id372_0)"
" #f)"
"((post-expansion373_0)"
" #f)"
"((inner374_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((namespace375_0)"
" submod-m-ns_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
" namespace375_0"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                    \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner374_0"
" post-expansion373_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
" frame-id372_0"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                  \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((declare-enclosing-module_0)"
"(promise1.1"
"(lambda()"
"(let-values(((fully-expanded-bodys-except-post-submodules376_0)"
" fully-expanded-bodys-except-post-submodules_0)"
"((temp377_0)"
" id:module-name217_0)"
"((rebuild-s378_0)"
" rebuild-s_0)"
"((requires+provides379_0)"
" requires+provides_0)"
"((submod-m-ns380_0)"
" submod-m-ns_0)"
"((self381_0)"
" self_0)"
"((enclosing-self382_0)"
" enclosing-self_0)"
"((root-ctx383_0)"
" root-ctx_0)"
"((submod-ctx384_0)"
" submod-ctx_0)"
"((modules-being-compiled385_0)"
" modules-being-compiled_0)"
"((flatten-requires?386_0)"
" flatten-requires?_0)"
"((realm387_0)"
" realm_0)"
"((portal-syntaxes388_0)"
" portal-syntaxes_0)"
"((compiled-module-box389_0)"
" compiled-module-box_0))"
"(declare-module-for-expansion.1"
" submod-ctx384_0"
" enclosing-self382_0"
" compiled-module-box389_0"
" flatten-requires?386_0"
" temp377_0"
" modules-being-compiled385_0"
" submod-m-ns380_0"
" portal-syntaxes388_0"
" realm387_0"
" rebuild-s378_0"
" requires+provides379_0"
" root-ctx383_0"
" self381_0"
" fully-expanded-bodys-except-post-submodules376_0)))"
" #f)))"
"(let-values(((fully-expanded-bodys_0)"
"(if(stop-at-module*?"
" submod-ctx_0)"
"(let-values()"
" fully-expanded-bodys-except-post-submodules_0)"
"(let-values()"
"(let-values(((fully-expanded-bodys-except-post-submodules390_0)"
" fully-expanded-bodys-except-post-submodules_0)"
"((declare-enclosing-module391_0)"
" declare-enclosing-module_0)"
"((phase392_0)"
" phase_0)"
"((self393_0)"
" self_0)"
"((requires+provides394_0)"
" requires+provides_0)"
"((is-cross-phase-persistent?395_0)"
" is-cross-phase-persistent?_0)"
"((all-scopes-s396_0)"
" all-scopes-s_0)"
"((mpis-to-reset397_0)"
" mpis-to-reset_0)"
"((declared-submodule-names398_0)"
" declared-submodule-names_0)"
"((compiled-submodules399_0)"
" compiled-submodules_0)"
"((modules-being-compiled400_0)"
" modules-being-compiled_0)"
"((submod-ctx401_0)"
" submod-ctx_0))"
"(expand-post-submodules.1"
" all-scopes-s396_0"
" compiled-submodules399_0"
" submod-ctx401_0"
" declare-enclosing-module391_0"
" declared-submodule-names398_0"
" is-cross-phase-persistent?395_0"
" modules-being-compiled400_0"
" mpis-to-reset397_0"
" phase392_0"
" requires+provides394_0"
" self393_0"
" fully-expanded-bodys-except-post-submodules390_0))))))"
"(if(expand-context-to-parsed?"
" submod-ctx_0)"
"(let-values()"
"(parsed-#%module-begin24.1"
" rebuild-mb-s_0"
"(parsed-only"
" fully-expanded-bodys_0)"
" realm_0"
" flatten-requires?_0))"
"(let-values()"
"(let-values(((mb-result-s_0)"
"(let-values(((rebuild-mb-s402_0)"
" rebuild-mb-s_0)"
"((temp403_0)"
"(list*"
" #%module-begin287_0"
"(syntax-only"
" fully-expanded-bodys_0))))"
"(rebuild.1"
" #t"
" rebuild-mb-s402_0"
" temp403_0))))"
"(if(not"
"(expand-context-in-local-expand?"
" submod-ctx_0))"
"(let-values()"
"(expanded+parsed1.1"
" mb-result-s_0"
"(parsed-#%module-begin24.1"
" rebuild-mb-s_0"
"(parsed-only"
" fully-expanded-bodys_0)"
" realm_0"
" flatten-requires?_0)))"
"(let-values()"
" mb-result-s_0))))))))))))))))))))))))))))))))))))"
"(let-values(((mb-ctx_0)"
"(let-values(((v_0)"
" ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((context404_0)"
" 'module-begin)"
"((inner405_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((module-begin-k406_0)"
" module-begin-k_0)"
"((in-local-expand?407_0)"
" #f)"
"((lifts408_0)"
" #f)"
"((module-lifts409_0)"
" #f)"
"((to-module-lifts410_0)"
" #f)"
"((require-lifts411_0)"
"(make-require-lift-context"
" phase_0"
"(let-values(((m-ns412_0)"
" m-ns_0)"
"((self413_0)"
" self_0)"
"((requires+provides414_0)"
" requires+provides_0)"
"((temp415_0)"
"(make-hasheq))"
"((add-defined-portal416_0)"
" add-defined-portal_0))"
"(make-parse-lifted-require.1"
" add-defined-portal416_0"
" temp415_0"
" m-ns412_0"
" self413_0"
" requires+provides414_0)))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
" module-begin-k406_0"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
" in-local-expand?407_0"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
" lifts408_0"
"(expand-context/inner-lift-envs"
" the-struct_1)"
" module-lifts409_0"
" require-lifts411_0"
" to-module-lifts410_0"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                 \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner405_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
" context404_0"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                               \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((mb-scopes-s_0)"
"(if keep-enclosing-scope-at-phase_0"
"(apply-module-scopes_0"
" s_0)"
" all-scopes-s_0)))"
"(let-values(((mb-def-ctx-scopes_0)"
"(box"
" null)))"
"(let-values(((mb_0)"
"(let-values(((bodys417_0)"
" bodys_0)"
"((module-name-sym418_0)"
" module-name-sym_0)"
"((mb-scopes-s419_0)"
" mb-scopes-s_0)"
"((m-ns420_0)"
" m-ns_0)"
"((mb-ctx421_0)"
" mb-ctx_0)"
"((mb-def-ctx-scopes422_0)"
" mb-def-ctx-scopes_0)"
"((phase423_0)"
" phase_0)"
"((s424_0)"
" s_0)"
"((paramz425_0)"
" paramz_0)"
"((exit-paramz426_0)"
" exit-paramz_0))"
"(ensure-module-begin.1"
" mb-ctx421_0"
" mb-def-ctx-scopes422_0"
" exit-paramz426_0"
" m-ns420_0"
" module-name-sym418_0"
" paramz425_0"
" phase423_0"
" s424_0"
" mb-scopes-s419_0"
" bodys417_0))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(if(compiled-module-expansion?"
"(syntax-e$1"
" mb_0))"
"(let-values()"
"(begin"
"(if(if(expand-context-to-parsed?"
" init-ctx_0)"
"(not"
" enclosing-self_0)"
" #f)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                               \"invalid context for a compiled module from module-begin expansion\""
" bodys_0)))"
"(if(eq?"
"(current-code-inspector)"
" initial-code-inspector)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                               \"compiled-module generation disallowed by code inspector\""
" bodys_0)))"
"(parsed-bundle26.1"
" rebuild-s_0"
"(syntax-e$1"
" mb_0))))"
"(let-values()"
"(let-values(((expanded-mb_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'module-begin))"
"(void))"
"(begin0"
"(let-values()"
"(call-with-configure-parameterization"
" paramz_0"
" exit-paramz_0"
"(lambda()"
"(let-values(((mb427_0)"
" mb_0)"
"((temp428_0)"
"(let-values(((v_0)"
"(accumulate-def-ctx-scopes"
" mb-ctx_0"
" mb-def-ctx-scopes_0)))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((def-ctx-scopes429_0)"
" #f)"
"((inner430_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner430_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
" def-ctx-scopes429_0"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                    \"expand-context/outer?\""
" the-struct_0))))))"
"(expand.1"
" #f"
" #f"
" mb427_0"
" temp428_0)))))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(let-values(((parsed-mb_0)"
"(if(expanded+parsed?"
" expanded-mb_0)"
"(expanded+parsed-parsed"
" expanded-mb_0)"
" expanded-mb_0)))"
"(let-values(((requires_0"
" recur-requires_0"
" flattened-requires_0"
" provides_0)"
"(let-values(((requires+provides431_0)"
" requires+provides_0)"
"((self432_0)"
" self_0)"
"((self433_0)"
" self_0)"
"((temp434_0)"
"(parsed-#%module-begin-flatten-requires?"
" parsed-mb_0))"
"((m-ns435_0)"
" m-ns_0))"
"(extract-requires-and-provides.1"
" temp434_0"
" m-ns435_0"
" requires+provides431_0"
" self432_0"
" self433_0))))"
"(let-values(((result-form_0)"
"(if(let-values(((or-part_0)"
"(expand-context-to-parsed?"
" init-ctx_0)))"
"(if or-part_0"
" or-part_0"
" always-produce-compiled?_0))"
"(parsed-module25.1"
" rebuild-s_0"
" #f"
" id:module-name217_0"
" self_0"
" requires_0"
" recur-requires_0"
" flattened-requires_0"
" provides_0"
"(requires+provides-all-bindings-simple?"
" requires+provides_0)"
"(root-expand-context-encode-for-module"
" root-ctx_0"
" self_0"
" self_0)"
"(parsed-#%module-begin-body"
" parsed-mb_0)"
"(parsed-#%module-begin-realm"
" parsed-mb_0)"
" portal-syntaxes_0"
"(unbox"
" compiled-module-box_0)"
" compiled-submodules_0)"
" #f)))"
"(let-values(((result-s_0)"
"(if(not"
"(expand-context-to-parsed?"
" init-ctx_0))"
"(let-values()"
"(let-values(((generic-self_0)"
"(make-generic-self-module-path-index"
" self_0)))"
"(begin"
"(imitate-generic-module-path-index!"
" self_0)"
"(let-values()"
"(let-values(((lst_0)"
"(unbox"
" mpis-to-reset_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((mpi_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(imitate-generic-module-path-index!"
" mpi_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(let-values(((result-s_0)"
"(let-values(((rebuild-s436_0)"
" rebuild-s_0)"
"((temp437_0)"
"(list"
" module216_0"
" id:module-name217_0"
" initial-require-s_0"
"(expanded+parsed-s"
" expanded-mb_0))))"
"(rebuild.1"
" #t"
" rebuild-s436_0"
" temp437_0))))"
"(let-values(((result-s_1)"
"(let-values(((result-s438_0)"
" result-s_0)"
"((self439_0)"
" self_0)"
"((generic-self440_0)"
" generic-self_0))"
"(syntax-module-path-index-shift.1"
" #f"
" result-s438_0"
" self439_0"
" generic-self440_0"
" #f))))"
"(let-values(((result-s_2)"
"(attach-root-expand-context-properties"
" result-s_1"
" root-ctx_0"
" self_0"
" generic-self_0)))"
"(let-values(((result-s_3)"
"(if(requires+provides-all-bindings-simple?"
" requires+provides_0)"
"(syntax-property$1"
" result-s_2"
" 'module-body-context-simple?"
" #t)"
" result-s_2)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" init-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
" result-s_3)))"
"(void)))"
" result-s_3))))))))"
"(void))))"
"(if(expand-context-to-parsed?"
" init-ctx_0)"
"(let-values()"
" result-form_0)"
"(if always-produce-compiled?_0"
"(let-values()"
"(expanded+parsed1.1"
" result-s_0"
" result-form_0))"
"(let-values()"
" result-s_0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(ensure-module-begin.1)"
"(lambda(ctx20_0"
" def-ctx-scopes21_0"
" exit-paramz25_0"
" m-ns19_0"
" module-name-sym17_0"
" paramz24_0"
" phase22_0"
" s23_0"
" scopes-s18_0"
" bodys35_0)"
"(begin"
" 'ensure-module-begin"
"(let-values(((bodys_0) bodys35_0))"
"(let-values(((module-name-sym_0) module-name-sym17_0))"
"(let-values(((scopes-s_0) scopes-s18_0))"
"(let-values()"
"(let-values(((ctx_0) ctx20_0))"
"(let-values(((def-ctx-scopes_0) def-ctx-scopes21_0))"
"(let-values(((phase_0) phase22_0))"
"(let-values(((s_0) s23_0))"
"(let-values(((paramz_0) paramz24_0))"
"(let-values(((exit-paramz_0) exit-paramz25_0))"
"(let-values()"
"(let-values(((make-mb-ctx_0)"
"(lambda()"
"(begin"
" 'make-mb-ctx"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context441_0) 'module-begin)"
"((only-immediate?442_0) #t)"
"((def-ctx-scopes443_0) def-ctx-scopes_0)"
"((inner444_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner444_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
" context441_0"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
" def-ctx-scopes443_0"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
" only-immediate?442_0"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                     \"expand-context/outer?\""
" the-struct_0))))))))"
"(let-values(((mb_0)"
"(if(= 1(length bodys_0))"
"(let-values()"
"(if(eq? '#%module-begin(core-form-sym(car bodys_0) phase_0))"
"(let-values()(car bodys_0))"
"(let-values()"
"(let-values(((named-body-s_0)"
"(add-enclosing-name-property"
"(car bodys_0)"
" module-name-sym_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'track-syntax"
" 'property"
" named-body-s_0"
"(car bodys_0))))"
"(void)))"
"(values))))"
"(let-values(((partly-expanded-body_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'module-begin))"
"(void))"
"(begin0"
"(let-values()"
"(call-with-configure-parameterization"
" paramz_0"
" exit-paramz_0"
"(lambda()"
"(let-values(((named-body-s445_0)"
" named-body-s_0)"
"((temp446_0)"
"(make-mb-ctx_0)))"
"(expand.1"
" #f"
" #f"
" named-body-s445_0"
" temp446_0)))))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(if(compiled-module-expansion?"
"(syntax-e$1 partly-expanded-body_0))"
"(let-values() partly-expanded-body_0)"
"(if(eq?"
" '#%module-begin"
"(core-form-sym partly-expanded-body_0 phase_0))"
"(let-values() partly-expanded-body_0)"
"(let-values()"
"(let-values(((temp447_0)(list partly-expanded-body_0))"
"((s448_0) s_0)"
"((scopes-s449_0) scopes-s_0)"
"((phase450_0) phase_0)"
"((module-name-sym451_0) module-name-sym_0)"
"((temp452_0)(make-mb-ctx_0))"
"((temp453_0) #f))"
"(add-module-begin.1"
" temp453_0"
" temp447_0"
" s448_0"
" scopes-s449_0"
" phase450_0"
" module-name-sym451_0"
" temp452_0)))))))))))"
"(let-values()"
"(let-values(((bodys454_0) bodys_0)"
"((s455_0) s_0)"
"((scopes-s456_0) scopes-s_0)"
"((phase457_0) phase_0)"
"((module-name-sym458_0) module-name-sym_0)"
"((temp459_0)(make-mb-ctx_0)))"
"(add-module-begin.1"
" #t"
" bodys454_0"
" s455_0"
" scopes-s456_0"
" phase457_0"
" module-name-sym458_0"
" temp459_0))))))"
"(let-values(((named-mb_0)(add-enclosing-name-property mb_0 module-name-sym_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'track-syntax 'property named-mb_0 mb_0)))"
"(void)))"
" named-mb_0))))))))))))))))))"
"(define-values"
"(add-module-begin.1)"
"(lambda(log-rename-one?37_0 bodys39_0 s40_0 scopes-s41_0 phase42_0 module-name-sym43_0 mb-ctx44_0)"
"(begin"
" 'add-module-begin"
"(let-values(((bodys_0) bodys39_0))"
"(let-values(((s_0) s40_0))"
"(let-values(((scopes-s_0) scopes-s41_0))"
"(let-values(((phase_0) phase42_0))"
"(let-values(((module-name-sym_0) module-name-sym43_0))"
"(let-values(((mb-ctx_0) mb-ctx44_0))"
"(let-values()"
"(let-values()"
"(let-values(((mb-id_0)(datum->syntax$1 scopes-s_0 '#%module-begin)))"
"(let-values((()"
"(begin"
"(if(let-values(((mb-id460_0) mb-id_0)((phase461_0) phase_0))"
"(resolve.1 #f #f null #f mb-id460_0 phase461_0))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                             \"no #%module-begin binding in the module's language\""
" s_0)))"
"(values))))"
"(let-values(((mb_0)(datum->syntax$1 scopes-s_0(list* mb-id_0 bodys_0) s_0 s_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer mb-ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'tag mb_0)))"
"(void)))"
"(values))))"
"(let-values(((named-mb_0)(add-enclosing-name-property mb_0 module-name-sym_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer mb-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'track-syntax"
" 'property"
" named-mb_0"
" mb_0)))"
"(void)))"
"(values))))"
"(let-values(((partly-expanded-mb_0)"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'expand 'module-begin))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((named-mb462_0) named-mb_0)"
"((mb-ctx463_0) mb-ctx_0))"
"(expand.1 #f #f named-mb462_0 mb-ctx463_0)))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(begin"
"(if(eq? '#%module-begin(core-form-sym partly-expanded-mb_0 phase_0))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                           \"expansion of #%module-begin is not a #%plain-module-begin form\""
" s_0"
" partly-expanded-mb_0)))"
" partly-expanded-mb_0)))))))))))))))))))"
"(define-values"
"(add-enclosing-name-property)"
"(lambda(stx_0 module-name-sym_0)(begin(syntax-property$1 stx_0 'enclosing-module-name module-name-sym_0))))"
"(define-values"
"(compiled-module-expansion?)"
"(lambda(v_0)"
"(begin(let-values(((or-part_0)(1/linklet-bundle? v_0)))(if or-part_0 or-part_0(linklet-directory?$1 v_0))))))"
"(define-values"
"(make-apply-module-scopes)"
"(lambda(inside-scope_0"
" outside-scope_0"
" init-ctx_0"
" keep-enclosing-scope-at-phase_0"
" self_0"
" enclosing-self_0"
" enclosing-mod_0)"
"(begin"
"(lambda(s_0)"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand 'module 'scopes))(void))"
"(begin0"
"(let-values()"
"(let-values(((s-without-enclosing_0)"
"(if keep-enclosing-scope-at-phase_0"
" s_0"
"(remove-use-site-scopes"
"(remove-scopes s_0(root-expand-context-module-scopes init-ctx_0))"
" init-ctx_0))))"
"(let-values(((s-with-edges_0)"
"(add-scope(add-scope s-without-enclosing_0 outside-scope_0) inside-scope_0)))"
"(let-values(((s-with-suitable-enclosing_0)"
"(if keep-enclosing-scope-at-phase_0"
"(let-values()"
"(let-values(((s-with-edges468_0) s-with-edges_0)"
"((enclosing-self469_0) enclosing-self_0)"
"((enclosing-mod470_0) enclosing-mod_0))"
"(syntax-module-path-index-shift.1"
" #f"
" s-with-edges468_0"
" enclosing-self469_0"
" enclosing-mod470_0"
" #f)))"
"(let-values() s-with-edges_0))))"
"(let-values(((s-with-suitable-enclosing464_0) s-with-suitable-enclosing_0)"
"((temp465_0)(make-generic-self-module-path-index self_0))"
"((self466_0) self_0)"
"((temp467_0)(current-code-inspector)))"
"(syntax-module-path-index-shift.1"
" #f"
" s-with-suitable-enclosing464_0"
" temp465_0"
" self466_0"
" temp467_0))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))"
"(define-values"
"(partially-expand-bodys.1)"
"(lambda(add-defined-portal61_0"
" all-scopes-stx53_0"
" compiled-submodules57_0"
" ctx47_0"
" declared-keywords55_0"
" declared-submodule-names56_0"
" defined-syms54_0"
" frame-id50_0"
" loop62_0"
" modules-being-compiled58_0"
" mpis-to-reset59_0"
" namespace48_0"
" need-eventually-defined52_0"
" phase46_0"
" portal-syntaxes60_0"
" requires-and-provides51_0"
" self49_0"
" bodys80_0)"
"(begin"
" 'partially-expand-bodys"
"(let-values(((bodys_0) bodys80_0))"
"(let-values(((phase_0) phase46_0))"
"(let-values(((partial-body-ctx_0) ctx47_0))"
"(let-values(((m-ns_0) namespace48_0))"
"(let-values(((self_0) self49_0))"
"(let-values(((frame-id_0) frame-id50_0))"
"(let-values(((requires+provides_0) requires-and-provides51_0))"
"(let-values(((need-eventually-defined_0) need-eventually-defined52_0))"
"(let-values(((all-scopes-stx_0) all-scopes-stx53_0))"
"(let-values(((defined-syms_0) defined-syms54_0))"
"(let-values(((declared-keywords_0) declared-keywords55_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names56_0))"
"(let-values(((compiled-submodules_0) compiled-submodules57_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled58_0))"
"(let-values(((mpis-to-reset_0) mpis-to-reset59_0))"
"(let-values(((portal-syntaxes_0) portal-syntaxes60_0))"
"(let-values(((add-defined-portal_0) add-defined-portal61_0))"
"(let-values(((pass-1-and-2-loop_0) loop62_0))"
"(let-values()"
"(begin"
"(namespace-visit-available-modules! m-ns_0 phase_0)"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 bodys_1)"
"(begin"
" 'loop"
"(if(null? bodys_1)"
"(let-values()"
"(if(if tail?_0(not(zero? phase_0)) #f)"
"(let-values() null)"
"(if tail?_0"
"(let-values()"
"(let-values(((bodys_2)"
"(append"
"(get-and-clear-end-lifts!"
"(expand-context-to-module-lifts"
" partial-body-ctx_0))"
"(get-and-clear-provide-lifts!"
"(expand-context-to-module-lifts"
" partial-body-ctx_0)))))"
"(if(null? bodys_2)"
"(let-values() null)"
"(let-values()"
"(let-values(((added-bodys_0)"
"(add-post-expansion-scope"
" bodys_2"
" partial-body-ctx_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-end-lifts"
" added-bodys_0)))"
"(void)))"
"(loop_0 #t added-bodys_0)))))))"
"(let-values() null))))"
"(let-values()"
"(let-values(((rest-bodys_0)(cdr bodys_1)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-body_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'form-in-module/1))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((temp471_0)"
"(car"
" bodys_1))"
"((partial-body-ctx472_0)"
" partial-body-ctx_0))"
"(expand.1"
" #f"
" #f"
" temp471_0"
" partial-body-ctx472_0)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(let-values(((lifted-defns_0)"
"(get-and-clear-lifts!"
"(expand-context-lifts"
" partial-body-ctx_0))))"
"(let-values(((lifted-reqs_0)"
"(get-and-clear-require-lifts!"
"(expand-context-require-lifts"
" partial-body-ctx_0))))"
"(let-values(((lifted-mods_0)"
"(get-and-clear-module-lifts!"
"(expand-context-module-lifts"
" partial-body-ctx_0))))"
"(let-values(((added-lifted-mods_0)"
"(add-post-expansion-scope"
" lifted-mods_0"
" partial-body-ctx_0)))"
"(let-values((()"
"(begin"
"(if(if(null?"
" lifted-defns_0)"
"(if(null?"
" lifted-reqs_0)"
"(null?"
" lifted-mods_0)"
" #f)"
" #f)"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-pass1-lifts"
"(lifted-defns-extract-syntax"
" lifted-defns_0)"
" lifted-reqs_0"
" added-lifted-mods_0)))"
"(void)))))"
"(values))))"
"(let-values(((exp-lifted-mods_0)"
"(loop_0"
" #f"
" added-lifted-mods_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-pass1-case"
" exp-body_0)))"
"(void)))"
"(let-values(((finish_0)"
"(lambda()"
"(begin"
" 'finish"
"(let-values(((tmp_0)"
"(core-form-sym"
" exp-body_0"
" phase_0)))"
"(if(equal?"
" tmp_0"
" 'begin)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-begin"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" begin473_0"
" e474_0)"
"(let-values(((s_0)"
" exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((begin473_0"
" e474_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((begin475_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e476_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin475_0"
" e476_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                           \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin473_0"
" e474_0))))))"
"(let-values(((track_0)"
"(lambda(e_0)"
"(begin"
" 'track"
"(syntax-track-origin$1"
" e_0"
" exp-body_0)))))"
"(let-values(((spliced-bodys_0)"
"(append"
"(map2"
" track_0"
" e474_0)"
" rest-bodys_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'splice"
" spliced-bodys_0)))"
"(void)))"
"(loop_0"
" tail?_0"
" spliced-bodys_0)))))))"
"(if(equal?"
" tmp_0"
" 'begin-for-syntax)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-begin-for-syntax"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" begin-for-syntax477_0"
" e478_0)"
"(let-values(((s_0)"
" exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((begin-for-syntax477_0"
" e478_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((begin-for-syntax479_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e480_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin-for-syntax479_0"
" e480_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                             \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin-for-syntax477_0"
" e478_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values(((ct-m-ns_0)"
"(namespace->namespace-at-phase"
" m-ns_0"
"(add1"
" phase_0))))"
"(let-values((()"
"(begin"
"(prepare-next-phase-namespace"
" partial-body-ctx_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'phase-up)))"
"(void)))"
"(values))))"
"(let-values(((nested-bodys_0)"
"(pass-1-and-2-loop_0"
" e478_0"
"(add1"
" phase_0)"
" #f"
" null)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))"
"(namespace-run-available-modules!"
" m-ns_0"
"(add1"
" phase_0))"
"(eval-nested-bodys"
" nested-bodys_0"
"(add1"
" phase_0)"
" ct-m-ns_0"
" self_0"
" partial-body-ctx_0)"
"(namespace-visit-available-modules!"
" m-ns_0"
" phase_0)"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-case"
"(let-values(((s-nested-bodys_0)"
"(reverse$1"
"(let-values(((fold-var_0)"
"(let-values(((fold-var_0)"
" null))"
" fold-var_0)))"
"(let-values(((lst_0)"
" nested-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((nested-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(extract-syntax"
" nested-body_0))"
" fold-var_1))))"
"(values"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(cons"
" begin-for-syntax477_0"
" s-nested-bodys_0)))))"
"(void)))"
"(cons"
"(semi-parsed-begin-for-syntax3.1"
" exp-body_0"
" nested-bodys_0)"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))))))"
"(if(equal?"
" tmp_0"
" 'define-values)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-define-values"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" define-values481_0"
" id482_0"
" rhs483_0)"
"(let-values(((s_0)"
" exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((define-values481_0"
" id482_0"
" rhs483_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((define-values484_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id485_0"
" rhs486_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id487_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                           \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id500_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                           \"not an identifier\""
" orig-s_0"
" s_6)))))"
"(cons"
" id500_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_2"
" rest_0)"
" id_2)))"
" id_1))))))"
" for-loop_0)"
" id_0"
" lst_0))))))"
"(reverse$1"
" id_0))))))))"
"((rhs488_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((rhs489_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs489_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" id487_0"
" rhs488_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-values484_0"
" id485_0"
" rhs486_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                               \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-values481_0"
" id482_0"
" rhs483_0))))))"
"(let-values(((ids_0)"
"(remove-use-site-scopes"
" id482_0"
" partial-body-ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((ids490_0)"
" ids_0)"
"((phase491_0)"
" phase_0)"
"((exp-body492_0)"
" exp-body_0))"
"(check-no-duplicate-ids.1"
" unsafe-undefined"
" ids490_0"
" phase491_0"
" exp-body492_0"
" unsafe-undefined))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((ids493_0)"
" ids_0)"
"((phase494_0)"
" phase_0)"
"((requires+provides495_0)"
" requires+provides_0)"
"((exp-body496_0)"
" exp-body_0))"
"(check-ids-unbound.1"
" exp-body496_0"
" ids493_0"
" phase494_0"
" requires+provides495_0))"
"(values))))"
"(let-values(((syms_0)"
"(let-values(((ids501_0)"
" ids_0)"
"((defined-syms502_0)"
" defined-syms_0)"
"((self503_0)"
" self_0)"
"((phase504_0)"
" phase_0)"
"((all-scopes-stx505_0)"
" all-scopes-stx_0)"
"((frame-id506_0)"
" frame-id_0)"
"((requires+provides507_0)"
" requires+provides_0)"
"((exp-body508_0)"
" exp-body_0))"
"(select-defined-syms-and-bind!.1"
" #f"
" frame-id506_0"
" exp-body508_0"
" requires+provides507_0"
" #f"
" ids501_0"
" defined-syms502_0"
" self503_0"
" phase504_0"
" all-scopes-stx505_0))))"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-unset-transformer!"
" m-ns_0"
" phase_0"
" sym_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)"
"(let-values(((requires+provides497_0)"
" requires+provides_0)"
"((syms498_0)"
" syms_0)"
"((phase499_0)"
" phase_0))"
"(add-defined-syms!.1"
" #f"
" requires+provides497_0"
" syms498_0"
" phase499_0))"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-case"
"(list"
" define-values481_0"
" ids_0"
" rhs483_0))))"
"(void)))"
"(cons"
"(semi-parsed-define-values2.1"
" exp-body_0"
" syms_0"
" ids_0"
" rhs483_0)"
"(loop_0"
" tail?_0"
" rest-bodys_0))))))))))"
"(if(equal?"
" tmp_0"
" 'define-syntaxes)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-define-syntaxes"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" define-syntaxes509_0"
" id510_0"
" rhs511_0)"
"(let-values(((s_0)"
" exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((define-syntaxes509_0"
" id510_0"
" rhs511_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((define-syntaxes512_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id513_0"
" rhs514_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id515_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                             \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id529_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                             \"not an identifier\""
" orig-s_0"
" s_6)))))"
"(cons"
" id529_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_2"
" rest_0)"
" id_2)))"
" id_1))))))"
" for-loop_0)"
" id_0"
" lst_0))))))"
"(reverse$1"
" id_0))))))))"
"((rhs516_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((rhs517_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs517_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values"
" id515_0"
" rhs516_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-syntaxes512_0"
" id513_0"
" rhs514_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                 \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-syntaxes509_0"
" id510_0"
" rhs511_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(prepare-next-phase-namespace"
" partial-body-ctx_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'phase-up)))"
"(void)))"
"(values))))"
"(let-values(((ids_0)"
"(remove-use-site-scopes"
" id510_0"
" partial-body-ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((ids518_0)"
" ids_0)"
"((phase519_0)"
" phase_0)"
"((exp-body520_0)"
" exp-body_0))"
"(check-no-duplicate-ids.1"
" unsafe-undefined"
" ids518_0"
" phase519_0"
" exp-body520_0"
" unsafe-undefined))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((ids521_0)"
" ids_0)"
"((phase522_0)"
" phase_0)"
"((requires+provides523_0)"
" requires+provides_0)"
"((exp-body524_0)"
" exp-body_0))"
"(check-ids-unbound.1"
" exp-body524_0"
" ids521_0"
" phase522_0"
" requires+provides523_0))"
"(values))))"
"(let-values(((syms_0)"
"(let-values(((ids530_0)"
" ids_0)"
"((defined-syms531_0)"
" defined-syms_0)"
"((self532_0)"
" self_0)"
"((phase533_0)"
" phase_0)"
"((all-scopes-stx534_0)"
" all-scopes-stx_0)"
"((frame-id535_0)"
" frame-id_0)"
"((requires+provides536_0)"
" requires+provides_0)"
"((exp-body537_0)"
" exp-body_0)"
"((temp538_0)"
" #t))"
"(select-defined-syms-and-bind!.1"
" temp538_0"
" frame-id535_0"
" exp-body537_0"
" requires+provides536_0"
" #f"
" ids530_0"
" defined-syms531_0"
" self532_0"
" phase533_0"
" all-scopes-stx534_0))))"
"(let-values((()"
"(begin"
"(let-values(((requires+provides525_0)"
" requires+provides_0)"
"((syms526_0)"
" syms_0)"
"((phase527_0)"
" phase_0)"
"((temp528_0)"
" #t))"
"(add-defined-syms!.1"
" temp528_0"
" requires+provides525_0"
" syms526_0"
" phase527_0))"
"(values))))"
"(let-values(((install-values_0)"
"(lambda(vals_0)"
"(begin"
" 'install-values"
"(begin"
"(let-values()"
"(let-values(((lst_0)"
" syms_0)"
"((lst_1)"
" vals_0)"
"((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_3"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_3)"
"(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
" #f)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_0)"
"(unsafe-cdr"
" lst_3))"
"((val_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(maybe-install-free=id-in-context!"
" val_0"
" id_0"
" phase_0"
" partial-body-ctx_0)"
"(maybe-install-portal-syntax!"
" val_0"
" sym_0"
" phase_0"
" portal-syntaxes_0)"
"(namespace-set-transformer!"
" m-ns_0"
" phase_0"
" sym_0"
" val_0)))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0"
" rest_1"
" rest_2)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" lst_1"
" lst_2))))"
"(void))))))"
"(let-values(((exp-rhs_0"
" parsed-rhs_0"
" vals_0)"
"(let-values(((temp539_0)"
" 'define-syntaxes)"
"((temp540_0)"
" rhs511_0)"
"((ids541_0)"
" ids_0)"
"((temp542_0)"
"(let-values(((v_0)"
" partial-body-ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((need-eventually-defined545_0)"
" need-eventually-defined_0)"
"((inner546_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((lifts547_0)"
" #f)"
"((module-lifts548_0)"
" #f)"
"((to-module-lifts549_0)"
" #f))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
" lifts547_0"
"(expand-context/inner-lift-envs"
" the-struct_1)"
" module-lifts548_0"
"(expand-context/inner-require-lifts"
" the-struct_1)"
" to-module-lifts549_0"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                     \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner546_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
" need-eventually-defined545_0"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                   \"expand-context/outer?\""
" the-struct_0)))))"
"((temp543_0)"
" #f)"
"((temp544_0)"
"(lambda(go_0)"
"(call-with-module-prompt/value-list"
" 'define-syntaxes"
" go_0"
" ids_0"
" install-values_0))))"
"(expand+eval-for-syntaxes-binding.1"
" temp543_0"
" temp544_0"
" temp539_0"
" temp540_0"
" ids541_0"
" temp542_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-case"
"(list"
" define-syntaxes509_0"
" ids_0"
" exp-rhs_0))))"
"(void)))"
"(values))))"
"(let-values(((parsed-body_0)"
"(parsed-define-syntaxes20.1"
"(keep-properties-only"
" exp-body_0)"
" ids_0"
" syms_0"
" parsed-rhs_0)))"
"(cons"
"(if(expand-context-to-parsed?"
" partial-body-ctx_0)"
" parsed-body_0"
"(expanded+parsed1.1"
"(let-values(((exp-body550_0)"
" exp-body_0)"
"((temp551_0)"
"(list"
" define-syntaxes509_0"
" ids_0"
" exp-rhs_0)))"
"(rebuild.1"
" #t"
" exp-body550_0"
" temp551_0))"
" parsed-body_0))"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))))))))))))"
"(if(equal?"
" tmp_0"
" '#%require)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-require"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ready-body_0)"
"(remove-use-site-scopes"
" exp-body_0"
" partial-body-ctx_0)))"
"(let-values(((ok?_0"
" #%require552_0"
" req553_0)"
"(let-values(((s_0)"
" ready-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((#%require552_0"
" req553_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((#%require554_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((req555_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                             \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" #%require554_0"
" req555_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                     \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" #%require552_0"
" req553_0))))))"
"(begin"
"(let-values(((temp556_0)"
" req553_0)"
"((exp-body557_0)"
" exp-body_0)"
"((self558_0)"
" self_0)"
"((m-ns559_0)"
" m-ns_0)"
"((phase560_0)"
" phase_0)"
"((phase561_0)"
" phase_0)"
"((requires+provides562_0)"
" requires+provides_0)"
"((declared-submodule-names563_0)"
" declared-submodule-names_0)"
"((temp564_0)"
" 'module)"
"((all-scopes-stx565_0)"
" all-scopes-stx_0)"
"((add-defined-portal566_0)"
" add-defined-portal_0))"
"(parse-and-perform-requires!.1"
" add-defined-portal566_0"
" all-scopes-stx565_0"
" #f"
" #f"
" declared-submodule-names563_0"
" #f"
" phase561_0"
" #f"
" self558_0"
" #f"
" #t"
" temp564_0"
" temp556_0"
" exp-body557_0"
" m-ns559_0"
" phase560_0"
" requires+provides562_0))"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-case"
" ready-body_0)))"
"(void)))"
"(cons"
" ready-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))"
"(if(equal?"
" tmp_0"
" '#%provide)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-stop"
" #f)))"
"(void)))"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0))))"
"(if(equal?"
" tmp_0"
" 'module)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-submodule"
" #f)))"
"(void)))"
"(values))))"
"(let-values(((ready-body_0)"
"(remove-use-site-scopes"
" exp-body_0"
" partial-body-ctx_0)))"
"(let-values(((submod_0)"
"(let-values(((ready-body567_0)"
" ready-body_0)"
"((self568_0)"
" self_0)"
"((partial-body-ctx569_0)"
" partial-body-ctx_0)"
"((temp570_0)"
" #f)"
"((declared-submodule-names571_0)"
" declared-submodule-names_0)"
"((mpis-to-reset572_0)"
" mpis-to-reset_0)"
"((compiled-submodules573_0)"
" compiled-submodules_0)"
"((modules-being-compiled574_0)"
" modules-being-compiled_0))"
"(expand-submodule.1"
" compiled-submodules573_0"
" declared-submodule-names571_0"
" #f"
" #f"
" temp570_0"
" #f"
" modules-being-compiled574_0"
" mpis-to-reset572_0"
" ready-body567_0"
" self568_0"
" partial-body-ctx569_0))))"
"(cons"
" submod_0"
"(loop_0"
" tail?_0"
" rest-bodys_0))))))"
"(if(equal?"
" tmp_0"
" 'module*)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-stop"
" #f)))"
"(void)))"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0))))"
"(if(equal?"
" tmp_0"
" '#%declare)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-declare"
" exp-body_0)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" #%declare575_0"
" kw576_0)"
"(let-values(((s_0)"
" exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((#%declare575_0"
" kw576_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((#%declare577_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((kw578_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" #%declare577_0"
" kw578_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                           \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" #%declare575_0"
" kw576_0))))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_1)"
"(lambda(kws_0)"
"(begin"
" 'loop"
"(if(null?"
" kws_0)"
"(void)"
"(let-values()"
"(let-values(((kw_0)"
"(car"
" kws_0)))"
"(let-values((()"
"(begin"
"(if(keyword?"
"(syntax-e$1"
" kw_0))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                         \"expected a keyword\""
" exp-body_0"
" kw_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(memq"
"(syntax-e$1"
" kw_0)"
" '(#:cross-phase-persistent"
" #:empty-namespace"
" #:unsafe"
" #:unlimited-require"
" #:realm"
" #:require=define"
" #:flatten-requires))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                           \"not an allowed declaration keyword\""
" exp-body_0"
" kw_0)))"
"(values))))"
"(let-values(((has-arg?_0)"
"(eq?"
"(syntax-e$1"
" kw_0)"
" '#:realm)))"
"(begin"
"(if(hash-ref"
" declared-keywords_0"
"(syntax-e$1"
" kw_0)"
" #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                 \"keyword declared multiple times\""
" exp-body_0"
" kw_0))"
"(void))"
"(if(eq?"
"(syntax-e$1"
" kw_0)"
" '#:unsafe)"
"(let-values()"
"(if(eq?"
"(current-code-inspector)"
" initial-code-inspector)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                     \"unsafe compilation disallowed by code inspector\""
" exp-body_0"
" kw_0))))"
"(void))"
"(if(eq?"
"(syntax-e$1"
" kw_0)"
" '#:realm)"
"(let-values()"
"(if(if(pair?"
"(cdr"
" kws_0))"
"(identifier?"
"(cadr"
" kws_0))"
" #f)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                     \"expected an identifier after keyword\""
" exp-body_0"
" kw_0))))"
"(void))"
"(if(eq?"
"(syntax-e$1"
" kw_0)"
" '#:require=define)"
"(let-values()"
"(disable-definitions-shadow-imports!"
" requires+provides_0))"
"(void))"
"(hash-set!"
" declared-keywords_0"
"(syntax-e$1"
" kw_0)"
"(if has-arg?_0"
"(cadr"
" kws_0)"
" kw_0))"
"(loop_1"
"(if has-arg?_0"
"(cddr"
" kws_0)"
"(cdr"
" kws_0))))))))))))))"
" loop_1)"
" kw576_0)"
"(values))))"
"(let-values(((parsed-body_0)"
"(parsed-#%declare22.1"
" exp-body_0)))"
"(cons"
"(if(expand-context-to-parsed?"
" partial-body-ctx_0)"
" parsed-body_0"
"(expanded+parsed1.1"
" exp-body_0"
" parsed-body_0))"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-stop"
" #f)))"
"(void)))"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0))))))))))))))))))"
"(let-values(((l_0)"
"(append"
" lifted-reqs_0"
" lifted-defns_0"
" exp-lifted-mods_0)))"
"(if(null? l_0)"
"(finish_0)"
"(append"
" l_0"
"(finish_0)))))))))))))))))))))"
" loop_0)"
" #t"
" bodys_0))))))))))))))))))))))))"
"(define-values"
"(make-wrap-as-definition)"
"(lambda(self_0 frame-id_0 inside-scope_0 all-scopes-stx_0 defined-syms_0 requires+provides_0)"
"(begin"
"(lambda(ids_0 rhs_0 phase_0)"
"(let-values(((scoped-ids_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" inside-scope_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))"
"(let-values(((syms_0)"
"(let-values(((scoped-ids579_0) scoped-ids_0)"
"((defined-syms580_0) defined-syms_0)"
"((self581_0) self_0)"
"((phase582_0) phase_0)"
"((all-scopes-stx583_0) all-scopes-stx_0)"
"((frame-id584_0) frame-id_0)"
"((requires+provides585_0) requires+provides_0))"
"(select-defined-syms-and-bind!.1"
" #f"
" frame-id584_0"
" #f"
" requires+provides585_0"
" #f"
" scoped-ids579_0"
" defined-syms580_0"
" self581_0"
" phase582_0"
" all-scopes-stx583_0))))"
"(let-values(((s_0)"
"(add-scope"
"(datum->syntax$1"
" #f"
"(list"
"(datum->syntax$1(syntax-shift-phase-level$1 core-stx phase_0) 'define-values)"
" scoped-ids_0"
" rhs_0))"
" inside-scope_0)))"
"(values scoped-ids_0(semi-parsed-define-values2.1 s_0 syms_0 scoped-ids_0 rhs_0)))))))))"
"(define-values"
"(add-post-expansion-scope)"
"(lambda(bodys_0 ctx_0)"
"(begin"
"(let-values(((pe_0)(root-expand-context-post-expansion ctx_0)))"
"(if pe_0"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(apply-post-expansion pe_0 body_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))"
" bodys_0)))))"
"(define-values"
"(finish-expanding-body-expressions.1)"
"(lambda(compiled-submodules86_0"
" ctx83_0"
" declared-submodule-names85_0"
" modules-being-compiled87_0"
" mpis-to-reset88_0"
" phase82_0"
" self84_0"
" partially-expanded-bodys96_0)"
"(begin"
" 'finish-expanding-body-expressions"
"(let-values(((partially-expanded-bodys_0) partially-expanded-bodys96_0))"
"(let-values(((phase_0) phase82_0))"
"(let-values(((body-ctx_0) ctx83_0))"
"(let-values(((self_0) self84_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names85_0))"
"(let-values(((compiled-submodules_0) compiled-submodules86_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled87_0))"
"(let-values(((mpis-to-reset_0) mpis-to-reset88_0))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 bodys_0)"
"(begin"
" 'loop"
"(if(null? bodys_0)"
"(let-values()"
"(if(if tail?_0(not(zero? phase_0)) #f)"
"(let-values() null)"
"(if tail?_0"
"(let-values()"
"(let-values(((bodys_1)"
"(append"
"(get-and-clear-end-lifts!"
"(expand-context-to-module-lifts body-ctx_0))"
"(get-and-clear-provide-lifts!"
"(expand-context-to-module-lifts body-ctx_0)))))"
"(if(null? bodys_1)"
"(let-values() null)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-end-lifts"
" bodys_1)))"
"(void)))"
"(loop_0"
" #t"
"(add-post-expansion-scope bodys_1 body-ctx_0)))))))"
"(let-values() null))))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((body_0)(car bodys_0)))"
"(let-values(((rest-bodys_0)(cdr bodys_0)))"
"(let-values(((exp-body_0)"
"(if(let-values(((or-part_0)(parsed? body_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(expanded+parsed? body_0)))"
"(if or-part_1"
" or-part_1"
"(semi-parsed-begin-for-syntax?"
" body_0)))))"
"(let-values() body_0)"
"(if(semi-parsed-define-values? body_0)"
"(let-values()"
"(let-values(((ids_0)"
"(semi-parsed-define-values-ids"
" body_0)))"
"(let-values(((rhs-ctx_0)"
"(as-named-context"
"(as-expression-context"
" body-ctx_0)"
" ids_0)))"
"(let-values(((syms_0)"
"(semi-parsed-define-values-syms"
" body_0)))"
"(let-values(((s_0)"
"(semi-parsed-define-values-s"
" body_0)))"
"(let-values(((ok?_0"
" define-values586_0"
" _587_0"
" _588_0)"
"(let-values(((s_1)"
" s_0))"
"(if(if(not"
"(expand-context-to-parsed?"
" rhs-ctx_0))"
" #t"
" #f)"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((define-values586_0"
" _587_0"
" _588_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((define-values589_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((_590_0"
" _591_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((_592_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
" s_5))"
"((_593_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((_594_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" _594_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" _592_0"
" _593_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-values589_0"
" _590_0"
" _591_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                           \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-values586_0"
" _587_0"
" _588_0)))"
"(values"
" #f"
" #f"
" #f"
" #f)))))"
"(let-values(((rebuild-s_0)"
"(let-values(((rhs-ctx595_0)"
" rhs-ctx_0)"
"((s596_0)"
" s_0)"
"((temp597_0)"
" #t))"
"(keep-as-needed.1"
" #f"
" #f"
" temp597_0"
" rhs-ctx595_0"
" s596_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'visit"
" #f)"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" #f)"
"(call-expand-observe"
" obs_0"
" 'prim-define-values"
" #f))))"
"(void)))"
"(values))))"
"(let-values(((exp-rhs_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'form-in-module/2))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((temp598_0)"
"(semi-parsed-define-values-rhs"
" body_0))"
"((rhs-ctx599_0)"
" rhs-ctx_0))"
"(expand.1"
" #f"
" #f"
" temp598_0"
" rhs-ctx599_0)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim/return"
" #f)))"
"(void)))"
"(values))))"
"(let-values(((comp-form_0)"
"(parsed-define-values19.1"
" rebuild-s_0"
" ids_0"
" syms_0"
"(if(expand-context-to-parsed?"
" rhs-ctx_0)"
" exp-rhs_0"
"(let-values(((exp-rhs600_0)"
" exp-rhs_0)"
"((temp601_0)"
"(as-to-parsed-context"
" rhs-ctx_0)))"
"(expand.1"
" #f"
" #f"
" exp-rhs600_0"
" temp601_0))))))"
"(if(expand-context-to-parsed?"
" rhs-ctx_0)"
" comp-form_0"
"(expanded+parsed1.1"
"(let-values(((rebuild-s602_0)"
" rebuild-s_0)"
"((temp603_0)"
"(list"
" define-values586_0"
" ids_0"
" exp-rhs_0)))"
"(rebuild.1"
" #t"
" rebuild-s602_0"
" temp603_0))"
" comp-form_0)))))))))))))"
"(let-values()"
"(let-values(((tmp_0)"
"(core-form-sym"
" body_0"
" phase_0)))"
"(if(if(equal? tmp_0 '#%require)"
" #t"
"(if(equal? tmp_0 '#%provide)"
" #t"
"(equal? tmp_0 'module*)))"
"(let-values() body_0)"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'form-in-module/2))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((exp-body_0)"
"(let-values(((body604_0)"
" body_0)"
"((temp605_0)"
"(as-expression-context"
" body-ctx_0)))"
"(expand.1"
" #f"
" #f"
" body604_0"
" temp605_0))))"
"(if(expand-context-to-parsed?"
" body-ctx_0)"
" exp-body_0"
"(expanded+parsed1.1"
" exp-body_0"
"(let-values(((exp-body606_0)"
" exp-body_0)"
"((temp607_0)"
"(as-to-parsed-context"
" body-ctx_0)))"
"(expand.1"
" #f"
" #f"
" exp-body606_0"
" temp607_0))))))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))))))))"
"(let-values(((lifted-defns_0)"
"(get-and-clear-lifts!"
"(expand-context-lifts body-ctx_0))))"
"(let-values(((lifted-requires_0)"
"(get-and-clear-require-lifts!"
"(expand-context-require-lifts body-ctx_0))))"
"(let-values(((lifted-modules_0)"
"(get-and-clear-module-lifts!"
"(expand-context-module-lifts body-ctx_0))))"
"(let-values(((no-lifts?_0)"
"(if(null? lifted-defns_0)"
"(if(null? lifted-modules_0)"
"(null? lifted-requires_0)"
" #f)"
" #f)))"
"(let-values((()"
"(begin"
"(if no-lifts?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-pass2-lifts"
" lifted-requires_0"
"(add-post-expansion-scope"
" lifted-modules_0"
" body-ctx_0)"
"(lifted-defns-extract-syntax"
" lifted-defns_0))))"
"(void)))))"
"(values))))"
"(let-values(((exp-lifted-modules_0)"
"(let-values(((lifted-modules608_0)"
" lifted-modules_0)"
"((phase609_0) phase_0)"
"((self610_0) self_0)"
"((body-ctx611_0)"
" body-ctx_0)"
"((mpis-to-reset612_0)"
" mpis-to-reset_0)"
"((declared-submodule-names613_0)"
" declared-submodule-names_0)"
"((compiled-submodules614_0)"
" compiled-submodules_0)"
"((modules-being-compiled615_0)"
" modules-being-compiled_0))"
"(expand-non-module*-submodules.1"
" compiled-submodules614_0"
" declared-submodule-names613_0"
" modules-being-compiled615_0"
" mpis-to-reset612_0"
" lifted-modules608_0"
" phase609_0"
" self610_0"
" body-ctx611_0))))"
"(let-values((()"
"(begin"
"(if no-lifts?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))))"
"(values))))"
"(let-values(((exp-lifted-defns_0)"
"(loop_0 #f lifted-defns_0)))"
"(begin"
"(if no-lifts?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))))"
"(append"
" lifted-requires_0"
" exp-lifted-modules_0"
" exp-lifted-defns_0"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0))))))))))))))))))))))"
" loop_0)"
" #t"
" partially-expanded-bodys_0)))))))))))))"
"(define-values"
"(check-defined-by-now)"
"(lambda(need-eventually-defined_0 self_0 ctx_0 requires+provides_0)"
"(begin"
"(begin"
"(let-values()"
"(let-values(((ht_0) need-eventually-defined_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 l_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0)(reverse$1 l_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id616_0)"
" id_0)"
"((phase617_0)"
" phase_0))"
"(resolve+shift.1"
" #f"
" #f"
" null"
" unsafe-undefined"
" #f"
" id616_0"
" phase617_0))))"
"(let-values(((bound-here?_0)"
"(if b_0"
"(if(module-binding?"
" b_0)"
"(if(eq?"
"(module-binding-sym"
" b_0)"
"(syntax-e$1"
" id_0))"
"(eq?"
"(module-binding-module"
" b_0)"
" self_0)"
" #f)"
" #f)"
" #f)))"
"(let-values(((bound-kind_0)"
"(if bound-here?_0"
"(defined-sym-kind"
" requires+provides_0"
"(module-binding-sym"
" b_0)"
" phase_0)"
" #f)))"
"(if(eq?"
" bound-kind_0"
" 'variable)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(string-append"
"(if(not"
" b_0)"
"(let-values()"
"                                                                                                                                                              \"reference to an unbound identifier\")"
"(if(eq?"
" bound-kind_0"
" 'transformer)"
"(let-values()"
"                                                                                                                                                                \"identifier treated as a variable, but later defined as syntax\")"
"(let-values()"
"                                                                                                                                                                \"identifier treated as a variable, but later bound differently\")))"
"(format"
"                                                                                                                                                           \"\\n  at phase: ~a\""
"(let-values(((tmp_0)"
" phase_0))"
"(if(equal?"
" tmp_0"
" 1)"
"(let-values()"
"                                                                                                                                                                 \"1; the transformer environment\")"
"(let-values()"
" phase_0)))))"
" id_0"
" #f"
" null"
"(syntax-debug-info-string"
" id_0"
" ctx_0))))))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_0))))"
"(void)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0)))))"
"(void)))))"
"(define-values"
"(resolve-provides.1)"
"(lambda(ctx103_0"
" declared-submodule-names99_0"
" namespace100_0"
" phase101_0"
" requires-and-provides98_0"
" self102_0"
" expression-expanded-bodys110_0)"
"(begin"
" 'resolve-provides"
"(let-values(((expression-expanded-bodys_0) expression-expanded-bodys110_0))"
"(let-values(((requires+provides_0) requires-and-provides98_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names99_0))"
"(let-values(((m-ns_0) namespace100_0))"
"(let-values(((phase_0) phase101_0))"
"(let-values(((self_0) self102_0))"
"(let-values(((ctx_0) ctx103_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand 'provide))(void))"
"(begin0"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(bodys_0 phase_1)"
"(begin"
" 'loop"
"(if(null? bodys_0)"
"(let-values() null)"
"(if(let-values(((or-part_0)(parsed?(car bodys_0))))"
"(if or-part_0 or-part_0(expanded+parsed?(car bodys_0))))"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(cons(car bodys_0)(loop_0(cdr bodys_0) phase_1))))"
"(if(semi-parsed-begin-for-syntax?(car bodys_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-begin-for-syntax)))"
"(void)))"
"(values))))"
"(let-values(((nested-bodys_0)"
"(loop_0"
"(semi-parsed-begin-for-syntax-body"
"(car bodys_0))"
"(add1 phase_1))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-begin-for-syntax)))"
"(void)))"
"(cons"
"(let-values(((the-struct_0)(car bodys_0)))"
"(if(semi-parsed-begin-for-syntax? the-struct_0)"
"(let-values(((body618_0) nested-bodys_0))"
"(semi-parsed-begin-for-syntax3.1"
"(semi-parsed-begin-for-syntax-s the-struct_0)"
" body618_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                      \"semi-parsed-begin-for-syntax?\""
" the-struct_0)))"
"(loop_0(cdr bodys_0) phase_1))))))"
"(let-values()"
"(let-values(((body_0)(car bodys_0)))"
"(let-values(((tmp_0)(core-form-sym body_0 phase_1)))"
"(if(equal? tmp_0 '#%provide)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" body_0)"
"(call-expand-observe"
" obs_0"
" 'prim-provide"
" body_0))))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 #%provide619_0 spec620_0)"
"(let-values(((s_0) body_0))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((#%provide619_0"
" spec620_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((#%provide621_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec622_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" #%provide621_0"
" spec622_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" #%provide619_0"
" spec620_0))))))"
"(let-values(((track-stxes_0 specs_0)"
"(parse-and-expand-provides!"
" spec620_0"
" body_0"
" requires+provides_0"
" self_0"
" phase_1"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((context623_0)"
" 'top-level)"
"((inner624_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((phase625_0)"
" phase_1)"
"((namespace626_0)"
"(namespace->namespace-at-phase"
" m-ns_0"
" phase_1))"
"((requires+provides627_0)"
" requires+provides_0)"
"((declared-submodule-names628_0)"
" declared-submodule-names_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase625_0"
" namespace626_0"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
" declared-submodule-names628_0"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
" requires+provides627_0"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                              \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner624_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
" context623_0"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                            \"expand-context/outer?\""
" the-struct_0)))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(let-values()(loop_0(cdr bodys_0) phase_1))"
"(let-values()"
"(let-values(((new-s_0)"
"(syntax-track-origin*"
" track-stxes_0"
"(let-values(((body629_0)"
" body_0)"
"((temp630_0)"
"(list*"
" #%provide619_0"
" specs_0)))"
"(rebuild.1"
" #t"
" body629_0"
" temp630_0)))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
" new-s_0)))"
"(void)))"
"(cons"
" new-s_0"
"(loop_0(cdr bodys_0) phase_1))))))))))"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(cons"
" body_0"
"(loop_0(cdr bodys_0) phase_1)))))))))))))))"
" loop_0)"
" expression-expanded-bodys_0"
" phase_0))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))))))))))"
"(define-values"
"(declare-module-for-expansion.1)"
"(lambda(ctx119_0"
" enclosing117_0"
" fill124_0"
" flatten-requires?122_0"
" module-name-id112_0"
" modules-being-compiled120_0"
" namespace115_0"
" portal-syntaxes123_0"
" realm121_0"
" rebuild-s113_0"
" requires-and-provides114_0"
" root-ctx118_0"
" self116_0"
" fully-expanded-bodys-except-post-submodules138_0)"
"(begin"
" 'declare-module-for-expansion"
"(let-values(((fully-expanded-bodys-except-post-submodules_0) fully-expanded-bodys-except-post-submodules138_0))"
"(let-values(((module-name-id_0) module-name-id112_0))"
"(let-values(((rebuild-s_0) rebuild-s113_0))"
"(let-values(((requires+provides_0) requires-and-provides114_0))"
"(let-values(((m-ns_0) namespace115_0))"
"(let-values(((self_0) self116_0))"
"(let-values(((enclosing-self_0) enclosing117_0))"
"(let-values(((root-ctx_0) root-ctx118_0))"
"(let-values(((ctx_0) ctx119_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled120_0))"
"(let-values(((realm_0) realm121_0))"
"(let-values(((flatten-requires?_0) flatten-requires?122_0))"
"(let-values(((portal-syntaxes_0) portal-syntaxes123_0))"
"(let-values(((compiled-module-box_0) fill124_0))"
"(let-values()"
"(let-values(((requires_0 recur-requires_0 flattened-requires_0 provides_0)"
"(let-values(((requires+provides631_0) requires+provides_0)"
"((self632_0) self_0)"
"((self633_0) self_0)"
"((flatten-requires?634_0) flatten-requires?_0)"
"((m-ns635_0) m-ns_0))"
"(extract-requires-and-provides.1"
" flatten-requires?634_0"
" m-ns635_0"
" requires+provides631_0"
" self632_0"
" self633_0))))"
"(let-values(((parsed-mod_0)"
"(parsed-module25.1"
" rebuild-s_0"
" #f"
" module-name-id_0"
" self_0"
" requires_0"
" recur-requires_0"
" flattened-requires_0"
" provides_0"
"(requires+provides-all-bindings-simple? requires+provides_0)"
"(root-expand-context-encode-for-module root-ctx_0 self_0 self_0)"
"(parsed-only fully-expanded-bodys-except-post-submodules_0)"
" realm_0"
" portal-syntaxes_0"
" #f"
"(hasheq))))"
"(let-values(((module-name_0)"
"(1/module-path-index-resolve"
"(let-values(((or-part_0) enclosing-self_0))"
"(if or-part_0 or-part_0 self_0)))))"
"(let-values(((compiled-module_0)"
"(let-values(((parsed-mod636_0) parsed-mod_0)"
"((temp637_0)"
"(let-values(((m-ns642_0) m-ns_0)"
"((enclosing-self643_0)"
" enclosing-self_0)"
"((temp644_0)"
"(if enclosing-self_0"
"(1/resolved-module-path-name"
" module-name_0)"
" #f)))"
"(make-compile-context.1"
" temp644_0"
" unsafe-undefined"
" enclosing-self643_0"
" m-ns642_0"
" unsafe-undefined"
" unsafe-undefined)))"
"((temp638_0)"
"(expand-context-for-serializable? ctx_0))"
"((temp639_0)"
"(expand-context-to-correlated-linklet? ctx_0))"
"((modules-being-compiled640_0)"
" modules-being-compiled_0)"
"((temp641_0) #f))"
"(compile-module.1"
" #f"
" modules-being-compiled640_0"
" temp641_0"
" temp638_0"
" temp639_0"
" parsed-mod636_0"
" temp637_0))))"
"(let-values((()"
"(begin"
"(set-box! compiled-module-box_0 compiled-module_0)"
"(values))))"
"(let-values(((root-module-name_0)"
"(resolved-module-path-root-name module-name_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" m-ns_0"
" 1/current-module-declare-name"
"(1/make-resolved-module-path root-module-name_0))"
"(let-values()"
"(let-values(((compiled-module645_0) compiled-module_0)"
"((temp646_0) #f))"
"(eval-module.1"
" unsafe-undefined"
" #f"
" temp646_0"
" compiled-module645_0))))))))))))))))))))))))))))"
"(define-values"
"(attach-root-expand-context-properties)"
"(lambda(s_0 root-ctx_0 orig-self_0 new-self_0)"
"(begin"
"(let-values(((s_1)(syntax-property$1 s_0 'module-body-context(root-expand-context-all-scopes-stx root-ctx_0))))"
"(let-values(((s_2)"
"(syntax-property$1"
" s_1"
" 'module-body-inside-context"
"(apply-post-expansion(root-expand-context-post-expansion root-ctx_0) empty-syntax))))"
" s_2)))))"
"(define-values"
"(expand-post-submodules.1)"
"(lambda(all-scopes-s145_0"
" compiled-submodules148_0"
" ctx150_0"
" declare-enclosing140_0"
" declared-submodule-names147_0"
" enclosing-is-cross-phase-persistent?144_0"
" modules-being-compiled149_0"
" mpis-to-reset146_0"
" phase141_0"
" requires-and-provides143_0"
" self142_0"
" fully-expanded-bodys-except-post-submodules162_0)"
"(begin"
" 'expand-post-submodules"
"(let-values(((fully-expanded-bodys-except-post-submodules_0) fully-expanded-bodys-except-post-submodules162_0))"
"(let-values(((declare-enclosing-module_0) declare-enclosing140_0))"
"(let-values(((phase_0) phase141_0))"
"(let-values(((self_0) self142_0))"
"(let-values(((requires+provides_0) requires-and-provides143_0))"
"(let-values(((enclosing-is-cross-phase-persistent?_0) enclosing-is-cross-phase-persistent?144_0))"
"(let-values()"
"(let-values(((mpis-to-reset_0) mpis-to-reset146_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names147_0))"
"(let-values(((compiled-submodules_0) compiled-submodules148_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled149_0))"
"(let-values(((submod-ctx_0) ctx150_0))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(bodys_0 phase_1)"
"(begin"
" 'loop"
"(if(null? bodys_0)"
"(let-values() null)"
"(let-values()"
"(let-values(((body_0)(car bodys_0)))"
"(let-values(((rest-bodys_0)(cdr bodys_0)))"
"(if(semi-parsed-begin-for-syntax? body_0)"
"(let-values()"
"(let-values(((body-s_0)"
"(semi-parsed-begin-for-syntax-s"
" body_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" submod-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-begin-for-syntax)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 begin-for-syntax647_0 _648_0)"
"(let-values(((s_0) body-s_0))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((begin-for-syntax647_0"
" _648_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((begin-for-syntax649_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((_650_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin-for-syntax649_0"
" _650_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                           \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin-for-syntax647_0"
" _648_0))))))"
"(let-values(((rebuild-body-s_0)"
"(let-values(((submod-ctx651_0)"
" submod-ctx_0)"
"((body-s652_0)"
" body-s_0))"
"(keep-as-needed.1"
" #f"
" #f"
" #f"
" submod-ctx651_0"
" body-s652_0))))"
"(let-values(((nested-bodys_0)"
"(loop_0"
"(semi-parsed-begin-for-syntax-body"
" body_0)"
"(add1 phase_1))))"
"(let-values(((parsed-bfs_0)"
"(parsed-begin-for-syntax21.1"
" rebuild-body-s_0"
"(parsed-only"
" nested-bodys_0))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" submod-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-begin-for-syntax)))"
"(void)))"
"(cons"
"(if(expand-context-to-parsed?"
" submod-ctx_0)"
" parsed-bfs_0"
"(expanded+parsed1.1"
"(let-values(((rebuild-body-s653_0)"
" rebuild-body-s_0)"
"((temp654_0)"
"(list*"
" begin-for-syntax647_0"
"(syntax-only"
" nested-bodys_0))))"
"(rebuild.1"
" #t"
" rebuild-body-s653_0"
" temp654_0))"
" parsed-bfs_0))"
"(loop_0 rest-bodys_0 phase_1))))))))))"
"(if(let-values(((or-part_0)(parsed? body_0)))"
"(if or-part_0"
" or-part_0"
"(expanded+parsed? body_0)))"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" submod-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(cons body_0(loop_0 rest-bodys_0 phase_1))))"
"(let-values()"
"(let-values(((tmp_0)"
"(core-form-sym body_0 phase_1)))"
"(if(equal? tmp_0 'module*)"
"(let-values()"
"(let-values((()"
"(begin"
"(force"
" declare-enclosing-module_0)"
"(values))))"
"(let-values(((ready-body_0)"
"(remove-use-site-scopes"
" body_0"
" submod-ctx_0)))"
"(let-values(((ok?_0"
" module*655_0"
" name656_0"
" _657_0)"
"(let-values(((s_0) body_0))"
"(if(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
" #t)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(eq?"
" #f"
" s_7)))"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
" #t)"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((module*655_0"
" name656_0"
" _657_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(let-values(((module*658_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((name659_0"
" _660_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((name661_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((_662_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values((()"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(values))))"
"((_663_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
" s_6)))"
"(values"
" _663_0))))))"
"(values"
" name661_0"
" _662_0))))))"
"(values"
" module*658_0"
" name659_0"
" _660_0)))))"
"(values"
" #t"
" module*655_0"
" name656_0"
" _657_0)))"
"(values #f #f #f #f)))))"
"(let-values(((submod_0)"
"(if ok?_0"
"(let-values()"
"(let-values(((neg-phase_0)"
"(phase-"
" 0"
" phase_1)))"
"(let-values(((shifted-s_0)"
"(syntax-shift-phase-level$1"
" ready-body_0"
" neg-phase_0)))"
"(let-values(((submod_0)"
"(let-values(((shifted-s664_0)"
" shifted-s_0)"
"((self665_0)"
" self_0)"
"((submod-ctx666_0)"
" submod-ctx_0)"
"((temp667_0)"
" #t)"
"((neg-phase668_0)"
" neg-phase_0)"
"((requires+provides669_0)"
" requires+provides_0)"
"((enclosing-is-cross-phase-persistent?670_0)"
" enclosing-is-cross-phase-persistent?_0)"
"((mpis-to-reset671_0)"
" mpis-to-reset_0)"
"((declared-submodule-names672_0)"
" declared-submodule-names_0)"
"((compiled-submodules673_0)"
" compiled-submodules_0)"
"((modules-being-compiled674_0)"
" modules-being-compiled_0))"
"(expand-submodule.1"
" compiled-submodules673_0"
" declared-submodule-names672_0"
" enclosing-is-cross-phase-persistent?670_0"
" requires+provides669_0"
" temp667_0"
" neg-phase668_0"
" modules-being-compiled674_0"
" mpis-to-reset671_0"
" shifted-s664_0"
" self665_0"
" submod-ctx666_0))))"
"(if(parsed?"
" submod_0)"
"(let-values()"
" submod_0)"
"(if(expanded+parsed?"
" submod_0)"
"(let-values()"
"(let-values(((the-struct_0)"
" submod_0))"
"(if(expanded+parsed?"
" the-struct_0)"
"(let-values(((s675_0)"
"(syntax-shift-phase-level$1"
"(expanded+parsed-s"
" submod_0)"
" phase_1)))"
"(expanded+parsed1.1"
" s675_0"
"(expanded+parsed-parsed"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                   \"expanded+parsed?\""
" the-struct_0))))"
"(let-values()"
"(syntax-shift-phase-level$1"
" submod_0"
" phase_1))))))))"
"(let-values()"
"(let-values(((ready-body676_0)"
" ready-body_0)"
"((self677_0)"
" self_0)"
"((submod-ctx678_0)"
" submod-ctx_0)"
"((temp679_0)"
" #t)"
"((mpis-to-reset680_0)"
" mpis-to-reset_0)"
"((declared-submodule-names681_0)"
" declared-submodule-names_0)"
"((compiled-submodules682_0)"
" compiled-submodules_0)"
"((modules-being-compiled683_0)"
" modules-being-compiled_0))"
"(expand-submodule.1"
" compiled-submodules682_0"
" declared-submodule-names681_0"
" #f"
" #f"
" temp679_0"
" #f"
" modules-being-compiled683_0"
" mpis-to-reset680_0"
" ready-body676_0"
" self677_0"
" submod-ctx678_0))))))"
"(cons"
" submod_0"
"(loop_0 rest-bodys_0 phase_1)))))))"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" submod-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(cons"
" body_0"
"(loop_0"
" rest-bodys_0"
" phase_1)))))))))))))))))"
" loop_0)"
" fully-expanded-bodys-except-post-submodules_0"
" phase_0)))))))))))))))))"
"(define-values"
"(stop-at-module*?)"
"(lambda(ctx_0)"
"(begin"
"(free-id-set-member?"
"(expand-context-stops ctx_0)"
"(expand-context-phase ctx_0)"
"(syntax-shift-phase-level$1(datum->syntax$1 core-stx 'module*)(expand-context-phase ctx_0))))))"
"(define-values"
"(check-ids-unbound.1)"
"(lambda(in164_0 ids166_0 phase167_0 requires+provides168_0)"
"(begin"
" 'check-ids-unbound"
"(let-values(((ids_0) ids166_0))"
"(let-values(((phase_0) phase167_0))"
"(let-values(((requires+provides_0) requires+provides168_0))"
"(let-values(((s_0) in164_0))"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((requires+provides684_0)"
" requires+provides_0)"
"((id685_0) id_0)"
"((phase686_0) phase_0)"
"((temp687_0) #f)"
"((s688_0) s_0)"
"((temp689_0) 'module))"
"(check-not-defined.1"
" #f"
" #f"
" #f"
" s688_0"
" #f"
" #f"
" temp689_0"
" requires+provides684_0"
" id685_0"
" phase686_0"
" temp687_0)))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))))))))))"
"(define-values"
"(eval-nested-bodys)"
"(lambda(bodys_0 phase_0 m-ns_0 self_0 ctx_0)"
"(begin"
"(begin"
"(let-values()"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((p_0)"
"(if(expanded+parsed? body_0)"
"(expanded+parsed-parsed"
" body_0)"
" body_0)))"
"(if(parsed-define-values? p_0)"
"(let-values()"
"(let-values(((syms_0)"
"(parsed-define-values-syms"
" p_0)))"
"(let-values(((ids_0)"
"(parsed-define-values-ids"
" p_0)))"
"(begin"
"(let-values(((temp690_0)"
" 'define-values)"
"((ids691_0) ids_0)"
"((temp692_0)"
"(parsed-define-values-rhs"
" p_0))"
"((phase693_0)"
" phase_0)"
"((m-ns694_0) m-ns_0)"
"((ctx695_0) ctx_0)"
"((temp696_0)"
"(lambda(go_0)"
"(call-with-module-prompt/value-list"
" 'define"
" go_0"
" ids_0"
"(lambda(vals_0)"
"(begin"
"(let-values()"
"(let-values(((lst_2)"
" syms_0)"
"((lst_3)"
" vals_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_3)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((val_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-set-variable!"
" m-ns_0"
" phase_0"
" sym_0"
" val_0))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1"
" rest_2)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2"
" lst_3))))"
"(void)))))))"
"(eval-for-bindings.1"
" temp696_0"
" temp690_0"
" ids691_0"
" temp692_0"
" phase693_0"
" m-ns694_0"
" ctx695_0))"
"(let-values()"
"(let-values(((lst_2) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-get-variable"
" m-ns_0"
" phase_0"
" sym_0"
"(lambda()"
"(raise"
"(exn:fail:contract:variable"
"(string-append"
"                                                                                                                                                              \"define-values: skipped variable definition during expansion\\n\""
"                                                                                                                                                              \"  variable: \""
"(symbol->string"
" sym_0))"
"(current-continuation-marks)"
" sym_0)))))"
"(values)))))"
"(values))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2))))"
"(void)))))"
"(if(let-values(((or-part_0)"
"(parsed-define-syntaxes?"
" p_0)))"
"(if or-part_0"
" or-part_0"
"(semi-parsed-begin-for-syntax?"
" p_0)))"
"(let-values()(void))"
"(if(let-values(((or-part_0)"
"(parsed-#%declare?"
" p_0)))"
"(if or-part_0"
" or-part_0"
"(syntax?$1 p_0)))"
"(let-values()(void))"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" m-ns_0)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" ctx_0"
"(let-values()"
"(let-values(((c_0)"
"(compile-single"
" p_0"
"(let-values(((m-ns697_0)"
" m-ns_0)"
"((phase698_0)"
" phase_0))"
"(make-compile-context.1"
" #f"
" unsafe-undefined"
" #f"
" m-ns697_0"
" phase698_0"
" unsafe-undefined)))))"
"(1/call-with-module-prompt"
"(lambda()"
"(eval-single-top"
" c_0"
" m-ns_0))))))))))))))"
"(values)))))"
"(values))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void)))))"
"(define-values"
"(expand-submodule.1)"
"(lambda(compiled-submodules176_0"
" declared-submodule-names175_0"
" enclosing-is-cross-phase-persistent?173_0"
" enclosing-requires+provides172_0"
" is-star?170_0"
" keep-enclosing-scope-at-phase171_0"
" modules-being-compiled177_0"
" mpis-to-reset174_0"
" s186_0"
" self187_0"
" ctx188_0)"
"(begin"
" 'expand-submodule"
"(let-values(((s_0) s186_0))"
"(let-values(((self_0) self187_0))"
"(let-values(((ctx_0) ctx188_0))"
"(let-values(((is-star?_0) is-star?170_0))"
"(let-values(((keep-enclosing-scope-at-phase_0) keep-enclosing-scope-at-phase171_0))"
"(let-values(((enclosing-r+p_0) enclosing-requires+provides172_0))"
"(let-values(((enclosing-is-cross-phase-persistent?_0) enclosing-is-cross-phase-persistent?173_0))"
"(let-values(((mpis-to-reset_0) mpis-to-reset174_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names175_0))"
"(let-values(((compiled-submodules_0) compiled-submodules176_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled177_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'enter-prim s_0)"
"(call-expand-observe"
" obs_0"
"(if is-star?_0 'prim-submodule* 'prim-submodule)"
" #f))))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 module699_0 name700_0 _701_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((module699_0 name700_0 _701_0)"
"(let-values(((s_2)"
"(if(syntax?$1 s_1)"
"(syntax-e$1 s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((module702_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((name703_0 _704_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((name705_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
" s_5))"
"((_706_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
" s_5)))"
"(values name705_0 _706_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values module702_0 name703_0 _704_0))"
"                                                                    (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t module699_0 name700_0 _701_0))))))"
"(let-values(((name_0)(syntax-e$1 name700_0)))"
"(let-values((()"
"(begin"
"(if(hash-ref declared-submodule-names_0 name_0 #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                         \"submodule already declared with the same name\""
" s_0"
" name_0))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(hash-set!"
" declared-submodule-names_0"
" name_0"
"(syntax-e$1 module699_0))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'enter-prim s_0)))"
"(void)))"
"(values))))"
"(let-values(((submod_0)"
"(let-values(((s707_0) s_0)"
"((temp708_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context716_0) 'module)"
"((post-expansion717_0) #f)"
"((inner718_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((stops719_0)"
" empty-free-id-set))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
" stops719_0"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-parsing-expanded?"
" the-struct_1)"
"(expand-context/inner-skip-visit-available?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                               \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner718_0"
" post-expansion717_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
" context716_0"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                             \"expand-context/outer?\""
" the-struct_0)))))"
"((self709_0) self_0)"
"((temp710_0) #t)"
"((keep-enclosing-scope-at-phase711_0)"
" keep-enclosing-scope-at-phase_0)"
"((enclosing-r+p712_0) enclosing-r+p_0)"
"((enclosing-is-cross-phase-persistent?713_0)"
" enclosing-is-cross-phase-persistent?_0)"
"((mpis-to-reset714_0) mpis-to-reset_0)"
"((modules-being-compiled715_0)"
" modules-being-compiled_0))"
"(expand-module.1"
" temp710_0"
" enclosing-is-cross-phase-persistent?713_0"
" enclosing-r+p712_0"
" keep-enclosing-scope-at-phase711_0"
" modules-being-compiled715_0"
" mpis-to-reset714_0"
" s707_0"
" temp708_0"
" self709_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
"(extract-syntax submod_0))))"
"(void)))"
"(values))))"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"(let-values(((module-name_0)(1/module-path-index-resolve self_0)))"
"(let-values(((root-module-name_0)"
"(resolved-module-path-root-name module-name_0)))"
"(let-values(((compiled-submodule_0)"
"(let-values(((temp720_0)"
"(if(expanded+parsed? submod_0)"
"(expanded+parsed-parsed submod_0)"
" submod_0))"
"((temp721_0)"
"(let-values(((ns727_0) ns_0)"
"((self728_0) self_0)"
"((temp729_0)"
"(1/resolved-module-path-name"
" module-name_0)))"
"(make-compile-context.1"
" temp729_0"
" unsafe-undefined"
" self728_0"
" ns727_0"
" unsafe-undefined"
" unsafe-undefined)))"
"((temp722_0) #t)"
"((temp723_0)"
"(expand-context-for-serializable?"
" ctx_0))"
"((temp724_0)"
"(expand-context-to-correlated-linklet?"
" ctx_0))"
"((modules-being-compiled725_0)"
" modules-being-compiled_0)"
"((temp726_0) #f))"
"(compile-module.1"
" temp722_0"
" modules-being-compiled725_0"
" temp726_0"
" temp723_0"
" temp724_0"
" temp720_0"
" temp721_0))))"
"(begin"
"(hash-set!"
" compiled-submodules_0"
" name_0"
"(cons is-star?_0 compiled-submodule_0))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" ns_0"
" 1/current-module-declare-name"
"(1/make-resolved-module-path root-module-name_0))"
"(let-values()"
"(let-values(((compiled-submodule730_0) compiled-submodule_0)"
"((temp731_0) #f))"
"(eval-module.1"
" unsafe-undefined"
" #f"
" temp731_0"
" compiled-submodule730_0))))"
"(if(not is-star?_0)"
"(let-values() submod_0)"
"(if(expanded+parsed? submod_0)"
"(let-values()"
"(let-values(((the-struct_0) submod_0))"
"(if(expanded+parsed? the-struct_0)"
"(let-values(((parsed732_0)"
"(let-values(((the-struct_1)"
"(expanded+parsed-parsed"
" submod_0)))"
"(if(parsed-module? the-struct_1)"
"(let-values(((star?733_0) #t))"
"(parsed-module25.1"
"(parsed-s the-struct_1)"
" star?733_0"
"(parsed-module-name-id"
" the-struct_1)"
"(parsed-module-self the-struct_1)"
"(parsed-module-requires"
" the-struct_1)"
"(parsed-module-recur-requires"
" the-struct_1)"
"(parsed-module-flattened-requires"
" the-struct_1)"
"(parsed-module-provides"
" the-struct_1)"
"(parsed-module-root-ctx-simple?"
" the-struct_1)"
"(parsed-module-encoded-root-ctx"
" the-struct_1)"
"(parsed-module-body the-struct_1)"
"(parsed-module-realm"
" the-struct_1)"
"(parsed-module-portal-syntaxes"
" the-struct_1)"
"(parsed-module-compiled-module"
" the-struct_1)"
"(parsed-module-compiled-submodules"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                     \"parsed-module?\""
" the-struct_1)))))"
"(expanded+parsed1.1"
"(expanded+parsed-s the-struct_0)"
" parsed732_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                   \"expanded+parsed?\""
" the-struct_0))))"
"(let-values()"
"(let-values(((the-struct_0) submod_0))"
"(if(parsed-module? the-struct_0)"
"(let-values(((star?734_0) #t))"
"(parsed-module25.1"
"(parsed-s the-struct_0)"
" star?734_0"
"(parsed-module-name-id the-struct_0)"
"(parsed-module-self the-struct_0)"
"(parsed-module-requires the-struct_0)"
"(parsed-module-recur-requires the-struct_0)"
"(parsed-module-flattened-requires the-struct_0)"
"(parsed-module-provides the-struct_0)"
"(parsed-module-root-ctx-simple? the-struct_0)"
"(parsed-module-encoded-root-ctx the-struct_0)"
"(parsed-module-body the-struct_0)"
"(parsed-module-realm the-struct_0)"
"(parsed-module-portal-syntaxes the-struct_0)"
"(parsed-module-compiled-module the-struct_0)"
"(parsed-module-compiled-submodules the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                   \"parsed-module?\""
" the-struct_0))))))))))))))))))))))))))))))))))"
"(define-values"
"(expand-non-module*-submodules.1)"
"(lambda(compiled-submodules192_0"
" declared-submodule-names191_0"
" modules-being-compiled193_0"
" mpis-to-reset190_0"
" bodys198_0"
" phase199_0"
" self200_0"
" ctx201_0)"
"(begin"
" 'expand-non-module*-submodules"
"(let-values(((bodys_0) bodys198_0))"
"(let-values(((phase_0) phase199_0))"
"(let-values(((self_0) self200_0))"
"(let-values(((ctx_0) ctx201_0))"
"(let-values(((mpis-to-reset_0) mpis-to-reset190_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names191_0))"
"(let-values(((compiled-submodules_0) compiled-submodules192_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled193_0))"
"(let-values()"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(let-values(((tmp_0)"
"(core-form-sym"
" body_0"
" phase_0)))"
"(if(equal?"
" tmp_0"
" 'module)"
"(let-values()"
"(let-values(((body735_0)"
" body_0)"
"((self736_0)"
" self_0)"
"((ctx737_0)"
" ctx_0)"
"((temp738_0)"
" #f)"
"((mpis-to-reset739_0)"
" mpis-to-reset_0)"
"((declared-submodule-names740_0)"
" declared-submodule-names_0)"
"((compiled-submodules741_0)"
" compiled-submodules_0)"
"((modules-being-compiled742_0)"
" modules-being-compiled_0))"
"(expand-submodule.1"
" compiled-submodules741_0"
" declared-submodule-names740_0"
" #f"
" #f"
" temp738_0"
" #f"
" modules-being-compiled742_0"
" mpis-to-reset739_0"
" body735_0"
" self736_0"
" ctx737_0)))"
"(let-values()"
" body_0)))))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0)))))))))))))))))"
"(define-values"
"(make-parse-lifted-require.1)"
"(lambda(add-defined-portal204_0 declared-submodule-names203_0 m-ns207_0 self208_0 requires+provides209_0)"
"(begin"
" 'make-parse-lifted-require"
"(let-values(((m-ns_0) m-ns207_0))"
"(let-values(((self_0) self208_0))"
"(let-values(((requires+provides_0) requires+provides209_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names203_0))"
"(let-values(((add-defined-portal_0) add-defined-portal204_0))"
"(let-values()"
"(lambda(s_0 phase_0)"
"(let-values(((ok?_0 #%require743_0 req744_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%require743_0 req744_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%require745_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((req746_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((req747_0)"
"(let-values(((s_5)"
"(car s_4)))"
" s_5))"
"(()"
"(let-values(((s_5)"
"(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values req747_0))"
"(raise-syntax-error$1"
" #f"
"                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values #%require745_0 req746_0))"
"                                                        (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%require743_0 req744_0))))))"
"(begin"
"(let-values(((temp748_0)(list req744_0))"
"((s749_0) s_0)"
"((self750_0) self_0)"
"((m-ns751_0) m-ns_0)"
"((phase752_0) phase_0)"
"((phase753_0) phase_0)"
"((requires+provides754_0) requires+provides_0)"
"((declared-submodule-names755_0) declared-submodule-names_0)"
"((add-defined-portal756_0) add-defined-portal_0)"
"((temp757_0) 'require))"
"(parse-and-perform-requires!.1"
" add-defined-portal756_0"
" #f"
" #f"
" #f"
" declared-submodule-names755_0"
" #f"
" phase753_0"
" #f"
" self750_0"
" #f"
" #t"
" temp757_0"
" temp748_0"
" s749_0"
" m-ns751_0"
" phase752_0"
" requires+provides754_0))"
"(set-requires+provides-all-bindings-simple?! requires+provides_0 #f)"
" s_0))))))))))))"
"(define-values"
"(defn-extract-syntax)"
"(lambda(defn_0)"
"(begin"
"(datum->syntax$1"
" #f"
"(list 'define-values(semi-parsed-define-values-ids defn_0)(semi-parsed-define-values-rhs defn_0))"
"(semi-parsed-define-values-s defn_0)))))"
"(define-values"
"(lifted-defns-extract-syntax)"
"(lambda(lifted-defns_0)"
"(begin"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) lifted-defns_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((lifted-defn_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(defn-extract-syntax lifted-defn_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)(for-loop_0 fold-var_2 rest_0) fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))))"
"(define-values"
"(maybe-install-portal-syntax!)"
"(lambda(val_0 sym_0 phase_0 portal-syntaxes_0)"
"(begin"
"(if(1/portal-syntax? val_0)(let-values()(add-portal-stx! portal-syntaxes_0 val_0 sym_0 phase_0))(void)))))"
"(define-values"
"(add-portal-stx!)"
"(lambda(portal-syntaxes_0 val_0 sym_0 phase_0)"
"(begin"
"(let-values(((ht_0)(hash-ref portal-syntaxes_0 phase_0 '#hasheq())))"
"(hash-set! portal-syntaxes_0 phase_0(hash-set ht_0 sym_0(1/portal-syntax-content val_0)))))))"
"(define-values"
"(make-add-defined-portal)"
"(lambda(self_0 requires+provides_0 portal-syntaxes_0 defined-syms_0 all-scopes-stx_0 frame-id_0 m-ns_0)"
"(begin"
"(lambda(id_0 phase_0 portal-stx_0 orig-s_0)"
"(let-values((()"
"(begin"
"(let-values(((temp758_0)(list id_0))"
"((phase759_0) phase_0)"
"((requires+provides760_0) requires+provides_0)"
"((orig-s761_0) orig-s_0))"
"(check-ids-unbound.1 orig-s761_0 temp758_0 phase759_0 requires+provides760_0))"
"(values))))"
"(let-values(((syms_0)"
"(let-values(((temp766_0)(list id_0))"
"((defined-syms767_0) defined-syms_0)"
"((self768_0) self_0)"
"((phase769_0) phase_0)"
"((all-scopes-stx770_0) all-scopes-stx_0)"
"((requires+provides771_0) requires+provides_0)"
"((orig-s772_0) orig-s_0)"
"((frame-id773_0) frame-id_0)"
"((temp774_0) #t))"
"(select-defined-syms-and-bind!.1"
" temp774_0"
" frame-id773_0"
" orig-s772_0"
" requires+provides771_0"
" #f"
" temp766_0"
" defined-syms767_0"
" self768_0"
" phase769_0"
" all-scopes-stx770_0))))"
"(let-values((()"
"(begin"
"(let-values(((requires+provides762_0) requires+provides_0)"
"((syms763_0) syms_0)"
"((phase764_0) phase_0)"
"((temp765_0) #t))"
"(add-defined-syms!.1 temp765_0 requires+provides762_0 syms763_0 phase764_0))"
"(values))))"
"(let-values(((sym_0)(car syms_0)))"
"(let-values(((t_0)(portal-syntax1.1 portal-stx_0 #f)))"
"(begin"
"(namespace-set-transformer! m-ns_0 phase_0 sym_0 t_0)"
"(add-portal-stx! portal-syntaxes_0 t_0 sym_0 phase_0)"
" sym_0))))))))))"
"(void"
"(add-core-form!*"
" 'define-values"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-define-values s_0)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"                         (let-values () (raise-syntax-error$1 #f \"not allowed in an expression position\" s_0)))"
"(values))))"
"(let-values(((ok?_0 define-values1_0 id2_0 rhs3_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((define-values1_0 id2_0 rhs3_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((define-values4_0)(let-values(((s_3)(car s_2))) s_3))"
"((id5_0 rhs6_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((id7_0)"
"(let-values(((s_5)(car s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                          \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id10_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_7)"
"(symbol?"
"(syntax-e$1"
" s_7))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_7)))"
" s_7"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                          \"not an identifier\""
" orig-s_0"
" s_7)))))"
"(cons"
" id10_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_2"
" rest_0)"
" id_2)))"
" id_1))))))"
" for-loop_0)"
" id_0"
" lst_0))))))"
"(reverse$1 id_0))))))))"
"((rhs8_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((rhs9_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null? s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                          \"bad syntax\""
" orig-s_0))))))"
"(values rhs9_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values id7_0 rhs8_0))"
"                                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values define-values4_0 id5_0 rhs6_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t define-values1_0 id2_0 rhs3_0))))))"
"(let-values(((ids_0 syms_0)(as-expand-time-top-level-bindings id2_0 s_0 ctx_0)))"
"(let-values(((exp-rhs_0)"
"(let-values(((temp11_0) rhs3_0)"
"((temp12_0)(as-named-context(as-expression-context ctx_0) ids_0)))"
"(expand.1 #f #f temp11_0 temp12_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-define-values19.1 s_0 ids_0 syms_0 exp-rhs_0)"
"(let-values(((s13_0) s_0)((temp14_0)(list define-values1_0 ids_0 exp-rhs_0)))"
"(rebuild.1 #t s13_0 temp14_0)))))))))))"
"(void"
"(add-core-form!*"
" 'define-syntaxes"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-define-syntaxes s_0)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"                         (let-values () (raise-syntax-error$1 #f \"not in a definition context\" s_0)))"
"(values))))"
"(let-values(((ok?_0 define-syntaxes15_0 id16_0 rhs17_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((define-syntaxes15_0 id16_0 rhs17_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((define-syntaxes18_0)(let-values(((s_3)(car s_2))) s_3))"
"((id19_0 rhs20_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((id21_0)"
"(let-values(((s_5)(car s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                          \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((id_0)"
"(let-values(((id_0)"
" null))"
" id_0)))"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_1"
" lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_2)"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id24_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_7)"
"(symbol?"
"(syntax-e$1"
" s_7))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_7)))"
" s_7"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                          \"not an identifier\""
" orig-s_0"
" s_7)))))"
"(cons"
" id24_0"
" id_1)))))"
"(values"
" id_2))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_2"
" rest_0)"
" id_2)))"
" id_1))))))"
" for-loop_0)"
" id_0"
" lst_0))))))"
"(reverse$1 id_0))))))))"
"((rhs22_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((rhs23_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null? s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                          \"bad syntax\""
" orig-s_0))))))"
"(values rhs23_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values id21_0 rhs22_0))"
"                                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values define-syntaxes18_0 id19_0 rhs20_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t define-syntaxes15_0 id16_0 rhs17_0))))))"
"(let-values(((ids_0 syms_0)(as-expand-time-top-level-bindings id16_0 s_0 ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values(((exp-rhs_0)"
"(let-values(((temp25_0) rhs17_0)((temp26_0)(as-named-context ctx_0 ids_0)))"
"(expand-transformer.1 #f #f 'expression #t #f unsafe-undefined temp25_0 temp26_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-define-syntaxes20.1 s_0 ids_0 syms_0 exp-rhs_0)"
"(let-values(((s27_0) s_0)((temp28_0)(list define-syntaxes15_0 ids_0 exp-rhs_0)))"
"(rebuild.1 #t s27_0 temp28_0))))))))))))"
"(void"
"(add-core-form!*"
" 'begin-for-syntax"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-begin-for-syntax #f)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"                         (let-values () (raise-syntax-error$1 #f \"not in a definition context\" s_0)))"
"(values))))"
"(let-values(((ok?_0 begin-for-syntax29_0 form30_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((begin-for-syntax29_0 form30_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((begin-for-syntax31_0)(let-values(((s_3)(car s_2))) s_3))"
"((form32_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                     (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values begin-for-syntax31_0 form32_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t begin-for-syntax29_0 form30_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prepare-env)))(void)))"
"(values))))"
"(let-values(((trans-ctx_0)"
"(let-values(((ctx33_0) ctx_0)((temp34_0) 'top-level)((temp35_0) #t))"
"(context->transformer-context.1 temp35_0 ctx33_0 temp34_0))))"
"(let-values(((lift-ctx_0)"
"(let-values(((temp36_0)(make-top-level-lift trans-ctx_0)))"
"(make-lift-context.1 #f temp36_0))))"
"(let-values(((capture-ctx_0)"
"(let-values(((v_0) trans-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner37_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((lift-key38_0)(generate-lift-key))"
"((lifts39_0) lift-ctx_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
" lift-key38_0"
"(expand-context/inner-to-parsed? the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once? the-struct_1)"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
" lifts39_0"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-parsing-expanded? the-struct_1)"
"(expand-context/inner-skip-visit-available? the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                        \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner37_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"                                     (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))"
"(let-values(((all-exp-forms_0)"
"((letrec-values(((loop_0)"
"(lambda(forms_0)"
"(begin"
" 'loop"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-list"
" form30_0)))"
"(void)))"
"(values))))"
"(let-values(((exp-forms_0)"
"((letrec-values(((loop_1)"
"(lambda(forms_1 accum_0)"
"(begin"
" 'loop"
"(if(null? forms_1)"
"(let-values()"
"(let-values(((forms_2)"
"(reverse$1"
" accum_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-list"
" forms_2)))"
"(void)))"
" forms_2)))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-form_0)"
"(let-values(((temp40_0)"
"(car"
" forms_1))"
"((capture-ctx41_0)"
" capture-ctx_0))"
"(expand.1"
" #f"
" #f"
" temp40_0"
" capture-ctx41_0))))"
"(loop_1"
"(cdr forms_1)"
"(cons"
" exp-form_0"
" accum_0))))))))))"
" loop_1)"
" forms_0"
" null)))"
"(let-values(((lifts_0)(get-and-clear-lifts! lift-ctx_0)))"
"(if(null? lifts_0)"
"(let-values() exp-forms_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-lift-loop"
" lifts_0)))"
"(void)))"
"(values))))"
"(let-values(((beg_0)"
"(let-values(((lifts42_0) lifts_0)"
"((temp43_0) #f)"
"((temp44_0)"
"(expand-context-phase"
" trans-ctx_0)))"
"(wrap-lifts-as-begin.1"
" unsafe-undefined"
" unsafe-undefined"
" lifts42_0"
" temp43_0"
" temp44_0))))"
"(let-values(((exprs_0)"
"(reverse$1"
"(cdr"
"(reverse$1"
"(cdr(syntax-e$1 beg_0)))))))"
"(append(loop_0 exprs_0) exp-forms_0)))))))))))))"
" loop_0)"
" form30_0)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-begin-for-syntax21.1 s_0 all-exp-forms_0)"
"(let-values(((s45_0) s_0)((temp46_0)(cons begin-for-syntax29_0 all-exp-forms_0)))"
"(rebuild.1 #t s45_0 temp46_0))))))))))))))"
"(void"
"(add-core-form!*"
" '#%require"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-require s_0)))(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"                         (let-values () (raise-syntax-error$1 #f \"allowed only in a module or the top level\" s_0)))"
"(values))))"
"(let-values(((ok?_0 #%require47_0 req48_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%require47_0 req48_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%require49_0)(let-values(((s_3)(car s_2))) s_3))"
"((req50_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                     (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values #%require49_0 req50_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%require47_0 req48_0))))))"
"(let-values(((sc_0)(new-scope 'macro)))"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"(let-values(((generated-syms_0)(box null)))"
"(begin"
"(let-values(((temp51_0)"
"(reverse$1"
"(let-values(((fold-var_0)(let-values(((fold-var_0) null)) fold-var_0)))"
"(let-values(((lst_0) req48_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(if(pair? lst_1)"
"(let-values(((req_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" req_0"
" sc_0))"
" fold-var_1))))"
"(values fold-var_2))))"
"(if(not #f)"
"(for-loop_0 fold-var_2 rest_0)"
" fold-var_2)))"
" fold-var_1))))))"
" for-loop_0)"
" fold-var_0"
" lst_0))))))"
"((s52_0) s_0)"
"((temp53_0)(namespace-self-mpi/no-top-level ns_0))"
"((temp54_0) #f)"
"((ns55_0) ns_0)"
"((temp56_0)(expand-context-phase ctx_0))"
"((temp57_0)"
"(let-values(((temp61_0) #f))(make-requires+provides.1 #f unsafe-undefined temp61_0)))"
"((temp58_0) 'require)"
"((temp59_0) #t)"
"((temp60_0)(make-top-add-defined-portal ns_0 ctx_0 generated-syms_0)))"
"(parse-and-perform-requires!.1"
" temp60_0"
" #f"
" #f"
" #f"
" '#hasheq()"
" temp59_0"
" unsafe-undefined"
" #f"
" temp53_0"
" #f"
" temp54_0"
" temp58_0"
" temp51_0"
" s52_0"
" ns55_0"
" temp56_0"
" temp57_0))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-require23.1 s_0(reverse$1(unbox generated-syms_0)))"
" s_0)))))))))))"
"(void"
"(add-core-form!*"
" '#%provide"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-provide #f)))(void)))"
"       (raise-syntax-error$1 #f \"not allowed outside of a module body\" s_0)))))"
"(define-values"
"(namespace-init!)"
"(lambda()"
"(begin"
"(let-values(((ns_0)(make-namespace)))"
"(void"
"(begin"
"(declare-core-module! ns_0)"
"(let-values(((temp1_0) '#%read)((read-primitives2_0) read-primitives)((ns3_0) ns_0))"
"(declare-hash-based-module!.1 ns3_0 #f null #f #f temp1_0 read-primitives2_0))"
"(let-values(((temp4_0) '#%main)"
"((main-primitives5_0) main-primitives)"
"((ns6_0) ns_0)"
"((temp7_0) '(current-compile)))"
"(declare-hash-based-module!.1 ns6_0 #f temp7_0 #f #f temp4_0 main-primitives5_0))"
"(let-values(((temp8_0) '#%utils)((utils-primitives9_0) utils-primitives)((ns10_0) ns_0))"
"(declare-hash-based-module!.1 ns10_0 #f null #f #f temp8_0 utils-primitives9_0))"
"(let-values(((temp11_0) '#%place-struct)"
"((place-struct-primitives12_0) place-struct-primitives)"
"((ns13_0) ns_0)"
"((temp14_0) '(dynamic-place)))"
"(declare-hash-based-module!.1 ns13_0 #f temp14_0 #f #f temp11_0 place-struct-primitives12_0))"
"(let-values(((temp15_0) '#%boot)((boot-primitives16_0) boot-primitives)((ns17_0) ns_0))"
"(declare-hash-based-module!.1 ns17_0 #f null #f #f temp15_0 boot-primitives16_0))"
"(let-values(((linklet-primitives_0)"
"(hash-remove"
"(hash-remove linklet-primitives 'variable-reference?)"
" 'variable-reference-constant?)))"
"(begin"
"(let-values(((temp18_0) '#%linklet-primitive)"
"((linklet-primitives19_0) linklet-primitives_0)"
"((ns20_0) ns_0)"
"((temp21_0) #t)"
"((temp22_0) #t)"
"((temp23_0) #t))"
"(declare-hash-based-module!.1 ns20_0 temp21_0 null temp23_0 temp22_0 temp18_0 linklet-primitives19_0))"
"(let-values(((temp24_0) '#%linklet-expander)"
"((linklet-expander-primitives25_0) linklet-expander-primitives)"
"((ns26_0) ns_0)"
"((temp27_0) #t)"
"((temp28_0) #t))"
"(declare-hash-based-module!.1"
" ns26_0"
" #f"
" null"
" temp28_0"
" temp27_0"
" temp24_0"
" linklet-expander-primitives25_0))"
"(let-values(((temp29_0) '#%linklet)"
"((temp30_0)(list '#%linklet-primitive '#%linklet-expander))"
"((ns31_0) ns_0))"
"(declare-reexporting-module!.1 ns31_0 #t temp29_0 temp30_0))))"
"(let-values(((temp32_0) '#%expobs)"
"((expobs-primitives33_0) expobs-primitives)"
"((ns34_0) ns_0)"
"((temp35_0) #t))"
"(declare-hash-based-module!.1 ns34_0 #f null temp35_0 #f temp32_0 expobs-primitives33_0))"
"(let-values(((ns36_0) ns_0)"
"((temp37_0)"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0) main-primitives))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((name_0)(hash-iterate-key ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
" name_0)"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0))))))"
"((temp38_0)"
"(let-values(((table_0)(let-values(((table_0) '#hash())) table_0)))"
"(let-values(((ht_0) read-primitives))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(let-values()"
"(if i_0"
"(let-values(((name_0)(hash-iterate-key ht_0 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
" name_0)"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2))))"
"(if(not #f)"
"(for-loop_0 table_2(hash-iterate-next ht_0 i_0))"
" table_2)))"
" table_1))))))"
" for-loop_0)"
" table_0"
"(hash-iterate-first ht_0)))))))"
"(declare-kernel-module!.1 temp37_0 temp38_0 ns36_0))"
"(begin"
"(let-values()"
"(let-values(((lst_0) runtime-instances))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((name_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(if(eq? name_0 '#%kernel)"
"(values)"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((name39_0) name_0)"
"((ns40_0) ns_0)"
"((temp41_0)"
"(let-values(((or-part_0)"
"(eq?"
" name_0"
" '#%foreign)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(eq?"
" name_0"
" '#%futures)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(eq?"
" name_0"
" '#%unsafe)))"
"(if or-part_2"
" or-part_2"
"(eq?"
" name_0"
" '#%terminal)))))))))"
"(copy-runtime-module!.1"
" '#hasheq()"
" '#hasheq()"
" ns40_0"
" #t"
" temp41_0"
" unsafe-undefined"
" unsafe-undefined"
" name39_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0))))"
"(void))"
"(let-values(((temp42_0) '#%builtin)"
"((temp43_0)(list* '#%place-struct '#%utils '#%boot '#%expobs '#%linklet runtime-instances))"
"((ns44_0) ns_0)"
"((temp45_0) #f))"
"(declare-reexporting-module!.1 ns44_0 temp45_0 temp42_0 temp43_0))"
"(1/current-namespace ns_0)"
"(1/dynamic-require ''#%kernel 0)))))))"
"(call-with-values(lambda()(namespace-init!)) print-values)"
"(call-with-values(lambda()(install-error-syntax->string-handler!)) print-values)"
"(call-with-values"
"(lambda()"
"(set-load-configure-expand!"
"(lambda(mpi_0 ns_0)"
"       (let-values (((config-m_0) (1/module-path-index-join '(submod \".\" configure-expand) mpi_0)))"
"(if(1/module-declared? config-m_0 #t)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace ns_0)"
"(let-values()"
"(let-values(((enter_0)(1/dynamic-require config-m_0 'enter-parameterization))"
"((exit_0)(1/dynamic-require config-m_0 'exit-parameterization)))"
"(begin"
"(if(if(procedure? enter_0)(procedure-arity-includes? enter_0 0) #f)"
"(void)"
"                    (let-values () (raise-result-error 'configure-expand \"(procedure-arity-includes/c 0)\" enter_0)))"
"(if(if(procedure? enter_0)(procedure-arity-includes? exit_0 0) #f)"
"(void)"
"                    (let-values () (raise-result-error 'configure-expand \"(procedure-arity-includes/c 0)\" exit_0)))"
"(values enter_0 exit_0)))))"
"(values current-parameterization current-parameterization))))))"
" print-values)"
"(define-values(datum->kernel-syntax)(lambda(s_0)(begin(1/datum->syntax core-stx s_0))))"
"(define-values"
"(expander-place-init!)"
"(lambda()"
"(begin"
"(begin"
"(syntax-place-init!)"
"(scope-place-init!)"
"(cache-place-init!)"
"(core-place-init!)"
"(phase+space-place-init!)"
"(module-path-place-init!)"
"(module-cache-place-init!)"
"(shadow-directory-place-init!)"
"(collection-place-init!)"
"(performance-place-init!)"
"(namespace-init!)"
"(install-error-syntax->string-handler!))))))"
;
