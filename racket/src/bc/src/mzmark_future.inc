/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

#ifdef MZ_USE_FUTURES

static int future_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(future_t));
#else
  return 0;
#endif
}

static int future_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  future_t *f = (future_t *)p;
  gcMARK2(f->orig_lambda, gc);
  gcMARK2(f->cust, gc);
  gcMARK2(f->arg_s0, gc);
  gcMARK2(f->arg_t0, gc);
  gcMARK2(f->arg_S0, gc);
  gcMARK2(f->arg_b0, gc);
  gcMARK2(f->arg_n0, gc);
  gcMARK2(f->arg_s1, gc);
  gcMARK2(f->arg_t1, gc);
  gcMARK2(f->arg_S1, gc);
  gcMARK2(f->arg_s2, gc);
  gcMARK2(f->arg_S2, gc);
  gcMARK2(f->arg_S4, gc);
  gcMARK2(f->retval_s, gc);
  gcMARK2(f->retval, gc);
  gcMARK2(f->multiple_array, gc);
  gcMARK2(f->tail_rator, gc);
  gcMARK2(f->tail_rands, gc);
  gcMARK2(f->prev, gc);
  gcMARK2(f->next, gc);
  gcMARK2(f->next_waiting_atomic, gc);
  gcMARK2(f->next_waiting_lwc, gc);
  gcMARK2(f->next_waiting_touch, gc);
  gcMARK2(f->suspended_lw, gc);
  gcMARK2(f->suspended_lw_stack, gc);
  gcMARK2(f->prev_in_fsema_queue, gc);
  gcMARK2(f->next_in_fsema_queue, gc);
  gcMARK2(f->touching, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
# endif
#endif
}

static int future_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  future_t *f = (future_t *)p;
  gcFIXUP2(f->orig_lambda, gc);
  gcFIXUP2(f->cust, gc);
  gcFIXUP2(f->arg_s0, gc);
  gcFIXUP2(f->arg_t0, gc);
  gcFIXUP2(f->arg_S0, gc);
  gcFIXUP2(f->arg_b0, gc);
  gcFIXUP2(f->arg_n0, gc);
  gcFIXUP2(f->arg_s1, gc);
  gcFIXUP2(f->arg_t1, gc);
  gcFIXUP2(f->arg_S1, gc);
  gcFIXUP2(f->arg_s2, gc);
  gcFIXUP2(f->arg_S2, gc);
  gcFIXUP2(f->arg_S4, gc);
  gcFIXUP2(f->retval_s, gc);
  gcFIXUP2(f->retval, gc);
  gcFIXUP2(f->multiple_array, gc);
  gcFIXUP2(f->tail_rator, gc);
  gcFIXUP2(f->tail_rands, gc);
  gcFIXUP2(f->prev, gc);
  gcFIXUP2(f->next, gc);
  gcFIXUP2(f->next_waiting_atomic, gc);
  gcFIXUP2(f->next_waiting_lwc, gc);
  gcFIXUP2(f->next_waiting_touch, gc);
  gcFIXUP2(f->suspended_lw, gc);
  gcFIXUP2(f->suspended_lw_stack, gc);
  gcFIXUP2(f->prev_in_fsema_queue, gc);
  gcFIXUP2(f->next_in_fsema_queue, gc);
  gcFIXUP2(f->touching, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
# endif
#endif
}

#define future_IS_ATOMIC 0
#define future_IS_CONST_SIZE 1


static int fsemaphore_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
    gcBYTES_TO_WORDS(sizeof(fsemaphore_t));
#else
  return 0;
#endif
}

static int fsemaphore_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
    fsemaphore_t *s = (fsemaphore_t*)p;
    gcMARK2(s->queue_front, gc);
    gcMARK2(s->queue_end, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
    gcBYTES_TO_WORDS(sizeof(fsemaphore_t));
# endif
#endif
}

static int fsemaphore_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
    fsemaphore_t *s = (fsemaphore_t*)p;
    gcFIXUP2(s->queue_front, gc);
    gcFIXUP2(s->queue_end, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
    gcBYTES_TO_WORDS(sizeof(fsemaphore_t));
# endif
#endif
}

#define fsemaphore_IS_ATOMIC 0
#define fsemaphore_IS_CONST_SIZE 1


#else

static int sequential_future_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(future_t));
#else
  return 0;
#endif
}

static int sequential_future_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  future_t *f = (future_t *)p;
  gcMARK2(f->orig_lambda, gc);
  gcMARK2(f->running_sema, gc);
  gcMARK2(f->retval, gc);
  gcMARK2(f->multiple_array, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
# endif
#endif
}

static int sequential_future_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  future_t *f = (future_t *)p;
  gcFIXUP2(f->orig_lambda, gc);
  gcFIXUP2(f->running_sema, gc);
  gcFIXUP2(f->retval, gc);
  gcFIXUP2(f->multiple_array, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
# endif
#endif
}

#define sequential_future_IS_ATOMIC 0
#define sequential_future_IS_CONST_SIZE 1


static int sequential_fsemaphore_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
    gcBYTES_TO_WORDS(sizeof(fsemaphore_t));
#else
  return 0;
#endif
}

static int sequential_fsemaphore_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
    fsemaphore_t *s = (fsemaphore_t*)p;
    gcMARK2(s->sema, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
    gcBYTES_TO_WORDS(sizeof(fsemaphore_t));
# endif
#endif
}

static int sequential_fsemaphore_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
    fsemaphore_t *s = (fsemaphore_t*)p;
    gcFIXUP2(s->sema, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
    gcBYTES_TO_WORDS(sizeof(fsemaphore_t));
# endif
#endif
}

#define sequential_fsemaphore_IS_ATOMIC 0
#define sequential_fsemaphore_IS_CONST_SIZE 1


#endif

